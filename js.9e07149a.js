// modules are defined as an array
// [ module function, map of requires ]
//
// map of requires is short require name -> numeric require
//
// anything defined in a previous bundle is accessed via the
// orig method which is the require for previous bundles
parcelRequire = (function (modules, cache, entry, globalName) {
  // Save the require from previous bundle to this closure if any
  var previousRequire = typeof parcelRequire === 'function' && parcelRequire;
  var nodeRequire = typeof require === 'function' && require;

  function newRequire(name, jumped) {
    if (!cache[name]) {
      if (!modules[name]) {
        // if we cannot find the module within our internal map or
        // cache jump to the current global require ie. the last bundle
        // that was added to the page.
        var currentRequire = typeof parcelRequire === 'function' && parcelRequire;
        if (!jumped && currentRequire) {
          return currentRequire(name, true);
        }

        // If there are other bundles on this page the require from the
        // previous one is saved to 'previousRequire'. Repeat this as
        // many times as there are bundles until the module is found or
        // we exhaust the require chain.
        if (previousRequire) {
          return previousRequire(name, true);
        }

        // Try the node require function if it exists.
        if (nodeRequire && typeof name === 'string') {
          return nodeRequire(name);
        }

        var err = new Error('Cannot find module \'' + name + '\'');
        err.code = 'MODULE_NOT_FOUND';
        throw err;
      }

      localRequire.resolve = resolve;
      localRequire.cache = {};

      var module = cache[name] = new newRequire.Module(name);

      modules[name][0].call(module.exports, localRequire, module, module.exports, this);
    }

    return cache[name].exports;

    function localRequire(x){
      return newRequire(localRequire.resolve(x));
    }

    function resolve(x){
      return modules[name][1][x] || x;
    }
  }

  function Module(moduleName) {
    this.id = moduleName;
    this.bundle = newRequire;
    this.exports = {};
  }

  newRequire.isParcelRequire = true;
  newRequire.Module = Module;
  newRequire.modules = modules;
  newRequire.cache = cache;
  newRequire.parent = previousRequire;
  newRequire.register = function (id, exports) {
    modules[id] = [function (require, module) {
      module.exports = exports;
    }, {}];
  };

  var error;
  for (var i = 0; i < entry.length; i++) {
    try {
      newRequire(entry[i]);
    } catch (e) {
      // Save first error but execute all entries
      if (!error) {
        error = e;
      }
    }
  }

  if (entry.length) {
    // Expose entry point to Node, AMD or browser globals
    // Based on https://github.com/ForbesLindesay/umd/blob/master/template.js
    var mainExports = newRequire(entry[entry.length - 1]);

    // CommonJS
    if (typeof exports === "object" && typeof module !== "undefined") {
      module.exports = mainExports;

    // RequireJS
    } else if (typeof define === "function" && define.amd) {
     define(function () {
       return mainExports;
     });

    // <script>
    } else if (globalName) {
      this[globalName] = mainExports;
    }
  }

  // Override the current require with this new one
  parcelRequire = newRequire;

  if (error) {
    // throw error from earlier, _after updating parcelRequire_
    throw error;
  }

  return newRequire;
})({"g5IB":[function(require,module,exports) {

// shim for using process in browser
var process = module.exports = {}; // cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
  throw new Error('setTimeout has not been defined');
}

function defaultClearTimeout() {
  throw new Error('clearTimeout has not been defined');
}

(function () {
  try {
    if (typeof setTimeout === 'function') {
      cachedSetTimeout = setTimeout;
    } else {
      cachedSetTimeout = defaultSetTimout;
    }
  } catch (e) {
    cachedSetTimeout = defaultSetTimout;
  }

  try {
    if (typeof clearTimeout === 'function') {
      cachedClearTimeout = clearTimeout;
    } else {
      cachedClearTimeout = defaultClearTimeout;
    }
  } catch (e) {
    cachedClearTimeout = defaultClearTimeout;
  }
})();

function runTimeout(fun) {
  if (cachedSetTimeout === setTimeout) {
    //normal enviroments in sane situations
    return setTimeout(fun, 0);
  } // if setTimeout wasn't available but was latter defined


  if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
    cachedSetTimeout = setTimeout;
    return setTimeout(fun, 0);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedSetTimeout(fun, 0);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
      return cachedSetTimeout.call(null, fun, 0);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
      return cachedSetTimeout.call(this, fun, 0);
    }
  }
}

function runClearTimeout(marker) {
  if (cachedClearTimeout === clearTimeout) {
    //normal enviroments in sane situations
    return clearTimeout(marker);
  } // if clearTimeout wasn't available but was latter defined


  if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
    cachedClearTimeout = clearTimeout;
    return clearTimeout(marker);
  }

  try {
    // when when somebody has screwed with setTimeout but no I.E. maddness
    return cachedClearTimeout(marker);
  } catch (e) {
    try {
      // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
      return cachedClearTimeout.call(null, marker);
    } catch (e) {
      // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
      // Some versions of I.E. have different rules for clearTimeout vs setTimeout
      return cachedClearTimeout.call(this, marker);
    }
  }
}

var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
  if (!draining || !currentQueue) {
    return;
  }

  draining = false;

  if (currentQueue.length) {
    queue = currentQueue.concat(queue);
  } else {
    queueIndex = -1;
  }

  if (queue.length) {
    drainQueue();
  }
}

function drainQueue() {
  if (draining) {
    return;
  }

  var timeout = runTimeout(cleanUpNextTick);
  draining = true;
  var len = queue.length;

  while (len) {
    currentQueue = queue;
    queue = [];

    while (++queueIndex < len) {
      if (currentQueue) {
        currentQueue[queueIndex].run();
      }
    }

    queueIndex = -1;
    len = queue.length;
  }

  currentQueue = null;
  draining = false;
  runClearTimeout(timeout);
}

process.nextTick = function (fun) {
  var args = new Array(arguments.length - 1);

  if (arguments.length > 1) {
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
  }

  queue.push(new Item(fun, args));

  if (queue.length === 1 && !draining) {
    runTimeout(drainQueue);
  }
}; // v8 likes predictible objects


function Item(fun, array) {
  this.fun = fun;
  this.array = array;
}

Item.prototype.run = function () {
  this.fun.apply(null, this.array);
};

process.title = 'browser';
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues

process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
  return [];
};

process.binding = function (name) {
  throw new Error('process.binding is not supported');
};

process.cwd = function () {
  return '/';
};

process.chdir = function (dir) {
  throw new Error('process.chdir is not supported');
};

process.umask = function () {
  return 0;
};
},{}],"HlZQ":[function(require,module,exports) {
var global = arguments[3];
var process = require("process");
var define;
/*!
 * jQuery JavaScript Library v3.6.0
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright OpenJS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2021-03-02T17:08Z
 */
( function( global, factory ) {

	"use strict";

	if ( typeof module === "object" && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var flat = arr.flat ? function( array ) {
	return arr.flat.call( array );
} : function( array ) {
	return arr.concat.apply( [], array );
};


var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

		// Support: Chrome <=57, Firefox <=52
		// In some browsers, typeof returns "function" for HTML <object> elements
		// (i.e., `typeof document.createElement( "object" ) === "function"`).
		// We don't want to classify *any* DOM node as a function.
		// Support: QtWeb <=3.8.5, WebKit <=534.34, wkhtmltopdf tool <=0.12.5
		// Plus for old WebKit, typeof returns "function" for HTML collections
		// (e.g., `typeof document.getElementsByTagName("div") === "function"`). (gh-4756)
		return typeof obj === "function" && typeof obj.nodeType !== "number" &&
			typeof obj.item !== "function";
	};


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};


var document = window.document;



	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.6.0",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	even: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return ( i + 1 ) % 2;
		} ) );
	},

	odd: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return i % 2;
		} ) );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a provided context; falls back to the global one
	// if not specified.
	globalEval: function( code, options, doc ) {
		DOMEval( code, { nonce: options && options.nonce }, doc );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
						[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return flat( ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
	function( _i, name ) {
		class2type[ "[object " + name + "]" ] = name.toLowerCase();
	} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.6
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://js.foundation/
 *
 * Date: 2021-02-16
 */
( function( window ) {
var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ( {} ).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	pushNative = arr.push,
	push = arr.push,
	slice = arr.slice,

	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[ i ] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|" +
		"ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
	identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +

		// "Attribute values must be CSS identifiers [capture 5]
		// or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
		whitespace + "*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +

		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" +
		whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace +
		"*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
			whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
			whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),

		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace +
			"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
			"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rhtml = /HTML$/i,
	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g" ),
	funescape = function( escape, nonHex ) {
		var high = "0x" + escape.slice( 1 ) - 0x10000;

		return nonHex ?

			// Strip the backslash prefix from a non-hex escape sequence
			nonHex :

			// Replace a hexadecimal escape sequence with the encoded Unicode code point
			// Support: IE <=11+
			// For values outside the Basic Multilingual Plane (BMP), manually construct a
			// surrogate pair
			high < 0 ?
				String.fromCharCode( high + 0x10000 ) :
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" +
				ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		( arr = slice.call( preferredDoc.childNodes ) ),
		preferredDoc.childNodes
	);

	// Support: Android<4.0
	// Detect silently failing push.apply
	// eslint-disable-next-line no-unused-expressions
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			pushNative.apply( target, slice.call( els ) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;

			// Can't trust NodeList.length
			while ( ( target[ j++ ] = els[ i++ ] ) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {
		setDocument( context );
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

				// ID selector
				if ( ( m = match[ 1 ] ) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( ( elem = context.getElementById( m ) ) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && ( elem = newContext.getElementById( m ) ) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[ 2 ] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( ( m = match[ 3 ] ) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!nonnativeSelectorCache[ selector + " " ] &&
				( !rbuggyQSA || !rbuggyQSA.test( selector ) ) &&

				// Support: IE 8 only
				// Exclude object elements
				( nodeType !== 1 || context.nodeName.toLowerCase() !== "object" ) ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// The technique has to be used as well when a leading combinator is used
				// as such selectors are not recognized by querySelectorAll.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 &&
					( rdescend.test( selector ) || rcombinators.test( selector ) ) ) {

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;

					// We can use :scope instead of the ID hack if the browser
					// supports it & if we're not changing the context.
					if ( newContext !== context || !support.scope ) {

						// Capture the context ID, setting it first if necessary
						if ( ( nid = context.getAttribute( "id" ) ) ) {
							nid = nid.replace( rcssescape, fcssescape );
						} else {
							context.setAttribute( "id", ( nid = expando ) );
						}
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
							toSelector( groups[ i ] );
					}
					newSelector = groups.join( "," );
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {

		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {

			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return ( cache[ key + " " ] = value );
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement( "fieldset" );

	try {
		return !!fn( el );
	} catch ( e ) {
		return false;
	} finally {

		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}

		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split( "|" ),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[ i ] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( ( cur = cur.nextSibling ) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return ( name === "input" || name === "button" ) && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
					inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction( function( argument ) {
		argument = +argument;
		return markFunction( function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
					seed[ j ] = !( matches[ j ] = seed[ j ] );
				}
			}
		} );
	} );
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	var namespace = elem && elem.namespaceURI,
		docElem = elem && ( elem.ownerDocument || elem ).documentElement;

	// Support: IE <=8
	// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
	// https://bugs.jquery.com/ticket/4833
	return !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9 - 11+, Edge 12 - 18+
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( preferredDoc != document &&
		( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	// Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
	// Safari 4 - 5 only, Opera <=11.6 - 12.x only
	// IE/Edge & older browsers don't support the :scope pseudo-class.
	// Support: Safari 6.0 only
	// Safari 6.0 supports :scope but it's an alias of :root there.
	support.scope = assert( function( el ) {
		docElem.appendChild( el ).appendChild( document.createElement( "div" ) );
		return typeof el.querySelectorAll !== "undefined" &&
			!el.querySelectorAll( ":scope fieldset div" ).length;
	} );

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert( function( el ) {
		el.className = "i";
		return !el.getAttribute( "className" );
	} );

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert( function( el ) {
		el.appendChild( document.createComment( "" ) );
		return !el.getElementsByTagName( "*" ).length;
	} );

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert( function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	} );

	// ID filter and find
	if ( support.getById ) {
		Expr.filter[ "ID" ] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute( "id" ) === attrId;
			};
		};
		Expr.find[ "ID" ] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter[ "ID" ] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode( "id" );
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find[ "ID" ] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode( "id" );
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( ( elem = elems[ i++ ] ) ) {
						node = elem.getAttributeNode( "id" );
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find[ "TAG" ] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,

				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( ( elem = results[ i++ ] ) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find[ "CLASS" ] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( ( support.qsa = rnative.test( document.querySelectorAll ) ) ) {

		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert( function( el ) {

			var input;

			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll( "[msallowcapture^='']" ).length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll( "[selected]" ).length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push( "~=" );
			}

			// Support: IE 11+, Edge 15 - 18+
			// IE 11/Edge don't find elements on a `[name='']` query in some cases.
			// Adding a temporary attribute to the document before the selection works
			// around the issue.
			// Interestingly, IE 10 & older don't seem to have the issue.
			input = document.createElement( "input" );
			input.setAttribute( "name", "" );
			el.appendChild( input );
			if ( !el.querySelectorAll( "[name='']" ).length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
					whitespace + "*(?:''|\"\")" );
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll( ":checked" ).length ) {
				rbuggyQSA.push( ":checked" );
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push( ".#.+[+~]" );
			}

			// Support: Firefox <=3.6 - 5 only
			// Old Firefox doesn't throw on a badly-escaped identifier.
			el.querySelectorAll( "\\\f" );
			rbuggyQSA.push( "[\\r\\n\\f]" );
		} );

		assert( function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement( "input" );
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll( "[name=d]" ).length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll( ":enabled" ).length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: Opera 10 - 11 only
			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll( "*,:x" );
			rbuggyQSA.push( ",.*:" );
		} );
	}

	if ( ( support.matchesSelector = rnative.test( ( matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector ) ) ) ) {

		assert( function( el ) {

			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		} );
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join( "|" ) );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			) );
		} :
		function( a, b ) {
			if ( b ) {
				while ( ( b = b.parentNode ) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

			// Choose the first element that is related to our preferred document
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( a == document || a.ownerDocument == preferredDoc &&
				contains( preferredDoc, a ) ) {
				return -1;
			}

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( b == document || b.ownerDocument == preferredDoc &&
				contains( preferredDoc, b ) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {

		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			/* eslint-disable eqeqeq */
			return a == document ? -1 :
				b == document ? 1 :
				/* eslint-enable eqeqeq */
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( ( cur = cur.parentNode ) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( ( cur = cur.parentNode ) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[ i ] === bp[ i ] ) {
			i++;
		}

		return i ?

			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[ i ], bp[ i ] ) :

			// Otherwise nodes in our document sort first
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			/* eslint-disable eqeqeq */
			ap[ i ] == preferredDoc ? -1 :
			bp[ i ] == preferredDoc ? 1 :
			/* eslint-enable eqeqeq */
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	setDocument( elem );

	if ( support.matchesSelector && documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||

				// As well, disconnected nodes are said to be in a document
				// fragment in IE 9
				elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch ( e ) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( context.ownerDocument || context ) != document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( elem.ownerDocument || elem ) != document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],

		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			( val = elem.getAttributeNode( name ) ) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return ( sel + "" ).replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( ( elem = results[ i++ ] ) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {

		// If no nodeType, this is expected to be an array
		while ( ( node = elem[ i++ ] ) ) {

			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {

		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {

			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}

	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[ 1 ] = match[ 1 ].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[ 3 ] = ( match[ 3 ] || match[ 4 ] ||
				match[ 5 ] || "" ).replace( runescape, funescape );

			if ( match[ 2 ] === "~=" ) {
				match[ 3 ] = " " + match[ 3 ] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {

			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[ 1 ] = match[ 1 ].toLowerCase();

			if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

				// nth-* requires argument
				if ( !match[ 3 ] ) {
					Sizzle.error( match[ 0 ] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[ 4 ] = +( match[ 4 ] ?
					match[ 5 ] + ( match[ 6 ] || 1 ) :
					2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" ) );
				match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

				// other types prohibit arguments
			} else if ( match[ 3 ] ) {
				Sizzle.error( match[ 0 ] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[ 6 ] && match[ 2 ];

			if ( matchExpr[ "CHILD" ].test( match[ 0 ] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[ 3 ] ) {
				match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&

				// Get excess from tokenize (recursively)
				( excess = tokenize( unquoted, true ) ) &&

				// advance to the next closing parenthesis
				( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

				// excess is a negative index
				match[ 0 ] = match[ 0 ].slice( 0, excess );
				match[ 2 ] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() {
					return true;
				} :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				( pattern = new RegExp( "(^|" + whitespace +
					")" + className + "(" + whitespace + "|$)" ) ) && classCache(
						className, function( elem ) {
							return pattern.test(
								typeof elem.className === "string" && elem.className ||
								typeof elem.getAttribute !== "undefined" &&
									elem.getAttribute( "class" ) ||
								""
							);
				} );
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				/* eslint-disable max-len */

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
				/* eslint-enable max-len */

			};
		},

		"CHILD": function( type, what, _argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, _context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( ( node = node[ dir ] ) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}

								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || ( node[ expando ] = {} );

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								( outerCache[ node.uniqueID ] = {} );

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( ( node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								( diff = nodeIndex = 0 ) || start.pop() ) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {

							// Use previously-cached element index if available
							if ( useCache ) {

								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || ( node[ expando ] = {} );

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									( outerCache[ node.uniqueID ] = {} );

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {

								// Use the same loop as above to seek `elem` from the start
								while ( ( node = ++nodeIndex && node && node[ dir ] ||
									( diff = nodeIndex = 0 ) || start.pop() ) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] ||
												( node[ expando ] = {} );

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												( outerCache[ node.uniqueID ] = {} );

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {

			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction( function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[ i ] );
							seed[ idx ] = !( matches[ idx ] = matched[ i ] );
						}
					} ) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {

		// Potentially complex pseudos
		"not": markFunction( function( selector ) {

			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction( function( seed, matches, _context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( ( elem = unmatched[ i ] ) ) {
							seed[ i ] = !( matches[ i ] = elem );
						}
					}
				} ) :
				function( elem, _context, xml ) {
					input[ 0 ] = elem;
					matcher( input, null, xml, results );

					// Don't keep the element (issue #299)
					input[ 0 ] = null;
					return !results.pop();
				};
		} ),

		"has": markFunction( function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		} ),

		"contains": markFunction( function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;
			};
		} ),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {

			// lang value must be a valid identifier
			if ( !ridentifier.test( lang || "" ) ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( ( elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
				return false;
			};
		} ),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement &&
				( !document.hasFocus || document.hasFocus() ) &&
				!!( elem.type || elem.href || ~elem.tabIndex );
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {

			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return ( nodeName === "input" && !!elem.checked ) ||
				( nodeName === "option" && !!elem.selected );
		},

		"selected": function( elem ) {

			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				// eslint-disable-next-line no-unused-expressions
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {

			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos[ "empty" ]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( ( attr = elem.getAttribute( "type" ) ) == null ||
					attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo( function() {
			return [ 0 ];
		} ),

		"last": createPositionalPseudo( function( _matchIndexes, length ) {
			return [ length - 1 ];
		} ),

		"eq": createPositionalPseudo( function( _matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		} ),

		"even": createPositionalPseudo( function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"odd": createPositionalPseudo( function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"lt": createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ?
				argument + length :
				argument > length ?
					length :
					argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"gt": createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} )
	}
};

Expr.pseudos[ "nth" ] = Expr.pseudos[ "eq" ];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
			if ( match ) {

				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[ 0 ].length ) || soFar;
			}
			groups.push( ( tokens = [] ) );
		}

		matched = false;

		// Combinators
		if ( ( match = rcombinators.exec( soFar ) ) ) {
			matched = match.shift();
			tokens.push( {
				value: matched,

				// Cast descendant combinators to space
				type: match[ 0 ].replace( rtrim, " " )
			} );
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
				( match = preFilters[ type ]( match ) ) ) ) {
				matched = match.shift();
				tokens.push( {
					value: matched,
					type: type,
					matches: match
				} );
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :

			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[ i ].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?

		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( ( elem = elem[ dir ] ) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || ( elem[ expando ] = {} );

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] ||
							( outerCache[ elem.uniqueID ] = {} );

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( ( oldCache = uniqueCache[ key ] ) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return ( newCache[ 2 ] = oldCache[ 2 ] );
						} else {

							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[ i ]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[ 0 ];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[ i ], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( ( elem = unmatched[ i ] ) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction( function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts(
				selector || "*",
				context.nodeType ? [ context ] : context,
				[]
			),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?

				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( ( elem = temp[ i ] ) ) {
					matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {

					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( ( elem = matcherOut[ i ] ) ) {

							// Restore matcherIn since elem is not yet a final match
							temp.push( ( matcherIn[ i ] = elem ) );
						}
					}
					postFinder( null, ( matcherOut = [] ), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( ( elem = matcherOut[ i ] ) &&
						( temp = postFinder ? indexOf( seed, elem ) : preMap[ i ] ) > -1 ) {

						seed[ temp ] = !( results[ temp ] = elem );
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	} );
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[ 0 ].type ],
		implicitRelative = leadingRelative || Expr.relative[ " " ],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				( checkContext = context ).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );

			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
			matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
		} else {
			matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {

				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[ j ].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(

					// If the preceding token was a descendant combinator, insert an implicit any-element `*`
					tokens
						.slice( 0, i - 1 )
						.concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,

				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find[ "TAG" ]( "*", outermost ),

				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
				len = elems.length;

			if ( outermost ) {

				// Support: IE 11+, Edge 17 - 18+
				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
				// two documents; shallow comparisons work.
				// eslint-disable-next-line eqeqeq
				outermostContext = context == document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;

					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
					// two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( !context && elem.ownerDocument != document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( ( matcher = elementMatchers[ j++ ] ) ) {
						if ( matcher( elem, context || document, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {

					// They will have gone through all possible matchers
					if ( ( elem = !matcher && elem ) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( ( matcher = setMatchers[ j++ ] ) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {

					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
								setMatched[ i ] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {

		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[ i ] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache(
			selector,
			matcherFromGroupMatchers( elementMatchers, setMatchers )
		);

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( ( selector = compiled.selector || selector ) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[ 0 ] = match[ 0 ].slice( 0 );
		if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
			context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

			context = ( Expr.find[ "ID" ]( token.matches[ 0 ]
				.replace( runescape, funescape ), context ) || [] )[ 0 ];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr[ "needsContext" ].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[ i ];

			// Abort if we hit a combinator
			if ( Expr.relative[ ( type = token.type ) ] ) {
				break;
			}
			if ( ( find = Expr.find[ type ] ) ) {

				// Search, expanding context for leading sibling combinators
				if ( ( seed = find(
					token.matches[ 0 ].replace( runescape, funescape ),
					rsibling.test( tokens[ 0 ].type ) && testContext( context.parentNode ) ||
						context
				) ) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert( function( el ) {

	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
} );

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert( function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute( "href" ) === "#";
} ) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	} );
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert( function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
} ) ) {
	addHandle( "value", function( elem, _name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	} );
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert( function( el ) {
	return el.getAttribute( "disabled" ) == null;
} ) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
				( val = elem.getAttributeNode( name ) ) && val.specified ?
					val.value :
					null;
		}
	} );
}

return Sizzle;

} )( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

	return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

}
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, _i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, _i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, _i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( elem.contentDocument != null &&

			// Support: IE 11+
			// <object> elements with no `data` attribute has an object
			// `contentDocument` with a `null` prototype.
			getProto( elem.contentDocument ) ) {

			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( _i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the primary Deferred
			primary = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						primary.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, primary.done( updateFunc( i ) ).resolve, primary.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( primary.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return primary.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), primary.reject );
		}

		return primary.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, _key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
						value :
						value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( _all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};



function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

	// Support: IE <=9 only
	// IE <=9 replaces <option> tags with their contents when inserted outside of
	// the select element.
	div.innerHTML = "<option></option>";
	support.option = !!div.lastChild;
} )();


// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: IE <=9 only
if ( !support.option ) {
	wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
}


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


var rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 - 11+
// focus() and blur() are asynchronous, except when they are no-op.
// So expect focus to be synchronous when the element is already active,
// and blur to be synchronous when the element is not already active.
// (focus and blur are always synchronous in other supported browsers,
// this just defines when we can count on it).
function expectSync( elem, type ) {
	return ( elem === safeActiveElement() ) === ( type === "focus" );
}

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Only attach events to objects that accept data
		if ( !acceptData( elem ) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = Object.create( null );
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( nativeEvent ),

			handlers = (
				dataPriv.get( this, "events" ) || Object.create( null )
			)[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
						return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
						return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", returnTrue );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, expectSync ) {

	// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
	if ( !expectSync ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var notAsync, result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				// Saved data should be false in such cases, but might be a leftover capture object
				// from an async native handler (gh-4350)
				if ( !saved.length ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					// Support: IE <=9 - 11+
					// focus() and blur() are asynchronous
					notAsync = expectSync( this, type );
					this[ type ]();
					result = dataPriv.get( this, type );
					if ( saved !== result || notAsync ) {
						dataPriv.set( this, type, false );
					} else {
						result = {};
					}
					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();

						// Support: Chrome 86+
						// In Chrome, if an element having a focusout handler is blurred by
						// clicking outside of it, it invokes the handler synchronously. If
						// that handler calls `.remove()` on the element, the data is cleared,
						// leaving `result` undefined. We need to guard against this.
						return result && result.value;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering the
				// native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved.length ) {

				// ...and capture the result
				dataPriv.set( this, type, {
					value: jQuery.event.trigger(

						// Support: IE <=9 - 11+
						// Extend with the prototype to reset the above stopImmediatePropagation()
						jQuery.extend( saved[ 0 ], jQuery.Event.prototype ),
						saved.slice( 1 ),
						this
					)
				} );

				// Abort handling of the native event
				event.stopImmediatePropagation();
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,
	which: true
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, expectSync );

			// Return false to allow normal processing in the caller
			return false;
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		// Suppress native focus or blur as it's already being fired
		// in leverageNative.
		_default: function() {
			return true;
		},

		delegateType: delegateType
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.get( src );
		events = pdataOld.events;

		if ( events ) {
			dataPriv.remove( dest, "handle events" );

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = flat( args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								}, doc );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html;
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var swap = function( elem, options, callback ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.call( elem );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableTrDimensionsVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		},

		// Support: IE 9 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Behavior in IE 9 is more subtle than in newer versions & it passes
		// some versions of this test; make sure not to make it pass there!
		//
		// Support: Firefox 70+
		// Only Firefox includes border widths
		// in computed dimensions. (gh-4529)
		reliableTrDimensions: function() {
			var table, tr, trChild, trStyle;
			if ( reliableTrDimensionsVal == null ) {
				table = document.createElement( "table" );
				tr = document.createElement( "tr" );
				trChild = document.createElement( "div" );

				table.style.cssText = "position:absolute;left:-11111px;border-collapse:separate";
				tr.style.cssText = "border:1px solid";

				// Support: Chrome 86+
				// Height set through cssText does not get applied.
				// Computed height then comes back as 0.
				tr.style.height = "1px";
				trChild.style.height = "9px";

				// Support: Android 8 Chrome 86+
				// In our bodyBackground.html iframe,
				// display for all div elements is set to "inline",
				// which causes a problem only in Android 8 Chrome 86.
				// Ensuring the div is display: block
				// gets around this issue.
				trChild.style.display = "block";

				documentElement
					.appendChild( table )
					.appendChild( tr )
					.appendChild( trChild );

				trStyle = window.getComputedStyle( tr );
				reliableTrDimensionsVal = ( parseInt( trStyle.height, 10 ) +
					parseInt( trStyle.borderTopWidth, 10 ) +
					parseInt( trStyle.borderBottomWidth, 10 ) ) === tr.offsetHeight;

				documentElement.removeChild( table );
			}
			return reliableTrDimensionsVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( _elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Support: IE 9 - 11 only
	// Use offsetWidth/offsetHeight for when box sizing is unreliable.
	// In those cases, the computed value can be trusted to be border-box.
	if ( ( !support.boxSizingReliable() && isBorderBox ||

		// Support: IE 10 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Interestingly, in some cases IE 9 doesn't suffer from this issue.
		!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

		// Fall back to offsetWidth/offsetHeight when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		val === "auto" ||

		// Support: Android <=4.1 - 4.3 only
		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

		// Make sure the element is visible & connected
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"gridArea": true,
		"gridColumn": true,
		"gridColumnEnd": true,
		"gridColumnStart": true,
		"gridRow": true,
		"gridRowEnd": true,
		"gridRowStart": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( _i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
					swap( elem, cssShow, function() {
						return getWidthOrHeight( elem, dimension, extra );
					} ) :
					getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
			) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
				jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

				/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
					animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};

		doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
							"" :
							dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
				return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || Object.create( null ) )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {

				// Handle: regular nodes (via `this.ownerDocument`), window
				// (via `this.document`) & document (via `this`).
				var doc = this.ownerDocument || this.document || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this.document || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = { guid: Date.now() };

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml, parserErrorElem;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {}

	parserErrorElem = xml && xml.getElementsByTagName( "parsererror" )[ 0 ];
	if ( !xml || parserErrorElem ) {
		jQuery.error( "Invalid XML: " + (
			parserErrorElem ?
				jQuery.map( parserErrorElem.childNodes, function( el ) {
					return el.textContent;
				} ).join( "\n" ) :
				data
		) );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} ).filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} ).map( function( _i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );

originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
				jQuery( callbackContext ) :
				jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
					uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Use a noop converter for missing script but not if jsonp
			if ( !isSuccess &&
				jQuery.inArray( "script", s.dataTypes ) > -1 &&
				jQuery.inArray( "json", s.dataTypes ) < 0 ) {
				s.converters[ "text script" ] = function() {};
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( _i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );

jQuery.ajaxPrefilter( function( s ) {
	var i;
	for ( i in s.headers ) {
		if ( i.toLowerCase() === "content-type" ) {
			s.contentType = s.headers[ i ] || "";
		}
	}
} );


jQuery._evalUrl = function( url, options, doc ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options, doc );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( _i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( {
		padding: "inner" + name,
		content: type,
		"": "outer" + name
	}, function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( _i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );

jQuery.each(
	( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( _i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	}
);




// Support: Android <=4.0 only
// Make sure we trim BOM and NBSP
var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};

jQuery.trim = function( text ) {
	return text == null ?
		"" :
		( text + "" ).replace( rtrim, "" );
};



// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	} );
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === "undefined" ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );

},{"process":"g5IB"}],"FtjA":[function(require,module,exports) {
//importing jquery first at the top level and making it globally availble
var $ = require('jquery');

window.$ = $;
window.jQuery = $;
globalThis.jQuery = $;
},{"jquery":"HlZQ"}],"v5IM":[function(require,module,exports) {
var global = arguments[3];
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

/**!
 * @fileOverview Kickass library to create and place poppers near their reference elements.
 * @version 1.16.1
 * @license
 * Copyright (c) 2016 Federico Zivolo and contributors
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && typeof navigator !== 'undefined';

var timeoutDuration = function () {
  var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];

  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
      return 1;
    }
  }

  return 0;
}();

function microtaskDebounce(fn) {
  var called = false;
  return function () {
    if (called) {
      return;
    }

    called = true;
    window.Promise.resolve().then(function () {
      called = false;
      fn();
    });
  };
}

function taskDebounce(fn) {
  var scheduled = false;
  return function () {
    if (!scheduled) {
      scheduled = true;
      setTimeout(function () {
        scheduled = false;
        fn();
      }, timeoutDuration);
    }
  };
}

var supportsMicroTasks = isBrowser && window.Promise;
/**
* Create a debounced version of a method, that's asynchronously deferred
* but called in the minimum time possible.
*
* @method
* @memberof Popper.Utils
* @argument {Function} fn
* @returns {Function}
*/

var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;
/**
 * Check if the given variable is a function
 * @method
 * @memberof Popper.Utils
 * @argument {Any} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */

function isFunction(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}
/**
 * Get CSS computed property of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Eement} element
 * @argument {String} property
 */


function getStyleComputedProperty(element, property) {
  if (element.nodeType !== 1) {
    return [];
  } // NOTE: 1 DOM access here


  var window = element.ownerDocument.defaultView;
  var css = window.getComputedStyle(element, null);
  return property ? css[property] : css;
}
/**
 * Returns the parentNode or the host of the element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} parent
 */


function getParentNode(element) {
  if (element.nodeName === 'HTML') {
    return element;
  }

  return element.parentNode || element.host;
}
/**
 * Returns the scrolling parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} scroll parent
 */


function getScrollParent(element) {
  // Return body, `getScroll` will take care to get the correct `scrollTop` from it
  if (!element) {
    return document.body;
  }

  switch (element.nodeName) {
    case 'HTML':
    case 'BODY':
      return element.ownerDocument.body;

    case '#document':
      return element.body;
  } // Firefox want us to check `-x` and `-y` variations as well


  var _getStyleComputedProp = getStyleComputedProperty(element),
      overflow = _getStyleComputedProp.overflow,
      overflowX = _getStyleComputedProp.overflowX,
      overflowY = _getStyleComputedProp.overflowY;

  if (/(auto|scroll|overlay)/.test(overflow + overflowY + overflowX)) {
    return element;
  }

  return getScrollParent(getParentNode(element));
}
/**
 * Returns the reference node of the reference object, or the reference object itself.
 * @method
 * @memberof Popper.Utils
 * @param {Element|Object} reference - the reference element (the popper will be relative to this)
 * @returns {Element} parent
 */


function getReferenceNode(reference) {
  return reference && reference.referenceNode ? reference.referenceNode : reference;
}

var isIE11 = isBrowser && !!(window.MSInputMethodContext && document.documentMode);
var isIE10 = isBrowser && /MSIE 10/.test(navigator.userAgent);
/**
 * Determines if the browser is Internet Explorer
 * @method
 * @memberof Popper.Utils
 * @param {Number} version to check
 * @returns {Boolean} isIE
 */

function isIE(version) {
  if (version === 11) {
    return isIE11;
  }

  if (version === 10) {
    return isIE10;
  }

  return isIE11 || isIE10;
}
/**
 * Returns the offset parent of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} offset parent
 */


function getOffsetParent(element) {
  if (!element) {
    return document.documentElement;
  }

  var noOffsetParent = isIE(10) ? document.body : null; // NOTE: 1 DOM access here

  var offsetParent = element.offsetParent || null; // Skip hidden elements which don't have an offsetParent

  while (offsetParent === noOffsetParent && element.nextElementSibling) {
    offsetParent = (element = element.nextElementSibling).offsetParent;
  }

  var nodeName = offsetParent && offsetParent.nodeName;

  if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
    return element ? element.ownerDocument.documentElement : document.documentElement;
  } // .offsetParent will return the closest TH, TD or TABLE in case
  // no offsetParent is present, I hate this job...


  if (['TH', 'TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
    return getOffsetParent(offsetParent);
  }

  return offsetParent;
}

function isOffsetContainer(element) {
  var nodeName = element.nodeName;

  if (nodeName === 'BODY') {
    return false;
  }

  return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
}
/**
 * Finds the root node (document, shadowDOM root) of the given element
 * @method
 * @memberof Popper.Utils
 * @argument {Element} node
 * @returns {Element} root node
 */


function getRoot(node) {
  if (node.parentNode !== null) {
    return getRoot(node.parentNode);
  }

  return node;
}
/**
 * Finds the offset parent common to the two provided nodes
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element1
 * @argument {Element} element2
 * @returns {Element} common offset parent
 */


function findCommonOffsetParent(element1, element2) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
    return document.documentElement;
  } // Here we make sure to give as "start" the element that comes first in the DOM


  var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
  var start = order ? element1 : element2;
  var end = order ? element2 : element1; // Get common ancestor container

  var range = document.createRange();
  range.setStart(start, 0);
  range.setEnd(end, 0);
  var commonAncestorContainer = range.commonAncestorContainer; // Both nodes are inside #document

  if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
    if (isOffsetContainer(commonAncestorContainer)) {
      return commonAncestorContainer;
    }

    return getOffsetParent(commonAncestorContainer);
  } // one of the nodes is inside shadowDOM, find which one


  var element1root = getRoot(element1);

  if (element1root.host) {
    return findCommonOffsetParent(element1root.host, element2);
  } else {
    return findCommonOffsetParent(element1, getRoot(element2).host);
  }
}
/**
 * Gets the scroll value of the given element in the given side (top and left)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {String} side `top` or `left`
 * @returns {number} amount of scrolled pixels
 */


function getScroll(element) {
  var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';
  var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
  var nodeName = element.nodeName;

  if (nodeName === 'BODY' || nodeName === 'HTML') {
    var html = element.ownerDocument.documentElement;
    var scrollingElement = element.ownerDocument.scrollingElement || html;
    return scrollingElement[upperSide];
  }

  return element[upperSide];
}
/*
 * Sum or subtract the element scroll values (left and top) from a given rect object
 * @method
 * @memberof Popper.Utils
 * @param {Object} rect - Rect object you want to change
 * @param {HTMLElement} element - The element from the function reads the scroll values
 * @param {Boolean} subtract - set to true if you want to subtract the scroll values
 * @return {Object} rect - The modifier rect object
 */


function includeScroll(rect, element) {
  var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var scrollTop = getScroll(element, 'top');
  var scrollLeft = getScroll(element, 'left');
  var modifier = subtract ? -1 : 1;
  rect.top += scrollTop * modifier;
  rect.bottom += scrollTop * modifier;
  rect.left += scrollLeft * modifier;
  rect.right += scrollLeft * modifier;
  return rect;
}
/*
 * Helper to detect borders of a given element
 * @method
 * @memberof Popper.Utils
 * @param {CSSStyleDeclaration} styles
 * Result of `getStyleComputedProperty` on the given element
 * @param {String} axis - `x` or `y`
 * @return {number} borders - The borders size of the given axis
 */


function getBordersSize(styles, axis) {
  var sideA = axis === 'x' ? 'Left' : 'Top';
  var sideB = sideA === 'Left' ? 'Right' : 'Bottom';
  return parseFloat(styles['border' + sideA + 'Width']) + parseFloat(styles['border' + sideB + 'Width']);
}

function getSize(axis, body, html, computedStyle) {
  return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE(10) ? parseInt(html['offset' + axis]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')]) + parseInt(computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')]) : 0);
}

function getWindowSizes(document) {
  var body = document.body;
  var html = document.documentElement;
  var computedStyle = isIE(10) && getComputedStyle(html);
  return {
    height: getSize('Height', body, html, computedStyle),
    width: getSize('Width', body, html, computedStyle)
  };
}

var classCallCheck = function (instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
};

var createClass = function () {
  function defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  return function (Constructor, protoProps, staticProps) {
    if (protoProps) defineProperties(Constructor.prototype, protoProps);
    if (staticProps) defineProperties(Constructor, staticProps);
    return Constructor;
  };
}();

var defineProperty = function (obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
};

var _extends = Object.assign || function (target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
};
/**
 * Given element offsets, generate an output similar to getBoundingClientRect
 * @method
 * @memberof Popper.Utils
 * @argument {Object} offsets
 * @returns {Object} ClientRect like output
 */


function getClientRect(offsets) {
  return _extends({}, offsets, {
    right: offsets.left + offsets.width,
    bottom: offsets.top + offsets.height
  });
}
/**
 * Get bounding client rect of given element
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} element
 * @return {Object} client rect
 */


function getBoundingClientRect(element) {
  var rect = {}; // IE10 10 FIX: Please, don't ask, the element isn't
  // considered in DOM in some circumstances...
  // This isn't reproducible in IE10 compatibility mode of IE11

  try {
    if (isIE(10)) {
      rect = element.getBoundingClientRect();
      var scrollTop = getScroll(element, 'top');
      var scrollLeft = getScroll(element, 'left');
      rect.top += scrollTop;
      rect.left += scrollLeft;
      rect.bottom += scrollTop;
      rect.right += scrollLeft;
    } else {
      rect = element.getBoundingClientRect();
    }
  } catch (e) {}

  var result = {
    left: rect.left,
    top: rect.top,
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  }; // subtract scrollbar size from sizes

  var sizes = element.nodeName === 'HTML' ? getWindowSizes(element.ownerDocument) : {};
  var width = sizes.width || element.clientWidth || result.width;
  var height = sizes.height || element.clientHeight || result.height;
  var horizScrollbar = element.offsetWidth - width;
  var vertScrollbar = element.offsetHeight - height; // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
  // we make this check conditional for performance reasons

  if (horizScrollbar || vertScrollbar) {
    var styles = getStyleComputedProperty(element);
    horizScrollbar -= getBordersSize(styles, 'x');
    vertScrollbar -= getBordersSize(styles, 'y');
    result.width -= horizScrollbar;
    result.height -= vertScrollbar;
  }

  return getClientRect(result);
}

function getOffsetRectRelativeToArbitraryNode(children, parent) {
  var fixedPosition = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
  var isIE10 = isIE(10);
  var isHTML = parent.nodeName === 'HTML';
  var childrenRect = getBoundingClientRect(children);
  var parentRect = getBoundingClientRect(parent);
  var scrollParent = getScrollParent(children);
  var styles = getStyleComputedProperty(parent);
  var borderTopWidth = parseFloat(styles.borderTopWidth);
  var borderLeftWidth = parseFloat(styles.borderLeftWidth); // In cases where the parent is fixed, we must ignore negative scroll in offset calc

  if (fixedPosition && isHTML) {
    parentRect.top = Math.max(parentRect.top, 0);
    parentRect.left = Math.max(parentRect.left, 0);
  }

  var offsets = getClientRect({
    top: childrenRect.top - parentRect.top - borderTopWidth,
    left: childrenRect.left - parentRect.left - borderLeftWidth,
    width: childrenRect.width,
    height: childrenRect.height
  });
  offsets.marginTop = 0;
  offsets.marginLeft = 0; // Subtract margins of documentElement in case it's being used as parent
  // we do this only on HTML because it's the only element that behaves
  // differently when margins are applied to it. The margins are included in
  // the box of the documentElement, in the other cases not.

  if (!isIE10 && isHTML) {
    var marginTop = parseFloat(styles.marginTop);
    var marginLeft = parseFloat(styles.marginLeft);
    offsets.top -= borderTopWidth - marginTop;
    offsets.bottom -= borderTopWidth - marginTop;
    offsets.left -= borderLeftWidth - marginLeft;
    offsets.right -= borderLeftWidth - marginLeft; // Attach marginTop and marginLeft because in some circumstances we may need them

    offsets.marginTop = marginTop;
    offsets.marginLeft = marginLeft;
  }

  if (isIE10 && !fixedPosition ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
    offsets = includeScroll(offsets, parent);
  }

  return offsets;
}

function getViewportOffsetRectRelativeToArtbitraryNode(element) {
  var excludeScroll = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var html = element.ownerDocument.documentElement;
  var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
  var width = Math.max(html.clientWidth, window.innerWidth || 0);
  var height = Math.max(html.clientHeight, window.innerHeight || 0);
  var scrollTop = !excludeScroll ? getScroll(html) : 0;
  var scrollLeft = !excludeScroll ? getScroll(html, 'left') : 0;
  var offset = {
    top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
    left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
    width: width,
    height: height
  };
  return getClientRect(offset);
}
/**
 * Check if the given element is fixed or is inside a fixed parent
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */


function isFixed(element) {
  var nodeName = element.nodeName;

  if (nodeName === 'BODY' || nodeName === 'HTML') {
    return false;
  }

  if (getStyleComputedProperty(element, 'position') === 'fixed') {
    return true;
  }

  var parentNode = getParentNode(element);

  if (!parentNode) {
    return false;
  }

  return isFixed(parentNode);
}
/**
 * Finds the first parent of an element that has a transformed property defined
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Element} first transformed parent or documentElement
 */


function getFixedPositionOffsetParent(element) {
  // This check is needed to avoid errors in case one of the elements isn't defined for any reason
  if (!element || !element.parentElement || isIE()) {
    return document.documentElement;
  }

  var el = element.parentElement;

  while (el && getStyleComputedProperty(el, 'transform') === 'none') {
    el = el.parentElement;
  }

  return el || document.documentElement;
}
/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper.Utils
 * @param {HTMLElement} popper
 * @param {HTMLElement} reference
 * @param {number} padding
 * @param {HTMLElement} boundariesElement - Element used to define the boundaries
 * @param {Boolean} fixedPosition - Is in fixed position mode
 * @returns {Object} Coordinates of the boundaries
 */


function getBoundaries(popper, reference, padding, boundariesElement) {
  var fixedPosition = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false; // NOTE: 1 DOM access here

  var boundaries = {
    top: 0,
    left: 0
  };
  var offsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference)); // Handle viewport case

  if (boundariesElement === 'viewport') {
    boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent, fixedPosition);
  } else {
    // Handle other cases based on DOM element used as boundaries
    var boundariesNode = void 0;

    if (boundariesElement === 'scrollParent') {
      boundariesNode = getScrollParent(getParentNode(reference));

      if (boundariesNode.nodeName === 'BODY') {
        boundariesNode = popper.ownerDocument.documentElement;
      }
    } else if (boundariesElement === 'window') {
      boundariesNode = popper.ownerDocument.documentElement;
    } else {
      boundariesNode = boundariesElement;
    }

    var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent, fixedPosition); // In case of HTML, we need a different computation

    if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
      var _getWindowSizes = getWindowSizes(popper.ownerDocument),
          height = _getWindowSizes.height,
          width = _getWindowSizes.width;

      boundaries.top += offsets.top - offsets.marginTop;
      boundaries.bottom = height + offsets.top;
      boundaries.left += offsets.left - offsets.marginLeft;
      boundaries.right = width + offsets.left;
    } else {
      // for all the other DOM elements, this one is good
      boundaries = offsets;
    }
  } // Add paddings


  padding = padding || 0;
  var isPaddingNumber = typeof padding === 'number';
  boundaries.left += isPaddingNumber ? padding : padding.left || 0;
  boundaries.top += isPaddingNumber ? padding : padding.top || 0;
  boundaries.right -= isPaddingNumber ? padding : padding.right || 0;
  boundaries.bottom -= isPaddingNumber ? padding : padding.bottom || 0;
  return boundaries;
}

function getArea(_ref) {
  var width = _ref.width,
      height = _ref.height;
  return width * height;
}
/**
 * Utility used to transform the `auto` placement to the placement with more
 * available space.
 * @method
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
  var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

  if (placement.indexOf('auto') === -1) {
    return placement;
  }

  var boundaries = getBoundaries(popper, reference, padding, boundariesElement);
  var rects = {
    top: {
      width: boundaries.width,
      height: refRect.top - boundaries.top
    },
    right: {
      width: boundaries.right - refRect.right,
      height: boundaries.height
    },
    bottom: {
      width: boundaries.width,
      height: boundaries.bottom - refRect.bottom
    },
    left: {
      width: refRect.left - boundaries.left,
      height: boundaries.height
    }
  };
  var sortedAreas = Object.keys(rects).map(function (key) {
    return _extends({
      key: key
    }, rects[key], {
      area: getArea(rects[key])
    });
  }).sort(function (a, b) {
    return b.area - a.area;
  });
  var filteredAreas = sortedAreas.filter(function (_ref2) {
    var width = _ref2.width,
        height = _ref2.height;
    return width >= popper.clientWidth && height >= popper.clientHeight;
  });
  var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;
  var variation = placement.split('-')[1];
  return computedPlacement + (variation ? '-' + variation : '');
}
/**
 * Get offsets to the reference element
 * @method
 * @memberof Popper.Utils
 * @param {Object} state
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @param {Element} fixedPosition - is in fixed position mode
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */


function getReferenceOffsets(state, popper, reference) {
  var fixedPosition = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
  var commonOffsetParent = fixedPosition ? getFixedPositionOffsetParent(popper) : findCommonOffsetParent(popper, getReferenceNode(reference));
  return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent, fixedPosition);
}
/**
 * Get the outer sizes of the given element (offset size + margins)
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */


function getOuterSizes(element) {
  var window = element.ownerDocument.defaultView;
  var styles = window.getComputedStyle(element);
  var x = parseFloat(styles.marginTop || 0) + parseFloat(styles.marginBottom || 0);
  var y = parseFloat(styles.marginLeft || 0) + parseFloat(styles.marginRight || 0);
  var result = {
    width: element.offsetWidth + y,
    height: element.offsetHeight + x
  };
  return result;
}
/**
 * Get the opposite placement of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement
 * @returns {String} flipped placement
 */


function getOppositePlacement(placement) {
  var hash = {
    left: 'right',
    right: 'left',
    bottom: 'top',
    top: 'bottom'
  };
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}
/**
 * Get offsets to the popper
 * @method
 * @memberof Popper.Utils
 * @param {Object} position - CSS position the Popper will get applied
 * @param {HTMLElement} popper - the popper element
 * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
 * @param {String} placement - one of the valid placement options
 * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
 */


function getPopperOffsets(popper, referenceOffsets, placement) {
  placement = placement.split('-')[0]; // Get popper node sizes

  var popperRect = getOuterSizes(popper); // Add position, width and height to our offsets object

  var popperOffsets = {
    width: popperRect.width,
    height: popperRect.height
  }; // depending by the popper placement we have to compute its offsets slightly differently

  var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
  var mainSide = isHoriz ? 'top' : 'left';
  var secondarySide = isHoriz ? 'left' : 'top';
  var measurement = isHoriz ? 'height' : 'width';
  var secondaryMeasurement = !isHoriz ? 'height' : 'width';
  popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;

  if (placement === secondarySide) {
    popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
  } else {
    popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
  }

  return popperOffsets;
}
/**
 * Mimics the `find` method of Array
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */


function find(arr, check) {
  // use native find if supported
  if (Array.prototype.find) {
    return arr.find(check);
  } // use `filter` to obtain the same behavior of `find`


  return arr.filter(check)[0];
}
/**
 * Return the index of the matching object
 * @method
 * @memberof Popper.Utils
 * @argument {Array} arr
 * @argument prop
 * @argument value
 * @returns index or -1
 */


function findIndex(arr, prop, value) {
  // use native findIndex if supported
  if (Array.prototype.findIndex) {
    return arr.findIndex(function (cur) {
      return cur[prop] === value;
    });
  } // use `find` + `indexOf` if `findIndex` isn't supported


  var match = find(arr, function (obj) {
    return obj[prop] === value;
  });
  return arr.indexOf(match);
}
/**
 * Loop trough the list of modifiers and run them in order,
 * each of them will then edit the data object.
 * @method
 * @memberof Popper.Utils
 * @param {dataObject} data
 * @param {Array} modifiers
 * @param {String} ends - Optional modifier name used as stopper
 * @returns {dataObject}
 */


function runModifiers(modifiers, data, ends) {
  var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex(modifiers, 'name', ends));
  modifiersToRun.forEach(function (modifier) {
    if (modifier['function']) {
      // eslint-disable-line dot-notation
      console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
    }

    var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation

    if (modifier.enabled && isFunction(fn)) {
      // Add properties to offsets to make them a complete clientRect object
      // we do this before each modifier to make sure the previous one doesn't
      // mess with these values
      data.offsets.popper = getClientRect(data.offsets.popper);
      data.offsets.reference = getClientRect(data.offsets.reference);
      data = fn(data, modifier);
    }
  });
  return data;
}
/**
 * Updates the position of the popper, computing the new offsets and applying
 * the new style.<br />
 * Prefer `scheduleUpdate` over `update` because of performance reasons.
 * @method
 * @memberof Popper
 */


function update() {
  // if popper is destroyed, don't perform any further update
  if (this.state.isDestroyed) {
    return;
  }

  var data = {
    instance: this,
    styles: {},
    arrowStyles: {},
    attributes: {},
    flipped: false,
    offsets: {}
  }; // compute reference element offsets

  data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference, this.options.positionFixed); // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value

  data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding); // store the computed placement inside `originalPlacement`

  data.originalPlacement = data.placement;
  data.positionFixed = this.options.positionFixed; // compute the popper offsets

  data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
  data.offsets.popper.position = this.options.positionFixed ? 'fixed' : 'absolute'; // run the modifiers

  data = runModifiers(this.modifiers, data); // the first `update` will call `onCreate` callback
  // the other ones will call `onUpdate` callback

  if (!this.state.isCreated) {
    this.state.isCreated = true;
    this.options.onCreate(data);
  } else {
    this.options.onUpdate(data);
  }
}
/**
 * Helper used to know if the given modifier is enabled.
 * @method
 * @memberof Popper.Utils
 * @returns {Boolean}
 */


function isModifierEnabled(modifiers, modifierName) {
  return modifiers.some(function (_ref) {
    var name = _ref.name,
        enabled = _ref.enabled;
    return enabled && name === modifierName;
  });
}
/**
 * Get the prefixed supported property name
 * @method
 * @memberof Popper.Utils
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
 */


function getSupportedPropertyName(property) {
  var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
  var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

  for (var i = 0; i < prefixes.length; i++) {
    var prefix = prefixes[i];
    var toCheck = prefix ? '' + prefix + upperProp : property;

    if (typeof document.body.style[toCheck] !== 'undefined') {
      return toCheck;
    }
  }

  return null;
}
/**
 * Destroys the popper.
 * @method
 * @memberof Popper
 */


function destroy() {
  this.state.isDestroyed = true; // touch DOM only if `applyStyle` modifier is enabled

  if (isModifierEnabled(this.modifiers, 'applyStyle')) {
    this.popper.removeAttribute('x-placement');
    this.popper.style.position = '';
    this.popper.style.top = '';
    this.popper.style.left = '';
    this.popper.style.right = '';
    this.popper.style.bottom = '';
    this.popper.style.willChange = '';
    this.popper.style[getSupportedPropertyName('transform')] = '';
  }

  this.disableEventListeners(); // remove the popper if user explicitly asked for the deletion on destroy
  // do not use `remove` because IE11 doesn't support it

  if (this.options.removeOnDestroy) {
    this.popper.parentNode.removeChild(this.popper);
  }

  return this;
}
/**
 * Get the window associated with the element
 * @argument {Element} element
 * @returns {Window}
 */


function getWindow(element) {
  var ownerDocument = element.ownerDocument;
  return ownerDocument ? ownerDocument.defaultView : window;
}

function attachToScrollParents(scrollParent, event, callback, scrollParents) {
  var isBody = scrollParent.nodeName === 'BODY';
  var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
  target.addEventListener(event, callback, {
    passive: true
  });

  if (!isBody) {
    attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
  }

  scrollParents.push(target);
}
/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */


function setupEventListeners(reference, options, state, updateBound) {
  // Resize event listener on window
  state.updateBound = updateBound;
  getWindow(reference).addEventListener('resize', state.updateBound, {
    passive: true
  }); // Scroll event listener on scroll parents

  var scrollElement = getScrollParent(reference);
  attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
  state.scrollElement = scrollElement;
  state.eventsEnabled = true;
  return state;
}
/**
 * It will add resize/scroll events and start recalculating
 * position of the popper element when they are triggered.
 * @method
 * @memberof Popper
 */


function enableEventListeners() {
  if (!this.state.eventsEnabled) {
    this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
  }
}
/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper.Utils
 * @private
 */


function removeEventListeners(reference, state) {
  // Remove resize event listener on window
  getWindow(reference).removeEventListener('resize', state.updateBound); // Remove scroll event listener on scroll parents

  state.scrollParents.forEach(function (target) {
    target.removeEventListener('scroll', state.updateBound);
  }); // Reset state

  state.updateBound = null;
  state.scrollParents = [];
  state.scrollElement = null;
  state.eventsEnabled = false;
  return state;
}
/**
 * It will remove resize/scroll events and won't recalculate popper position
 * when they are triggered. It also won't trigger `onUpdate` callback anymore,
 * unless you call `update` method manually.
 * @method
 * @memberof Popper
 */


function disableEventListeners() {
  if (this.state.eventsEnabled) {
    cancelAnimationFrame(this.scheduleUpdate);
    this.state = removeEventListeners(this.reference, this.state);
  }
}
/**
 * Tells if a given input is a number
 * @method
 * @memberof Popper.Utils
 * @param {*} input to check
 * @return {Boolean}
 */


function isNumeric(n) {
  return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
}
/**
 * Set the style to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */


function setStyles(element, styles) {
  Object.keys(styles).forEach(function (prop) {
    var unit = ''; // add unit if the value is numeric and is one of the following

    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
      unit = 'px';
    }

    element.style[prop] = styles[prop] + unit;
  });
}
/**
 * Set the attributes to the given popper
 * @method
 * @memberof Popper.Utils
 * @argument {Element} element - Element to apply the attributes to
 * @argument {Object} styles
 * Object with a list of properties and values which will be applied to the element
 */


function setAttributes(element, attributes) {
  Object.keys(attributes).forEach(function (prop) {
    var value = attributes[prop];

    if (value !== false) {
      element.setAttribute(prop, attributes[prop]);
    } else {
      element.removeAttribute(prop);
    }
  });
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} data.styles - List of style properties - values to apply to popper element
 * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The same data object
 */


function applyStyle(data) {
  // any property present in `data.styles` will be applied to the popper,
  // in this way we can make the 3rd party modifiers add custom styles to it
  // Be aware, modifiers could override the properties defined in the previous
  // lines of this modifier!
  setStyles(data.instance.popper, data.styles); // any property present in `data.attributes` will be applied to the popper,
  // they will be set as HTML attributes of the element

  setAttributes(data.instance.popper, data.attributes); // if arrowElement is defined and arrowStyles has some properties

  if (data.arrowElement && Object.keys(data.arrowStyles).length) {
    setStyles(data.arrowElement, data.arrowStyles);
  }

  return data;
}
/**
 * Set the x-placement attribute before everything else because it could be used
 * to add margins to the popper margins needs to be calculated to get the
 * correct popper offsets.
 * @method
 * @memberof Popper.modifiers
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement} popper - The HTML element used as popper
 * @param {Object} options - Popper.js options
 */


function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
  // compute reference element offsets
  var referenceOffsets = getReferenceOffsets(state, popper, reference, options.positionFixed); // compute auto placement, store placement inside the data object,
  // modifiers will be able to edit `placement` if needed
  // and refer to originalPlacement to know the original value

  var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);
  popper.setAttribute('x-placement', placement); // Apply `position` to popper before anything else because
  // without the position applied we can't guarantee correct computations

  setStyles(popper, {
    position: options.positionFixed ? 'fixed' : 'absolute'
  });
  return options;
}
/**
 * @function
 * @memberof Popper.Utils
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Boolean} shouldRound - If the offsets should be rounded at all
 * @returns {Object} The popper's position offsets rounded
 *
 * The tale of pixel-perfect positioning. It's still not 100% perfect, but as
 * good as it can be within reason.
 * Discussion here: https://github.com/FezVrasta/popper.js/pull/715
 *
 * Low DPI screens cause a popper to be blurry if not using full pixels (Safari
 * as well on High DPI screens).
 *
 * Firefox prefers no rounding for positioning and does not have blurriness on
 * high DPI screens.
 *
 * Only horizontal placement and left/right values need to be considered.
 */


function getRoundedOffsets(data, shouldRound) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var round = Math.round,
      floor = Math.floor;

  var noRound = function noRound(v) {
    return v;
  };

  var referenceWidth = round(reference.width);
  var popperWidth = round(popper.width);
  var isVertical = ['left', 'right'].indexOf(data.placement) !== -1;
  var isVariation = data.placement.indexOf('-') !== -1;
  var sameWidthParity = referenceWidth % 2 === popperWidth % 2;
  var bothOddWidth = referenceWidth % 2 === 1 && popperWidth % 2 === 1;
  var horizontalToInteger = !shouldRound ? noRound : isVertical || isVariation || sameWidthParity ? round : floor;
  var verticalToInteger = !shouldRound ? noRound : round;
  return {
    left: horizontalToInteger(bothOddWidth && !isVariation && shouldRound ? popper.left - 1 : popper.left),
    top: verticalToInteger(popper.top),
    bottom: verticalToInteger(popper.bottom),
    right: horizontalToInteger(popper.right)
  };
}

var isFirefox = isBrowser && /Firefox/i.test(navigator.userAgent);
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */

function computeStyle(data, options) {
  var x = options.x,
      y = options.y;
  var popper = data.offsets.popper; // Remove this legacy support in Popper.js v2

  var legacyGpuAccelerationOption = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'applyStyle';
  }).gpuAcceleration;

  if (legacyGpuAccelerationOption !== undefined) {
    console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
  }

  var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;
  var offsetParent = getOffsetParent(data.instance.popper);
  var offsetParentRect = getBoundingClientRect(offsetParent); // Styles

  var styles = {
    position: popper.position
  };
  var offsets = getRoundedOffsets(data, window.devicePixelRatio < 2 || !isFirefox);
  var sideA = x === 'bottom' ? 'top' : 'bottom';
  var sideB = y === 'right' ? 'left' : 'right'; // if gpuAcceleration is set to `true` and transform is supported,
  //  we use `translate3d` to apply the position to the popper we
  // automatically use the supported prefixed version if needed

  var prefixedProperty = getSupportedPropertyName('transform'); // now, let's make a step back and look at this code closely (wtf?)
  // If the content of the popper grows once it's been positioned, it
  // may happen that the popper gets misplaced because of the new content
  // overflowing its reference element
  // To avoid this problem, we provide two options (x and y), which allow
  // the consumer to define the offset origin.
  // If we position a popper on top of a reference element, we can set
  // `x` to `top` to make the popper grow towards its top instead of
  // its bottom.

  var left = void 0,
      top = void 0;

  if (sideA === 'bottom') {
    // when offsetParent is <html> the positioning is relative to the bottom of the screen (excluding the scrollbar)
    // and not the bottom of the html element
    if (offsetParent.nodeName === 'HTML') {
      top = -offsetParent.clientHeight + offsets.bottom;
    } else {
      top = -offsetParentRect.height + offsets.bottom;
    }
  } else {
    top = offsets.top;
  }

  if (sideB === 'right') {
    if (offsetParent.nodeName === 'HTML') {
      left = -offsetParent.clientWidth + offsets.right;
    } else {
      left = -offsetParentRect.width + offsets.right;
    }
  } else {
    left = offsets.left;
  }

  if (gpuAcceleration && prefixedProperty) {
    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
    styles[sideA] = 0;
    styles[sideB] = 0;
    styles.willChange = 'transform';
  } else {
    // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
    var invertTop = sideA === 'bottom' ? -1 : 1;
    var invertLeft = sideB === 'right' ? -1 : 1;
    styles[sideA] = top * invertTop;
    styles[sideB] = left * invertLeft;
    styles.willChange = sideA + ', ' + sideB;
  } // Attributes


  var attributes = {
    'x-placement': data.placement
  }; // Update `data` attributes, styles and arrowStyles

  data.attributes = _extends({}, attributes, data.attributes);
  data.styles = _extends({}, styles, data.styles);
  data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);
  return data;
}
/**
 * Helper used to know if the given modifier depends from another one.<br />
 * It checks if the needed modifier is listed and enabled.
 * @method
 * @memberof Popper.Utils
 * @param {Array} modifiers - list of modifiers
 * @param {String} requestingName - name of requesting modifier
 * @param {String} requestedName - name of requested modifier
 * @returns {Boolean}
 */


function isModifierRequired(modifiers, requestingName, requestedName) {
  var requesting = find(modifiers, function (_ref) {
    var name = _ref.name;
    return name === requestingName;
  });
  var isRequired = !!requesting && modifiers.some(function (modifier) {
    return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
  });

  if (!isRequired) {
    var _requesting = '`' + requestingName + '`';

    var requested = '`' + requestedName + '`';
    console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
  }

  return isRequired;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function arrow(data, options) {
  var _data$offsets$arrow; // arrow depends on keepTogether in order to work


  if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
    return data;
  }

  var arrowElement = options.element; // if arrowElement is a string, suppose it's a CSS selector

  if (typeof arrowElement === 'string') {
    arrowElement = data.instance.popper.querySelector(arrowElement); // if arrowElement is not found, don't run the modifier

    if (!arrowElement) {
      return data;
    }
  } else {
    // if the arrowElement isn't a query selector we must check that the
    // provided DOM node is child of its popper node
    if (!data.instance.popper.contains(arrowElement)) {
      console.warn('WARNING: `arrow.element` must be child of its popper element!');
      return data;
    }
  }

  var placement = data.placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var isVertical = ['left', 'right'].indexOf(placement) !== -1;
  var len = isVertical ? 'height' : 'width';
  var sideCapitalized = isVertical ? 'Top' : 'Left';
  var side = sideCapitalized.toLowerCase();
  var altSide = isVertical ? 'left' : 'top';
  var opSide = isVertical ? 'bottom' : 'right';
  var arrowElementSize = getOuterSizes(arrowElement)[len]; //
  // extends keepTogether behavior making sure the popper and its
  // reference have enough pixels in conjunction
  //
  // top/left side

  if (reference[opSide] - arrowElementSize < popper[side]) {
    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
  } // bottom/right side


  if (reference[side] + arrowElementSize > popper[opSide]) {
    data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
  }

  data.offsets.popper = getClientRect(data.offsets.popper); // compute center of the popper

  var center = reference[side] + reference[len] / 2 - arrowElementSize / 2; // Compute the sideValue using the updated popper offsets
  // take popper margin in account because we don't have this info available

  var css = getStyleComputedProperty(data.instance.popper);
  var popperMarginSide = parseFloat(css['margin' + sideCapitalized]);
  var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width']);
  var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide; // prevent arrowElement from being placed not contiguously to its popper

  sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);
  data.arrowElement = arrowElement;
  data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);
  return data;
}
/**
 * Get the opposite placement variation of the given one
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement variation
 * @returns {String} flipped placement variation
 */


function getOppositeVariation(variation) {
  if (variation === 'end') {
    return 'start';
  } else if (variation === 'start') {
    return 'end';
  }

  return variation;
}
/**
 * List of accepted placements to use as values of the `placement` option.<br />
 * Valid placements are:
 * - `auto`
 * - `top`
 * - `right`
 * - `bottom`
 * - `left`
 *
 * Each placement can have a variation from this list:
 * - `-start`
 * - `-end`
 *
 * Variations are interpreted easily if you think of them as the left to right
 * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
 * is right.<br />
 * Vertically (`left` and `right`), `start` is top and `end` is bottom.
 *
 * Some valid examples are:
 * - `top-end` (on top of reference, right aligned)
 * - `right-start` (on right of reference, top aligned)
 * - `bottom` (on bottom, centered)
 * - `auto-end` (on the side with more space available, alignment depends by placement)
 *
 * @static
 * @type {Array}
 * @enum {String}
 * @readonly
 * @method placements
 * @memberof Popper
 */


var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start']; // Get rid of `auto` `auto-start` and `auto-end`

var validPlacements = placements.slice(3);
/**
 * Given an initial placement, returns all the subsequent placements
 * clockwise (or counter-clockwise).
 *
 * @method
 * @memberof Popper.Utils
 * @argument {String} placement - A valid placement (it accepts variations)
 * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
 * @returns {Array} placements including their variations
 */

function clockwise(placement) {
  var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var index = validPlacements.indexOf(placement);
  var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
  return counter ? arr.reverse() : arr;
}

var BEHAVIORS = {
  FLIP: 'flip',
  CLOCKWISE: 'clockwise',
  COUNTERCLOCKWISE: 'counterclockwise'
};
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */

function flip(data, options) {
  // if `inner` modifier is enabled, we can't use the `flip` modifier
  if (isModifierEnabled(data.instance.modifiers, 'inner')) {
    return data;
  }

  if (data.flipped && data.placement === data.originalPlacement) {
    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
    return data;
  }

  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement, data.positionFixed);
  var placement = data.placement.split('-')[0];
  var placementOpposite = getOppositePlacement(placement);
  var variation = data.placement.split('-')[1] || '';
  var flipOrder = [];

  switch (options.behavior) {
    case BEHAVIORS.FLIP:
      flipOrder = [placement, placementOpposite];
      break;

    case BEHAVIORS.CLOCKWISE:
      flipOrder = clockwise(placement);
      break;

    case BEHAVIORS.COUNTERCLOCKWISE:
      flipOrder = clockwise(placement, true);
      break;

    default:
      flipOrder = options.behavior;
  }

  flipOrder.forEach(function (step, index) {
    if (placement !== step || flipOrder.length === index + 1) {
      return data;
    }

    placement = data.placement.split('-')[0];
    placementOpposite = getOppositePlacement(placement);
    var popperOffsets = data.offsets.popper;
    var refOffsets = data.offsets.reference; // using floor because the reference offsets may contain decimals we are not going to consider here

    var floor = Math.floor;
    var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);
    var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
    var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
    var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
    var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);
    var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom; // flip the variation if required

    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1; // flips variation if reference element overflows boundaries

    var flippedVariationByRef = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom); // flips variation if popper content overflows boundaries

    var flippedVariationByContent = !!options.flipVariationsByContent && (isVertical && variation === 'start' && overflowsRight || isVertical && variation === 'end' && overflowsLeft || !isVertical && variation === 'start' && overflowsBottom || !isVertical && variation === 'end' && overflowsTop);
    var flippedVariation = flippedVariationByRef || flippedVariationByContent;

    if (overlapsRef || overflowsBoundaries || flippedVariation) {
      // this boolean to detect any flip loop
      data.flipped = true;

      if (overlapsRef || overflowsBoundaries) {
        placement = flipOrder[index + 1];
      }

      if (flippedVariation) {
        variation = getOppositeVariation(variation);
      }

      data.placement = placement + (variation ? '-' + variation : ''); // this object contains `position`, we want to preserve it along with
      // any additional property we may add in the future

      data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));
      data = runModifiers(data.instance.modifiers, data, 'flip');
    }
  });
  return data;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function keepTogether(data) {
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var placement = data.placement.split('-')[0];
  var floor = Math.floor;
  var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
  var side = isVertical ? 'right' : 'bottom';
  var opSide = isVertical ? 'left' : 'top';
  var measurement = isVertical ? 'width' : 'height';

  if (popper[side] < floor(reference[opSide])) {
    data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
  }

  if (popper[opSide] > floor(reference[side])) {
    data.offsets.popper[opSide] = floor(reference[side]);
  }

  return data;
}
/**
 * Converts a string containing value + unit into a px value number
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} str - Value + unit string
 * @argument {String} measurement - `height` or `width`
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @returns {Number|String}
 * Value in pixels, or original string if no values were extracted
 */


function toValue(str, measurement, popperOffsets, referenceOffsets) {
  // separate value from unit
  var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
  var value = +split[1];
  var unit = split[2]; // If it's not a number it's an operator, I guess

  if (!value) {
    return str;
  }

  if (unit.indexOf('%') === 0) {
    var element = void 0;

    switch (unit) {
      case '%p':
        element = popperOffsets;
        break;

      case '%':
      case '%r':
      default:
        element = referenceOffsets;
    }

    var rect = getClientRect(element);
    return rect[measurement] / 100 * value;
  } else if (unit === 'vh' || unit === 'vw') {
    // if is a vh or vw, we calculate the size based on the viewport
    var size = void 0;

    if (unit === 'vh') {
      size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
    } else {
      size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
    }

    return size / 100 * value;
  } else {
    // if is an explicit pixel unit, we get rid of the unit and keep the value
    // if is an implicit unit, it's px, and we return just the value
    return value;
  }
}
/**
 * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
 * @function
 * @memberof {modifiers~offset}
 * @private
 * @argument {String} offset
 * @argument {Object} popperOffsets
 * @argument {Object} referenceOffsets
 * @argument {String} basePlacement
 * @returns {Array} a two cells array with x and y offsets in numbers
 */


function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
  var offsets = [0, 0]; // Use height if placement is left or right and index is 0 otherwise use width
  // in this way the first offset will use an axis and the second one
  // will use the other one

  var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1; // Split the offset string to obtain a list of values and operands
  // The regex addresses values with the plus or minus sign in front (+10, -20, etc)

  var fragments = offset.split(/(\+|\-)/).map(function (frag) {
    return frag.trim();
  }); // Detect if the offset string contains a pair of values or a single one
  // they could be separated by comma or space

  var divider = fragments.indexOf(find(fragments, function (frag) {
    return frag.search(/,|\s/) !== -1;
  }));

  if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
    console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
  } // If divider is found, we divide the list of values and operands to divide
  // them by ofset X and Y.


  var splitRegex = /\s*,\s*|\s+/;
  var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments]; // Convert the values with units to absolute pixels to allow our computations

  ops = ops.map(function (op, index) {
    // Most of the units rely on the orientation of the popper
    var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
    var mergeWithPrevious = false;
    return op // This aggregates any `+` or `-` sign that aren't considered operators
    // e.g.: 10 + +5 => [10, +, +5]
    .reduce(function (a, b) {
      if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
        a[a.length - 1] = b;
        mergeWithPrevious = true;
        return a;
      } else if (mergeWithPrevious) {
        a[a.length - 1] += b;
        mergeWithPrevious = false;
        return a;
      } else {
        return a.concat(b);
      }
    }, []) // Here we convert the string values into number values (in px)
    .map(function (str) {
      return toValue(str, measurement, popperOffsets, referenceOffsets);
    });
  }); // Loop trough the offsets arrays and execute the operations

  ops.forEach(function (op, index) {
    op.forEach(function (frag, index2) {
      if (isNumeric(frag)) {
        offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
      }
    });
  });
  return offsets;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @argument {Number|String} options.offset=0
 * The offset value as described in the modifier description
 * @returns {Object} The data object, properly modified
 */


function offset(data, _ref) {
  var offset = _ref.offset;
  var placement = data.placement,
      _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var basePlacement = placement.split('-')[0];
  var offsets = void 0;

  if (isNumeric(+offset)) {
    offsets = [+offset, 0];
  } else {
    offsets = parseOffset(offset, popper, reference, basePlacement);
  }

  if (basePlacement === 'left') {
    popper.top += offsets[0];
    popper.left -= offsets[1];
  } else if (basePlacement === 'right') {
    popper.top += offsets[0];
    popper.left += offsets[1];
  } else if (basePlacement === 'top') {
    popper.left += offsets[0];
    popper.top -= offsets[1];
  } else if (basePlacement === 'bottom') {
    popper.left += offsets[0];
    popper.top += offsets[1];
  }

  data.popper = popper;
  return data;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function preventOverflow(data, options) {
  var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper); // If offsetParent is the reference element, we really want to
  // go one step up and use the next offsetParent as reference to
  // avoid to make this modifier completely useless and look like broken

  if (data.instance.reference === boundariesElement) {
    boundariesElement = getOffsetParent(boundariesElement);
  } // NOTE: DOM access here
  // resets the popper's position so that the document size can be calculated excluding
  // the size of the popper element itself


  var transformProp = getSupportedPropertyName('transform');
  var popperStyles = data.instance.popper.style; // assignment to help minification

  var top = popperStyles.top,
      left = popperStyles.left,
      transform = popperStyles[transformProp];
  popperStyles.top = '';
  popperStyles.left = '';
  popperStyles[transformProp] = '';
  var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement, data.positionFixed); // NOTE: DOM access here
  // restores the original style properties after the offsets have been computed

  popperStyles.top = top;
  popperStyles.left = left;
  popperStyles[transformProp] = transform;
  options.boundaries = boundaries;
  var order = options.priority;
  var popper = data.offsets.popper;
  var check = {
    primary: function primary(placement) {
      var value = popper[placement];

      if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
        value = Math.max(popper[placement], boundaries[placement]);
      }

      return defineProperty({}, placement, value);
    },
    secondary: function secondary(placement) {
      var mainSide = placement === 'right' ? 'left' : 'top';
      var value = popper[mainSide];

      if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
        value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
      }

      return defineProperty({}, mainSide, value);
    }
  };
  order.forEach(function (placement) {
    var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
    popper = _extends({}, popper, check[side](placement));
  });
  data.offsets.popper = popper;
  return data;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function shift(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var shiftvariation = placement.split('-')[1]; // if shift shiftvariation is specified, run the modifier

  if (shiftvariation) {
    var _data$offsets = data.offsets,
        reference = _data$offsets.reference,
        popper = _data$offsets.popper;
    var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
    var side = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';
    var shiftOffsets = {
      start: defineProperty({}, side, reference[side]),
      end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
    };
    data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
  }

  return data;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by update method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function hide(data) {
  if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
    return data;
  }

  var refRect = data.offsets.reference;
  var bound = find(data.instance.modifiers, function (modifier) {
    return modifier.name === 'preventOverflow';
  }).boundaries;

  if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === true) {
      return data;
    }

    data.hide = true;
    data.attributes['x-out-of-boundaries'] = '';
  } else {
    // Avoid unnecessary DOM access if visibility hasn't changed
    if (data.hide === false) {
      return data;
    }

    data.hide = false;
    data.attributes['x-out-of-boundaries'] = false;
  }

  return data;
}
/**
 * @function
 * @memberof Modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {Object} The data object, properly modified
 */


function inner(data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var _data$offsets = data.offsets,
      popper = _data$offsets.popper,
      reference = _data$offsets.reference;
  var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;
  var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;
  popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);
  data.placement = getOppositePlacement(placement);
  data.offsets.popper = getClientRect(popper);
  return data;
}
/**
 * Modifier function, each modifier can have a function of this type assigned
 * to its `fn` property.<br />
 * These functions will be called on each update, this means that you must
 * make sure they are performant enough to avoid performance bottlenecks.
 *
 * @function ModifierFn
 * @argument {dataObject} data - The data object generated by `update` method
 * @argument {Object} options - Modifiers configuration and options
 * @returns {dataObject} The data object, properly modified
 */

/**
 * Modifiers are plugins used to alter the behavior of your poppers.<br />
 * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
 * needed by the library.
 *
 * Usually you don't want to override the `order`, `fn` and `onLoad` props.
 * All the other properties are configurations that could be tweaked.
 * @namespace modifiers
 */


var modifiers = {
  /**
   * Modifier used to shift the popper on the start or end of its reference
   * element.<br />
   * It will read the variation of the `placement` property.<br />
   * It can be one either `-end` or `-start`.
   * @memberof modifiers
   * @inner
   */
  shift: {
    /** @prop {number} order=100 - Index used to define the order of execution */
    order: 100,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: shift
  },

  /**
   * The `offset` modifier can shift your popper on both its axis.
   *
   * It accepts the following units:
   * - `px` or unit-less, interpreted as pixels
   * - `%` or `%r`, percentage relative to the length of the reference element
   * - `%p`, percentage relative to the length of the popper element
   * - `vw`, CSS viewport width unit
   * - `vh`, CSS viewport height unit
   *
   * For length is intended the main axis relative to the placement of the popper.<br />
   * This means that if the placement is `top` or `bottom`, the length will be the
   * `width`. In case of `left` or `right`, it will be the `height`.
   *
   * You can provide a single value (as `Number` or `String`), or a pair of values
   * as `String` divided by a comma or one (or more) white spaces.<br />
   * The latter is a deprecated method because it leads to confusion and will be
   * removed in v2.<br />
   * Additionally, it accepts additions and subtractions between different units.
   * Note that multiplications and divisions aren't supported.
   *
   * Valid examples are:
   * ```
   * 10
   * '10%'
   * '10, 10'
   * '10%, 10'
   * '10 + 10%'
   * '10 - 5vh + 3%'
   * '-10px + 5vh, 5px - 6%'
   * ```
   * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
   * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
   * > You can read more on this at this [issue](https://github.com/FezVrasta/popper.js/issues/373).
   *
   * @memberof modifiers
   * @inner
   */
  offset: {
    /** @prop {number} order=200 - Index used to define the order of execution */
    order: 200,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: offset,

    /** @prop {Number|String} offset=0
     * The offset value as described in the modifier description
     */
    offset: 0
  },

  /**
   * Modifier used to prevent the popper from being positioned outside the boundary.
   *
   * A scenario exists where the reference itself is not within the boundaries.<br />
   * We can say it has "escaped the boundaries" — or just "escaped".<br />
   * In this case we need to decide whether the popper should either:
   *
   * - detach from the reference and remain "trapped" in the boundaries, or
   * - if it should ignore the boundary and "escape with its reference"
   *
   * When `escapeWithReference` is set to`true` and reference is completely
   * outside its boundaries, the popper will overflow (or completely leave)
   * the boundaries in order to remain attached to the edge of the reference.
   *
   * @memberof modifiers
   * @inner
   */
  preventOverflow: {
    /** @prop {number} order=300 - Index used to define the order of execution */
    order: 300,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: preventOverflow,

    /**
     * @prop {Array} [priority=['left','right','top','bottom']]
     * Popper will try to prevent overflow following these priorities by default,
     * then, it could overflow on the left and on top of the `boundariesElement`
     */
    priority: ['left', 'right', 'top', 'bottom'],

    /**
     * @prop {number} padding=5
     * Amount of pixel used to define a minimum distance between the boundaries
     * and the popper. This makes sure the popper always has a little padding
     * between the edges of its container
     */
    padding: 5,

    /**
     * @prop {String|HTMLElement} boundariesElement='scrollParent'
     * Boundaries used by the modifier. Can be `scrollParent`, `window`,
     * `viewport` or any DOM element.
     */
    boundariesElement: 'scrollParent'
  },

  /**
   * Modifier used to make sure the reference and its popper stay near each other
   * without leaving any gap between the two. Especially useful when the arrow is
   * enabled and you want to ensure that it points to its reference element.
   * It cares only about the first axis. You can still have poppers with margin
   * between the popper and its reference element.
   * @memberof modifiers
   * @inner
   */
  keepTogether: {
    /** @prop {number} order=400 - Index used to define the order of execution */
    order: 400,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: keepTogether
  },

  /**
   * This modifier is used to move the `arrowElement` of the popper to make
   * sure it is positioned between the reference element and its popper element.
   * It will read the outer size of the `arrowElement` node to detect how many
   * pixels of conjunction are needed.
   *
   * It has no effect if no `arrowElement` is provided.
   * @memberof modifiers
   * @inner
   */
  arrow: {
    /** @prop {number} order=500 - Index used to define the order of execution */
    order: 500,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: arrow,

    /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
    element: '[x-arrow]'
  },

  /**
   * Modifier used to flip the popper's placement when it starts to overlap its
   * reference element.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   *
   * **NOTE:** this modifier will interrupt the current update cycle and will
   * restart it if it detects the need to flip the placement.
   * @memberof modifiers
   * @inner
   */
  flip: {
    /** @prop {number} order=600 - Index used to define the order of execution */
    order: 600,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: flip,

    /**
     * @prop {String|Array} behavior='flip'
     * The behavior used to change the popper's placement. It can be one of
     * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
     * placements (with optional variations)
     */
    behavior: 'flip',

    /**
     * @prop {number} padding=5
     * The popper will flip if it hits the edges of the `boundariesElement`
     */
    padding: 5,

    /**
     * @prop {String|HTMLElement} boundariesElement='viewport'
     * The element which will define the boundaries of the popper position.
     * The popper will never be placed outside of the defined boundaries
     * (except if `keepTogether` is enabled)
     */
    boundariesElement: 'viewport',

    /**
     * @prop {Boolean} flipVariations=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the reference element overlaps its boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariations: false,

    /**
     * @prop {Boolean} flipVariationsByContent=false
     * The popper will switch placement variation between `-start` and `-end` when
     * the popper element overlaps its reference boundaries.
     *
     * The original placement should have a set variation.
     */
    flipVariationsByContent: false
  },

  /**
   * Modifier used to make the popper flow toward the inner of the reference element.
   * By default, when this modifier is disabled, the popper will be placed outside
   * the reference element.
   * @memberof modifiers
   * @inner
   */
  inner: {
    /** @prop {number} order=700 - Index used to define the order of execution */
    order: 700,

    /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
    enabled: false,

    /** @prop {ModifierFn} */
    fn: inner
  },

  /**
   * Modifier used to hide the popper when its reference element is outside of the
   * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
   * be used to hide with a CSS selector the popper when its reference is
   * out of boundaries.
   *
   * Requires the `preventOverflow` modifier before it in order to work.
   * @memberof modifiers
   * @inner
   */
  hide: {
    /** @prop {number} order=800 - Index used to define the order of execution */
    order: 800,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: hide
  },

  /**
   * Computes the style that will be applied to the popper element to gets
   * properly positioned.
   *
   * Note that this modifier will not touch the DOM, it just prepares the styles
   * so that `applyStyle` modifier can apply it. This separation is useful
   * in case you need to replace `applyStyle` with a custom implementation.
   *
   * This modifier has `850` as `order` value to maintain backward compatibility
   * with previous versions of Popper.js. Expect the modifiers ordering method
   * to change in future major versions of the library.
   *
   * @memberof modifiers
   * @inner
   */
  computeStyle: {
    /** @prop {number} order=850 - Index used to define the order of execution */
    order: 850,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: computeStyle,

    /**
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: true,

    /**
     * @prop {string} [x='bottom']
     * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
     * Change this if your popper should grow in a direction different from `bottom`
     */
    x: 'bottom',

    /**
     * @prop {string} [x='left']
     * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
     * Change this if your popper should grow in a direction different from `right`
     */
    y: 'right'
  },

  /**
   * Applies the computed styles to the popper element.
   *
   * All the DOM manipulations are limited to this modifier. This is useful in case
   * you want to integrate Popper.js inside a framework or view library and you
   * want to delegate all the DOM manipulations to it.
   *
   * Note that if you disable this modifier, you must make sure the popper element
   * has its position set to `absolute` before Popper.js can do its work!
   *
   * Just disable this modifier and define your own to achieve the desired effect.
   *
   * @memberof modifiers
   * @inner
   */
  applyStyle: {
    /** @prop {number} order=900 - Index used to define the order of execution */
    order: 900,

    /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
    enabled: true,

    /** @prop {ModifierFn} */
    fn: applyStyle,

    /** @prop {Function} */
    onLoad: applyStyleOnLoad,

    /**
     * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
     * @prop {Boolean} gpuAcceleration=true
     * If true, it uses the CSS 3D transformation to position the popper.
     * Otherwise, it will use the `top` and `left` properties
     */
    gpuAcceleration: undefined
  }
};
/**
 * The `dataObject` is an object containing all the information used by Popper.js.
 * This object is passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
 * @name dataObject
 * @property {Object} data.instance The Popper.js instance
 * @property {String} data.placement Placement applied to popper
 * @property {String} data.originalPlacement Placement originally defined on init
 * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
 * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper
 * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
 * @property {Object} data.styles Any CSS property defined here will be applied to the popper. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow. It expects the JavaScript nomenclature (eg. `marginBottom`)
 * @property {Object} data.boundaries Offsets of the popper boundaries
 * @property {Object} data.offsets The measurements of popper, reference and arrow elements
 * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
 * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
 */

/**
 * Default options provided to Popper.js constructor.<br />
 * These can be overridden using the `options` argument of Popper.js.<br />
 * To override an option, simply pass an object with the same
 * structure of the `options` object, as the 3rd argument. For example:
 * ```
 * new Popper(ref, pop, {
 *   modifiers: {
 *     preventOverflow: { enabled: false }
 *   }
 * })
 * ```
 * @type {Object}
 * @static
 * @memberof Popper
 */

var Defaults = {
  /**
   * Popper's placement.
   * @prop {Popper.placements} placement='bottom'
   */
  placement: 'bottom',

  /**
   * Set this to true if you want popper to position it self in 'fixed' mode
   * @prop {Boolean} positionFixed=false
   */
  positionFixed: false,

  /**
   * Whether events (resize, scroll) are initially enabled.
   * @prop {Boolean} eventsEnabled=true
   */
  eventsEnabled: true,

  /**
   * Set to true if you want to automatically remove the popper when
   * you call the `destroy` method.
   * @prop {Boolean} removeOnDestroy=false
   */
  removeOnDestroy: false,

  /**
   * Callback called when the popper is created.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onCreate}
   */
  onCreate: function onCreate() {},

  /**
   * Callback called when the popper is updated. This callback is not called
   * on the initialization/creation of the popper, but only on subsequent
   * updates.<br />
   * By default, it is set to no-op.<br />
   * Access Popper.js instance with `data.instance`.
   * @prop {onUpdate}
   */
  onUpdate: function onUpdate() {},

  /**
   * List of modifiers used to modify the offsets before they are applied to the popper.
   * They provide most of the functionalities of Popper.js.
   * @prop {modifiers}
   */
  modifiers: modifiers
};
/**
 * @callback onCreate
 * @param {dataObject} data
 */

/**
 * @callback onUpdate
 * @param {dataObject} data
 */
// Utils
// Methods

var Popper = function () {
  /**
   * Creates a new Popper.js instance.
   * @class Popper
   * @param {Element|referenceObject} reference - The reference element used to position the popper
   * @param {Element} popper - The HTML / XML element used as the popper
   * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
   * @return {Object} instance - The generated Popper.js instance
   */
  function Popper(reference, popper) {
    var _this = this;

    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    classCallCheck(this, Popper);

    this.scheduleUpdate = function () {
      return requestAnimationFrame(_this.update);
    }; // make update() debounced, so that it only runs at most once-per-tick


    this.update = debounce(this.update.bind(this)); // with {} we create a new object with the options inside it

    this.options = _extends({}, Popper.Defaults, options); // init state

    this.state = {
      isDestroyed: false,
      isCreated: false,
      scrollParents: []
    }; // get reference and popper elements (allow jQuery wrappers)

    this.reference = reference && reference.jquery ? reference[0] : reference;
    this.popper = popper && popper.jquery ? popper[0] : popper; // Deep merge modifiers options

    this.options.modifiers = {};
    Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
      _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
    }); // Refactoring modifiers' list (Object => Array)

    this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
      return _extends({
        name: name
      }, _this.options.modifiers[name]);
    }) // sort the modifiers by order
    .sort(function (a, b) {
      return a.order - b.order;
    }); // modifiers have the ability to execute arbitrary code when Popper.js get inited
    // such code is executed in the same order of its modifier
    // they could add new properties to their options configuration
    // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!

    this.modifiers.forEach(function (modifierOptions) {
      if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
        modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
      }
    }); // fire the first update to position the popper in the right place

    this.update();
    var eventsEnabled = this.options.eventsEnabled;

    if (eventsEnabled) {
      // setup event listeners, they will take care of update the position in specific situations
      this.enableEventListeners();
    }

    this.state.eventsEnabled = eventsEnabled;
  } // We can't use class properties because they don't get listed in the
  // class prototype and break stuff like Sinon stubs


  createClass(Popper, [{
    key: 'update',
    value: function update$$1() {
      return update.call(this);
    }
  }, {
    key: 'destroy',
    value: function destroy$$1() {
      return destroy.call(this);
    }
  }, {
    key: 'enableEventListeners',
    value: function enableEventListeners$$1() {
      return enableEventListeners.call(this);
    }
  }, {
    key: 'disableEventListeners',
    value: function disableEventListeners$$1() {
      return disableEventListeners.call(this);
    }
    /**
     * Schedules an update. It will run on the next UI update available.
     * @method scheduleUpdate
     * @memberof Popper
     */

    /**
     * Collection of utilities useful when writing custom modifiers.
     * Starting from version 1.7, this method is available only if you
     * include `popper-utils.js` before `popper.js`.
     *
     * **DEPRECATION**: This way to access PopperUtils is deprecated
     * and will be removed in v2! Use the PopperUtils module directly instead.
     * Due to the high instability of the methods contained in Utils, we can't
     * guarantee them to follow semver. Use them at your own risk!
     * @static
     * @private
     * @type {Object}
     * @deprecated since version 1.8
     * @member Utils
     * @memberof Popper
     */

  }]);
  return Popper;
}();
/**
 * The `referenceObject` is an object that provides an interface compatible with Popper.js
 * and lets you use it as replacement of a real DOM node.<br />
 * You can use this method to position a popper relatively to a set of coordinates
 * in case you don't have a DOM node to use as reference.
 *
 * ```
 * new Popper(referenceObject, popperNode);
 * ```
 *
 * NB: This feature isn't supported in Internet Explorer 10.
 * @name referenceObject
 * @property {Function} data.getBoundingClientRect
 * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
 * @property {number} data.clientWidth
 * An ES6 getter that will return the width of the virtual reference element.
 * @property {number} data.clientHeight
 * An ES6 getter that will return the height of the virtual reference element.
 */


Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
Popper.placements = placements;
Popper.Defaults = Defaults;
var _default = Popper;
exports.default = _default;
},{}],"AC2V":[function(require,module,exports) {

},{"./images/ui-bg_highlight-soft_75_cccccc_1x100.png":[["ui-bg_highlight-soft_75_cccccc_1x100.8845db0a.png","NAof"],"NAof"],"./images/ui-bg_glass_75_e6e6e6_1x400.png":[["ui-bg_glass_75_e6e6e6_1x400.4ecb847c.png","v631"],"v631"],"./images/ui-bg_glass_75_dadada_1x400.png":[["ui-bg_glass_75_dadada_1x400.20cbcd31.png","pkmC"],"pkmC"],"./images/ui-bg_glass_65_ffffff_1x400.png":[["ui-bg_glass_65_ffffff_1x400.8aa05abb.png","EYL0"],"EYL0"],"./images/ui-bg_glass_55_fbf9ee_1x400.png":[["ui-bg_glass_55_fbf9ee_1x400.a7cd9eba.png","sk7d"],"sk7d"],"./images/ui-bg_glass_95_fef1ec_1x400.png":[["ui-bg_glass_95_fef1ec_1x400.b05f9107.png","B6mw"],"B6mw"],"./images/ui-icons_222222_256x240.png":[["ui-icons_222222_256x240.144e05f1.png","Qzx8"],"Qzx8"],"./images/ui-icons_888888_256x240.png":[["ui-icons_888888_256x240.8d916acf.png","Rr1m"],"Rr1m"],"./images/ui-icons_454545_256x240.png":[["ui-icons_454545_256x240.90d1965b.png","aYYo"],"aYYo"],"./images/ui-icons_2e83ff_256x240.png":[["ui-icons_2e83ff_256x240.6ac71131.png","CHms"],"CHms"],"./images/ui-icons_cd0a0a_256x240.png":[["ui-icons_cd0a0a_256x240.1cea75f9.png","Ifxy"],"Ifxy"]}],"Hifx":[function(require,module,exports) {
var define;
/*! jQuery UI - v1.12.1 - 2017-03-19
* http://jqueryui.com
* Includes: widget.js, position.js, data.js, disable-selection.js, focusable.js, form-reset-mixin.js, jquery-1-7.js, keycode.js, labels.js, scroll-parent.js, tabbable.js, unique-id.js, widgets/draggable.js, widgets/droppable.js, widgets/resizable.js, widgets/selectable.js, widgets/sortable.js, widgets/accordion.js, widgets/autocomplete.js, widgets/button.js, widgets/checkboxradio.js, widgets/controlgroup.js, widgets/datepicker.js, widgets/dialog.js, widgets/menu.js, widgets/mouse.js, widgets/progressbar.js, widgets/selectmenu.js, widgets/slider.js, widgets/spinner.js, widgets/tabs.js, widgets/tooltip.js, effect.js, effects/effect-blind.js, effects/effect-bounce.js, effects/effect-clip.js, effects/effect-drop.js, effects/effect-explode.js, effects/effect-fade.js, effects/effect-fold.js, effects/effect-highlight.js, effects/effect-puff.js, effects/effect-pulsate.js, effects/effect-scale.js, effects/effect-shake.js, effects/effect-size.js, effects/effect-slide.js, effects/effect-transfer.js
* Copyright jQuery Foundation and other contributors; Licensed MIT */

(function( factory ) {
	if ( typeof define === "function" && define.amd ) {

		// AMD. Register as an anonymous module.
		define([ "jquery" ], factory );
	} else {

		// Browser globals
		factory( jQuery );
	}
}(function( $ ) {

$.ui = $.ui || {};

var version = $.ui.version = "1.12.1";


/*!
 * jQuery UI Widget 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Widget
//>>group: Core
//>>description: Provides a factory for creating stateful widgets with a common API.
//>>docs: http://api.jqueryui.com/jQuery.widget/
//>>demos: http://jqueryui.com/widget/



var widgetUuid = 0;
var widgetSlice = Array.prototype.slice;

$.cleanData = ( function( orig ) {
	return function( elems ) {
		var events, elem, i;
		for ( i = 0; ( elem = elems[ i ] ) != null; i++ ) {
			try {

				// Only trigger remove when necessary to save time
				events = $._data( elem, "events" );
				if ( events && events.remove ) {
					$( elem ).triggerHandler( "remove" );
				}

			// Http://bugs.jquery.com/ticket/8235
			} catch ( e ) {}
		}
		orig( elems );
	};
} )( $.cleanData );

$.widget = function( name, base, prototype ) {
	var existingConstructor, constructor, basePrototype;

	// ProxiedPrototype allows the provided prototype to remain unmodified
	// so that it can be used as a mixin for multiple widgets (#8876)
	var proxiedPrototype = {};

	var namespace = name.split( "." )[ 0 ];
	name = name.split( "." )[ 1 ];
	var fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	if ( $.isArray( prototype ) ) {
		prototype = $.extend.apply( null, [ {} ].concat( prototype ) );
	}

	// Create selector for plugin
	$.expr.pseudos[ fullName.toLowerCase() ] = function( elem ) {
		return !!$.data( elem, fullName );
	};

	$[ namespace ] = $[ namespace ] || {};
	existingConstructor = $[ namespace ][ name ];
	constructor = $[ namespace ][ name ] = function( options, element ) {

		// Allow instantiation without "new" keyword
		if ( !this._createWidget ) {
			return new constructor( options, element );
		}

		// Allow instantiation without initializing for simple inheritance
		// must use "new" keyword (the code above always passes args)
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};

	// Extend with the existing constructor to carry over any static properties
	$.extend( constructor, existingConstructor, {
		version: prototype.version,

		// Copy the object used to create the prototype in case we need to
		// redefine the widget later
		_proto: $.extend( {}, prototype ),

		// Track widgets that inherit from this widget in case this widget is
		// redefined after a widget inherits from it
		_childConstructors: []
	} );

	basePrototype = new base();

	// We need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
	basePrototype.options = $.widget.extend( {}, basePrototype.options );
	$.each( prototype, function( prop, value ) {
		if ( !$.isFunction( value ) ) {
			proxiedPrototype[ prop ] = value;
			return;
		}
		proxiedPrototype[ prop ] = ( function() {
			function _super() {
				return base.prototype[ prop ].apply( this, arguments );
			}

			function _superApply( args ) {
				return base.prototype[ prop ].apply( this, args );
			}

			return function() {
				var __super = this._super;
				var __superApply = this._superApply;
				var returnValue;

				this._super = _super;
				this._superApply = _superApply;

				returnValue = value.apply( this, arguments );

				this._super = __super;
				this._superApply = __superApply;

				return returnValue;
			};
		} )();
	} );
	constructor.prototype = $.widget.extend( basePrototype, {

		// TODO: remove support for widgetEventPrefix
		// always use the name + a colon as the prefix, e.g., draggable:start
		// don't prefix for widgets that aren't DOM-based
		widgetEventPrefix: existingConstructor ? ( basePrototype.widgetEventPrefix || name ) : name
	}, proxiedPrototype, {
		constructor: constructor,
		namespace: namespace,
		widgetName: name,
		widgetFullName: fullName
	} );

	// If this widget is being redefined then we need to find all widgets that
	// are inheriting from it and redefine all of them so that they inherit from
	// the new version of this widget. We're essentially trying to replace one
	// level in the prototype chain.
	if ( existingConstructor ) {
		$.each( existingConstructor._childConstructors, function( i, child ) {
			var childPrototype = child.prototype;

			// Redefine the child widget using the same prototype that was
			// originally used, but inherit from the new version of the base
			$.widget( childPrototype.namespace + "." + childPrototype.widgetName, constructor,
				child._proto );
		} );

		// Remove the list of existing child constructors from the old constructor
		// so the old child constructors can be garbage collected
		delete existingConstructor._childConstructors;
	} else {
		base._childConstructors.push( constructor );
	}

	$.widget.bridge( name, constructor );

	return constructor;
};

$.widget.extend = function( target ) {
	var input = widgetSlice.call( arguments, 1 );
	var inputIndex = 0;
	var inputLength = input.length;
	var key;
	var value;

	for ( ; inputIndex < inputLength; inputIndex++ ) {
		for ( key in input[ inputIndex ] ) {
			value = input[ inputIndex ][ key ];
			if ( input[ inputIndex ].hasOwnProperty( key ) && value !== undefined ) {

				// Clone objects
				if ( $.isPlainObject( value ) ) {
					target[ key ] = $.isPlainObject( target[ key ] ) ?
						$.widget.extend( {}, target[ key ], value ) :

						// Don't extend strings, arrays, etc. with objects
						$.widget.extend( {}, value );

				// Copy everything else by reference
				} else {
					target[ key ] = value;
				}
			}
		}
	}
	return target;
};

$.widget.bridge = function( name, object ) {
	var fullName = object.prototype.widgetFullName || name;
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string";
		var args = widgetSlice.call( arguments, 1 );
		var returnValue = this;

		if ( isMethodCall ) {

			// If this is an empty collection, we need to have the instance method
			// return undefined instead of the jQuery instance
			if ( !this.length && options === "instance" ) {
				returnValue = undefined;
			} else {
				this.each( function() {
					var methodValue;
					var instance = $.data( this, fullName );

					if ( options === "instance" ) {
						returnValue = instance;
						return false;
					}

					if ( !instance ) {
						return $.error( "cannot call methods on " + name +
							" prior to initialization; " +
							"attempted to call method '" + options + "'" );
					}

					if ( !$.isFunction( instance[ options ] ) || options.charAt( 0 ) === "_" ) {
						return $.error( "no such method '" + options + "' for " + name +
							" widget instance" );
					}

					methodValue = instance[ options ].apply( instance, args );

					if ( methodValue !== instance && methodValue !== undefined ) {
						returnValue = methodValue && methodValue.jquery ?
							returnValue.pushStack( methodValue.get() ) :
							methodValue;
						return false;
					}
				} );
			}
		} else {

			// Allow multiple hashes to be passed on init
			if ( args.length ) {
				options = $.widget.extend.apply( null, [ options ].concat( args ) );
			}

			this.each( function() {
				var instance = $.data( this, fullName );
				if ( instance ) {
					instance.option( options || {} );
					if ( instance._init ) {
						instance._init();
					}
				} else {
					$.data( this, fullName, new object( options, this ) );
				}
			} );
		}

		return returnValue;
	};
};

$.Widget = function( /* options, element */ ) {};
$.Widget._childConstructors = [];

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	defaultElement: "<div>",

	options: {
		classes: {},
		disabled: false,

		// Callbacks
		create: null
	},

	_createWidget: function( options, element ) {
		element = $( element || this.defaultElement || this )[ 0 ];
		this.element = $( element );
		this.uuid = widgetUuid++;
		this.eventNamespace = "." + this.widgetName + this.uuid;

		this.bindings = $();
		this.hoverable = $();
		this.focusable = $();
		this.classesElementLookup = {};

		if ( element !== this ) {
			$.data( element, this.widgetFullName, this );
			this._on( true, this.element, {
				remove: function( event ) {
					if ( event.target === element ) {
						this.destroy();
					}
				}
			} );
			this.document = $( element.style ?

				// Element within the document
				element.ownerDocument :

				// Element is window or document
				element.document || element );
			this.window = $( this.document[ 0 ].defaultView || this.document[ 0 ].parentWindow );
		}

		this.options = $.widget.extend( {},
			this.options,
			this._getCreateOptions(),
			options );

		this._create();

		if ( this.options.disabled ) {
			this._setOptionDisabled( this.options.disabled );
		}

		this._trigger( "create", null, this._getCreateEventData() );
		this._init();
	},

	_getCreateOptions: function() {
		return {};
	},

	_getCreateEventData: $.noop,

	_create: $.noop,

	_init: $.noop,

	destroy: function() {
		var that = this;

		this._destroy();
		$.each( this.classesElementLookup, function( key, value ) {
			that._removeClass( value, key );
		} );

		// We can probably remove the unbind calls in 2.0
		// all event bindings should go through this._on()
		this.element
			.off( this.eventNamespace )
			.removeData( this.widgetFullName );
		this.widget()
			.off( this.eventNamespace )
			.removeAttr( "aria-disabled" );

		// Clean up events and states
		this.bindings.off( this.eventNamespace );
	},

	_destroy: $.noop,

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key;
		var parts;
		var curOption;
		var i;

		if ( arguments.length === 0 ) {

			// Don't return a reference to the internal hash
			return $.widget.extend( {}, this.options );
		}

		if ( typeof key === "string" ) {

			// Handle nested keys, e.g., "foo.bar" => { foo: { bar: ___ } }
			options = {};
			parts = key.split( "." );
			key = parts.shift();
			if ( parts.length ) {
				curOption = options[ key ] = $.widget.extend( {}, this.options[ key ] );
				for ( i = 0; i < parts.length - 1; i++ ) {
					curOption[ parts[ i ] ] = curOption[ parts[ i ] ] || {};
					curOption = curOption[ parts[ i ] ];
				}
				key = parts.pop();
				if ( arguments.length === 1 ) {
					return curOption[ key ] === undefined ? null : curOption[ key ];
				}
				curOption[ key ] = value;
			} else {
				if ( arguments.length === 1 ) {
					return this.options[ key ] === undefined ? null : this.options[ key ];
				}
				options[ key ] = value;
			}
		}

		this._setOptions( options );

		return this;
	},

	_setOptions: function( options ) {
		var key;

		for ( key in options ) {
			this._setOption( key, options[ key ] );
		}

		return this;
	},

	_setOption: function( key, value ) {
		if ( key === "classes" ) {
			this._setOptionClasses( value );
		}

		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this._setOptionDisabled( value );
		}

		return this;
	},

	_setOptionClasses: function( value ) {
		var classKey, elements, currentElements;

		for ( classKey in value ) {
			currentElements = this.classesElementLookup[ classKey ];
			if ( value[ classKey ] === this.options.classes[ classKey ] ||
					!currentElements ||
					!currentElements.length ) {
				continue;
			}

			// We are doing this to create a new jQuery object because the _removeClass() call
			// on the next line is going to destroy the reference to the current elements being
			// tracked. We need to save a copy of this collection so that we can add the new classes
			// below.
			elements = $( currentElements.get() );
			this._removeClass( currentElements, classKey );

			// We don't use _addClass() here, because that uses this.options.classes
			// for generating the string of classes. We want to use the value passed in from
			// _setOption(), this is the new value of the classes option which was passed to
			// _setOption(). We pass this value directly to _classes().
			elements.addClass( this._classes( {
				element: elements,
				keys: classKey,
				classes: value,
				add: true
			} ) );
		}
	},

	_setOptionDisabled: function( value ) {
		this._toggleClass( this.widget(), this.widgetFullName + "-disabled", null, !!value );

		// If the widget is becoming disabled, then nothing is interactive
		if ( value ) {
			this._removeClass( this.hoverable, null, "ui-state-hover" );
			this._removeClass( this.focusable, null, "ui-state-focus" );
		}
	},

	enable: function() {
		return this._setOptions( { disabled: false } );
	},

	disable: function() {
		return this._setOptions( { disabled: true } );
	},

	_classes: function( options ) {
		var full = [];
		var that = this;

		options = $.extend( {
			element: this.element,
			classes: this.options.classes || {}
		}, options );

		function processClassString( classes, checkOption ) {
			var current, i;
			for ( i = 0; i < classes.length; i++ ) {
				current = that.classesElementLookup[ classes[ i ] ] || $();
				if ( options.add ) {
					current = $( $.uniqueSort( current.get().concat( options.element.get() ) ) );
				} else {
					current = $( current.not( options.element ).get() );
				}
				that.classesElementLookup[ classes[ i ] ] = current;
				full.push( classes[ i ] );
				if ( checkOption && options.classes[ classes[ i ] ] ) {
					full.push( options.classes[ classes[ i ] ] );
				}
			}
		}

		this._on( options.element, {
			"remove": "_untrackClassesElement"
		} );

		if ( options.keys ) {
			processClassString( options.keys.match( /\S+/g ) || [], true );
		}
		if ( options.extra ) {
			processClassString( options.extra.match( /\S+/g ) || [] );
		}

		return full.join( " " );
	},

	_untrackClassesElement: function( event ) {
		var that = this;
		$.each( that.classesElementLookup, function( key, value ) {
			if ( $.inArray( event.target, value ) !== -1 ) {
				that.classesElementLookup[ key ] = $( value.not( event.target ).get() );
			}
		} );
	},

	_removeClass: function( element, keys, extra ) {
		return this._toggleClass( element, keys, extra, false );
	},

	_addClass: function( element, keys, extra ) {
		return this._toggleClass( element, keys, extra, true );
	},

	_toggleClass: function( element, keys, extra, add ) {
		add = ( typeof add === "boolean" ) ? add : extra;
		var shift = ( typeof element === "string" || element === null ),
			options = {
				extra: shift ? keys : extra,
				keys: shift ? element : keys,
				element: shift ? this.element : element,
				add: add
			};
		options.element.toggleClass( this._classes( options ), add );
		return this;
	},

	_on: function( suppressDisabledCheck, element, handlers ) {
		var delegateElement;
		var instance = this;

		// No suppressDisabledCheck flag, shuffle arguments
		if ( typeof suppressDisabledCheck !== "boolean" ) {
			handlers = element;
			element = suppressDisabledCheck;
			suppressDisabledCheck = false;
		}

		// No element argument, shuffle and use this.element
		if ( !handlers ) {
			handlers = element;
			element = this.element;
			delegateElement = this.widget();
		} else {
			element = delegateElement = $( element );
			this.bindings = this.bindings.add( element );
		}

		$.each( handlers, function( event, handler ) {
			function handlerProxy() {

				// Allow widgets to customize the disabled handling
				// - disabled as an array instead of boolean
				// - disabled class as method for disabling individual parts
				if ( !suppressDisabledCheck &&
						( instance.options.disabled === true ||
						$( this ).hasClass( "ui-state-disabled" ) ) ) {
					return;
				}
				return ( typeof handler === "string" ? instance[ handler ] : handler )
					.apply( instance, arguments );
			}

			// Copy the guid so direct unbinding works
			if ( typeof handler !== "string" ) {
				handlerProxy.guid = handler.guid =
					handler.guid || handlerProxy.guid || $.guid++;
			}

			var match = event.match( /^([\w:-]*)\s*(.*)$/ );
			var eventName = match[ 1 ] + instance.eventNamespace;
			var selector = match[ 2 ];

			if ( selector ) {
				delegateElement.on( eventName, selector, handlerProxy );
			} else {
				element.on( eventName, handlerProxy );
			}
		} );
	},

	_off: function( element, eventName ) {
		eventName = ( eventName || "" ).split( " " ).join( this.eventNamespace + " " ) +
			this.eventNamespace;
		element.off( eventName ).off( eventName );

		// Clear the stack to avoid memory leaks (#10056)
		this.bindings = $( this.bindings.not( element ).get() );
		this.focusable = $( this.focusable.not( element ).get() );
		this.hoverable = $( this.hoverable.not( element ).get() );
	},

	_delay: function( handler, delay ) {
		function handlerProxy() {
			return ( typeof handler === "string" ? instance[ handler ] : handler )
				.apply( instance, arguments );
		}
		var instance = this;
		return setTimeout( handlerProxy, delay || 0 );
	},

	_hoverable: function( element ) {
		this.hoverable = this.hoverable.add( element );
		this._on( element, {
			mouseenter: function( event ) {
				this._addClass( $( event.currentTarget ), null, "ui-state-hover" );
			},
			mouseleave: function( event ) {
				this._removeClass( $( event.currentTarget ), null, "ui-state-hover" );
			}
		} );
	},

	_focusable: function( element ) {
		this.focusable = this.focusable.add( element );
		this._on( element, {
			focusin: function( event ) {
				this._addClass( $( event.currentTarget ), null, "ui-state-focus" );
			},
			focusout: function( event ) {
				this._removeClass( $( event.currentTarget ), null, "ui-state-focus" );
			}
		} );
	},

	_trigger: function( type, event, data ) {
		var prop, orig;
		var callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();

		// The original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// Copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );
		return !( $.isFunction( callback ) &&
			callback.apply( this.element[ 0 ], [ event ].concat( data ) ) === false ||
			event.isDefaultPrevented() );
	}
};

$.each( { show: "fadeIn", hide: "fadeOut" }, function( method, defaultEffect ) {
	$.Widget.prototype[ "_" + method ] = function( element, options, callback ) {
		if ( typeof options === "string" ) {
			options = { effect: options };
		}

		var hasOptions;
		var effectName = !options ?
			method :
			options === true || typeof options === "number" ?
				defaultEffect :
				options.effect || defaultEffect;

		options = options || {};
		if ( typeof options === "number" ) {
			options = { duration: options };
		}

		hasOptions = !$.isEmptyObject( options );
		options.complete = callback;

		if ( options.delay ) {
			element.delay( options.delay );
		}

		if ( hasOptions && $.effects && $.effects.effect[ effectName ] ) {
			element[ method ]( options );
		} else if ( effectName !== method && element[ effectName ] ) {
			element[ effectName ]( options.duration, options.easing, callback );
		} else {
			element.queue( function( next ) {
				$( this )[ method ]();
				if ( callback ) {
					callback.call( element[ 0 ] );
				}
				next();
			} );
		}
	};
} );

var widget = $.widget;


/*!
 * jQuery UI Position 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/position/
 */

//>>label: Position
//>>group: Core
//>>description: Positions elements relative to other elements.
//>>docs: http://api.jqueryui.com/position/
//>>demos: http://jqueryui.com/position/


( function() {
var cachedScrollbarWidth,
	max = Math.max,
	abs = Math.abs,
	rhorizontal = /left|center|right/,
	rvertical = /top|center|bottom/,
	roffset = /[\+\-]\d+(\.[\d]+)?%?/,
	rposition = /^\w+/,
	rpercent = /%$/,
	_position = $.fn.position;

function getOffsets( offsets, width, height ) {
	return [
		parseFloat( offsets[ 0 ] ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
		parseFloat( offsets[ 1 ] ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
	];
}

function parseCss( element, property ) {
	return parseInt( $.css( element, property ), 10 ) || 0;
}

function getDimensions( elem ) {
	var raw = elem[ 0 ];
	if ( raw.nodeType === 9 ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: 0, left: 0 }
		};
	}
	if ( $.isWindow( raw ) ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
		};
	}
	if ( raw.preventDefault ) {
		return {
			width: 0,
			height: 0,
			offset: { top: raw.pageY, left: raw.pageX }
		};
	}
	return {
		width: elem.outerWidth(),
		height: elem.outerHeight(),
		offset: elem.offset()
	};
}

$.position = {
	scrollbarWidth: function() {
		if ( cachedScrollbarWidth !== undefined ) {
			return cachedScrollbarWidth;
		}
		var w1, w2,
			div = $( "<div " +
				"style='display:block;position:absolute;width:50px;height:50px;overflow:hidden;'>" +
				"<div style='height:100px;width:auto;'></div></div>" ),
			innerDiv = div.children()[ 0 ];

		$( "body" ).append( div );
		w1 = innerDiv.offsetWidth;
		div.css( "overflow", "scroll" );

		w2 = innerDiv.offsetWidth;

		if ( w1 === w2 ) {
			w2 = div[ 0 ].clientWidth;
		}

		div.remove();

		return ( cachedScrollbarWidth = w1 - w2 );
	},
	getScrollInfo: function( within ) {
		var overflowX = within.isWindow || within.isDocument ? "" :
				within.element.css( "overflow-x" ),
			overflowY = within.isWindow || within.isDocument ? "" :
				within.element.css( "overflow-y" ),
			hasOverflowX = overflowX === "scroll" ||
				( overflowX === "auto" && within.width < within.element[ 0 ].scrollWidth ),
			hasOverflowY = overflowY === "scroll" ||
				( overflowY === "auto" && within.height < within.element[ 0 ].scrollHeight );
		return {
			width: hasOverflowY ? $.position.scrollbarWidth() : 0,
			height: hasOverflowX ? $.position.scrollbarWidth() : 0
		};
	},
	getWithinInfo: function( element ) {
		var withinElement = $( element || window ),
			isWindow = $.isWindow( withinElement[ 0 ] ),
			isDocument = !!withinElement[ 0 ] && withinElement[ 0 ].nodeType === 9,
			hasOffset = !isWindow && !isDocument;
		return {
			element: withinElement,
			isWindow: isWindow,
			isDocument: isDocument,
			offset: hasOffset ? $( element ).offset() : { left: 0, top: 0 },
			scrollLeft: withinElement.scrollLeft(),
			scrollTop: withinElement.scrollTop(),
			width: withinElement.outerWidth(),
			height: withinElement.outerHeight()
		};
	}
};

$.fn.position = function( options ) {
	if ( !options || !options.of ) {
		return _position.apply( this, arguments );
	}

	// Make a copy, we don't want to modify arguments
	options = $.extend( {}, options );

	var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
		target = $( options.of ),
		within = $.position.getWithinInfo( options.within ),
		scrollInfo = $.position.getScrollInfo( within ),
		collision = ( options.collision || "flip" ).split( " " ),
		offsets = {};

	dimensions = getDimensions( target );
	if ( target[ 0 ].preventDefault ) {

		// Force left top to allow flipping
		options.at = "left top";
	}
	targetWidth = dimensions.width;
	targetHeight = dimensions.height;
	targetOffset = dimensions.offset;

	// Clone to reuse original targetOffset later
	basePosition = $.extend( {}, targetOffset );

	// Force my and at to have valid horizontal and vertical positions
	// if a value is missing or invalid, it will be converted to center
	$.each( [ "my", "at" ], function() {
		var pos = ( options[ this ] || "" ).split( " " ),
			horizontalOffset,
			verticalOffset;

		if ( pos.length === 1 ) {
			pos = rhorizontal.test( pos[ 0 ] ) ?
				pos.concat( [ "center" ] ) :
				rvertical.test( pos[ 0 ] ) ?
					[ "center" ].concat( pos ) :
					[ "center", "center" ];
		}
		pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
		pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

		// Calculate offsets
		horizontalOffset = roffset.exec( pos[ 0 ] );
		verticalOffset = roffset.exec( pos[ 1 ] );
		offsets[ this ] = [
			horizontalOffset ? horizontalOffset[ 0 ] : 0,
			verticalOffset ? verticalOffset[ 0 ] : 0
		];

		// Reduce to just the positions without the offsets
		options[ this ] = [
			rposition.exec( pos[ 0 ] )[ 0 ],
			rposition.exec( pos[ 1 ] )[ 0 ]
		];
	} );

	// Normalize collision option
	if ( collision.length === 1 ) {
		collision[ 1 ] = collision[ 0 ];
	}

	if ( options.at[ 0 ] === "right" ) {
		basePosition.left += targetWidth;
	} else if ( options.at[ 0 ] === "center" ) {
		basePosition.left += targetWidth / 2;
	}

	if ( options.at[ 1 ] === "bottom" ) {
		basePosition.top += targetHeight;
	} else if ( options.at[ 1 ] === "center" ) {
		basePosition.top += targetHeight / 2;
	}

	atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
	basePosition.left += atOffset[ 0 ];
	basePosition.top += atOffset[ 1 ];

	return this.each( function() {
		var collisionPosition, using,
			elem = $( this ),
			elemWidth = elem.outerWidth(),
			elemHeight = elem.outerHeight(),
			marginLeft = parseCss( this, "marginLeft" ),
			marginTop = parseCss( this, "marginTop" ),
			collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) +
				scrollInfo.width,
			collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) +
				scrollInfo.height,
			position = $.extend( {}, basePosition ),
			myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );

		if ( options.my[ 0 ] === "right" ) {
			position.left -= elemWidth;
		} else if ( options.my[ 0 ] === "center" ) {
			position.left -= elemWidth / 2;
		}

		if ( options.my[ 1 ] === "bottom" ) {
			position.top -= elemHeight;
		} else if ( options.my[ 1 ] === "center" ) {
			position.top -= elemHeight / 2;
		}

		position.left += myOffset[ 0 ];
		position.top += myOffset[ 1 ];

		collisionPosition = {
			marginLeft: marginLeft,
			marginTop: marginTop
		};

		$.each( [ "left", "top" ], function( i, dir ) {
			if ( $.ui.position[ collision[ i ] ] ) {
				$.ui.position[ collision[ i ] ][ dir ]( position, {
					targetWidth: targetWidth,
					targetHeight: targetHeight,
					elemWidth: elemWidth,
					elemHeight: elemHeight,
					collisionPosition: collisionPosition,
					collisionWidth: collisionWidth,
					collisionHeight: collisionHeight,
					offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
					my: options.my,
					at: options.at,
					within: within,
					elem: elem
				} );
			}
		} );

		if ( options.using ) {

			// Adds feedback as second argument to using callback, if present
			using = function( props ) {
				var left = targetOffset.left - position.left,
					right = left + targetWidth - elemWidth,
					top = targetOffset.top - position.top,
					bottom = top + targetHeight - elemHeight,
					feedback = {
						target: {
							element: target,
							left: targetOffset.left,
							top: targetOffset.top,
							width: targetWidth,
							height: targetHeight
						},
						element: {
							element: elem,
							left: position.left,
							top: position.top,
							width: elemWidth,
							height: elemHeight
						},
						horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
						vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
					};
				if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
					feedback.horizontal = "center";
				}
				if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
					feedback.vertical = "middle";
				}
				if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
					feedback.important = "horizontal";
				} else {
					feedback.important = "vertical";
				}
				options.using.call( this, props, feedback );
			};
		}

		elem.offset( $.extend( position, { using: using } ) );
	} );
};

$.ui.position = {
	fit: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
				outerWidth = within.width,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = withinOffset - collisionPosLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
				newOverRight;

			// Element is wider than within
			if ( data.collisionWidth > outerWidth ) {

				// Element is initially over the left side of within
				if ( overLeft > 0 && overRight <= 0 ) {
					newOverRight = position.left + overLeft + data.collisionWidth - outerWidth -
						withinOffset;
					position.left += overLeft - newOverRight;

				// Element is initially over right side of within
				} else if ( overRight > 0 && overLeft <= 0 ) {
					position.left = withinOffset;

				// Element is initially over both left and right sides of within
				} else {
					if ( overLeft > overRight ) {
						position.left = withinOffset + outerWidth - data.collisionWidth;
					} else {
						position.left = withinOffset;
					}
				}

			// Too far left -> align with left edge
			} else if ( overLeft > 0 ) {
				position.left += overLeft;

			// Too far right -> align with right edge
			} else if ( overRight > 0 ) {
				position.left -= overRight;

			// Adjust based on position and margin
			} else {
				position.left = max( position.left - collisionPosLeft, position.left );
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
				outerHeight = data.within.height,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = withinOffset - collisionPosTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
				newOverBottom;

			// Element is taller than within
			if ( data.collisionHeight > outerHeight ) {

				// Element is initially over the top of within
				if ( overTop > 0 && overBottom <= 0 ) {
					newOverBottom = position.top + overTop + data.collisionHeight - outerHeight -
						withinOffset;
					position.top += overTop - newOverBottom;

				// Element is initially over bottom of within
				} else if ( overBottom > 0 && overTop <= 0 ) {
					position.top = withinOffset;

				// Element is initially over both top and bottom of within
				} else {
					if ( overTop > overBottom ) {
						position.top = withinOffset + outerHeight - data.collisionHeight;
					} else {
						position.top = withinOffset;
					}
				}

			// Too far up -> align with top
			} else if ( overTop > 0 ) {
				position.top += overTop;

			// Too far down -> align with bottom edge
			} else if ( overBottom > 0 ) {
				position.top -= overBottom;

			// Adjust based on position and margin
			} else {
				position.top = max( position.top - collisionPosTop, position.top );
			}
		}
	},
	flip: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.left + within.scrollLeft,
				outerWidth = within.width,
				offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = collisionPosLeft - offsetLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
				myOffset = data.my[ 0 ] === "left" ?
					-data.elemWidth :
					data.my[ 0 ] === "right" ?
						data.elemWidth :
						0,
				atOffset = data.at[ 0 ] === "left" ?
					data.targetWidth :
					data.at[ 0 ] === "right" ?
						-data.targetWidth :
						0,
				offset = -2 * data.offset[ 0 ],
				newOverRight,
				newOverLeft;

			if ( overLeft < 0 ) {
				newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth -
					outerWidth - withinOffset;
				if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
					position.left += myOffset + atOffset + offset;
				}
			} else if ( overRight > 0 ) {
				newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset +
					atOffset + offset - offsetLeft;
				if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
					position.left += myOffset + atOffset + offset;
				}
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.top + within.scrollTop,
				outerHeight = within.height,
				offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = collisionPosTop - offsetTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
				top = data.my[ 1 ] === "top",
				myOffset = top ?
					-data.elemHeight :
					data.my[ 1 ] === "bottom" ?
						data.elemHeight :
						0,
				atOffset = data.at[ 1 ] === "top" ?
					data.targetHeight :
					data.at[ 1 ] === "bottom" ?
						-data.targetHeight :
						0,
				offset = -2 * data.offset[ 1 ],
				newOverTop,
				newOverBottom;
			if ( overTop < 0 ) {
				newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight -
					outerHeight - withinOffset;
				if ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) {
					position.top += myOffset + atOffset + offset;
				}
			} else if ( overBottom > 0 ) {
				newOverTop = position.top - data.collisionPosition.marginTop + myOffset + atOffset +
					offset - offsetTop;
				if ( newOverTop > 0 || abs( newOverTop ) < overBottom ) {
					position.top += myOffset + atOffset + offset;
				}
			}
		}
	},
	flipfit: {
		left: function() {
			$.ui.position.flip.left.apply( this, arguments );
			$.ui.position.fit.left.apply( this, arguments );
		},
		top: function() {
			$.ui.position.flip.top.apply( this, arguments );
			$.ui.position.fit.top.apply( this, arguments );
		}
	}
};

} )();

var position = $.ui.position;


/*!
 * jQuery UI :data 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: :data Selector
//>>group: Core
//>>description: Selects elements which have data stored under the specified key.
//>>docs: http://api.jqueryui.com/data-selector/


var data = $.extend( $.expr.pseudos, {
	data: $.expr.createPseudo ?
		$.expr.createPseudo( function( dataName ) {
			return function( elem ) {
				return !!$.data( elem, dataName );
			};
		} ) :

		// Support: jQuery <1.8
		function( elem, i, match ) {
			return !!$.data( elem, match[ 3 ] );
		}
} );

/*!
 * jQuery UI Disable Selection 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: disableSelection
//>>group: Core
//>>description: Disable selection of text content within the set of matched elements.
//>>docs: http://api.jqueryui.com/disableSelection/

// This file is deprecated


var disableSelection = $.fn.extend( {
	disableSelection: ( function() {
		var eventType = "onselectstart" in document.createElement( "div" ) ?
			"selectstart" :
			"mousedown";

		return function() {
			return this.on( eventType + ".ui-disableSelection", function( event ) {
				event.preventDefault();
			} );
		};
	} )(),

	enableSelection: function() {
		return this.off( ".ui-disableSelection" );
	}
} );


/*!
 * jQuery UI Focusable 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: :focusable Selector
//>>group: Core
//>>description: Selects elements which can be focused.
//>>docs: http://api.jqueryui.com/focusable-selector/



// Selectors
$.ui.focusable = function( element, hasTabindex ) {
	var map, mapName, img, focusableIfVisible, fieldset,
		nodeName = element.nodeName.toLowerCase();

	if ( "area" === nodeName ) {
		map = element.parentNode;
		mapName = map.name;
		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
			return false;
		}
		img = $( "img[usemap='#" + mapName + "']" );
		return img.length > 0 && img.is( ":visible" );
	}

	if ( /^(input|select|textarea|button|object)$/.test( nodeName ) ) {
		focusableIfVisible = !element.disabled;

		if ( focusableIfVisible ) {

			// Form controls within a disabled fieldset are disabled.
			// However, controls within the fieldset's legend do not get disabled.
			// Since controls generally aren't placed inside legends, we skip
			// this portion of the check.
			fieldset = $( element ).closest( "fieldset" )[ 0 ];
			if ( fieldset ) {
				focusableIfVisible = !fieldset.disabled;
			}
		}
	} else if ( "a" === nodeName ) {
		focusableIfVisible = element.href || hasTabindex;
	} else {
		focusableIfVisible = hasTabindex;
	}

	return focusableIfVisible && $( element ).is( ":visible" ) && visible( $( element ) );
};

// Support: IE 8 only
// IE 8 doesn't resolve inherit to visible/hidden for computed values
function visible( element ) {
	var visibility = element.css( "visibility" );
	while ( visibility === "inherit" ) {
		element = element.parent();
		visibility = element.css( "visibility" );
	}
	return visibility !== "hidden";
}

$.extend( $.expr.pseudos, {
	focusable: function( element ) {
		return $.ui.focusable( element, $.attr( element, "tabindex" ) != null );
	}
} );

var focusable = $.ui.focusable;




// Support: IE8 Only
// IE8 does not support the form attribute and when it is supplied. It overwrites the form prop
// with a string, so we need to find the proper form.
var form = $.fn.form = function() {
	return typeof this[ 0 ].form === "string" ? this.closest( "form" ) : $( this[ 0 ].form );
};


/*!
 * jQuery UI Form Reset Mixin 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Form Reset Mixin
//>>group: Core
//>>description: Refresh input widgets when their form is reset
//>>docs: http://api.jqueryui.com/form-reset-mixin/



var formResetMixin = $.ui.formResetMixin = {
	_formResetHandler: function() {
		var form = $( this );

		// Wait for the form reset to actually happen before refreshing
		setTimeout( function() {
			var instances = form.data( "ui-form-reset-instances" );
			$.each( instances, function() {
				this.refresh();
			} );
		} );
	},

	_bindFormResetHandler: function() {
		this.form = this.element.form();
		if ( !this.form.length ) {
			return;
		}

		var instances = this.form.data( "ui-form-reset-instances" ) || [];
		if ( !instances.length ) {

			// We don't use _on() here because we use a single event handler per form
			this.form.on( "reset.ui-form-reset", this._formResetHandler );
		}
		instances.push( this );
		this.form.data( "ui-form-reset-instances", instances );
	},

	_unbindFormResetHandler: function() {
		if ( !this.form.length ) {
			return;
		}

		var instances = this.form.data( "ui-form-reset-instances" );
		instances.splice( $.inArray( this, instances ), 1 );
		if ( instances.length ) {
			this.form.data( "ui-form-reset-instances", instances );
		} else {
			this.form
				.removeData( "ui-form-reset-instances" )
				.off( "reset.ui-form-reset" );
		}
	}
};


/*!
 * jQuery UI Support for jQuery core 1.7.x 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 */

//>>label: jQuery 1.7 Support
//>>group: Core
//>>description: Support version 1.7.x of jQuery core



// Support: jQuery 1.7 only
// Not a great way to check versions, but since we only support 1.7+ and only
// need to detect <1.8, this is a simple check that should suffice. Checking
// for "1.7." would be a bit safer, but the version string is 1.7, not 1.7.0
// and we'll never reach 1.70.0 (if we do, we certainly won't be supporting
// 1.7 anymore). See #11197 for why we're not using feature detection.
if ( $.fn.jquery.substring( 0, 3 ) === "1.7" ) {

	// Setters for .innerWidth(), .innerHeight(), .outerWidth(), .outerHeight()
	// Unlike jQuery Core 1.8+, these only support numeric values to set the
	// dimensions in pixels
	$.each( [ "Width", "Height" ], function( i, name ) {
		var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
			type = name.toLowerCase(),
			orig = {
				innerWidth: $.fn.innerWidth,
				innerHeight: $.fn.innerHeight,
				outerWidth: $.fn.outerWidth,
				outerHeight: $.fn.outerHeight
			};

		function reduce( elem, size, border, margin ) {
			$.each( side, function() {
				size -= parseFloat( $.css( elem, "padding" + this ) ) || 0;
				if ( border ) {
					size -= parseFloat( $.css( elem, "border" + this + "Width" ) ) || 0;
				}
				if ( margin ) {
					size -= parseFloat( $.css( elem, "margin" + this ) ) || 0;
				}
			} );
			return size;
		}

		$.fn[ "inner" + name ] = function( size ) {
			if ( size === undefined ) {
				return orig[ "inner" + name ].call( this );
			}

			return this.each( function() {
				$( this ).css( type, reduce( this, size ) + "px" );
			} );
		};

		$.fn[ "outer" + name ] = function( size, margin ) {
			if ( typeof size !== "number" ) {
				return orig[ "outer" + name ].call( this, size );
			}

			return this.each( function() {
				$( this ).css( type, reduce( this, size, true, margin ) + "px" );
			} );
		};
	} );

	$.fn.addBack = function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	};
}

;
/*!
 * jQuery UI Keycode 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Keycode
//>>group: Core
//>>description: Provide keycodes as keynames
//>>docs: http://api.jqueryui.com/jQuery.ui.keyCode/


var keycode = $.ui.keyCode = {
	BACKSPACE: 8,
	COMMA: 188,
	DELETE: 46,
	DOWN: 40,
	END: 35,
	ENTER: 13,
	ESCAPE: 27,
	HOME: 36,
	LEFT: 37,
	PAGE_DOWN: 34,
	PAGE_UP: 33,
	PERIOD: 190,
	RIGHT: 39,
	SPACE: 32,
	TAB: 9,
	UP: 38
};




// Internal use only
var escapeSelector = $.ui.escapeSelector = ( function() {
	var selectorEscape = /([!"#$%&'()*+,./:;<=>?@[\]^`{|}~])/g;
	return function( selector ) {
		return selector.replace( selectorEscape, "\\$1" );
	};
} )();


/*!
 * jQuery UI Labels 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: labels
//>>group: Core
//>>description: Find all the labels associated with a given input
//>>docs: http://api.jqueryui.com/labels/



var labels = $.fn.labels = function() {
	var ancestor, selector, id, labels, ancestors;

	// Check control.labels first
	if ( this[ 0 ].labels && this[ 0 ].labels.length ) {
		return this.pushStack( this[ 0 ].labels );
	}

	// Support: IE <= 11, FF <= 37, Android <= 2.3 only
	// Above browsers do not support control.labels. Everything below is to support them
	// as well as document fragments. control.labels does not work on document fragments
	labels = this.eq( 0 ).parents( "label" );

	// Look for the label based on the id
	id = this.attr( "id" );
	if ( id ) {

		// We don't search against the document in case the element
		// is disconnected from the DOM
		ancestor = this.eq( 0 ).parents().last();

		// Get a full set of top level ancestors
		ancestors = ancestor.add( ancestor.length ? ancestor.siblings() : this.siblings() );

		// Create a selector for the label based on the id
		selector = "label[for='" + $.ui.escapeSelector( id ) + "']";

		labels = labels.add( ancestors.find( selector ).addBack( selector ) );

	}

	// Return whatever we have found for labels
	return this.pushStack( labels );
};


/*!
 * jQuery UI Scroll Parent 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: scrollParent
//>>group: Core
//>>description: Get the closest ancestor element that is scrollable.
//>>docs: http://api.jqueryui.com/scrollParent/



var scrollParent = $.fn.scrollParent = function( includeHidden ) {
	var position = this.css( "position" ),
		excludeStaticParent = position === "absolute",
		overflowRegex = includeHidden ? /(auto|scroll|hidden)/ : /(auto|scroll)/,
		scrollParent = this.parents().filter( function() {
			var parent = $( this );
			if ( excludeStaticParent && parent.css( "position" ) === "static" ) {
				return false;
			}
			return overflowRegex.test( parent.css( "overflow" ) + parent.css( "overflow-y" ) +
				parent.css( "overflow-x" ) );
		} ).eq( 0 );

	return position === "fixed" || !scrollParent.length ?
		$( this[ 0 ].ownerDocument || document ) :
		scrollParent;
};


/*!
 * jQuery UI Tabbable 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: :tabbable Selector
//>>group: Core
//>>description: Selects elements which can be tabbed to.
//>>docs: http://api.jqueryui.com/tabbable-selector/



var tabbable = $.extend( $.expr.pseudos, {
	tabbable: function( element ) {
		var tabIndex = $.attr( element, "tabindex" ),
			hasTabindex = tabIndex != null;
		return ( !hasTabindex || tabIndex >= 0 ) && $.ui.focusable( element, hasTabindex );
	}
} );


/*!
 * jQuery UI Unique ID 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: uniqueId
//>>group: Core
//>>description: Functions to generate and remove uniqueId's
//>>docs: http://api.jqueryui.com/uniqueId/



var uniqueId = $.fn.extend( {
	uniqueId: ( function() {
		var uuid = 0;

		return function() {
			return this.each( function() {
				if ( !this.id ) {
					this.id = "ui-id-" + ( ++uuid );
				}
			} );
		};
	} )(),

	removeUniqueId: function() {
		return this.each( function() {
			if ( /^ui-id-\d+$/.test( this.id ) ) {
				$( this ).removeAttr( "id" );
			}
		} );
	}
} );




// This file is deprecated
var ie = $.ui.ie = !!/msie [\w.]+/.exec( navigator.userAgent.toLowerCase() );

/*!
 * jQuery UI Mouse 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Mouse
//>>group: Widgets
//>>description: Abstracts mouse-based interactions to assist in creating certain widgets.
//>>docs: http://api.jqueryui.com/mouse/



var mouseHandled = false;
$( document ).on( "mouseup", function() {
	mouseHandled = false;
} );

var widgetsMouse = $.widget( "ui.mouse", {
	version: "1.12.1",
	options: {
		cancel: "input, textarea, button, select, option",
		distance: 1,
		delay: 0
	},
	_mouseInit: function() {
		var that = this;

		this.element
			.on( "mousedown." + this.widgetName, function( event ) {
				return that._mouseDown( event );
			} )
			.on( "click." + this.widgetName, function( event ) {
				if ( true === $.data( event.target, that.widgetName + ".preventClickEvent" ) ) {
					$.removeData( event.target, that.widgetName + ".preventClickEvent" );
					event.stopImmediatePropagation();
					return false;
				}
			} );

		this.started = false;
	},

	// TODO: make sure destroying one instance of mouse doesn't mess with
	// other instances of mouse
	_mouseDestroy: function() {
		this.element.off( "." + this.widgetName );
		if ( this._mouseMoveDelegate ) {
			this.document
				.off( "mousemove." + this.widgetName, this._mouseMoveDelegate )
				.off( "mouseup." + this.widgetName, this._mouseUpDelegate );
		}
	},

	_mouseDown: function( event ) {

		// don't let more than one widget handle mouseStart
		if ( mouseHandled ) {
			return;
		}

		this._mouseMoved = false;

		// We may have missed mouseup (out of window)
		( this._mouseStarted && this._mouseUp( event ) );

		this._mouseDownEvent = event;

		var that = this,
			btnIsLeft = ( event.which === 1 ),

			// event.target.nodeName works around a bug in IE 8 with
			// disabled inputs (#7620)
			elIsCancel = ( typeof this.options.cancel === "string" && event.target.nodeName ?
				$( event.target ).closest( this.options.cancel ).length : false );
		if ( !btnIsLeft || elIsCancel || !this._mouseCapture( event ) ) {
			return true;
		}

		this.mouseDelayMet = !this.options.delay;
		if ( !this.mouseDelayMet ) {
			this._mouseDelayTimer = setTimeout( function() {
				that.mouseDelayMet = true;
			}, this.options.delay );
		}

		if ( this._mouseDistanceMet( event ) && this._mouseDelayMet( event ) ) {
			this._mouseStarted = ( this._mouseStart( event ) !== false );
			if ( !this._mouseStarted ) {
				event.preventDefault();
				return true;
			}
		}

		// Click event may never have fired (Gecko & Opera)
		if ( true === $.data( event.target, this.widgetName + ".preventClickEvent" ) ) {
			$.removeData( event.target, this.widgetName + ".preventClickEvent" );
		}

		// These delegates are required to keep context
		this._mouseMoveDelegate = function( event ) {
			return that._mouseMove( event );
		};
		this._mouseUpDelegate = function( event ) {
			return that._mouseUp( event );
		};

		this.document
			.on( "mousemove." + this.widgetName, this._mouseMoveDelegate )
			.on( "mouseup." + this.widgetName, this._mouseUpDelegate );

		event.preventDefault();

		mouseHandled = true;
		return true;
	},

	_mouseMove: function( event ) {

		// Only check for mouseups outside the document if you've moved inside the document
		// at least once. This prevents the firing of mouseup in the case of IE<9, which will
		// fire a mousemove event if content is placed under the cursor. See #7778
		// Support: IE <9
		if ( this._mouseMoved ) {

			// IE mouseup check - mouseup happened when mouse was out of window
			if ( $.ui.ie && ( !document.documentMode || document.documentMode < 9 ) &&
					!event.button ) {
				return this._mouseUp( event );

			// Iframe mouseup check - mouseup occurred in another document
			} else if ( !event.which ) {

				// Support: Safari <=8 - 9
				// Safari sets which to 0 if you press any of the following keys
				// during a drag (#14461)
				if ( event.originalEvent.altKey || event.originalEvent.ctrlKey ||
						event.originalEvent.metaKey || event.originalEvent.shiftKey ) {
					this.ignoreMissingWhich = true;
				} else if ( !this.ignoreMissingWhich ) {
					return this._mouseUp( event );
				}
			}
		}

		if ( event.which || event.button ) {
			this._mouseMoved = true;
		}

		if ( this._mouseStarted ) {
			this._mouseDrag( event );
			return event.preventDefault();
		}

		if ( this._mouseDistanceMet( event ) && this._mouseDelayMet( event ) ) {
			this._mouseStarted =
				( this._mouseStart( this._mouseDownEvent, event ) !== false );
			( this._mouseStarted ? this._mouseDrag( event ) : this._mouseUp( event ) );
		}

		return !this._mouseStarted;
	},

	_mouseUp: function( event ) {
		this.document
			.off( "mousemove." + this.widgetName, this._mouseMoveDelegate )
			.off( "mouseup." + this.widgetName, this._mouseUpDelegate );

		if ( this._mouseStarted ) {
			this._mouseStarted = false;

			if ( event.target === this._mouseDownEvent.target ) {
				$.data( event.target, this.widgetName + ".preventClickEvent", true );
			}

			this._mouseStop( event );
		}

		if ( this._mouseDelayTimer ) {
			clearTimeout( this._mouseDelayTimer );
			delete this._mouseDelayTimer;
		}

		this.ignoreMissingWhich = false;
		mouseHandled = false;
		event.preventDefault();
	},

	_mouseDistanceMet: function( event ) {
		return ( Math.max(
				Math.abs( this._mouseDownEvent.pageX - event.pageX ),
				Math.abs( this._mouseDownEvent.pageY - event.pageY )
			) >= this.options.distance
		);
	},

	_mouseDelayMet: function( /* event */ ) {
		return this.mouseDelayMet;
	},

	// These are placeholder methods, to be overriden by extending plugin
	_mouseStart: function( /* event */ ) {},
	_mouseDrag: function( /* event */ ) {},
	_mouseStop: function( /* event */ ) {},
	_mouseCapture: function( /* event */ ) { return true; }
} );




// $.ui.plugin is deprecated. Use $.widget() extensions instead.
var plugin = $.ui.plugin = {
	add: function( module, option, set ) {
		var i,
			proto = $.ui[ module ].prototype;
		for ( i in set ) {
			proto.plugins[ i ] = proto.plugins[ i ] || [];
			proto.plugins[ i ].push( [ option, set[ i ] ] );
		}
	},
	call: function( instance, name, args, allowDisconnected ) {
		var i,
			set = instance.plugins[ name ];

		if ( !set ) {
			return;
		}

		if ( !allowDisconnected && ( !instance.element[ 0 ].parentNode ||
				instance.element[ 0 ].parentNode.nodeType === 11 ) ) {
			return;
		}

		for ( i = 0; i < set.length; i++ ) {
			if ( instance.options[ set[ i ][ 0 ] ] ) {
				set[ i ][ 1 ].apply( instance.element, args );
			}
		}
	}
};



var safeActiveElement = $.ui.safeActiveElement = function( document ) {
	var activeElement;

	// Support: IE 9 only
	// IE9 throws an "Unspecified error" accessing document.activeElement from an <iframe>
	try {
		activeElement = document.activeElement;
	} catch ( error ) {
		activeElement = document.body;
	}

	// Support: IE 9 - 11 only
	// IE may return null instead of an element
	// Interestingly, this only seems to occur when NOT in an iframe
	if ( !activeElement ) {
		activeElement = document.body;
	}

	// Support: IE 11 only
	// IE11 returns a seemingly empty object in some cases when accessing
	// document.activeElement from an <iframe>
	if ( !activeElement.nodeName ) {
		activeElement = document.body;
	}

	return activeElement;
};



var safeBlur = $.ui.safeBlur = function( element ) {

	// Support: IE9 - 10 only
	// If the <body> is blurred, IE will switch windows, see #9420
	if ( element && element.nodeName.toLowerCase() !== "body" ) {
		$( element ).trigger( "blur" );
	}
};


/*!
 * jQuery UI Draggable 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Draggable
//>>group: Interactions
//>>description: Enables dragging functionality for any element.
//>>docs: http://api.jqueryui.com/draggable/
//>>demos: http://jqueryui.com/draggable/
//>>css.structure: ../../themes/base/draggable.css



$.widget( "ui.draggable", $.ui.mouse, {
	version: "1.12.1",
	widgetEventPrefix: "drag",
	options: {
		addClasses: true,
		appendTo: "parent",
		axis: false,
		connectToSortable: false,
		containment: false,
		cursor: "auto",
		cursorAt: false,
		grid: false,
		handle: false,
		helper: "original",
		iframeFix: false,
		opacity: false,
		refreshPositions: false,
		revert: false,
		revertDuration: 500,
		scope: "default",
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		snap: false,
		snapMode: "both",
		snapTolerance: 20,
		stack: false,
		zIndex: false,

		// Callbacks
		drag: null,
		start: null,
		stop: null
	},
	_create: function() {

		if ( this.options.helper === "original" ) {
			this._setPositionRelative();
		}
		if ( this.options.addClasses ) {
			this._addClass( "ui-draggable" );
		}
		this._setHandleClassName();

		this._mouseInit();
	},

	_setOption: function( key, value ) {
		this._super( key, value );
		if ( key === "handle" ) {
			this._removeHandleClassName();
			this._setHandleClassName();
		}
	},

	_destroy: function() {
		if ( ( this.helper || this.element ).is( ".ui-draggable-dragging" ) ) {
			this.destroyOnClear = true;
			return;
		}
		this._removeHandleClassName();
		this._mouseDestroy();
	},

	_mouseCapture: function( event ) {
		var o = this.options;

		// Among others, prevent a drag on a resizable-handle
		if ( this.helper || o.disabled ||
				$( event.target ).closest( ".ui-resizable-handle" ).length > 0 ) {
			return false;
		}

		//Quit if we're not on a valid handle
		this.handle = this._getHandle( event );
		if ( !this.handle ) {
			return false;
		}

		this._blurActiveElement( event );

		this._blockFrames( o.iframeFix === true ? "iframe" : o.iframeFix );

		return true;

	},

	_blockFrames: function( selector ) {
		this.iframeBlocks = this.document.find( selector ).map( function() {
			var iframe = $( this );

			return $( "<div>" )
				.css( "position", "absolute" )
				.appendTo( iframe.parent() )
				.outerWidth( iframe.outerWidth() )
				.outerHeight( iframe.outerHeight() )
				.offset( iframe.offset() )[ 0 ];
		} );
	},

	_unblockFrames: function() {
		if ( this.iframeBlocks ) {
			this.iframeBlocks.remove();
			delete this.iframeBlocks;
		}
	},

	_blurActiveElement: function( event ) {
		var activeElement = $.ui.safeActiveElement( this.document[ 0 ] ),
			target = $( event.target );

		// Don't blur if the event occurred on an element that is within
		// the currently focused element
		// See #10527, #12472
		if ( target.closest( activeElement ).length ) {
			return;
		}

		// Blur any element that currently has focus, see #4261
		$.ui.safeBlur( activeElement );
	},

	_mouseStart: function( event ) {

		var o = this.options;

		//Create and append the visible helper
		this.helper = this._createHelper( event );

		this._addClass( this.helper, "ui-draggable-dragging" );

		//Cache the helper size
		this._cacheHelperProportions();

		//If ddmanager is used for droppables, set the global draggable
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.current = this;
		}

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Store the helper's css position
		this.cssPosition = this.helper.css( "position" );
		this.scrollParent = this.helper.scrollParent( true );
		this.offsetParent = this.helper.offsetParent();
		this.hasFixedAncestor = this.helper.parents().filter( function() {
				return $( this ).css( "position" ) === "fixed";
			} ).length > 0;

		//The element's absolute position on the page minus margins
		this.positionAbs = this.element.offset();
		this._refreshOffsets( event );

		//Generate the original position
		this.originalPosition = this.position = this._generatePosition( event, false );
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if "cursorAt" is supplied
		( o.cursorAt && this._adjustOffsetFromHelper( o.cursorAt ) );

		//Set a containment if given in the options
		this._setContainment();

		//Trigger event + callbacks
		if ( this._trigger( "start", event ) === false ) {
			this._clear();
			return false;
		}

		//Recache the helper size
		this._cacheHelperProportions();

		//Prepare the droppable offsets
		if ( $.ui.ddmanager && !o.dropBehaviour ) {
			$.ui.ddmanager.prepareOffsets( this, event );
		}

		// Execute the drag once - this causes the helper not to be visible before getting its
		// correct position
		this._mouseDrag( event, true );

		// If the ddmanager is used for droppables, inform the manager that dragging has started
		// (see #5003)
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.dragStart( this, event );
		}

		return true;
	},

	_refreshOffsets: function( event ) {
		this.offset = {
			top: this.positionAbs.top - this.margins.top,
			left: this.positionAbs.left - this.margins.left,
			scroll: false,
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset()
		};

		this.offset.click = {
			left: event.pageX - this.offset.left,
			top: event.pageY - this.offset.top
		};
	},

	_mouseDrag: function( event, noPropagation ) {

		// reset any necessary cached properties (see #5009)
		if ( this.hasFixedAncestor ) {
			this.offset.parent = this._getParentOffset();
		}

		//Compute the helpers position
		this.position = this._generatePosition( event, true );
		this.positionAbs = this._convertPositionTo( "absolute" );

		//Call plugins and callbacks and use the resulting position if something is returned
		if ( !noPropagation ) {
			var ui = this._uiHash();
			if ( this._trigger( "drag", event, ui ) === false ) {
				this._mouseUp( new $.Event( "mouseup", event ) );
				return false;
			}
			this.position = ui.position;
		}

		this.helper[ 0 ].style.left = this.position.left + "px";
		this.helper[ 0 ].style.top = this.position.top + "px";

		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.drag( this, event );
		}

		return false;
	},

	_mouseStop: function( event ) {

		//If we are using droppables, inform the manager about the drop
		var that = this,
			dropped = false;
		if ( $.ui.ddmanager && !this.options.dropBehaviour ) {
			dropped = $.ui.ddmanager.drop( this, event );
		}

		//if a drop comes from outside (a sortable)
		if ( this.dropped ) {
			dropped = this.dropped;
			this.dropped = false;
		}

		if ( ( this.options.revert === "invalid" && !dropped ) ||
				( this.options.revert === "valid" && dropped ) ||
				this.options.revert === true || ( $.isFunction( this.options.revert ) &&
				this.options.revert.call( this.element, dropped ) )
		) {
			$( this.helper ).animate(
				this.originalPosition,
				parseInt( this.options.revertDuration, 10 ),
				function() {
					if ( that._trigger( "stop", event ) !== false ) {
						that._clear();
					}
				}
			);
		} else {
			if ( this._trigger( "stop", event ) !== false ) {
				this._clear();
			}
		}

		return false;
	},

	_mouseUp: function( event ) {
		this._unblockFrames();

		// If the ddmanager is used for droppables, inform the manager that dragging has stopped
		// (see #5003)
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.dragStop( this, event );
		}

		// Only need to focus if the event occurred on the draggable itself, see #10527
		if ( this.handleElement.is( event.target ) ) {

			// The interaction is over; whether or not the click resulted in a drag,
			// focus the element
			this.element.trigger( "focus" );
		}

		return $.ui.mouse.prototype._mouseUp.call( this, event );
	},

	cancel: function() {

		if ( this.helper.is( ".ui-draggable-dragging" ) ) {
			this._mouseUp( new $.Event( "mouseup", { target: this.element[ 0 ] } ) );
		} else {
			this._clear();
		}

		return this;

	},

	_getHandle: function( event ) {
		return this.options.handle ?
			!!$( event.target ).closest( this.element.find( this.options.handle ) ).length :
			true;
	},

	_setHandleClassName: function() {
		this.handleElement = this.options.handle ?
			this.element.find( this.options.handle ) : this.element;
		this._addClass( this.handleElement, "ui-draggable-handle" );
	},

	_removeHandleClassName: function() {
		this._removeClass( this.handleElement, "ui-draggable-handle" );
	},

	_createHelper: function( event ) {

		var o = this.options,
			helperIsFunction = $.isFunction( o.helper ),
			helper = helperIsFunction ?
				$( o.helper.apply( this.element[ 0 ], [ event ] ) ) :
				( o.helper === "clone" ?
					this.element.clone().removeAttr( "id" ) :
					this.element );

		if ( !helper.parents( "body" ).length ) {
			helper.appendTo( ( o.appendTo === "parent" ?
				this.element[ 0 ].parentNode :
				o.appendTo ) );
		}

		// Http://bugs.jqueryui.com/ticket/9446
		// a helper function can return the original element
		// which wouldn't have been set to relative in _create
		if ( helperIsFunction && helper[ 0 ] === this.element[ 0 ] ) {
			this._setPositionRelative();
		}

		if ( helper[ 0 ] !== this.element[ 0 ] &&
				!( /(fixed|absolute)/ ).test( helper.css( "position" ) ) ) {
			helper.css( "position", "absolute" );
		}

		return helper;

	},

	_setPositionRelative: function() {
		if ( !( /^(?:r|a|f)/ ).test( this.element.css( "position" ) ) ) {
			this.element[ 0 ].style.position = "relative";
		}
	},

	_adjustOffsetFromHelper: function( obj ) {
		if ( typeof obj === "string" ) {
			obj = obj.split( " " );
		}
		if ( $.isArray( obj ) ) {
			obj = { left: +obj[ 0 ], top: +obj[ 1 ] || 0 };
		}
		if ( "left" in obj ) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ( "right" in obj ) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ( "top" in obj ) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ( "bottom" in obj ) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_isRootNode: function( element ) {
		return ( /(html|body)/i ).test( element.tagName ) || element === this.document[ 0 ];
	},

	_getParentOffset: function() {

		//Get the offsetParent and cache its position
		var po = this.offsetParent.offset(),
			document = this.document[ 0 ];

		// This is a special case where we need to modify a offset calculated on start, since the
		// following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the
		// next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't
		// the document, which means that the scroll is included in the initial calculation of the
		// offset of the parent, and never recalculated upon drag
		if ( this.cssPosition === "absolute" && this.scrollParent[ 0 ] !== document &&
				$.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		if ( this._isRootNode( this.offsetParent[ 0 ] ) ) {
			po = { top: 0, left: 0 };
		}

		return {
			top: po.top + ( parseInt( this.offsetParent.css( "borderTopWidth" ), 10 ) || 0 ),
			left: po.left + ( parseInt( this.offsetParent.css( "borderLeftWidth" ), 10 ) || 0 )
		};

	},

	_getRelativeOffset: function() {
		if ( this.cssPosition !== "relative" ) {
			return { top: 0, left: 0 };
		}

		var p = this.element.position(),
			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );

		return {
			top: p.top - ( parseInt( this.helper.css( "top" ), 10 ) || 0 ) +
				( !scrollIsRootNode ? this.scrollParent.scrollTop() : 0 ),
			left: p.left - ( parseInt( this.helper.css( "left" ), 10 ) || 0 ) +
				( !scrollIsRootNode ? this.scrollParent.scrollLeft() : 0 )
		};

	},

	_cacheMargins: function() {
		this.margins = {
			left: ( parseInt( this.element.css( "marginLeft" ), 10 ) || 0 ),
			top: ( parseInt( this.element.css( "marginTop" ), 10 ) || 0 ),
			right: ( parseInt( this.element.css( "marginRight" ), 10 ) || 0 ),
			bottom: ( parseInt( this.element.css( "marginBottom" ), 10 ) || 0 )
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var isUserScrollable, c, ce,
			o = this.options,
			document = this.document[ 0 ];

		this.relativeContainer = null;

		if ( !o.containment ) {
			this.containment = null;
			return;
		}

		if ( o.containment === "window" ) {
			this.containment = [
				$( window ).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
				$( window ).scrollTop() - this.offset.relative.top - this.offset.parent.top,
				$( window ).scrollLeft() + $( window ).width() -
					this.helperProportions.width - this.margins.left,
				$( window ).scrollTop() +
					( $( window ).height() || document.body.parentNode.scrollHeight ) -
					this.helperProportions.height - this.margins.top
			];
			return;
		}

		if ( o.containment === "document" ) {
			this.containment = [
				0,
				0,
				$( document ).width() - this.helperProportions.width - this.margins.left,
				( $( document ).height() || document.body.parentNode.scrollHeight ) -
					this.helperProportions.height - this.margins.top
			];
			return;
		}

		if ( o.containment.constructor === Array ) {
			this.containment = o.containment;
			return;
		}

		if ( o.containment === "parent" ) {
			o.containment = this.helper[ 0 ].parentNode;
		}

		c = $( o.containment );
		ce = c[ 0 ];

		if ( !ce ) {
			return;
		}

		isUserScrollable = /(scroll|auto)/.test( c.css( "overflow" ) );

		this.containment = [
			( parseInt( c.css( "borderLeftWidth" ), 10 ) || 0 ) +
				( parseInt( c.css( "paddingLeft" ), 10 ) || 0 ),
			( parseInt( c.css( "borderTopWidth" ), 10 ) || 0 ) +
				( parseInt( c.css( "paddingTop" ), 10 ) || 0 ),
			( isUserScrollable ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) -
				( parseInt( c.css( "borderRightWidth" ), 10 ) || 0 ) -
				( parseInt( c.css( "paddingRight" ), 10 ) || 0 ) -
				this.helperProportions.width -
				this.margins.left -
				this.margins.right,
			( isUserScrollable ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) -
				( parseInt( c.css( "borderBottomWidth" ), 10 ) || 0 ) -
				( parseInt( c.css( "paddingBottom" ), 10 ) || 0 ) -
				this.helperProportions.height -
				this.margins.top -
				this.margins.bottom
		];
		this.relativeContainer = c;
	},

	_convertPositionTo: function( d, pos ) {

		if ( !pos ) {
			pos = this.position;
		}

		var mod = d === "absolute" ? 1 : -1,
			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] );

		return {
			top: (

				// The absolute mouse position
				pos.top	+

				// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.relative.top * mod +

				// The offsetParent's offset without borders (offset + border)
				this.offset.parent.top * mod -
				( ( this.cssPosition === "fixed" ?
					-this.offset.scroll.top :
					( scrollIsRootNode ? 0 : this.offset.scroll.top ) ) * mod )
			),
			left: (

				// The absolute mouse position
				pos.left +

				// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.relative.left * mod +

				// The offsetParent's offset without borders (offset + border)
				this.offset.parent.left * mod	-
				( ( this.cssPosition === "fixed" ?
					-this.offset.scroll.left :
					( scrollIsRootNode ? 0 : this.offset.scroll.left ) ) * mod )
			)
		};

	},

	_generatePosition: function( event, constrainPosition ) {

		var containment, co, top, left,
			o = this.options,
			scrollIsRootNode = this._isRootNode( this.scrollParent[ 0 ] ),
			pageX = event.pageX,
			pageY = event.pageY;

		// Cache the scroll
		if ( !scrollIsRootNode || !this.offset.scroll ) {
			this.offset.scroll = {
				top: this.scrollParent.scrollTop(),
				left: this.scrollParent.scrollLeft()
			};
		}

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		// If we are not dragging yet, we won't check for options
		if ( constrainPosition ) {
			if ( this.containment ) {
				if ( this.relativeContainer ) {
					co = this.relativeContainer.offset();
					containment = [
						this.containment[ 0 ] + co.left,
						this.containment[ 1 ] + co.top,
						this.containment[ 2 ] + co.left,
						this.containment[ 3 ] + co.top
					];
				} else {
					containment = this.containment;
				}

				if ( event.pageX - this.offset.click.left < containment[ 0 ] ) {
					pageX = containment[ 0 ] + this.offset.click.left;
				}
				if ( event.pageY - this.offset.click.top < containment[ 1 ] ) {
					pageY = containment[ 1 ] + this.offset.click.top;
				}
				if ( event.pageX - this.offset.click.left > containment[ 2 ] ) {
					pageX = containment[ 2 ] + this.offset.click.left;
				}
				if ( event.pageY - this.offset.click.top > containment[ 3 ] ) {
					pageY = containment[ 3 ] + this.offset.click.top;
				}
			}

			if ( o.grid ) {

				//Check for grid elements set to 0 to prevent divide by 0 error causing invalid
				// argument errors in IE (see ticket #6950)
				top = o.grid[ 1 ] ? this.originalPageY + Math.round( ( pageY -
					this.originalPageY ) / o.grid[ 1 ] ) * o.grid[ 1 ] : this.originalPageY;
				pageY = containment ? ( ( top - this.offset.click.top >= containment[ 1 ] ||
					top - this.offset.click.top > containment[ 3 ] ) ?
						top :
						( ( top - this.offset.click.top >= containment[ 1 ] ) ?
							top - o.grid[ 1 ] : top + o.grid[ 1 ] ) ) : top;

				left = o.grid[ 0 ] ? this.originalPageX +
					Math.round( ( pageX - this.originalPageX ) / o.grid[ 0 ] ) * o.grid[ 0 ] :
					this.originalPageX;
				pageX = containment ? ( ( left - this.offset.click.left >= containment[ 0 ] ||
					left - this.offset.click.left > containment[ 2 ] ) ?
						left :
						( ( left - this.offset.click.left >= containment[ 0 ] ) ?
							left - o.grid[ 0 ] : left + o.grid[ 0 ] ) ) : left;
			}

			if ( o.axis === "y" ) {
				pageX = this.originalPageX;
			}

			if ( o.axis === "x" ) {
				pageY = this.originalPageY;
			}
		}

		return {
			top: (

				// The absolute mouse position
				pageY -

				// Click offset (relative to the element)
				this.offset.click.top -

				// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.relative.top -

				// The offsetParent's offset without borders (offset + border)
				this.offset.parent.top +
				( this.cssPosition === "fixed" ?
					-this.offset.scroll.top :
					( scrollIsRootNode ? 0 : this.offset.scroll.top ) )
			),
			left: (

				// The absolute mouse position
				pageX -

				// Click offset (relative to the element)
				this.offset.click.left -

				// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.relative.left -

				// The offsetParent's offset without borders (offset + border)
				this.offset.parent.left +
				( this.cssPosition === "fixed" ?
					-this.offset.scroll.left :
					( scrollIsRootNode ? 0 : this.offset.scroll.left ) )
			)
		};

	},

	_clear: function() {
		this._removeClass( this.helper, "ui-draggable-dragging" );
		if ( this.helper[ 0 ] !== this.element[ 0 ] && !this.cancelHelperRemoval ) {
			this.helper.remove();
		}
		this.helper = null;
		this.cancelHelperRemoval = false;
		if ( this.destroyOnClear ) {
			this.destroy();
		}
	},

	// From now on bulk stuff - mainly helpers

	_trigger: function( type, event, ui ) {
		ui = ui || this._uiHash();
		$.ui.plugin.call( this, type, [ event, ui, this ], true );

		// Absolute position and offset (see #6884 ) have to be recalculated after plugins
		if ( /^(drag|start|stop)/.test( type ) ) {
			this.positionAbs = this._convertPositionTo( "absolute" );
			ui.offset = this.positionAbs;
		}
		return $.Widget.prototype._trigger.call( this, type, event, ui );
	},

	plugins: {},

	_uiHash: function() {
		return {
			helper: this.helper,
			position: this.position,
			originalPosition: this.originalPosition,
			offset: this.positionAbs
		};
	}

} );

$.ui.plugin.add( "draggable", "connectToSortable", {
	start: function( event, ui, draggable ) {
		var uiSortable = $.extend( {}, ui, {
			item: draggable.element
		} );

		draggable.sortables = [];
		$( draggable.options.connectToSortable ).each( function() {
			var sortable = $( this ).sortable( "instance" );

			if ( sortable && !sortable.options.disabled ) {
				draggable.sortables.push( sortable );

				// RefreshPositions is called at drag start to refresh the containerCache
				// which is used in drag. This ensures it's initialized and synchronized
				// with any changes that might have happened on the page since initialization.
				sortable.refreshPositions();
				sortable._trigger( "activate", event, uiSortable );
			}
		} );
	},
	stop: function( event, ui, draggable ) {
		var uiSortable = $.extend( {}, ui, {
			item: draggable.element
		} );

		draggable.cancelHelperRemoval = false;

		$.each( draggable.sortables, function() {
			var sortable = this;

			if ( sortable.isOver ) {
				sortable.isOver = 0;

				// Allow this sortable to handle removing the helper
				draggable.cancelHelperRemoval = true;
				sortable.cancelHelperRemoval = false;

				// Use _storedCSS To restore properties in the sortable,
				// as this also handles revert (#9675) since the draggable
				// may have modified them in unexpected ways (#8809)
				sortable._storedCSS = {
					position: sortable.placeholder.css( "position" ),
					top: sortable.placeholder.css( "top" ),
					left: sortable.placeholder.css( "left" )
				};

				sortable._mouseStop( event );

				// Once drag has ended, the sortable should return to using
				// its original helper, not the shared helper from draggable
				sortable.options.helper = sortable.options._helper;
			} else {

				// Prevent this Sortable from removing the helper.
				// However, don't set the draggable to remove the helper
				// either as another connected Sortable may yet handle the removal.
				sortable.cancelHelperRemoval = true;

				sortable._trigger( "deactivate", event, uiSortable );
			}
		} );
	},
	drag: function( event, ui, draggable ) {
		$.each( draggable.sortables, function() {
			var innermostIntersecting = false,
				sortable = this;

			// Copy over variables that sortable's _intersectsWith uses
			sortable.positionAbs = draggable.positionAbs;
			sortable.helperProportions = draggable.helperProportions;
			sortable.offset.click = draggable.offset.click;

			if ( sortable._intersectsWith( sortable.containerCache ) ) {
				innermostIntersecting = true;

				$.each( draggable.sortables, function() {

					// Copy over variables that sortable's _intersectsWith uses
					this.positionAbs = draggable.positionAbs;
					this.helperProportions = draggable.helperProportions;
					this.offset.click = draggable.offset.click;

					if ( this !== sortable &&
							this._intersectsWith( this.containerCache ) &&
							$.contains( sortable.element[ 0 ], this.element[ 0 ] ) ) {
						innermostIntersecting = false;
					}

					return innermostIntersecting;
				} );
			}

			if ( innermostIntersecting ) {

				// If it intersects, we use a little isOver variable and set it once,
				// so that the move-in stuff gets fired only once.
				if ( !sortable.isOver ) {
					sortable.isOver = 1;

					// Store draggable's parent in case we need to reappend to it later.
					draggable._parent = ui.helper.parent();

					sortable.currentItem = ui.helper
						.appendTo( sortable.element )
						.data( "ui-sortable-item", true );

					// Store helper option to later restore it
					sortable.options._helper = sortable.options.helper;

					sortable.options.helper = function() {
						return ui.helper[ 0 ];
					};

					// Fire the start events of the sortable with our passed browser event,
					// and our own helper (so it doesn't create a new one)
					event.target = sortable.currentItem[ 0 ];
					sortable._mouseCapture( event, true );
					sortable._mouseStart( event, true, true );

					// Because the browser event is way off the new appended portlet,
					// modify necessary variables to reflect the changes
					sortable.offset.click.top = draggable.offset.click.top;
					sortable.offset.click.left = draggable.offset.click.left;
					sortable.offset.parent.left -= draggable.offset.parent.left -
						sortable.offset.parent.left;
					sortable.offset.parent.top -= draggable.offset.parent.top -
						sortable.offset.parent.top;

					draggable._trigger( "toSortable", event );

					// Inform draggable that the helper is in a valid drop zone,
					// used solely in the revert option to handle "valid/invalid".
					draggable.dropped = sortable.element;

					// Need to refreshPositions of all sortables in the case that
					// adding to one sortable changes the location of the other sortables (#9675)
					$.each( draggable.sortables, function() {
						this.refreshPositions();
					} );

					// Hack so receive/update callbacks work (mostly)
					draggable.currentItem = draggable.element;
					sortable.fromOutside = draggable;
				}

				if ( sortable.currentItem ) {
					sortable._mouseDrag( event );

					// Copy the sortable's position because the draggable's can potentially reflect
					// a relative position, while sortable is always absolute, which the dragged
					// element has now become. (#8809)
					ui.position = sortable.position;
				}
			} else {

				// If it doesn't intersect with the sortable, and it intersected before,
				// we fake the drag stop of the sortable, but make sure it doesn't remove
				// the helper by using cancelHelperRemoval.
				if ( sortable.isOver ) {

					sortable.isOver = 0;
					sortable.cancelHelperRemoval = true;

					// Calling sortable's mouseStop would trigger a revert,
					// so revert must be temporarily false until after mouseStop is called.
					sortable.options._revert = sortable.options.revert;
					sortable.options.revert = false;

					sortable._trigger( "out", event, sortable._uiHash( sortable ) );
					sortable._mouseStop( event, true );

					// Restore sortable behaviors that were modfied
					// when the draggable entered the sortable area (#9481)
					sortable.options.revert = sortable.options._revert;
					sortable.options.helper = sortable.options._helper;

					if ( sortable.placeholder ) {
						sortable.placeholder.remove();
					}

					// Restore and recalculate the draggable's offset considering the sortable
					// may have modified them in unexpected ways. (#8809, #10669)
					ui.helper.appendTo( draggable._parent );
					draggable._refreshOffsets( event );
					ui.position = draggable._generatePosition( event, true );

					draggable._trigger( "fromSortable", event );

					// Inform draggable that the helper is no longer in a valid drop zone
					draggable.dropped = false;

					// Need to refreshPositions of all sortables just in case removing
					// from one sortable changes the location of other sortables (#9675)
					$.each( draggable.sortables, function() {
						this.refreshPositions();
					} );
				}
			}
		} );
	}
} );

$.ui.plugin.add( "draggable", "cursor", {
	start: function( event, ui, instance ) {
		var t = $( "body" ),
			o = instance.options;

		if ( t.css( "cursor" ) ) {
			o._cursor = t.css( "cursor" );
		}
		t.css( "cursor", o.cursor );
	},
	stop: function( event, ui, instance ) {
		var o = instance.options;
		if ( o._cursor ) {
			$( "body" ).css( "cursor", o._cursor );
		}
	}
} );

$.ui.plugin.add( "draggable", "opacity", {
	start: function( event, ui, instance ) {
		var t = $( ui.helper ),
			o = instance.options;
		if ( t.css( "opacity" ) ) {
			o._opacity = t.css( "opacity" );
		}
		t.css( "opacity", o.opacity );
	},
	stop: function( event, ui, instance ) {
		var o = instance.options;
		if ( o._opacity ) {
			$( ui.helper ).css( "opacity", o._opacity );
		}
	}
} );

$.ui.plugin.add( "draggable", "scroll", {
	start: function( event, ui, i ) {
		if ( !i.scrollParentNotHidden ) {
			i.scrollParentNotHidden = i.helper.scrollParent( false );
		}

		if ( i.scrollParentNotHidden[ 0 ] !== i.document[ 0 ] &&
				i.scrollParentNotHidden[ 0 ].tagName !== "HTML" ) {
			i.overflowOffset = i.scrollParentNotHidden.offset();
		}
	},
	drag: function( event, ui, i  ) {

		var o = i.options,
			scrolled = false,
			scrollParent = i.scrollParentNotHidden[ 0 ],
			document = i.document[ 0 ];

		if ( scrollParent !== document && scrollParent.tagName !== "HTML" ) {
			if ( !o.axis || o.axis !== "x" ) {
				if ( ( i.overflowOffset.top + scrollParent.offsetHeight ) - event.pageY <
						o.scrollSensitivity ) {
					scrollParent.scrollTop = scrolled = scrollParent.scrollTop + o.scrollSpeed;
				} else if ( event.pageY - i.overflowOffset.top < o.scrollSensitivity ) {
					scrollParent.scrollTop = scrolled = scrollParent.scrollTop - o.scrollSpeed;
				}
			}

			if ( !o.axis || o.axis !== "y" ) {
				if ( ( i.overflowOffset.left + scrollParent.offsetWidth ) - event.pageX <
						o.scrollSensitivity ) {
					scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft + o.scrollSpeed;
				} else if ( event.pageX - i.overflowOffset.left < o.scrollSensitivity ) {
					scrollParent.scrollLeft = scrolled = scrollParent.scrollLeft - o.scrollSpeed;
				}
			}

		} else {

			if ( !o.axis || o.axis !== "x" ) {
				if ( event.pageY - $( document ).scrollTop() < o.scrollSensitivity ) {
					scrolled = $( document ).scrollTop( $( document ).scrollTop() - o.scrollSpeed );
				} else if ( $( window ).height() - ( event.pageY - $( document ).scrollTop() ) <
						o.scrollSensitivity ) {
					scrolled = $( document ).scrollTop( $( document ).scrollTop() + o.scrollSpeed );
				}
			}

			if ( !o.axis || o.axis !== "y" ) {
				if ( event.pageX - $( document ).scrollLeft() < o.scrollSensitivity ) {
					scrolled = $( document ).scrollLeft(
						$( document ).scrollLeft() - o.scrollSpeed
					);
				} else if ( $( window ).width() - ( event.pageX - $( document ).scrollLeft() ) <
						o.scrollSensitivity ) {
					scrolled = $( document ).scrollLeft(
						$( document ).scrollLeft() + o.scrollSpeed
					);
				}
			}

		}

		if ( scrolled !== false && $.ui.ddmanager && !o.dropBehaviour ) {
			$.ui.ddmanager.prepareOffsets( i, event );
		}

	}
} );

$.ui.plugin.add( "draggable", "snap", {
	start: function( event, ui, i ) {

		var o = i.options;

		i.snapElements = [];

		$( o.snap.constructor !== String ? ( o.snap.items || ":data(ui-draggable)" ) : o.snap )
			.each( function() {
				var $t = $( this ),
					$o = $t.offset();
				if ( this !== i.element[ 0 ] ) {
					i.snapElements.push( {
						item: this,
						width: $t.outerWidth(), height: $t.outerHeight(),
						top: $o.top, left: $o.left
					} );
				}
			} );

	},
	drag: function( event, ui, inst ) {

		var ts, bs, ls, rs, l, r, t, b, i, first,
			o = inst.options,
			d = o.snapTolerance,
			x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
			y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

		for ( i = inst.snapElements.length - 1; i >= 0; i-- ) {

			l = inst.snapElements[ i ].left - inst.margins.left;
			r = l + inst.snapElements[ i ].width;
			t = inst.snapElements[ i ].top - inst.margins.top;
			b = t + inst.snapElements[ i ].height;

			if ( x2 < l - d || x1 > r + d || y2 < t - d || y1 > b + d ||
					!$.contains( inst.snapElements[ i ].item.ownerDocument,
					inst.snapElements[ i ].item ) ) {
				if ( inst.snapElements[ i ].snapping ) {
					( inst.options.snap.release &&
						inst.options.snap.release.call(
							inst.element,
							event,
							$.extend( inst._uiHash(), { snapItem: inst.snapElements[ i ].item } )
						) );
				}
				inst.snapElements[ i ].snapping = false;
				continue;
			}

			if ( o.snapMode !== "inner" ) {
				ts = Math.abs( t - y2 ) <= d;
				bs = Math.abs( b - y1 ) <= d;
				ls = Math.abs( l - x2 ) <= d;
				rs = Math.abs( r - x1 ) <= d;
				if ( ts ) {
					ui.position.top = inst._convertPositionTo( "relative", {
						top: t - inst.helperProportions.height,
						left: 0
					} ).top;
				}
				if ( bs ) {
					ui.position.top = inst._convertPositionTo( "relative", {
						top: b,
						left: 0
					} ).top;
				}
				if ( ls ) {
					ui.position.left = inst._convertPositionTo( "relative", {
						top: 0,
						left: l - inst.helperProportions.width
					} ).left;
				}
				if ( rs ) {
					ui.position.left = inst._convertPositionTo( "relative", {
						top: 0,
						left: r
					} ).left;
				}
			}

			first = ( ts || bs || ls || rs );

			if ( o.snapMode !== "outer" ) {
				ts = Math.abs( t - y1 ) <= d;
				bs = Math.abs( b - y2 ) <= d;
				ls = Math.abs( l - x1 ) <= d;
				rs = Math.abs( r - x2 ) <= d;
				if ( ts ) {
					ui.position.top = inst._convertPositionTo( "relative", {
						top: t,
						left: 0
					} ).top;
				}
				if ( bs ) {
					ui.position.top = inst._convertPositionTo( "relative", {
						top: b - inst.helperProportions.height,
						left: 0
					} ).top;
				}
				if ( ls ) {
					ui.position.left = inst._convertPositionTo( "relative", {
						top: 0,
						left: l
					} ).left;
				}
				if ( rs ) {
					ui.position.left = inst._convertPositionTo( "relative", {
						top: 0,
						left: r - inst.helperProportions.width
					} ).left;
				}
			}

			if ( !inst.snapElements[ i ].snapping && ( ts || bs || ls || rs || first ) ) {
				( inst.options.snap.snap &&
					inst.options.snap.snap.call(
						inst.element,
						event,
						$.extend( inst._uiHash(), {
							snapItem: inst.snapElements[ i ].item
						} ) ) );
			}
			inst.snapElements[ i ].snapping = ( ts || bs || ls || rs || first );

		}

	}
} );

$.ui.plugin.add( "draggable", "stack", {
	start: function( event, ui, instance ) {
		var min,
			o = instance.options,
			group = $.makeArray( $( o.stack ) ).sort( function( a, b ) {
				return ( parseInt( $( a ).css( "zIndex" ), 10 ) || 0 ) -
					( parseInt( $( b ).css( "zIndex" ), 10 ) || 0 );
			} );

		if ( !group.length ) { return; }

		min = parseInt( $( group[ 0 ] ).css( "zIndex" ), 10 ) || 0;
		$( group ).each( function( i ) {
			$( this ).css( "zIndex", min + i );
		} );
		this.css( "zIndex", ( min + group.length ) );
	}
} );

$.ui.plugin.add( "draggable", "zIndex", {
	start: function( event, ui, instance ) {
		var t = $( ui.helper ),
			o = instance.options;

		if ( t.css( "zIndex" ) ) {
			o._zIndex = t.css( "zIndex" );
		}
		t.css( "zIndex", o.zIndex );
	},
	stop: function( event, ui, instance ) {
		var o = instance.options;

		if ( o._zIndex ) {
			$( ui.helper ).css( "zIndex", o._zIndex );
		}
	}
} );

var widgetsDraggable = $.ui.draggable;


/*!
 * jQuery UI Droppable 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Droppable
//>>group: Interactions
//>>description: Enables drop targets for draggable elements.
//>>docs: http://api.jqueryui.com/droppable/
//>>demos: http://jqueryui.com/droppable/



$.widget( "ui.droppable", {
	version: "1.12.1",
	widgetEventPrefix: "drop",
	options: {
		accept: "*",
		addClasses: true,
		greedy: false,
		scope: "default",
		tolerance: "intersect",

		// Callbacks
		activate: null,
		deactivate: null,
		drop: null,
		out: null,
		over: null
	},
	_create: function() {

		var proportions,
			o = this.options,
			accept = o.accept;

		this.isover = false;
		this.isout = true;

		this.accept = $.isFunction( accept ) ? accept : function( d ) {
			return d.is( accept );
		};

		this.proportions = function( /* valueToWrite */ ) {
			if ( arguments.length ) {

				// Store the droppable's proportions
				proportions = arguments[ 0 ];
			} else {

				// Retrieve or derive the droppable's proportions
				return proportions ?
					proportions :
					proportions = {
						width: this.element[ 0 ].offsetWidth,
						height: this.element[ 0 ].offsetHeight
					};
			}
		};

		this._addToManager( o.scope );

		o.addClasses && this._addClass( "ui-droppable" );

	},

	_addToManager: function( scope ) {

		// Add the reference and positions to the manager
		$.ui.ddmanager.droppables[ scope ] = $.ui.ddmanager.droppables[ scope ] || [];
		$.ui.ddmanager.droppables[ scope ].push( this );
	},

	_splice: function( drop ) {
		var i = 0;
		for ( ; i < drop.length; i++ ) {
			if ( drop[ i ] === this ) {
				drop.splice( i, 1 );
			}
		}
	},

	_destroy: function() {
		var drop = $.ui.ddmanager.droppables[ this.options.scope ];

		this._splice( drop );
	},

	_setOption: function( key, value ) {

		if ( key === "accept" ) {
			this.accept = $.isFunction( value ) ? value : function( d ) {
				return d.is( value );
			};
		} else if ( key === "scope" ) {
			var drop = $.ui.ddmanager.droppables[ this.options.scope ];

			this._splice( drop );
			this._addToManager( value );
		}

		this._super( key, value );
	},

	_activate: function( event ) {
		var draggable = $.ui.ddmanager.current;

		this._addActiveClass();
		if ( draggable ) {
			this._trigger( "activate", event, this.ui( draggable ) );
		}
	},

	_deactivate: function( event ) {
		var draggable = $.ui.ddmanager.current;

		this._removeActiveClass();
		if ( draggable ) {
			this._trigger( "deactivate", event, this.ui( draggable ) );
		}
	},

	_over: function( event ) {

		var draggable = $.ui.ddmanager.current;

		// Bail if draggable and droppable are same element
		if ( !draggable || ( draggable.currentItem ||
				draggable.element )[ 0 ] === this.element[ 0 ] ) {
			return;
		}

		if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem ||
				draggable.element ) ) ) {
			this._addHoverClass();
			this._trigger( "over", event, this.ui( draggable ) );
		}

	},

	_out: function( event ) {

		var draggable = $.ui.ddmanager.current;

		// Bail if draggable and droppable are same element
		if ( !draggable || ( draggable.currentItem ||
				draggable.element )[ 0 ] === this.element[ 0 ] ) {
			return;
		}

		if ( this.accept.call( this.element[ 0 ], ( draggable.currentItem ||
				draggable.element ) ) ) {
			this._removeHoverClass();
			this._trigger( "out", event, this.ui( draggable ) );
		}

	},

	_drop: function( event, custom ) {

		var draggable = custom || $.ui.ddmanager.current,
			childrenIntersection = false;

		// Bail if draggable and droppable are same element
		if ( !draggable || ( draggable.currentItem ||
				draggable.element )[ 0 ] === this.element[ 0 ] ) {
			return false;
		}

		this.element
			.find( ":data(ui-droppable)" )
			.not( ".ui-draggable-dragging" )
			.each( function() {
				var inst = $( this ).droppable( "instance" );
				if (
					inst.options.greedy &&
					!inst.options.disabled &&
					inst.options.scope === draggable.options.scope &&
					inst.accept.call(
						inst.element[ 0 ], ( draggable.currentItem || draggable.element )
					) &&
					intersect(
						draggable,
						$.extend( inst, { offset: inst.element.offset() } ),
						inst.options.tolerance, event
					)
				) {
					childrenIntersection = true;
					return false; }
			} );
		if ( childrenIntersection ) {
			return false;
		}

		if ( this.accept.call( this.element[ 0 ],
				( draggable.currentItem || draggable.element ) ) ) {
			this._removeActiveClass();
			this._removeHoverClass();

			this._trigger( "drop", event, this.ui( draggable ) );
			return this.element;
		}

		return false;

	},

	ui: function( c ) {
		return {
			draggable: ( c.currentItem || c.element ),
			helper: c.helper,
			position: c.position,
			offset: c.positionAbs
		};
	},

	// Extension points just to make backcompat sane and avoid duplicating logic
	// TODO: Remove in 1.13 along with call to it below
	_addHoverClass: function() {
		this._addClass( "ui-droppable-hover" );
	},

	_removeHoverClass: function() {
		this._removeClass( "ui-droppable-hover" );
	},

	_addActiveClass: function() {
		this._addClass( "ui-droppable-active" );
	},

	_removeActiveClass: function() {
		this._removeClass( "ui-droppable-active" );
	}
} );

var intersect = $.ui.intersect = ( function() {
	function isOverAxis( x, reference, size ) {
		return ( x >= reference ) && ( x < ( reference + size ) );
	}

	return function( draggable, droppable, toleranceMode, event ) {

		if ( !droppable.offset ) {
			return false;
		}

		var x1 = ( draggable.positionAbs ||
				draggable.position.absolute ).left + draggable.margins.left,
			y1 = ( draggable.positionAbs ||
				draggable.position.absolute ).top + draggable.margins.top,
			x2 = x1 + draggable.helperProportions.width,
			y2 = y1 + draggable.helperProportions.height,
			l = droppable.offset.left,
			t = droppable.offset.top,
			r = l + droppable.proportions().width,
			b = t + droppable.proportions().height;

		switch ( toleranceMode ) {
		case "fit":
			return ( l <= x1 && x2 <= r && t <= y1 && y2 <= b );
		case "intersect":
			return ( l < x1 + ( draggable.helperProportions.width / 2 ) && // Right Half
				x2 - ( draggable.helperProportions.width / 2 ) < r && // Left Half
				t < y1 + ( draggable.helperProportions.height / 2 ) && // Bottom Half
				y2 - ( draggable.helperProportions.height / 2 ) < b ); // Top Half
		case "pointer":
			return isOverAxis( event.pageY, t, droppable.proportions().height ) &&
				isOverAxis( event.pageX, l, droppable.proportions().width );
		case "touch":
			return (
				( y1 >= t && y1 <= b ) || // Top edge touching
				( y2 >= t && y2 <= b ) || // Bottom edge touching
				( y1 < t && y2 > b ) // Surrounded vertically
			) && (
				( x1 >= l && x1 <= r ) || // Left edge touching
				( x2 >= l && x2 <= r ) || // Right edge touching
				( x1 < l && x2 > r ) // Surrounded horizontally
			);
		default:
			return false;
		}
	};
} )();

/*
	This manager tracks offsets of draggables and droppables
*/
$.ui.ddmanager = {
	current: null,
	droppables: { "default": [] },
	prepareOffsets: function( t, event ) {

		var i, j,
			m = $.ui.ddmanager.droppables[ t.options.scope ] || [],
			type = event ? event.type : null, // workaround for #2317
			list = ( t.currentItem || t.element ).find( ":data(ui-droppable)" ).addBack();

		droppablesLoop: for ( i = 0; i < m.length; i++ ) {

			// No disabled and non-accepted
			if ( m[ i ].options.disabled || ( t && !m[ i ].accept.call( m[ i ].element[ 0 ],
					( t.currentItem || t.element ) ) ) ) {
				continue;
			}

			// Filter out elements in the current dragged item
			for ( j = 0; j < list.length; j++ ) {
				if ( list[ j ] === m[ i ].element[ 0 ] ) {
					m[ i ].proportions().height = 0;
					continue droppablesLoop;
				}
			}

			m[ i ].visible = m[ i ].element.css( "display" ) !== "none";
			if ( !m[ i ].visible ) {
				continue;
			}

			// Activate the droppable if used directly from draggables
			if ( type === "mousedown" ) {
				m[ i ]._activate.call( m[ i ], event );
			}

			m[ i ].offset = m[ i ].element.offset();
			m[ i ].proportions( {
				width: m[ i ].element[ 0 ].offsetWidth,
				height: m[ i ].element[ 0 ].offsetHeight
			} );

		}

	},
	drop: function( draggable, event ) {

		var dropped = false;

		// Create a copy of the droppables in case the list changes during the drop (#9116)
		$.each( ( $.ui.ddmanager.droppables[ draggable.options.scope ] || [] ).slice(), function() {

			if ( !this.options ) {
				return;
			}
			if ( !this.options.disabled && this.visible &&
					intersect( draggable, this, this.options.tolerance, event ) ) {
				dropped = this._drop.call( this, event ) || dropped;
			}

			if ( !this.options.disabled && this.visible && this.accept.call( this.element[ 0 ],
					( draggable.currentItem || draggable.element ) ) ) {
				this.isout = true;
				this.isover = false;
				this._deactivate.call( this, event );
			}

		} );
		return dropped;

	},
	dragStart: function( draggable, event ) {

		// Listen for scrolling so that if the dragging causes scrolling the position of the
		// droppables can be recalculated (see #5003)
		draggable.element.parentsUntil( "body" ).on( "scroll.droppable", function() {
			if ( !draggable.options.refreshPositions ) {
				$.ui.ddmanager.prepareOffsets( draggable, event );
			}
		} );
	},
	drag: function( draggable, event ) {

		// If you have a highly dynamic page, you might try this option. It renders positions
		// every time you move the mouse.
		if ( draggable.options.refreshPositions ) {
			$.ui.ddmanager.prepareOffsets( draggable, event );
		}

		// Run through all droppables and check their positions based on specific tolerance options
		$.each( $.ui.ddmanager.droppables[ draggable.options.scope ] || [], function() {

			if ( this.options.disabled || this.greedyChild || !this.visible ) {
				return;
			}

			var parentInstance, scope, parent,
				intersects = intersect( draggable, this, this.options.tolerance, event ),
				c = !intersects && this.isover ?
					"isout" :
					( intersects && !this.isover ? "isover" : null );
			if ( !c ) {
				return;
			}

			if ( this.options.greedy ) {

				// find droppable parents with same scope
				scope = this.options.scope;
				parent = this.element.parents( ":data(ui-droppable)" ).filter( function() {
					return $( this ).droppable( "instance" ).options.scope === scope;
				} );

				if ( parent.length ) {
					parentInstance = $( parent[ 0 ] ).droppable( "instance" );
					parentInstance.greedyChild = ( c === "isover" );
				}
			}

			// We just moved into a greedy child
			if ( parentInstance && c === "isover" ) {
				parentInstance.isover = false;
				parentInstance.isout = true;
				parentInstance._out.call( parentInstance, event );
			}

			this[ c ] = true;
			this[ c === "isout" ? "isover" : "isout" ] = false;
			this[ c === "isover" ? "_over" : "_out" ].call( this, event );

			// We just moved out of a greedy child
			if ( parentInstance && c === "isout" ) {
				parentInstance.isout = false;
				parentInstance.isover = true;
				parentInstance._over.call( parentInstance, event );
			}
		} );

	},
	dragStop: function( draggable, event ) {
		draggable.element.parentsUntil( "body" ).off( "scroll.droppable" );

		// Call prepareOffsets one final time since IE does not fire return scroll events when
		// overflow was caused by drag (see #5003)
		if ( !draggable.options.refreshPositions ) {
			$.ui.ddmanager.prepareOffsets( draggable, event );
		}
	}
};

// DEPRECATED
// TODO: switch return back to widget declaration at top of file when this is removed
if ( $.uiBackCompat !== false ) {

	// Backcompat for activeClass and hoverClass options
	$.widget( "ui.droppable", $.ui.droppable, {
		options: {
			hoverClass: false,
			activeClass: false
		},
		_addActiveClass: function() {
			this._super();
			if ( this.options.activeClass ) {
				this.element.addClass( this.options.activeClass );
			}
		},
		_removeActiveClass: function() {
			this._super();
			if ( this.options.activeClass ) {
				this.element.removeClass( this.options.activeClass );
			}
		},
		_addHoverClass: function() {
			this._super();
			if ( this.options.hoverClass ) {
				this.element.addClass( this.options.hoverClass );
			}
		},
		_removeHoverClass: function() {
			this._super();
			if ( this.options.hoverClass ) {
				this.element.removeClass( this.options.hoverClass );
			}
		}
	} );
}

var widgetsDroppable = $.ui.droppable;


/*!
 * jQuery UI Resizable 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Resizable
//>>group: Interactions
//>>description: Enables resize functionality for any element.
//>>docs: http://api.jqueryui.com/resizable/
//>>demos: http://jqueryui.com/resizable/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/resizable.css
//>>css.theme: ../../themes/base/theme.css



$.widget( "ui.resizable", $.ui.mouse, {
	version: "1.12.1",
	widgetEventPrefix: "resize",
	options: {
		alsoResize: false,
		animate: false,
		animateDuration: "slow",
		animateEasing: "swing",
		aspectRatio: false,
		autoHide: false,
		classes: {
			"ui-resizable-se": "ui-icon ui-icon-gripsmall-diagonal-se"
		},
		containment: false,
		ghost: false,
		grid: false,
		handles: "e,s,se",
		helper: false,
		maxHeight: null,
		maxWidth: null,
		minHeight: 10,
		minWidth: 10,

		// See #7960
		zIndex: 90,

		// Callbacks
		resize: null,
		start: null,
		stop: null
	},

	_num: function( value ) {
		return parseFloat( value ) || 0;
	},

	_isNumber: function( value ) {
		return !isNaN( parseFloat( value ) );
	},

	_hasScroll: function( el, a ) {

		if ( $( el ).css( "overflow" ) === "hidden" ) {
			return false;
		}

		var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
			has = false;

		if ( el[ scroll ] > 0 ) {
			return true;
		}

		// TODO: determine which cases actually cause this to happen
		// if the element doesn't have the scroll set, see if it's possible to
		// set the scroll
		el[ scroll ] = 1;
		has = ( el[ scroll ] > 0 );
		el[ scroll ] = 0;
		return has;
	},

	_create: function() {

		var margins,
			o = this.options,
			that = this;
		this._addClass( "ui-resizable" );

		$.extend( this, {
			_aspectRatio: !!( o.aspectRatio ),
			aspectRatio: o.aspectRatio,
			originalElement: this.element,
			_proportionallyResizeElements: [],
			_helper: o.helper || o.ghost || o.animate ? o.helper || "ui-resizable-helper" : null
		} );

		// Wrap the element if it cannot hold child nodes
		if ( this.element[ 0 ].nodeName.match( /^(canvas|textarea|input|select|button|img)$/i ) ) {

			this.element.wrap(
				$( "<div class='ui-wrapper' style='overflow: hidden;'></div>" ).css( {
					position: this.element.css( "position" ),
					width: this.element.outerWidth(),
					height: this.element.outerHeight(),
					top: this.element.css( "top" ),
					left: this.element.css( "left" )
				} )
			);

			this.element = this.element.parent().data(
				"ui-resizable", this.element.resizable( "instance" )
			);

			this.elementIsWrapper = true;

			margins = {
				marginTop: this.originalElement.css( "marginTop" ),
				marginRight: this.originalElement.css( "marginRight" ),
				marginBottom: this.originalElement.css( "marginBottom" ),
				marginLeft: this.originalElement.css( "marginLeft" )
			};

			this.element.css( margins );
			this.originalElement.css( "margin", 0 );

			// support: Safari
			// Prevent Safari textarea resize
			this.originalResizeStyle = this.originalElement.css( "resize" );
			this.originalElement.css( "resize", "none" );

			this._proportionallyResizeElements.push( this.originalElement.css( {
				position: "static",
				zoom: 1,
				display: "block"
			} ) );

			// Support: IE9
			// avoid IE jump (hard set the margin)
			this.originalElement.css( margins );

			this._proportionallyResize();
		}

		this._setupHandles();

		if ( o.autoHide ) {
			$( this.element )
				.on( "mouseenter", function() {
					if ( o.disabled ) {
						return;
					}
					that._removeClass( "ui-resizable-autohide" );
					that._handles.show();
				} )
				.on( "mouseleave", function() {
					if ( o.disabled ) {
						return;
					}
					if ( !that.resizing ) {
						that._addClass( "ui-resizable-autohide" );
						that._handles.hide();
					}
				} );
		}

		this._mouseInit();
	},

	_destroy: function() {

		this._mouseDestroy();

		var wrapper,
			_destroy = function( exp ) {
				$( exp )
					.removeData( "resizable" )
					.removeData( "ui-resizable" )
					.off( ".resizable" )
					.find( ".ui-resizable-handle" )
						.remove();
			};

		// TODO: Unwrap at same DOM position
		if ( this.elementIsWrapper ) {
			_destroy( this.element );
			wrapper = this.element;
			this.originalElement.css( {
				position: wrapper.css( "position" ),
				width: wrapper.outerWidth(),
				height: wrapper.outerHeight(),
				top: wrapper.css( "top" ),
				left: wrapper.css( "left" )
			} ).insertAfter( wrapper );
			wrapper.remove();
		}

		this.originalElement.css( "resize", this.originalResizeStyle );
		_destroy( this.originalElement );

		return this;
	},

	_setOption: function( key, value ) {
		this._super( key, value );

		switch ( key ) {
		case "handles":
			this._removeHandles();
			this._setupHandles();
			break;
		default:
			break;
		}
	},

	_setupHandles: function() {
		var o = this.options, handle, i, n, hname, axis, that = this;
		this.handles = o.handles ||
			( !$( ".ui-resizable-handle", this.element ).length ?
				"e,s,se" : {
					n: ".ui-resizable-n",
					e: ".ui-resizable-e",
					s: ".ui-resizable-s",
					w: ".ui-resizable-w",
					se: ".ui-resizable-se",
					sw: ".ui-resizable-sw",
					ne: ".ui-resizable-ne",
					nw: ".ui-resizable-nw"
				} );

		this._handles = $();
		if ( this.handles.constructor === String ) {

			if ( this.handles === "all" ) {
				this.handles = "n,e,s,w,se,sw,ne,nw";
			}

			n = this.handles.split( "," );
			this.handles = {};

			for ( i = 0; i < n.length; i++ ) {

				handle = $.trim( n[ i ] );
				hname = "ui-resizable-" + handle;
				axis = $( "<div>" );
				this._addClass( axis, "ui-resizable-handle " + hname );

				axis.css( { zIndex: o.zIndex } );

				this.handles[ handle ] = ".ui-resizable-" + handle;
				this.element.append( axis );
			}

		}

		this._renderAxis = function( target ) {

			var i, axis, padPos, padWrapper;

			target = target || this.element;

			for ( i in this.handles ) {

				if ( this.handles[ i ].constructor === String ) {
					this.handles[ i ] = this.element.children( this.handles[ i ] ).first().show();
				} else if ( this.handles[ i ].jquery || this.handles[ i ].nodeType ) {
					this.handles[ i ] = $( this.handles[ i ] );
					this._on( this.handles[ i ], { "mousedown": that._mouseDown } );
				}

				if ( this.elementIsWrapper &&
						this.originalElement[ 0 ]
							.nodeName
							.match( /^(textarea|input|select|button)$/i ) ) {
					axis = $( this.handles[ i ], this.element );

					padWrapper = /sw|ne|nw|se|n|s/.test( i ) ?
						axis.outerHeight() :
						axis.outerWidth();

					padPos = [ "padding",
						/ne|nw|n/.test( i ) ? "Top" :
						/se|sw|s/.test( i ) ? "Bottom" :
						/^e$/.test( i ) ? "Right" : "Left" ].join( "" );

					target.css( padPos, padWrapper );

					this._proportionallyResize();
				}

				this._handles = this._handles.add( this.handles[ i ] );
			}
		};

		// TODO: make renderAxis a prototype function
		this._renderAxis( this.element );

		this._handles = this._handles.add( this.element.find( ".ui-resizable-handle" ) );
		this._handles.disableSelection();

		this._handles.on( "mouseover", function() {
			if ( !that.resizing ) {
				if ( this.className ) {
					axis = this.className.match( /ui-resizable-(se|sw|ne|nw|n|e|s|w)/i );
				}
				that.axis = axis && axis[ 1 ] ? axis[ 1 ] : "se";
			}
		} );

		if ( o.autoHide ) {
			this._handles.hide();
			this._addClass( "ui-resizable-autohide" );
		}
	},

	_removeHandles: function() {
		this._handles.remove();
	},

	_mouseCapture: function( event ) {
		var i, handle,
			capture = false;

		for ( i in this.handles ) {
			handle = $( this.handles[ i ] )[ 0 ];
			if ( handle === event.target || $.contains( handle, event.target ) ) {
				capture = true;
			}
		}

		return !this.options.disabled && capture;
	},

	_mouseStart: function( event ) {

		var curleft, curtop, cursor,
			o = this.options,
			el = this.element;

		this.resizing = true;

		this._renderProxy();

		curleft = this._num( this.helper.css( "left" ) );
		curtop = this._num( this.helper.css( "top" ) );

		if ( o.containment ) {
			curleft += $( o.containment ).scrollLeft() || 0;
			curtop += $( o.containment ).scrollTop() || 0;
		}

		this.offset = this.helper.offset();
		this.position = { left: curleft, top: curtop };

		this.size = this._helper ? {
				width: this.helper.width(),
				height: this.helper.height()
			} : {
				width: el.width(),
				height: el.height()
			};

		this.originalSize = this._helper ? {
				width: el.outerWidth(),
				height: el.outerHeight()
			} : {
				width: el.width(),
				height: el.height()
			};

		this.sizeDiff = {
			width: el.outerWidth() - el.width(),
			height: el.outerHeight() - el.height()
		};

		this.originalPosition = { left: curleft, top: curtop };
		this.originalMousePosition = { left: event.pageX, top: event.pageY };

		this.aspectRatio = ( typeof o.aspectRatio === "number" ) ?
			o.aspectRatio :
			( ( this.originalSize.width / this.originalSize.height ) || 1 );

		cursor = $( ".ui-resizable-" + this.axis ).css( "cursor" );
		$( "body" ).css( "cursor", cursor === "auto" ? this.axis + "-resize" : cursor );

		this._addClass( "ui-resizable-resizing" );
		this._propagate( "start", event );
		return true;
	},

	_mouseDrag: function( event ) {

		var data, props,
			smp = this.originalMousePosition,
			a = this.axis,
			dx = ( event.pageX - smp.left ) || 0,
			dy = ( event.pageY - smp.top ) || 0,
			trigger = this._change[ a ];

		this._updatePrevProperties();

		if ( !trigger ) {
			return false;
		}

		data = trigger.apply( this, [ event, dx, dy ] );

		this._updateVirtualBoundaries( event.shiftKey );
		if ( this._aspectRatio || event.shiftKey ) {
			data = this._updateRatio( data, event );
		}

		data = this._respectSize( data, event );

		this._updateCache( data );

		this._propagate( "resize", event );

		props = this._applyChanges();

		if ( !this._helper && this._proportionallyResizeElements.length ) {
			this._proportionallyResize();
		}

		if ( !$.isEmptyObject( props ) ) {
			this._updatePrevProperties();
			this._trigger( "resize", event, this.ui() );
			this._applyChanges();
		}

		return false;
	},

	_mouseStop: function( event ) {

		this.resizing = false;
		var pr, ista, soffseth, soffsetw, s, left, top,
			o = this.options, that = this;

		if ( this._helper ) {

			pr = this._proportionallyResizeElements;
			ista = pr.length && ( /textarea/i ).test( pr[ 0 ].nodeName );
			soffseth = ista && this._hasScroll( pr[ 0 ], "left" ) ? 0 : that.sizeDiff.height;
			soffsetw = ista ? 0 : that.sizeDiff.width;

			s = {
				width: ( that.helper.width()  - soffsetw ),
				height: ( that.helper.height() - soffseth )
			};
			left = ( parseFloat( that.element.css( "left" ) ) +
				( that.position.left - that.originalPosition.left ) ) || null;
			top = ( parseFloat( that.element.css( "top" ) ) +
				( that.position.top - that.originalPosition.top ) ) || null;

			if ( !o.animate ) {
				this.element.css( $.extend( s, { top: top, left: left } ) );
			}

			that.helper.height( that.size.height );
			that.helper.width( that.size.width );

			if ( this._helper && !o.animate ) {
				this._proportionallyResize();
			}
		}

		$( "body" ).css( "cursor", "auto" );

		this._removeClass( "ui-resizable-resizing" );

		this._propagate( "stop", event );

		if ( this._helper ) {
			this.helper.remove();
		}

		return false;

	},

	_updatePrevProperties: function() {
		this.prevPosition = {
			top: this.position.top,
			left: this.position.left
		};
		this.prevSize = {
			width: this.size.width,
			height: this.size.height
		};
	},

	_applyChanges: function() {
		var props = {};

		if ( this.position.top !== this.prevPosition.top ) {
			props.top = this.position.top + "px";
		}
		if ( this.position.left !== this.prevPosition.left ) {
			props.left = this.position.left + "px";
		}
		if ( this.size.width !== this.prevSize.width ) {
			props.width = this.size.width + "px";
		}
		if ( this.size.height !== this.prevSize.height ) {
			props.height = this.size.height + "px";
		}

		this.helper.css( props );

		return props;
	},

	_updateVirtualBoundaries: function( forceAspectRatio ) {
		var pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b,
			o = this.options;

		b = {
			minWidth: this._isNumber( o.minWidth ) ? o.minWidth : 0,
			maxWidth: this._isNumber( o.maxWidth ) ? o.maxWidth : Infinity,
			minHeight: this._isNumber( o.minHeight ) ? o.minHeight : 0,
			maxHeight: this._isNumber( o.maxHeight ) ? o.maxHeight : Infinity
		};

		if ( this._aspectRatio || forceAspectRatio ) {
			pMinWidth = b.minHeight * this.aspectRatio;
			pMinHeight = b.minWidth / this.aspectRatio;
			pMaxWidth = b.maxHeight * this.aspectRatio;
			pMaxHeight = b.maxWidth / this.aspectRatio;

			if ( pMinWidth > b.minWidth ) {
				b.minWidth = pMinWidth;
			}
			if ( pMinHeight > b.minHeight ) {
				b.minHeight = pMinHeight;
			}
			if ( pMaxWidth < b.maxWidth ) {
				b.maxWidth = pMaxWidth;
			}
			if ( pMaxHeight < b.maxHeight ) {
				b.maxHeight = pMaxHeight;
			}
		}
		this._vBoundaries = b;
	},

	_updateCache: function( data ) {
		this.offset = this.helper.offset();
		if ( this._isNumber( data.left ) ) {
			this.position.left = data.left;
		}
		if ( this._isNumber( data.top ) ) {
			this.position.top = data.top;
		}
		if ( this._isNumber( data.height ) ) {
			this.size.height = data.height;
		}
		if ( this._isNumber( data.width ) ) {
			this.size.width = data.width;
		}
	},

	_updateRatio: function( data ) {

		var cpos = this.position,
			csize = this.size,
			a = this.axis;

		if ( this._isNumber( data.height ) ) {
			data.width = ( data.height * this.aspectRatio );
		} else if ( this._isNumber( data.width ) ) {
			data.height = ( data.width / this.aspectRatio );
		}

		if ( a === "sw" ) {
			data.left = cpos.left + ( csize.width - data.width );
			data.top = null;
		}
		if ( a === "nw" ) {
			data.top = cpos.top + ( csize.height - data.height );
			data.left = cpos.left + ( csize.width - data.width );
		}

		return data;
	},

	_respectSize: function( data ) {

		var o = this._vBoundaries,
			a = this.axis,
			ismaxw = this._isNumber( data.width ) && o.maxWidth && ( o.maxWidth < data.width ),
			ismaxh = this._isNumber( data.height ) && o.maxHeight && ( o.maxHeight < data.height ),
			isminw = this._isNumber( data.width ) && o.minWidth && ( o.minWidth > data.width ),
			isminh = this._isNumber( data.height ) && o.minHeight && ( o.minHeight > data.height ),
			dw = this.originalPosition.left + this.originalSize.width,
			dh = this.originalPosition.top + this.originalSize.height,
			cw = /sw|nw|w/.test( a ), ch = /nw|ne|n/.test( a );
		if ( isminw ) {
			data.width = o.minWidth;
		}
		if ( isminh ) {
			data.height = o.minHeight;
		}
		if ( ismaxw ) {
			data.width = o.maxWidth;
		}
		if ( ismaxh ) {
			data.height = o.maxHeight;
		}

		if ( isminw && cw ) {
			data.left = dw - o.minWidth;
		}
		if ( ismaxw && cw ) {
			data.left = dw - o.maxWidth;
		}
		if ( isminh && ch ) {
			data.top = dh - o.minHeight;
		}
		if ( ismaxh && ch ) {
			data.top = dh - o.maxHeight;
		}

		// Fixing jump error on top/left - bug #2330
		if ( !data.width && !data.height && !data.left && data.top ) {
			data.top = null;
		} else if ( !data.width && !data.height && !data.top && data.left ) {
			data.left = null;
		}

		return data;
	},

	_getPaddingPlusBorderDimensions: function( element ) {
		var i = 0,
			widths = [],
			borders = [
				element.css( "borderTopWidth" ),
				element.css( "borderRightWidth" ),
				element.css( "borderBottomWidth" ),
				element.css( "borderLeftWidth" )
			],
			paddings = [
				element.css( "paddingTop" ),
				element.css( "paddingRight" ),
				element.css( "paddingBottom" ),
				element.css( "paddingLeft" )
			];

		for ( ; i < 4; i++ ) {
			widths[ i ] = ( parseFloat( borders[ i ] ) || 0 );
			widths[ i ] += ( parseFloat( paddings[ i ] ) || 0 );
		}

		return {
			height: widths[ 0 ] + widths[ 2 ],
			width: widths[ 1 ] + widths[ 3 ]
		};
	},

	_proportionallyResize: function() {

		if ( !this._proportionallyResizeElements.length ) {
			return;
		}

		var prel,
			i = 0,
			element = this.helper || this.element;

		for ( ; i < this._proportionallyResizeElements.length; i++ ) {

			prel = this._proportionallyResizeElements[ i ];

			// TODO: Seems like a bug to cache this.outerDimensions
			// considering that we are in a loop.
			if ( !this.outerDimensions ) {
				this.outerDimensions = this._getPaddingPlusBorderDimensions( prel );
			}

			prel.css( {
				height: ( element.height() - this.outerDimensions.height ) || 0,
				width: ( element.width() - this.outerDimensions.width ) || 0
			} );

		}

	},

	_renderProxy: function() {

		var el = this.element, o = this.options;
		this.elementOffset = el.offset();

		if ( this._helper ) {

			this.helper = this.helper || $( "<div style='overflow:hidden;'></div>" );

			this._addClass( this.helper, this._helper );
			this.helper.css( {
				width: this.element.outerWidth(),
				height: this.element.outerHeight(),
				position: "absolute",
				left: this.elementOffset.left + "px",
				top: this.elementOffset.top + "px",
				zIndex: ++o.zIndex //TODO: Don't modify option
			} );

			this.helper
				.appendTo( "body" )
				.disableSelection();

		} else {
			this.helper = this.element;
		}

	},

	_change: {
		e: function( event, dx ) {
			return { width: this.originalSize.width + dx };
		},
		w: function( event, dx ) {
			var cs = this.originalSize, sp = this.originalPosition;
			return { left: sp.left + dx, width: cs.width - dx };
		},
		n: function( event, dx, dy ) {
			var cs = this.originalSize, sp = this.originalPosition;
			return { top: sp.top + dy, height: cs.height - dy };
		},
		s: function( event, dx, dy ) {
			return { height: this.originalSize.height + dy };
		},
		se: function( event, dx, dy ) {
			return $.extend( this._change.s.apply( this, arguments ),
				this._change.e.apply( this, [ event, dx, dy ] ) );
		},
		sw: function( event, dx, dy ) {
			return $.extend( this._change.s.apply( this, arguments ),
				this._change.w.apply( this, [ event, dx, dy ] ) );
		},
		ne: function( event, dx, dy ) {
			return $.extend( this._change.n.apply( this, arguments ),
				this._change.e.apply( this, [ event, dx, dy ] ) );
		},
		nw: function( event, dx, dy ) {
			return $.extend( this._change.n.apply( this, arguments ),
				this._change.w.apply( this, [ event, dx, dy ] ) );
		}
	},

	_propagate: function( n, event ) {
		$.ui.plugin.call( this, n, [ event, this.ui() ] );
		( n !== "resize" && this._trigger( n, event, this.ui() ) );
	},

	plugins: {},

	ui: function() {
		return {
			originalElement: this.originalElement,
			element: this.element,
			helper: this.helper,
			position: this.position,
			size: this.size,
			originalSize: this.originalSize,
			originalPosition: this.originalPosition
		};
	}

} );

/*
 * Resizable Extensions
 */

$.ui.plugin.add( "resizable", "animate", {

	stop: function( event ) {
		var that = $( this ).resizable( "instance" ),
			o = that.options,
			pr = that._proportionallyResizeElements,
			ista = pr.length && ( /textarea/i ).test( pr[ 0 ].nodeName ),
			soffseth = ista && that._hasScroll( pr[ 0 ], "left" ) ? 0 : that.sizeDiff.height,
			soffsetw = ista ? 0 : that.sizeDiff.width,
			style = {
				width: ( that.size.width - soffsetw ),
				height: ( that.size.height - soffseth )
			},
			left = ( parseFloat( that.element.css( "left" ) ) +
				( that.position.left - that.originalPosition.left ) ) || null,
			top = ( parseFloat( that.element.css( "top" ) ) +
				( that.position.top - that.originalPosition.top ) ) || null;

		that.element.animate(
			$.extend( style, top && left ? { top: top, left: left } : {} ), {
				duration: o.animateDuration,
				easing: o.animateEasing,
				step: function() {

					var data = {
						width: parseFloat( that.element.css( "width" ) ),
						height: parseFloat( that.element.css( "height" ) ),
						top: parseFloat( that.element.css( "top" ) ),
						left: parseFloat( that.element.css( "left" ) )
					};

					if ( pr && pr.length ) {
						$( pr[ 0 ] ).css( { width: data.width, height: data.height } );
					}

					// Propagating resize, and updating values for each animation step
					that._updateCache( data );
					that._propagate( "resize", event );

				}
			}
		);
	}

} );

$.ui.plugin.add( "resizable", "containment", {

	start: function() {
		var element, p, co, ch, cw, width, height,
			that = $( this ).resizable( "instance" ),
			o = that.options,
			el = that.element,
			oc = o.containment,
			ce = ( oc instanceof $ ) ?
				oc.get( 0 ) :
				( /parent/.test( oc ) ) ? el.parent().get( 0 ) : oc;

		if ( !ce ) {
			return;
		}

		that.containerElement = $( ce );

		if ( /document/.test( oc ) || oc === document ) {
			that.containerOffset = {
				left: 0,
				top: 0
			};
			that.containerPosition = {
				left: 0,
				top: 0
			};

			that.parentData = {
				element: $( document ),
				left: 0,
				top: 0,
				width: $( document ).width(),
				height: $( document ).height() || document.body.parentNode.scrollHeight
			};
		} else {
			element = $( ce );
			p = [];
			$( [ "Top", "Right", "Left", "Bottom" ] ).each( function( i, name ) {
				p[ i ] = that._num( element.css( "padding" + name ) );
			} );

			that.containerOffset = element.offset();
			that.containerPosition = element.position();
			that.containerSize = {
				height: ( element.innerHeight() - p[ 3 ] ),
				width: ( element.innerWidth() - p[ 1 ] )
			};

			co = that.containerOffset;
			ch = that.containerSize.height;
			cw = that.containerSize.width;
			width = ( that._hasScroll ( ce, "left" ) ? ce.scrollWidth : cw );
			height = ( that._hasScroll ( ce ) ? ce.scrollHeight : ch ) ;

			that.parentData = {
				element: ce,
				left: co.left,
				top: co.top,
				width: width,
				height: height
			};
		}
	},

	resize: function( event ) {
		var woset, hoset, isParent, isOffsetRelative,
			that = $( this ).resizable( "instance" ),
			o = that.options,
			co = that.containerOffset,
			cp = that.position,
			pRatio = that._aspectRatio || event.shiftKey,
			cop = {
				top: 0,
				left: 0
			},
			ce = that.containerElement,
			continueResize = true;

		if ( ce[ 0 ] !== document && ( /static/ ).test( ce.css( "position" ) ) ) {
			cop = co;
		}

		if ( cp.left < ( that._helper ? co.left : 0 ) ) {
			that.size.width = that.size.width +
				( that._helper ?
					( that.position.left - co.left ) :
					( that.position.left - cop.left ) );

			if ( pRatio ) {
				that.size.height = that.size.width / that.aspectRatio;
				continueResize = false;
			}
			that.position.left = o.helper ? co.left : 0;
		}

		if ( cp.top < ( that._helper ? co.top : 0 ) ) {
			that.size.height = that.size.height +
				( that._helper ?
					( that.position.top - co.top ) :
					that.position.top );

			if ( pRatio ) {
				that.size.width = that.size.height * that.aspectRatio;
				continueResize = false;
			}
			that.position.top = that._helper ? co.top : 0;
		}

		isParent = that.containerElement.get( 0 ) === that.element.parent().get( 0 );
		isOffsetRelative = /relative|absolute/.test( that.containerElement.css( "position" ) );

		if ( isParent && isOffsetRelative ) {
			that.offset.left = that.parentData.left + that.position.left;
			that.offset.top = that.parentData.top + that.position.top;
		} else {
			that.offset.left = that.element.offset().left;
			that.offset.top = that.element.offset().top;
		}

		woset = Math.abs( that.sizeDiff.width +
			( that._helper ?
				that.offset.left - cop.left :
				( that.offset.left - co.left ) ) );

		hoset = Math.abs( that.sizeDiff.height +
			( that._helper ?
				that.offset.top - cop.top :
				( that.offset.top - co.top ) ) );

		if ( woset + that.size.width >= that.parentData.width ) {
			that.size.width = that.parentData.width - woset;
			if ( pRatio ) {
				that.size.height = that.size.width / that.aspectRatio;
				continueResize = false;
			}
		}

		if ( hoset + that.size.height >= that.parentData.height ) {
			that.size.height = that.parentData.height - hoset;
			if ( pRatio ) {
				that.size.width = that.size.height * that.aspectRatio;
				continueResize = false;
			}
		}

		if ( !continueResize ) {
			that.position.left = that.prevPosition.left;
			that.position.top = that.prevPosition.top;
			that.size.width = that.prevSize.width;
			that.size.height = that.prevSize.height;
		}
	},

	stop: function() {
		var that = $( this ).resizable( "instance" ),
			o = that.options,
			co = that.containerOffset,
			cop = that.containerPosition,
			ce = that.containerElement,
			helper = $( that.helper ),
			ho = helper.offset(),
			w = helper.outerWidth() - that.sizeDiff.width,
			h = helper.outerHeight() - that.sizeDiff.height;

		if ( that._helper && !o.animate && ( /relative/ ).test( ce.css( "position" ) ) ) {
			$( this ).css( {
				left: ho.left - cop.left - co.left,
				width: w,
				height: h
			} );
		}

		if ( that._helper && !o.animate && ( /static/ ).test( ce.css( "position" ) ) ) {
			$( this ).css( {
				left: ho.left - cop.left - co.left,
				width: w,
				height: h
			} );
		}
	}
} );

$.ui.plugin.add( "resizable", "alsoResize", {

	start: function() {
		var that = $( this ).resizable( "instance" ),
			o = that.options;

		$( o.alsoResize ).each( function() {
			var el = $( this );
			el.data( "ui-resizable-alsoresize", {
				width: parseFloat( el.width() ), height: parseFloat( el.height() ),
				left: parseFloat( el.css( "left" ) ), top: parseFloat( el.css( "top" ) )
			} );
		} );
	},

	resize: function( event, ui ) {
		var that = $( this ).resizable( "instance" ),
			o = that.options,
			os = that.originalSize,
			op = that.originalPosition,
			delta = {
				height: ( that.size.height - os.height ) || 0,
				width: ( that.size.width - os.width ) || 0,
				top: ( that.position.top - op.top ) || 0,
				left: ( that.position.left - op.left ) || 0
			};

			$( o.alsoResize ).each( function() {
				var el = $( this ), start = $( this ).data( "ui-resizable-alsoresize" ), style = {},
					css = el.parents( ui.originalElement[ 0 ] ).length ?
							[ "width", "height" ] :
							[ "width", "height", "top", "left" ];

				$.each( css, function( i, prop ) {
					var sum = ( start[ prop ] || 0 ) + ( delta[ prop ] || 0 );
					if ( sum && sum >= 0 ) {
						style[ prop ] = sum || null;
					}
				} );

				el.css( style );
			} );
	},

	stop: function() {
		$( this ).removeData( "ui-resizable-alsoresize" );
	}
} );

$.ui.plugin.add( "resizable", "ghost", {

	start: function() {

		var that = $( this ).resizable( "instance" ), cs = that.size;

		that.ghost = that.originalElement.clone();
		that.ghost.css( {
			opacity: 0.25,
			display: "block",
			position: "relative",
			height: cs.height,
			width: cs.width,
			margin: 0,
			left: 0,
			top: 0
		} );

		that._addClass( that.ghost, "ui-resizable-ghost" );

		// DEPRECATED
		// TODO: remove after 1.12
		if ( $.uiBackCompat !== false && typeof that.options.ghost === "string" ) {

			// Ghost option
			that.ghost.addClass( this.options.ghost );
		}

		that.ghost.appendTo( that.helper );

	},

	resize: function() {
		var that = $( this ).resizable( "instance" );
		if ( that.ghost ) {
			that.ghost.css( {
				position: "relative",
				height: that.size.height,
				width: that.size.width
			} );
		}
	},

	stop: function() {
		var that = $( this ).resizable( "instance" );
		if ( that.ghost && that.helper ) {
			that.helper.get( 0 ).removeChild( that.ghost.get( 0 ) );
		}
	}

} );

$.ui.plugin.add( "resizable", "grid", {

	resize: function() {
		var outerDimensions,
			that = $( this ).resizable( "instance" ),
			o = that.options,
			cs = that.size,
			os = that.originalSize,
			op = that.originalPosition,
			a = that.axis,
			grid = typeof o.grid === "number" ? [ o.grid, o.grid ] : o.grid,
			gridX = ( grid[ 0 ] || 1 ),
			gridY = ( grid[ 1 ] || 1 ),
			ox = Math.round( ( cs.width - os.width ) / gridX ) * gridX,
			oy = Math.round( ( cs.height - os.height ) / gridY ) * gridY,
			newWidth = os.width + ox,
			newHeight = os.height + oy,
			isMaxWidth = o.maxWidth && ( o.maxWidth < newWidth ),
			isMaxHeight = o.maxHeight && ( o.maxHeight < newHeight ),
			isMinWidth = o.minWidth && ( o.minWidth > newWidth ),
			isMinHeight = o.minHeight && ( o.minHeight > newHeight );

		o.grid = grid;

		if ( isMinWidth ) {
			newWidth += gridX;
		}
		if ( isMinHeight ) {
			newHeight += gridY;
		}
		if ( isMaxWidth ) {
			newWidth -= gridX;
		}
		if ( isMaxHeight ) {
			newHeight -= gridY;
		}

		if ( /^(se|s|e)$/.test( a ) ) {
			that.size.width = newWidth;
			that.size.height = newHeight;
		} else if ( /^(ne)$/.test( a ) ) {
			that.size.width = newWidth;
			that.size.height = newHeight;
			that.position.top = op.top - oy;
		} else if ( /^(sw)$/.test( a ) ) {
			that.size.width = newWidth;
			that.size.height = newHeight;
			that.position.left = op.left - ox;
		} else {
			if ( newHeight - gridY <= 0 || newWidth - gridX <= 0 ) {
				outerDimensions = that._getPaddingPlusBorderDimensions( this );
			}

			if ( newHeight - gridY > 0 ) {
				that.size.height = newHeight;
				that.position.top = op.top - oy;
			} else {
				newHeight = gridY - outerDimensions.height;
				that.size.height = newHeight;
				that.position.top = op.top + os.height - newHeight;
			}
			if ( newWidth - gridX > 0 ) {
				that.size.width = newWidth;
				that.position.left = op.left - ox;
			} else {
				newWidth = gridX - outerDimensions.width;
				that.size.width = newWidth;
				that.position.left = op.left + os.width - newWidth;
			}
		}
	}

} );

var widgetsResizable = $.ui.resizable;


/*!
 * jQuery UI Selectable 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Selectable
//>>group: Interactions
//>>description: Allows groups of elements to be selected with the mouse.
//>>docs: http://api.jqueryui.com/selectable/
//>>demos: http://jqueryui.com/selectable/
//>>css.structure: ../../themes/base/selectable.css



var widgetsSelectable = $.widget( "ui.selectable", $.ui.mouse, {
	version: "1.12.1",
	options: {
		appendTo: "body",
		autoRefresh: true,
		distance: 0,
		filter: "*",
		tolerance: "touch",

		// Callbacks
		selected: null,
		selecting: null,
		start: null,
		stop: null,
		unselected: null,
		unselecting: null
	},
	_create: function() {
		var that = this;

		this._addClass( "ui-selectable" );

		this.dragged = false;

		// Cache selectee children based on filter
		this.refresh = function() {
			that.elementPos = $( that.element[ 0 ] ).offset();
			that.selectees = $( that.options.filter, that.element[ 0 ] );
			that._addClass( that.selectees, "ui-selectee" );
			that.selectees.each( function() {
				var $this = $( this ),
					selecteeOffset = $this.offset(),
					pos = {
						left: selecteeOffset.left - that.elementPos.left,
						top: selecteeOffset.top - that.elementPos.top
					};
				$.data( this, "selectable-item", {
					element: this,
					$element: $this,
					left: pos.left,
					top: pos.top,
					right: pos.left + $this.outerWidth(),
					bottom: pos.top + $this.outerHeight(),
					startselected: false,
					selected: $this.hasClass( "ui-selected" ),
					selecting: $this.hasClass( "ui-selecting" ),
					unselecting: $this.hasClass( "ui-unselecting" )
				} );
			} );
		};
		this.refresh();

		this._mouseInit();

		this.helper = $( "<div>" );
		this._addClass( this.helper, "ui-selectable-helper" );
	},

	_destroy: function() {
		this.selectees.removeData( "selectable-item" );
		this._mouseDestroy();
	},

	_mouseStart: function( event ) {
		var that = this,
			options = this.options;

		this.opos = [ event.pageX, event.pageY ];
		this.elementPos = $( this.element[ 0 ] ).offset();

		if ( this.options.disabled ) {
			return;
		}

		this.selectees = $( options.filter, this.element[ 0 ] );

		this._trigger( "start", event );

		$( options.appendTo ).append( this.helper );

		// position helper (lasso)
		this.helper.css( {
			"left": event.pageX,
			"top": event.pageY,
			"width": 0,
			"height": 0
		} );

		if ( options.autoRefresh ) {
			this.refresh();
		}

		this.selectees.filter( ".ui-selected" ).each( function() {
			var selectee = $.data( this, "selectable-item" );
			selectee.startselected = true;
			if ( !event.metaKey && !event.ctrlKey ) {
				that._removeClass( selectee.$element, "ui-selected" );
				selectee.selected = false;
				that._addClass( selectee.$element, "ui-unselecting" );
				selectee.unselecting = true;

				// selectable UNSELECTING callback
				that._trigger( "unselecting", event, {
					unselecting: selectee.element
				} );
			}
		} );

		$( event.target ).parents().addBack().each( function() {
			var doSelect,
				selectee = $.data( this, "selectable-item" );
			if ( selectee ) {
				doSelect = ( !event.metaKey && !event.ctrlKey ) ||
					!selectee.$element.hasClass( "ui-selected" );
				that._removeClass( selectee.$element, doSelect ? "ui-unselecting" : "ui-selected" )
					._addClass( selectee.$element, doSelect ? "ui-selecting" : "ui-unselecting" );
				selectee.unselecting = !doSelect;
				selectee.selecting = doSelect;
				selectee.selected = doSelect;

				// selectable (UN)SELECTING callback
				if ( doSelect ) {
					that._trigger( "selecting", event, {
						selecting: selectee.element
					} );
				} else {
					that._trigger( "unselecting", event, {
						unselecting: selectee.element
					} );
				}
				return false;
			}
		} );

	},

	_mouseDrag: function( event ) {

		this.dragged = true;

		if ( this.options.disabled ) {
			return;
		}

		var tmp,
			that = this,
			options = this.options,
			x1 = this.opos[ 0 ],
			y1 = this.opos[ 1 ],
			x2 = event.pageX,
			y2 = event.pageY;

		if ( x1 > x2 ) { tmp = x2; x2 = x1; x1 = tmp; }
		if ( y1 > y2 ) { tmp = y2; y2 = y1; y1 = tmp; }
		this.helper.css( { left: x1, top: y1, width: x2 - x1, height: y2 - y1 } );

		this.selectees.each( function() {
			var selectee = $.data( this, "selectable-item" ),
				hit = false,
				offset = {};

			//prevent helper from being selected if appendTo: selectable
			if ( !selectee || selectee.element === that.element[ 0 ] ) {
				return;
			}

			offset.left   = selectee.left   + that.elementPos.left;
			offset.right  = selectee.right  + that.elementPos.left;
			offset.top    = selectee.top    + that.elementPos.top;
			offset.bottom = selectee.bottom + that.elementPos.top;

			if ( options.tolerance === "touch" ) {
				hit = ( !( offset.left > x2 || offset.right < x1 || offset.top > y2 ||
                    offset.bottom < y1 ) );
			} else if ( options.tolerance === "fit" ) {
				hit = ( offset.left > x1 && offset.right < x2 && offset.top > y1 &&
                    offset.bottom < y2 );
			}

			if ( hit ) {

				// SELECT
				if ( selectee.selected ) {
					that._removeClass( selectee.$element, "ui-selected" );
					selectee.selected = false;
				}
				if ( selectee.unselecting ) {
					that._removeClass( selectee.$element, "ui-unselecting" );
					selectee.unselecting = false;
				}
				if ( !selectee.selecting ) {
					that._addClass( selectee.$element, "ui-selecting" );
					selectee.selecting = true;

					// selectable SELECTING callback
					that._trigger( "selecting", event, {
						selecting: selectee.element
					} );
				}
			} else {

				// UNSELECT
				if ( selectee.selecting ) {
					if ( ( event.metaKey || event.ctrlKey ) && selectee.startselected ) {
						that._removeClass( selectee.$element, "ui-selecting" );
						selectee.selecting = false;
						that._addClass( selectee.$element, "ui-selected" );
						selectee.selected = true;
					} else {
						that._removeClass( selectee.$element, "ui-selecting" );
						selectee.selecting = false;
						if ( selectee.startselected ) {
							that._addClass( selectee.$element, "ui-unselecting" );
							selectee.unselecting = true;
						}

						// selectable UNSELECTING callback
						that._trigger( "unselecting", event, {
							unselecting: selectee.element
						} );
					}
				}
				if ( selectee.selected ) {
					if ( !event.metaKey && !event.ctrlKey && !selectee.startselected ) {
						that._removeClass( selectee.$element, "ui-selected" );
						selectee.selected = false;

						that._addClass( selectee.$element, "ui-unselecting" );
						selectee.unselecting = true;

						// selectable UNSELECTING callback
						that._trigger( "unselecting", event, {
							unselecting: selectee.element
						} );
					}
				}
			}
		} );

		return false;
	},

	_mouseStop: function( event ) {
		var that = this;

		this.dragged = false;

		$( ".ui-unselecting", this.element[ 0 ] ).each( function() {
			var selectee = $.data( this, "selectable-item" );
			that._removeClass( selectee.$element, "ui-unselecting" );
			selectee.unselecting = false;
			selectee.startselected = false;
			that._trigger( "unselected", event, {
				unselected: selectee.element
			} );
		} );
		$( ".ui-selecting", this.element[ 0 ] ).each( function() {
			var selectee = $.data( this, "selectable-item" );
			that._removeClass( selectee.$element, "ui-selecting" )
				._addClass( selectee.$element, "ui-selected" );
			selectee.selecting = false;
			selectee.selected = true;
			selectee.startselected = true;
			that._trigger( "selected", event, {
				selected: selectee.element
			} );
		} );
		this._trigger( "stop", event );

		this.helper.remove();

		return false;
	}

} );


/*!
 * jQuery UI Sortable 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Sortable
//>>group: Interactions
//>>description: Enables items in a list to be sorted using the mouse.
//>>docs: http://api.jqueryui.com/sortable/
//>>demos: http://jqueryui.com/sortable/
//>>css.structure: ../../themes/base/sortable.css



var widgetsSortable = $.widget( "ui.sortable", $.ui.mouse, {
	version: "1.12.1",
	widgetEventPrefix: "sort",
	ready: false,
	options: {
		appendTo: "parent",
		axis: false,
		connectWith: false,
		containment: false,
		cursor: "auto",
		cursorAt: false,
		dropOnEmpty: true,
		forcePlaceholderSize: false,
		forceHelperSize: false,
		grid: false,
		handle: false,
		helper: "original",
		items: "> *",
		opacity: false,
		placeholder: false,
		revert: false,
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		scope: "default",
		tolerance: "intersect",
		zIndex: 1000,

		// Callbacks
		activate: null,
		beforeStop: null,
		change: null,
		deactivate: null,
		out: null,
		over: null,
		receive: null,
		remove: null,
		sort: null,
		start: null,
		stop: null,
		update: null
	},

	_isOverAxis: function( x, reference, size ) {
		return ( x >= reference ) && ( x < ( reference + size ) );
	},

	_isFloating: function( item ) {
		return ( /left|right/ ).test( item.css( "float" ) ) ||
			( /inline|table-cell/ ).test( item.css( "display" ) );
	},

	_create: function() {
		this.containerCache = {};
		this._addClass( "ui-sortable" );

		//Get the items
		this.refresh();

		//Let's determine the parent's offset
		this.offset = this.element.offset();

		//Initialize mouse events for interaction
		this._mouseInit();

		this._setHandleClassName();

		//We're ready to go
		this.ready = true;

	},

	_setOption: function( key, value ) {
		this._super( key, value );

		if ( key === "handle" ) {
			this._setHandleClassName();
		}
	},

	_setHandleClassName: function() {
		var that = this;
		this._removeClass( this.element.find( ".ui-sortable-handle" ), "ui-sortable-handle" );
		$.each( this.items, function() {
			that._addClass(
				this.instance.options.handle ?
					this.item.find( this.instance.options.handle ) :
					this.item,
				"ui-sortable-handle"
			);
		} );
	},

	_destroy: function() {
		this._mouseDestroy();

		for ( var i = this.items.length - 1; i >= 0; i-- ) {
			this.items[ i ].item.removeData( this.widgetName + "-item" );
		}

		return this;
	},

	_mouseCapture: function( event, overrideHandle ) {
		var currentItem = null,
			validHandle = false,
			that = this;

		if ( this.reverting ) {
			return false;
		}

		if ( this.options.disabled || this.options.type === "static" ) {
			return false;
		}

		//We have to refresh the items data once first
		this._refreshItems( event );

		//Find out if the clicked node (or one of its parents) is a actual item in this.items
		$( event.target ).parents().each( function() {
			if ( $.data( this, that.widgetName + "-item" ) === that ) {
				currentItem = $( this );
				return false;
			}
		} );
		if ( $.data( event.target, that.widgetName + "-item" ) === that ) {
			currentItem = $( event.target );
		}

		if ( !currentItem ) {
			return false;
		}
		if ( this.options.handle && !overrideHandle ) {
			$( this.options.handle, currentItem ).find( "*" ).addBack().each( function() {
				if ( this === event.target ) {
					validHandle = true;
				}
			} );
			if ( !validHandle ) {
				return false;
			}
		}

		this.currentItem = currentItem;
		this._removeCurrentsFromItems();
		return true;

	},

	_mouseStart: function( event, overrideHandle, noActivation ) {

		var i, body,
			o = this.options;

		this.currentContainer = this;

		//We only need to call refreshPositions, because the refreshItems call has been moved to
		// mouseCapture
		this.refreshPositions();

		//Create and append the visible helper
		this.helper = this._createHelper( event );

		//Cache the helper size
		this._cacheHelperProportions();

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Get the next scrolling parent
		this.scrollParent = this.helper.scrollParent();

		//The element's absolute position on the page minus margins
		this.offset = this.currentItem.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		$.extend( this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),

			// This is a relative to absolute position minus the actual position calculation -
			// only used for relative positioned helper
			relative: this._getRelativeOffset()
		} );

		// Only after we got the offset, we can change the helper's position to absolute
		// TODO: Still need to figure out a way to make relative sorting possible
		this.helper.css( "position", "absolute" );
		this.cssPosition = this.helper.css( "position" );

		//Generate the original position
		this.originalPosition = this._generatePosition( event );
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if "cursorAt" is supplied
		( o.cursorAt && this._adjustOffsetFromHelper( o.cursorAt ) );

		//Cache the former DOM position
		this.domPosition = {
			prev: this.currentItem.prev()[ 0 ],
			parent: this.currentItem.parent()[ 0 ]
		};

		// If the helper is not the original, hide the original so it's not playing any role during
		// the drag, won't cause anything bad this way
		if ( this.helper[ 0 ] !== this.currentItem[ 0 ] ) {
			this.currentItem.hide();
		}

		//Create the placeholder
		this._createPlaceholder();

		//Set a containment if given in the options
		if ( o.containment ) {
			this._setContainment();
		}

		if ( o.cursor && o.cursor !== "auto" ) { // cursor option
			body = this.document.find( "body" );

			// Support: IE
			this.storedCursor = body.css( "cursor" );
			body.css( "cursor", o.cursor );

			this.storedStylesheet =
				$( "<style>*{ cursor: " + o.cursor + " !important; }</style>" ).appendTo( body );
		}

		if ( o.opacity ) { // opacity option
			if ( this.helper.css( "opacity" ) ) {
				this._storedOpacity = this.helper.css( "opacity" );
			}
			this.helper.css( "opacity", o.opacity );
		}

		if ( o.zIndex ) { // zIndex option
			if ( this.helper.css( "zIndex" ) ) {
				this._storedZIndex = this.helper.css( "zIndex" );
			}
			this.helper.css( "zIndex", o.zIndex );
		}

		//Prepare scrolling
		if ( this.scrollParent[ 0 ] !== this.document[ 0 ] &&
				this.scrollParent[ 0 ].tagName !== "HTML" ) {
			this.overflowOffset = this.scrollParent.offset();
		}

		//Call callbacks
		this._trigger( "start", event, this._uiHash() );

		//Recache the helper size
		if ( !this._preserveHelperProportions ) {
			this._cacheHelperProportions();
		}

		//Post "activate" events to possible containers
		if ( !noActivation ) {
			for ( i = this.containers.length - 1; i >= 0; i-- ) {
				this.containers[ i ]._trigger( "activate", event, this._uiHash( this ) );
			}
		}

		//Prepare possible droppables
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.current = this;
		}

		if ( $.ui.ddmanager && !o.dropBehaviour ) {
			$.ui.ddmanager.prepareOffsets( this, event );
		}

		this.dragging = true;

		this._addClass( this.helper, "ui-sortable-helper" );

		// Execute the drag once - this causes the helper not to be visiblebefore getting its
		// correct position
		this._mouseDrag( event );
		return true;

	},

	_mouseDrag: function( event ) {
		var i, item, itemElement, intersection,
			o = this.options,
			scrolled = false;

		//Compute the helpers position
		this.position = this._generatePosition( event );
		this.positionAbs = this._convertPositionTo( "absolute" );

		if ( !this.lastPositionAbs ) {
			this.lastPositionAbs = this.positionAbs;
		}

		//Do scrolling
		if ( this.options.scroll ) {
			if ( this.scrollParent[ 0 ] !== this.document[ 0 ] &&
					this.scrollParent[ 0 ].tagName !== "HTML" ) {

				if ( ( this.overflowOffset.top + this.scrollParent[ 0 ].offsetHeight ) -
						event.pageY < o.scrollSensitivity ) {
					this.scrollParent[ 0 ].scrollTop =
						scrolled = this.scrollParent[ 0 ].scrollTop + o.scrollSpeed;
				} else if ( event.pageY - this.overflowOffset.top < o.scrollSensitivity ) {
					this.scrollParent[ 0 ].scrollTop =
						scrolled = this.scrollParent[ 0 ].scrollTop - o.scrollSpeed;
				}

				if ( ( this.overflowOffset.left + this.scrollParent[ 0 ].offsetWidth ) -
						event.pageX < o.scrollSensitivity ) {
					this.scrollParent[ 0 ].scrollLeft = scrolled =
						this.scrollParent[ 0 ].scrollLeft + o.scrollSpeed;
				} else if ( event.pageX - this.overflowOffset.left < o.scrollSensitivity ) {
					this.scrollParent[ 0 ].scrollLeft = scrolled =
						this.scrollParent[ 0 ].scrollLeft - o.scrollSpeed;
				}

			} else {

				if ( event.pageY - this.document.scrollTop() < o.scrollSensitivity ) {
					scrolled = this.document.scrollTop( this.document.scrollTop() - o.scrollSpeed );
				} else if ( this.window.height() - ( event.pageY - this.document.scrollTop() ) <
						o.scrollSensitivity ) {
					scrolled = this.document.scrollTop( this.document.scrollTop() + o.scrollSpeed );
				}

				if ( event.pageX - this.document.scrollLeft() < o.scrollSensitivity ) {
					scrolled = this.document.scrollLeft(
						this.document.scrollLeft() - o.scrollSpeed
					);
				} else if ( this.window.width() - ( event.pageX - this.document.scrollLeft() ) <
						o.scrollSensitivity ) {
					scrolled = this.document.scrollLeft(
						this.document.scrollLeft() + o.scrollSpeed
					);
				}

			}

			if ( scrolled !== false && $.ui.ddmanager && !o.dropBehaviour ) {
				$.ui.ddmanager.prepareOffsets( this, event );
			}
		}

		//Regenerate the absolute position used for position checks
		this.positionAbs = this._convertPositionTo( "absolute" );

		//Set the helper position
		if ( !this.options.axis || this.options.axis !== "y" ) {
			this.helper[ 0 ].style.left = this.position.left + "px";
		}
		if ( !this.options.axis || this.options.axis !== "x" ) {
			this.helper[ 0 ].style.top = this.position.top + "px";
		}

		//Rearrange
		for ( i = this.items.length - 1; i >= 0; i-- ) {

			//Cache variables and intersection, continue if no intersection
			item = this.items[ i ];
			itemElement = item.item[ 0 ];
			intersection = this._intersectsWithPointer( item );
			if ( !intersection ) {
				continue;
			}

			// Only put the placeholder inside the current Container, skip all
			// items from other containers. This works because when moving
			// an item from one container to another the
			// currentContainer is switched before the placeholder is moved.
			//
			// Without this, moving items in "sub-sortables" can cause
			// the placeholder to jitter between the outer and inner container.
			if ( item.instance !== this.currentContainer ) {
				continue;
			}

			// Cannot intersect with itself
			// no useless actions that have been done before
			// no action if the item moved is the parent of the item checked
			if ( itemElement !== this.currentItem[ 0 ] &&
				this.placeholder[ intersection === 1 ? "next" : "prev" ]()[ 0 ] !== itemElement &&
				!$.contains( this.placeholder[ 0 ], itemElement ) &&
				( this.options.type === "semi-dynamic" ?
					!$.contains( this.element[ 0 ], itemElement ) :
					true
				)
			) {

				this.direction = intersection === 1 ? "down" : "up";

				if ( this.options.tolerance === "pointer" || this._intersectsWithSides( item ) ) {
					this._rearrange( event, item );
				} else {
					break;
				}

				this._trigger( "change", event, this._uiHash() );
				break;
			}
		}

		//Post events to containers
		this._contactContainers( event );

		//Interconnect with droppables
		if ( $.ui.ddmanager ) {
			$.ui.ddmanager.drag( this, event );
		}

		//Call callbacks
		this._trigger( "sort", event, this._uiHash() );

		this.lastPositionAbs = this.positionAbs;
		return false;

	},

	_mouseStop: function( event, noPropagation ) {

		if ( !event ) {
			return;
		}

		//If we are using droppables, inform the manager about the drop
		if ( $.ui.ddmanager && !this.options.dropBehaviour ) {
			$.ui.ddmanager.drop( this, event );
		}

		if ( this.options.revert ) {
			var that = this,
				cur = this.placeholder.offset(),
				axis = this.options.axis,
				animation = {};

			if ( !axis || axis === "x" ) {
				animation.left = cur.left - this.offset.parent.left - this.margins.left +
					( this.offsetParent[ 0 ] === this.document[ 0 ].body ?
						0 :
						this.offsetParent[ 0 ].scrollLeft
					);
			}
			if ( !axis || axis === "y" ) {
				animation.top = cur.top - this.offset.parent.top - this.margins.top +
					( this.offsetParent[ 0 ] === this.document[ 0 ].body ?
						0 :
						this.offsetParent[ 0 ].scrollTop
					);
			}
			this.reverting = true;
			$( this.helper ).animate(
				animation,
				parseInt( this.options.revert, 10 ) || 500,
				function() {
					that._clear( event );
				}
			);
		} else {
			this._clear( event, noPropagation );
		}

		return false;

	},

	cancel: function() {

		if ( this.dragging ) {

			this._mouseUp( new $.Event( "mouseup", { target: null } ) );

			if ( this.options.helper === "original" ) {
				this.currentItem.css( this._storedCSS );
				this._removeClass( this.currentItem, "ui-sortable-helper" );
			} else {
				this.currentItem.show();
			}

			//Post deactivating events to containers
			for ( var i = this.containers.length - 1; i >= 0; i-- ) {
				this.containers[ i ]._trigger( "deactivate", null, this._uiHash( this ) );
				if ( this.containers[ i ].containerCache.over ) {
					this.containers[ i ]._trigger( "out", null, this._uiHash( this ) );
					this.containers[ i ].containerCache.over = 0;
				}
			}

		}

		if ( this.placeholder ) {

			//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately,
			// it unbinds ALL events from the original node!
			if ( this.placeholder[ 0 ].parentNode ) {
				this.placeholder[ 0 ].parentNode.removeChild( this.placeholder[ 0 ] );
			}
			if ( this.options.helper !== "original" && this.helper &&
					this.helper[ 0 ].parentNode ) {
				this.helper.remove();
			}

			$.extend( this, {
				helper: null,
				dragging: false,
				reverting: false,
				_noFinalSort: null
			} );

			if ( this.domPosition.prev ) {
				$( this.domPosition.prev ).after( this.currentItem );
			} else {
				$( this.domPosition.parent ).prepend( this.currentItem );
			}
		}

		return this;

	},

	serialize: function( o ) {

		var items = this._getItemsAsjQuery( o && o.connected ),
			str = [];
		o = o || {};

		$( items ).each( function() {
			var res = ( $( o.item || this ).attr( o.attribute || "id" ) || "" )
				.match( o.expression || ( /(.+)[\-=_](.+)/ ) );
			if ( res ) {
				str.push(
					( o.key || res[ 1 ] + "[]" ) +
					"=" + ( o.key && o.expression ? res[ 1 ] : res[ 2 ] ) );
			}
		} );

		if ( !str.length && o.key ) {
			str.push( o.key + "=" );
		}

		return str.join( "&" );

	},

	toArray: function( o ) {

		var items = this._getItemsAsjQuery( o && o.connected ),
			ret = [];

		o = o || {};

		items.each( function() {
			ret.push( $( o.item || this ).attr( o.attribute || "id" ) || "" );
		} );
		return ret;

	},

	/* Be careful with the following core functions */
	_intersectsWith: function( item ) {

		var x1 = this.positionAbs.left,
			x2 = x1 + this.helperProportions.width,
			y1 = this.positionAbs.top,
			y2 = y1 + this.helperProportions.height,
			l = item.left,
			r = l + item.width,
			t = item.top,
			b = t + item.height,
			dyClick = this.offset.click.top,
			dxClick = this.offset.click.left,
			isOverElementHeight = ( this.options.axis === "x" ) || ( ( y1 + dyClick ) > t &&
				( y1 + dyClick ) < b ),
			isOverElementWidth = ( this.options.axis === "y" ) || ( ( x1 + dxClick ) > l &&
				( x1 + dxClick ) < r ),
			isOverElement = isOverElementHeight && isOverElementWidth;

		if ( this.options.tolerance === "pointer" ||
			this.options.forcePointerForContainers ||
			( this.options.tolerance !== "pointer" &&
				this.helperProportions[ this.floating ? "width" : "height" ] >
				item[ this.floating ? "width" : "height" ] )
		) {
			return isOverElement;
		} else {

			return ( l < x1 + ( this.helperProportions.width / 2 ) && // Right Half
				x2 - ( this.helperProportions.width / 2 ) < r && // Left Half
				t < y1 + ( this.helperProportions.height / 2 ) && // Bottom Half
				y2 - ( this.helperProportions.height / 2 ) < b ); // Top Half

		}
	},

	_intersectsWithPointer: function( item ) {
		var verticalDirection, horizontalDirection,
			isOverElementHeight = ( this.options.axis === "x" ) ||
				this._isOverAxis(
					this.positionAbs.top + this.offset.click.top, item.top, item.height ),
			isOverElementWidth = ( this.options.axis === "y" ) ||
				this._isOverAxis(
					this.positionAbs.left + this.offset.click.left, item.left, item.width ),
			isOverElement = isOverElementHeight && isOverElementWidth;

		if ( !isOverElement ) {
			return false;
		}

		verticalDirection = this._getDragVerticalDirection();
		horizontalDirection = this._getDragHorizontalDirection();

		return this.floating ?
			( ( horizontalDirection === "right" || verticalDirection === "down" ) ? 2 : 1 )
			: ( verticalDirection && ( verticalDirection === "down" ? 2 : 1 ) );

	},

	_intersectsWithSides: function( item ) {

		var isOverBottomHalf = this._isOverAxis( this.positionAbs.top +
				this.offset.click.top, item.top + ( item.height / 2 ), item.height ),
			isOverRightHalf = this._isOverAxis( this.positionAbs.left +
				this.offset.click.left, item.left + ( item.width / 2 ), item.width ),
			verticalDirection = this._getDragVerticalDirection(),
			horizontalDirection = this._getDragHorizontalDirection();

		if ( this.floating && horizontalDirection ) {
			return ( ( horizontalDirection === "right" && isOverRightHalf ) ||
				( horizontalDirection === "left" && !isOverRightHalf ) );
		} else {
			return verticalDirection && ( ( verticalDirection === "down" && isOverBottomHalf ) ||
				( verticalDirection === "up" && !isOverBottomHalf ) );
		}

	},

	_getDragVerticalDirection: function() {
		var delta = this.positionAbs.top - this.lastPositionAbs.top;
		return delta !== 0 && ( delta > 0 ? "down" : "up" );
	},

	_getDragHorizontalDirection: function() {
		var delta = this.positionAbs.left - this.lastPositionAbs.left;
		return delta !== 0 && ( delta > 0 ? "right" : "left" );
	},

	refresh: function( event ) {
		this._refreshItems( event );
		this._setHandleClassName();
		this.refreshPositions();
		return this;
	},

	_connectWith: function() {
		var options = this.options;
		return options.connectWith.constructor === String ?
			[ options.connectWith ] :
			options.connectWith;
	},

	_getItemsAsjQuery: function( connected ) {

		var i, j, cur, inst,
			items = [],
			queries = [],
			connectWith = this._connectWith();

		if ( connectWith && connected ) {
			for ( i = connectWith.length - 1; i >= 0; i-- ) {
				cur = $( connectWith[ i ], this.document[ 0 ] );
				for ( j = cur.length - 1; j >= 0; j-- ) {
					inst = $.data( cur[ j ], this.widgetFullName );
					if ( inst && inst !== this && !inst.options.disabled ) {
						queries.push( [ $.isFunction( inst.options.items ) ?
							inst.options.items.call( inst.element ) :
							$( inst.options.items, inst.element )
								.not( ".ui-sortable-helper" )
								.not( ".ui-sortable-placeholder" ), inst ] );
					}
				}
			}
		}

		queries.push( [ $.isFunction( this.options.items ) ?
			this.options.items
				.call( this.element, null, { options: this.options, item: this.currentItem } ) :
			$( this.options.items, this.element )
				.not( ".ui-sortable-helper" )
				.not( ".ui-sortable-placeholder" ), this ] );

		function addItems() {
			items.push( this );
		}
		for ( i = queries.length - 1; i >= 0; i-- ) {
			queries[ i ][ 0 ].each( addItems );
		}

		return $( items );

	},

	_removeCurrentsFromItems: function() {

		var list = this.currentItem.find( ":data(" + this.widgetName + "-item)" );

		this.items = $.grep( this.items, function( item ) {
			for ( var j = 0; j < list.length; j++ ) {
				if ( list[ j ] === item.item[ 0 ] ) {
					return false;
				}
			}
			return true;
		} );

	},

	_refreshItems: function( event ) {

		this.items = [];
		this.containers = [ this ];

		var i, j, cur, inst, targetData, _queries, item, queriesLength,
			items = this.items,
			queries = [ [ $.isFunction( this.options.items ) ?
				this.options.items.call( this.element[ 0 ], event, { item: this.currentItem } ) :
				$( this.options.items, this.element ), this ] ],
			connectWith = this._connectWith();

		//Shouldn't be run the first time through due to massive slow-down
		if ( connectWith && this.ready ) {
			for ( i = connectWith.length - 1; i >= 0; i-- ) {
				cur = $( connectWith[ i ], this.document[ 0 ] );
				for ( j = cur.length - 1; j >= 0; j-- ) {
					inst = $.data( cur[ j ], this.widgetFullName );
					if ( inst && inst !== this && !inst.options.disabled ) {
						queries.push( [ $.isFunction( inst.options.items ) ?
							inst.options.items
								.call( inst.element[ 0 ], event, { item: this.currentItem } ) :
							$( inst.options.items, inst.element ), inst ] );
						this.containers.push( inst );
					}
				}
			}
		}

		for ( i = queries.length - 1; i >= 0; i-- ) {
			targetData = queries[ i ][ 1 ];
			_queries = queries[ i ][ 0 ];

			for ( j = 0, queriesLength = _queries.length; j < queriesLength; j++ ) {
				item = $( _queries[ j ] );

				// Data for target checking (mouse manager)
				item.data( this.widgetName + "-item", targetData );

				items.push( {
					item: item,
					instance: targetData,
					width: 0, height: 0,
					left: 0, top: 0
				} );
			}
		}

	},

	refreshPositions: function( fast ) {

		// Determine whether items are being displayed horizontally
		this.floating = this.items.length ?
			this.options.axis === "x" || this._isFloating( this.items[ 0 ].item ) :
			false;

		//This has to be redone because due to the item being moved out/into the offsetParent,
		// the offsetParent's position will change
		if ( this.offsetParent && this.helper ) {
			this.offset.parent = this._getParentOffset();
		}

		var i, item, t, p;

		for ( i = this.items.length - 1; i >= 0; i-- ) {
			item = this.items[ i ];

			//We ignore calculating positions of all connected containers when we're not over them
			if ( item.instance !== this.currentContainer && this.currentContainer &&
					item.item[ 0 ] !== this.currentItem[ 0 ] ) {
				continue;
			}

			t = this.options.toleranceElement ?
				$( this.options.toleranceElement, item.item ) :
				item.item;

			if ( !fast ) {
				item.width = t.outerWidth();
				item.height = t.outerHeight();
			}

			p = t.offset();
			item.left = p.left;
			item.top = p.top;
		}

		if ( this.options.custom && this.options.custom.refreshContainers ) {
			this.options.custom.refreshContainers.call( this );
		} else {
			for ( i = this.containers.length - 1; i >= 0; i-- ) {
				p = this.containers[ i ].element.offset();
				this.containers[ i ].containerCache.left = p.left;
				this.containers[ i ].containerCache.top = p.top;
				this.containers[ i ].containerCache.width =
					this.containers[ i ].element.outerWidth();
				this.containers[ i ].containerCache.height =
					this.containers[ i ].element.outerHeight();
			}
		}

		return this;
	},

	_createPlaceholder: function( that ) {
		that = that || this;
		var className,
			o = that.options;

		if ( !o.placeholder || o.placeholder.constructor === String ) {
			className = o.placeholder;
			o.placeholder = {
				element: function() {

					var nodeName = that.currentItem[ 0 ].nodeName.toLowerCase(),
						element = $( "<" + nodeName + ">", that.document[ 0 ] );

						that._addClass( element, "ui-sortable-placeholder",
								className || that.currentItem[ 0 ].className )
							._removeClass( element, "ui-sortable-helper" );

					if ( nodeName === "tbody" ) {
						that._createTrPlaceholder(
							that.currentItem.find( "tr" ).eq( 0 ),
							$( "<tr>", that.document[ 0 ] ).appendTo( element )
						);
					} else if ( nodeName === "tr" ) {
						that._createTrPlaceholder( that.currentItem, element );
					} else if ( nodeName === "img" ) {
						element.attr( "src", that.currentItem.attr( "src" ) );
					}

					if ( !className ) {
						element.css( "visibility", "hidden" );
					}

					return element;
				},
				update: function( container, p ) {

					// 1. If a className is set as 'placeholder option, we don't force sizes -
					// the class is responsible for that
					// 2. The option 'forcePlaceholderSize can be enabled to force it even if a
					// class name is specified
					if ( className && !o.forcePlaceholderSize ) {
						return;
					}

					//If the element doesn't have a actual height by itself (without styles coming
					// from a stylesheet), it receives the inline height from the dragged item
					if ( !p.height() ) {
						p.height(
							that.currentItem.innerHeight() -
							parseInt( that.currentItem.css( "paddingTop" ) || 0, 10 ) -
							parseInt( that.currentItem.css( "paddingBottom" ) || 0, 10 ) );
					}
					if ( !p.width() ) {
						p.width(
							that.currentItem.innerWidth() -
							parseInt( that.currentItem.css( "paddingLeft" ) || 0, 10 ) -
							parseInt( that.currentItem.css( "paddingRight" ) || 0, 10 ) );
					}
				}
			};
		}

		//Create the placeholder
		that.placeholder = $( o.placeholder.element.call( that.element, that.currentItem ) );

		//Append it after the actual current item
		that.currentItem.after( that.placeholder );

		//Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
		o.placeholder.update( that, that.placeholder );

	},

	_createTrPlaceholder: function( sourceTr, targetTr ) {
		var that = this;

		sourceTr.children().each( function() {
			$( "<td>&#160;</td>", that.document[ 0 ] )
				.attr( "colspan", $( this ).attr( "colspan" ) || 1 )
				.appendTo( targetTr );
		} );
	},

	_contactContainers: function( event ) {
		var i, j, dist, itemWithLeastDistance, posProperty, sizeProperty, cur, nearBottom,
			floating, axis,
			innermostContainer = null,
			innermostIndex = null;

		// Get innermost container that intersects with item
		for ( i = this.containers.length - 1; i >= 0; i-- ) {

			// Never consider a container that's located within the item itself
			if ( $.contains( this.currentItem[ 0 ], this.containers[ i ].element[ 0 ] ) ) {
				continue;
			}

			if ( this._intersectsWith( this.containers[ i ].containerCache ) ) {

				// If we've already found a container and it's more "inner" than this, then continue
				if ( innermostContainer &&
						$.contains(
							this.containers[ i ].element[ 0 ],
							innermostContainer.element[ 0 ] ) ) {
					continue;
				}

				innermostContainer = this.containers[ i ];
				innermostIndex = i;

			} else {

				// container doesn't intersect. trigger "out" event if necessary
				if ( this.containers[ i ].containerCache.over ) {
					this.containers[ i ]._trigger( "out", event, this._uiHash( this ) );
					this.containers[ i ].containerCache.over = 0;
				}
			}

		}

		// If no intersecting containers found, return
		if ( !innermostContainer ) {
			return;
		}

		// Move the item into the container if it's not there already
		if ( this.containers.length === 1 ) {
			if ( !this.containers[ innermostIndex ].containerCache.over ) {
				this.containers[ innermostIndex ]._trigger( "over", event, this._uiHash( this ) );
				this.containers[ innermostIndex ].containerCache.over = 1;
			}
		} else {

			// When entering a new container, we will find the item with the least distance and
			// append our item near it
			dist = 10000;
			itemWithLeastDistance = null;
			floating = innermostContainer.floating || this._isFloating( this.currentItem );
			posProperty = floating ? "left" : "top";
			sizeProperty = floating ? "width" : "height";
			axis = floating ? "pageX" : "pageY";

			for ( j = this.items.length - 1; j >= 0; j-- ) {
				if ( !$.contains(
						this.containers[ innermostIndex ].element[ 0 ], this.items[ j ].item[ 0 ] )
				) {
					continue;
				}
				if ( this.items[ j ].item[ 0 ] === this.currentItem[ 0 ] ) {
					continue;
				}

				cur = this.items[ j ].item.offset()[ posProperty ];
				nearBottom = false;
				if ( event[ axis ] - cur > this.items[ j ][ sizeProperty ] / 2 ) {
					nearBottom = true;
				}

				if ( Math.abs( event[ axis ] - cur ) < dist ) {
					dist = Math.abs( event[ axis ] - cur );
					itemWithLeastDistance = this.items[ j ];
					this.direction = nearBottom ? "up" : "down";
				}
			}

			//Check if dropOnEmpty is enabled
			if ( !itemWithLeastDistance && !this.options.dropOnEmpty ) {
				return;
			}

			if ( this.currentContainer === this.containers[ innermostIndex ] ) {
				if ( !this.currentContainer.containerCache.over ) {
					this.containers[ innermostIndex ]._trigger( "over", event, this._uiHash() );
					this.currentContainer.containerCache.over = 1;
				}
				return;
			}

			itemWithLeastDistance ?
				this._rearrange( event, itemWithLeastDistance, null, true ) :
				this._rearrange( event, null, this.containers[ innermostIndex ].element, true );
			this._trigger( "change", event, this._uiHash() );
			this.containers[ innermostIndex ]._trigger( "change", event, this._uiHash( this ) );
			this.currentContainer = this.containers[ innermostIndex ];

			//Update the placeholder
			this.options.placeholder.update( this.currentContainer, this.placeholder );

			this.containers[ innermostIndex ]._trigger( "over", event, this._uiHash( this ) );
			this.containers[ innermostIndex ].containerCache.over = 1;
		}

	},

	_createHelper: function( event ) {

		var o = this.options,
			helper = $.isFunction( o.helper ) ?
				$( o.helper.apply( this.element[ 0 ], [ event, this.currentItem ] ) ) :
				( o.helper === "clone" ? this.currentItem.clone() : this.currentItem );

		//Add the helper to the DOM if that didn't happen already
		if ( !helper.parents( "body" ).length ) {
			$( o.appendTo !== "parent" ?
				o.appendTo :
				this.currentItem[ 0 ].parentNode )[ 0 ].appendChild( helper[ 0 ] );
		}

		if ( helper[ 0 ] === this.currentItem[ 0 ] ) {
			this._storedCSS = {
				width: this.currentItem[ 0 ].style.width,
				height: this.currentItem[ 0 ].style.height,
				position: this.currentItem.css( "position" ),
				top: this.currentItem.css( "top" ),
				left: this.currentItem.css( "left" )
			};
		}

		if ( !helper[ 0 ].style.width || o.forceHelperSize ) {
			helper.width( this.currentItem.width() );
		}
		if ( !helper[ 0 ].style.height || o.forceHelperSize ) {
			helper.height( this.currentItem.height() );
		}

		return helper;

	},

	_adjustOffsetFromHelper: function( obj ) {
		if ( typeof obj === "string" ) {
			obj = obj.split( " " );
		}
		if ( $.isArray( obj ) ) {
			obj = { left: +obj[ 0 ], top: +obj[ 1 ] || 0 };
		}
		if ( "left" in obj ) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ( "right" in obj ) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ( "top" in obj ) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ( "bottom" in obj ) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {

		//Get the offsetParent and cache its position
		this.offsetParent = this.helper.offsetParent();
		var po = this.offsetParent.offset();

		// This is a special case where we need to modify a offset calculated on start, since the
		// following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the
		// next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't
		// the document, which means that the scroll is included in the initial calculation of the
		// offset of the parent, and never recalculated upon drag
		if ( this.cssPosition === "absolute" && this.scrollParent[ 0 ] !== this.document[ 0 ] &&
				$.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		// This needs to be actually done for all browsers, since pageX/pageY includes this
		// information with an ugly IE fix
		if ( this.offsetParent[ 0 ] === this.document[ 0 ].body ||
				( this.offsetParent[ 0 ].tagName &&
				this.offsetParent[ 0 ].tagName.toLowerCase() === "html" && $.ui.ie ) ) {
			po = { top: 0, left: 0 };
		}

		return {
			top: po.top + ( parseInt( this.offsetParent.css( "borderTopWidth" ), 10 ) || 0 ),
			left: po.left + ( parseInt( this.offsetParent.css( "borderLeftWidth" ), 10 ) || 0 )
		};

	},

	_getRelativeOffset: function() {

		if ( this.cssPosition === "relative" ) {
			var p = this.currentItem.position();
			return {
				top: p.top - ( parseInt( this.helper.css( "top" ), 10 ) || 0 ) +
					this.scrollParent.scrollTop(),
				left: p.left - ( parseInt( this.helper.css( "left" ), 10 ) || 0 ) +
					this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: ( parseInt( this.currentItem.css( "marginLeft" ), 10 ) || 0 ),
			top: ( parseInt( this.currentItem.css( "marginTop" ), 10 ) || 0 )
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var ce, co, over,
			o = this.options;
		if ( o.containment === "parent" ) {
			o.containment = this.helper[ 0 ].parentNode;
		}
		if ( o.containment === "document" || o.containment === "window" ) {
			this.containment = [
				0 - this.offset.relative.left - this.offset.parent.left,
				0 - this.offset.relative.top - this.offset.parent.top,
				o.containment === "document" ?
					this.document.width() :
					this.window.width() - this.helperProportions.width - this.margins.left,
				( o.containment === "document" ?
					( this.document.height() || document.body.parentNode.scrollHeight ) :
					this.window.height() || this.document[ 0 ].body.parentNode.scrollHeight
				) - this.helperProportions.height - this.margins.top
			];
		}

		if ( !( /^(document|window|parent)$/ ).test( o.containment ) ) {
			ce = $( o.containment )[ 0 ];
			co = $( o.containment ).offset();
			over = ( $( ce ).css( "overflow" ) !== "hidden" );

			this.containment = [
				co.left + ( parseInt( $( ce ).css( "borderLeftWidth" ), 10 ) || 0 ) +
					( parseInt( $( ce ).css( "paddingLeft" ), 10 ) || 0 ) - this.margins.left,
				co.top + ( parseInt( $( ce ).css( "borderTopWidth" ), 10 ) || 0 ) +
					( parseInt( $( ce ).css( "paddingTop" ), 10 ) || 0 ) - this.margins.top,
				co.left + ( over ? Math.max( ce.scrollWidth, ce.offsetWidth ) : ce.offsetWidth ) -
					( parseInt( $( ce ).css( "borderLeftWidth" ), 10 ) || 0 ) -
					( parseInt( $( ce ).css( "paddingRight" ), 10 ) || 0 ) -
					this.helperProportions.width - this.margins.left,
				co.top + ( over ? Math.max( ce.scrollHeight, ce.offsetHeight ) : ce.offsetHeight ) -
					( parseInt( $( ce ).css( "borderTopWidth" ), 10 ) || 0 ) -
					( parseInt( $( ce ).css( "paddingBottom" ), 10 ) || 0 ) -
					this.helperProportions.height - this.margins.top
			];
		}

	},

	_convertPositionTo: function( d, pos ) {

		if ( !pos ) {
			pos = this.position;
		}
		var mod = d === "absolute" ? 1 : -1,
			scroll = this.cssPosition === "absolute" &&
				!( this.scrollParent[ 0 ] !== this.document[ 0 ] &&
				$.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ?
					this.offsetParent :
					this.scrollParent,
			scrollIsRootNode = ( /(html|body)/i ).test( scroll[ 0 ].tagName );

		return {
			top: (

				// The absolute mouse position
				pos.top	+

				// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.relative.top * mod +

				// The offsetParent's offset without borders (offset + border)
				this.offset.parent.top * mod -
				( ( this.cssPosition === "fixed" ?
					-this.scrollParent.scrollTop() :
					( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod )
			),
			left: (

				// The absolute mouse position
				pos.left +

				// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.relative.left * mod +

				// The offsetParent's offset without borders (offset + border)
				this.offset.parent.left * mod	-
				( ( this.cssPosition === "fixed" ?
					-this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 :
					scroll.scrollLeft() ) * mod )
			)
		};

	},

	_generatePosition: function( event ) {

		var top, left,
			o = this.options,
			pageX = event.pageX,
			pageY = event.pageY,
			scroll = this.cssPosition === "absolute" &&
				!( this.scrollParent[ 0 ] !== this.document[ 0 ] &&
				$.contains( this.scrollParent[ 0 ], this.offsetParent[ 0 ] ) ) ?
					this.offsetParent :
					this.scrollParent,
				scrollIsRootNode = ( /(html|body)/i ).test( scroll[ 0 ].tagName );

		// This is another very weird special case that only happens for relative elements:
		// 1. If the css position is relative
		// 2. and the scroll parent is the document or similar to the offset parent
		// we have to refresh the relative offset during the scroll so there are no jumps
		if ( this.cssPosition === "relative" && !( this.scrollParent[ 0 ] !== this.document[ 0 ] &&
				this.scrollParent[ 0 ] !== this.offsetParent[ 0 ] ) ) {
			this.offset.relative = this._getRelativeOffset();
		}

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		if ( this.originalPosition ) { //If we are not dragging yet, we won't check for options

			if ( this.containment ) {
				if ( event.pageX - this.offset.click.left < this.containment[ 0 ] ) {
					pageX = this.containment[ 0 ] + this.offset.click.left;
				}
				if ( event.pageY - this.offset.click.top < this.containment[ 1 ] ) {
					pageY = this.containment[ 1 ] + this.offset.click.top;
				}
				if ( event.pageX - this.offset.click.left > this.containment[ 2 ] ) {
					pageX = this.containment[ 2 ] + this.offset.click.left;
				}
				if ( event.pageY - this.offset.click.top > this.containment[ 3 ] ) {
					pageY = this.containment[ 3 ] + this.offset.click.top;
				}
			}

			if ( o.grid ) {
				top = this.originalPageY + Math.round( ( pageY - this.originalPageY ) /
					o.grid[ 1 ] ) * o.grid[ 1 ];
				pageY = this.containment ?
					( ( top - this.offset.click.top >= this.containment[ 1 ] &&
						top - this.offset.click.top <= this.containment[ 3 ] ) ?
							top :
							( ( top - this.offset.click.top >= this.containment[ 1 ] ) ?
								top - o.grid[ 1 ] : top + o.grid[ 1 ] ) ) :
								top;

				left = this.originalPageX + Math.round( ( pageX - this.originalPageX ) /
					o.grid[ 0 ] ) * o.grid[ 0 ];
				pageX = this.containment ?
					( ( left - this.offset.click.left >= this.containment[ 0 ] &&
						left - this.offset.click.left <= this.containment[ 2 ] ) ?
							left :
							( ( left - this.offset.click.left >= this.containment[ 0 ] ) ?
								left - o.grid[ 0 ] : left + o.grid[ 0 ] ) ) :
								left;
			}

		}

		return {
			top: (

				// The absolute mouse position
				pageY -

				// Click offset (relative to the element)
				this.offset.click.top -

				// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.relative.top -

				// The offsetParent's offset without borders (offset + border)
				this.offset.parent.top +
				( ( this.cssPosition === "fixed" ?
					-this.scrollParent.scrollTop() :
					( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) )
			),
			left: (

				// The absolute mouse position
				pageX -

				// Click offset (relative to the element)
				this.offset.click.left -

				// Only for relative positioned nodes: Relative offset from element to offset parent
				this.offset.relative.left -

				// The offsetParent's offset without borders (offset + border)
				this.offset.parent.left +
				( ( this.cssPosition === "fixed" ?
					-this.scrollParent.scrollLeft() :
					scrollIsRootNode ? 0 : scroll.scrollLeft() ) )
			)
		};

	},

	_rearrange: function( event, i, a, hardRefresh ) {

		a ? a[ 0 ].appendChild( this.placeholder[ 0 ] ) :
			i.item[ 0 ].parentNode.insertBefore( this.placeholder[ 0 ],
				( this.direction === "down" ? i.item[ 0 ] : i.item[ 0 ].nextSibling ) );

		//Various things done here to improve the performance:
		// 1. we create a setTimeout, that calls refreshPositions
		// 2. on the instance, we have a counter variable, that get's higher after every append
		// 3. on the local scope, we copy the counter variable, and check in the timeout,
		// if it's still the same
		// 4. this lets only the last addition to the timeout stack through
		this.counter = this.counter ? ++this.counter : 1;
		var counter = this.counter;

		this._delay( function() {
			if ( counter === this.counter ) {

				//Precompute after each DOM insertion, NOT on mousemove
				this.refreshPositions( !hardRefresh );
			}
		} );

	},

	_clear: function( event, noPropagation ) {

		this.reverting = false;

		// We delay all events that have to be triggered to after the point where the placeholder
		// has been removed and everything else normalized again
		var i,
			delayedTriggers = [];

		// We first have to update the dom position of the actual currentItem
		// Note: don't do it if the current item is already removed (by a user), or it gets
		// reappended (see #4088)
		if ( !this._noFinalSort && this.currentItem.parent().length ) {
			this.placeholder.before( this.currentItem );
		}
		this._noFinalSort = null;

		if ( this.helper[ 0 ] === this.currentItem[ 0 ] ) {
			for ( i in this._storedCSS ) {
				if ( this._storedCSS[ i ] === "auto" || this._storedCSS[ i ] === "static" ) {
					this._storedCSS[ i ] = "";
				}
			}
			this.currentItem.css( this._storedCSS );
			this._removeClass( this.currentItem, "ui-sortable-helper" );
		} else {
			this.currentItem.show();
		}

		if ( this.fromOutside && !noPropagation ) {
			delayedTriggers.push( function( event ) {
				this._trigger( "receive", event, this._uiHash( this.fromOutside ) );
			} );
		}
		if ( ( this.fromOutside ||
				this.domPosition.prev !==
				this.currentItem.prev().not( ".ui-sortable-helper" )[ 0 ] ||
				this.domPosition.parent !== this.currentItem.parent()[ 0 ] ) && !noPropagation ) {

			// Trigger update callback if the DOM position has changed
			delayedTriggers.push( function( event ) {
				this._trigger( "update", event, this._uiHash() );
			} );
		}

		// Check if the items Container has Changed and trigger appropriate
		// events.
		if ( this !== this.currentContainer ) {
			if ( !noPropagation ) {
				delayedTriggers.push( function( event ) {
					this._trigger( "remove", event, this._uiHash() );
				} );
				delayedTriggers.push( ( function( c ) {
					return function( event ) {
						c._trigger( "receive", event, this._uiHash( this ) );
					};
				} ).call( this, this.currentContainer ) );
				delayedTriggers.push( ( function( c ) {
					return function( event ) {
						c._trigger( "update", event, this._uiHash( this ) );
					};
				} ).call( this, this.currentContainer ) );
			}
		}

		//Post events to containers
		function delayEvent( type, instance, container ) {
			return function( event ) {
				container._trigger( type, event, instance._uiHash( instance ) );
			};
		}
		for ( i = this.containers.length - 1; i >= 0; i-- ) {
			if ( !noPropagation ) {
				delayedTriggers.push( delayEvent( "deactivate", this, this.containers[ i ] ) );
			}
			if ( this.containers[ i ].containerCache.over ) {
				delayedTriggers.push( delayEvent( "out", this, this.containers[ i ] ) );
				this.containers[ i ].containerCache.over = 0;
			}
		}

		//Do what was originally in plugins
		if ( this.storedCursor ) {
			this.document.find( "body" ).css( "cursor", this.storedCursor );
			this.storedStylesheet.remove();
		}
		if ( this._storedOpacity ) {
			this.helper.css( "opacity", this._storedOpacity );
		}
		if ( this._storedZIndex ) {
			this.helper.css( "zIndex", this._storedZIndex === "auto" ? "" : this._storedZIndex );
		}

		this.dragging = false;

		if ( !noPropagation ) {
			this._trigger( "beforeStop", event, this._uiHash() );
		}

		//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately,
		// it unbinds ALL events from the original node!
		this.placeholder[ 0 ].parentNode.removeChild( this.placeholder[ 0 ] );

		if ( !this.cancelHelperRemoval ) {
			if ( this.helper[ 0 ] !== this.currentItem[ 0 ] ) {
				this.helper.remove();
			}
			this.helper = null;
		}

		if ( !noPropagation ) {
			for ( i = 0; i < delayedTriggers.length; i++ ) {

				// Trigger all delayed events
				delayedTriggers[ i ].call( this, event );
			}
			this._trigger( "stop", event, this._uiHash() );
		}

		this.fromOutside = false;
		return !this.cancelHelperRemoval;

	},

	_trigger: function() {
		if ( $.Widget.prototype._trigger.apply( this, arguments ) === false ) {
			this.cancel();
		}
	},

	_uiHash: function( _inst ) {
		var inst = _inst || this;
		return {
			helper: inst.helper,
			placeholder: inst.placeholder || $( [] ),
			position: inst.position,
			originalPosition: inst.originalPosition,
			offset: inst.positionAbs,
			item: inst.currentItem,
			sender: _inst ? _inst.element : null
		};
	}

} );


/*!
 * jQuery UI Accordion 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Accordion
//>>group: Widgets
// jscs:disable maximumLineLength
//>>description: Displays collapsible content panels for presenting information in a limited amount of space.
// jscs:enable maximumLineLength
//>>docs: http://api.jqueryui.com/accordion/
//>>demos: http://jqueryui.com/accordion/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/accordion.css
//>>css.theme: ../../themes/base/theme.css



var widgetsAccordion = $.widget( "ui.accordion", {
	version: "1.12.1",
	options: {
		active: 0,
		animate: {},
		classes: {
			"ui-accordion-header": "ui-corner-top",
			"ui-accordion-header-collapsed": "ui-corner-all",
			"ui-accordion-content": "ui-corner-bottom"
		},
		collapsible: false,
		event: "click",
		header: "> li > :first-child, > :not(li):even",
		heightStyle: "auto",
		icons: {
			activeHeader: "ui-icon-triangle-1-s",
			header: "ui-icon-triangle-1-e"
		},

		// Callbacks
		activate: null,
		beforeActivate: null
	},

	hideProps: {
		borderTopWidth: "hide",
		borderBottomWidth: "hide",
		paddingTop: "hide",
		paddingBottom: "hide",
		height: "hide"
	},

	showProps: {
		borderTopWidth: "show",
		borderBottomWidth: "show",
		paddingTop: "show",
		paddingBottom: "show",
		height: "show"
	},

	_create: function() {
		var options = this.options;

		this.prevShow = this.prevHide = $();
		this._addClass( "ui-accordion", "ui-widget ui-helper-reset" );
		this.element.attr( "role", "tablist" );

		// Don't allow collapsible: false and active: false / null
		if ( !options.collapsible && ( options.active === false || options.active == null ) ) {
			options.active = 0;
		}

		this._processPanels();

		// handle negative values
		if ( options.active < 0 ) {
			options.active += this.headers.length;
		}
		this._refresh();
	},

	_getCreateEventData: function() {
		return {
			header: this.active,
			panel: !this.active.length ? $() : this.active.next()
		};
	},

	_createIcons: function() {
		var icon, children,
			icons = this.options.icons;

		if ( icons ) {
			icon = $( "<span>" );
			this._addClass( icon, "ui-accordion-header-icon", "ui-icon " + icons.header );
			icon.prependTo( this.headers );
			children = this.active.children( ".ui-accordion-header-icon" );
			this._removeClass( children, icons.header )
				._addClass( children, null, icons.activeHeader )
				._addClass( this.headers, "ui-accordion-icons" );
		}
	},

	_destroyIcons: function() {
		this._removeClass( this.headers, "ui-accordion-icons" );
		this.headers.children( ".ui-accordion-header-icon" ).remove();
	},

	_destroy: function() {
		var contents;

		// Clean up main element
		this.element.removeAttr( "role" );

		// Clean up headers
		this.headers
			.removeAttr( "role aria-expanded aria-selected aria-controls tabIndex" )
			.removeUniqueId();

		this._destroyIcons();

		// Clean up content panels
		contents = this.headers.next()
			.css( "display", "" )
			.removeAttr( "role aria-hidden aria-labelledby" )
			.removeUniqueId();

		if ( this.options.heightStyle !== "content" ) {
			contents.css( "height", "" );
		}
	},

	_setOption: function( key, value ) {
		if ( key === "active" ) {

			// _activate() will handle invalid values and update this.options
			this._activate( value );
			return;
		}

		if ( key === "event" ) {
			if ( this.options.event ) {
				this._off( this.headers, this.options.event );
			}
			this._setupEvents( value );
		}

		this._super( key, value );

		// Setting collapsible: false while collapsed; open first panel
		if ( key === "collapsible" && !value && this.options.active === false ) {
			this._activate( 0 );
		}

		if ( key === "icons" ) {
			this._destroyIcons();
			if ( value ) {
				this._createIcons();
			}
		}
	},

	_setOptionDisabled: function( value ) {
		this._super( value );

		this.element.attr( "aria-disabled", value );

		// Support: IE8 Only
		// #5332 / #6059 - opacity doesn't cascade to positioned elements in IE
		// so we need to add the disabled class to the headers and panels
		this._toggleClass( null, "ui-state-disabled", !!value );
		this._toggleClass( this.headers.add( this.headers.next() ), null, "ui-state-disabled",
			!!value );
	},

	_keydown: function( event ) {
		if ( event.altKey || event.ctrlKey ) {
			return;
		}

		var keyCode = $.ui.keyCode,
			length = this.headers.length,
			currentIndex = this.headers.index( event.target ),
			toFocus = false;

		switch ( event.keyCode ) {
		case keyCode.RIGHT:
		case keyCode.DOWN:
			toFocus = this.headers[ ( currentIndex + 1 ) % length ];
			break;
		case keyCode.LEFT:
		case keyCode.UP:
			toFocus = this.headers[ ( currentIndex - 1 + length ) % length ];
			break;
		case keyCode.SPACE:
		case keyCode.ENTER:
			this._eventHandler( event );
			break;
		case keyCode.HOME:
			toFocus = this.headers[ 0 ];
			break;
		case keyCode.END:
			toFocus = this.headers[ length - 1 ];
			break;
		}

		if ( toFocus ) {
			$( event.target ).attr( "tabIndex", -1 );
			$( toFocus ).attr( "tabIndex", 0 );
			$( toFocus ).trigger( "focus" );
			event.preventDefault();
		}
	},

	_panelKeyDown: function( event ) {
		if ( event.keyCode === $.ui.keyCode.UP && event.ctrlKey ) {
			$( event.currentTarget ).prev().trigger( "focus" );
		}
	},

	refresh: function() {
		var options = this.options;
		this._processPanels();

		// Was collapsed or no panel
		if ( ( options.active === false && options.collapsible === true ) ||
				!this.headers.length ) {
			options.active = false;
			this.active = $();

		// active false only when collapsible is true
		} else if ( options.active === false ) {
			this._activate( 0 );

		// was active, but active panel is gone
		} else if ( this.active.length && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {

			// all remaining panel are disabled
			if ( this.headers.length === this.headers.find( ".ui-state-disabled" ).length ) {
				options.active = false;
				this.active = $();

			// activate previous panel
			} else {
				this._activate( Math.max( 0, options.active - 1 ) );
			}

		// was active, active panel still exists
		} else {

			// make sure active index is correct
			options.active = this.headers.index( this.active );
		}

		this._destroyIcons();

		this._refresh();
	},

	_processPanels: function() {
		var prevHeaders = this.headers,
			prevPanels = this.panels;

		this.headers = this.element.find( this.options.header );
		this._addClass( this.headers, "ui-accordion-header ui-accordion-header-collapsed",
			"ui-state-default" );

		this.panels = this.headers.next().filter( ":not(.ui-accordion-content-active)" ).hide();
		this._addClass( this.panels, "ui-accordion-content", "ui-helper-reset ui-widget-content" );

		// Avoid memory leaks (#10056)
		if ( prevPanels ) {
			this._off( prevHeaders.not( this.headers ) );
			this._off( prevPanels.not( this.panels ) );
		}
	},

	_refresh: function() {
		var maxHeight,
			options = this.options,
			heightStyle = options.heightStyle,
			parent = this.element.parent();

		this.active = this._findActive( options.active );
		this._addClass( this.active, "ui-accordion-header-active", "ui-state-active" )
			._removeClass( this.active, "ui-accordion-header-collapsed" );
		this._addClass( this.active.next(), "ui-accordion-content-active" );
		this.active.next().show();

		this.headers
			.attr( "role", "tab" )
			.each( function() {
				var header = $( this ),
					headerId = header.uniqueId().attr( "id" ),
					panel = header.next(),
					panelId = panel.uniqueId().attr( "id" );
				header.attr( "aria-controls", panelId );
				panel.attr( "aria-labelledby", headerId );
			} )
			.next()
				.attr( "role", "tabpanel" );

		this.headers
			.not( this.active )
				.attr( {
					"aria-selected": "false",
					"aria-expanded": "false",
					tabIndex: -1
				} )
				.next()
					.attr( {
						"aria-hidden": "true"
					} )
					.hide();

		// Make sure at least one header is in the tab order
		if ( !this.active.length ) {
			this.headers.eq( 0 ).attr( "tabIndex", 0 );
		} else {
			this.active.attr( {
				"aria-selected": "true",
				"aria-expanded": "true",
				tabIndex: 0
			} )
				.next()
					.attr( {
						"aria-hidden": "false"
					} );
		}

		this._createIcons();

		this._setupEvents( options.event );

		if ( heightStyle === "fill" ) {
			maxHeight = parent.height();
			this.element.siblings( ":visible" ).each( function() {
				var elem = $( this ),
					position = elem.css( "position" );

				if ( position === "absolute" || position === "fixed" ) {
					return;
				}
				maxHeight -= elem.outerHeight( true );
			} );

			this.headers.each( function() {
				maxHeight -= $( this ).outerHeight( true );
			} );

			this.headers.next()
				.each( function() {
					$( this ).height( Math.max( 0, maxHeight -
						$( this ).innerHeight() + $( this ).height() ) );
				} )
				.css( "overflow", "auto" );
		} else if ( heightStyle === "auto" ) {
			maxHeight = 0;
			this.headers.next()
				.each( function() {
					var isVisible = $( this ).is( ":visible" );
					if ( !isVisible ) {
						$( this ).show();
					}
					maxHeight = Math.max( maxHeight, $( this ).css( "height", "" ).height() );
					if ( !isVisible ) {
						$( this ).hide();
					}
				} )
				.height( maxHeight );
		}
	},

	_activate: function( index ) {
		var active = this._findActive( index )[ 0 ];

		// Trying to activate the already active panel
		if ( active === this.active[ 0 ] ) {
			return;
		}

		// Trying to collapse, simulate a click on the currently active header
		active = active || this.active[ 0 ];

		this._eventHandler( {
			target: active,
			currentTarget: active,
			preventDefault: $.noop
		} );
	},

	_findActive: function( selector ) {
		return typeof selector === "number" ? this.headers.eq( selector ) : $();
	},

	_setupEvents: function( event ) {
		var events = {
			keydown: "_keydown"
		};
		if ( event ) {
			$.each( event.split( " " ), function( index, eventName ) {
				events[ eventName ] = "_eventHandler";
			} );
		}

		this._off( this.headers.add( this.headers.next() ) );
		this._on( this.headers, events );
		this._on( this.headers.next(), { keydown: "_panelKeyDown" } );
		this._hoverable( this.headers );
		this._focusable( this.headers );
	},

	_eventHandler: function( event ) {
		var activeChildren, clickedChildren,
			options = this.options,
			active = this.active,
			clicked = $( event.currentTarget ),
			clickedIsActive = clicked[ 0 ] === active[ 0 ],
			collapsing = clickedIsActive && options.collapsible,
			toShow = collapsing ? $() : clicked.next(),
			toHide = active.next(),
			eventData = {
				oldHeader: active,
				oldPanel: toHide,
				newHeader: collapsing ? $() : clicked,
				newPanel: toShow
			};

		event.preventDefault();

		if (

				// click on active header, but not collapsible
				( clickedIsActive && !options.collapsible ) ||

				// allow canceling activation
				( this._trigger( "beforeActivate", event, eventData ) === false ) ) {
			return;
		}

		options.active = collapsing ? false : this.headers.index( clicked );

		// When the call to ._toggle() comes after the class changes
		// it causes a very odd bug in IE 8 (see #6720)
		this.active = clickedIsActive ? $() : clicked;
		this._toggle( eventData );

		// Switch classes
		// corner classes on the previously active header stay after the animation
		this._removeClass( active, "ui-accordion-header-active", "ui-state-active" );
		if ( options.icons ) {
			activeChildren = active.children( ".ui-accordion-header-icon" );
			this._removeClass( activeChildren, null, options.icons.activeHeader )
				._addClass( activeChildren, null, options.icons.header );
		}

		if ( !clickedIsActive ) {
			this._removeClass( clicked, "ui-accordion-header-collapsed" )
				._addClass( clicked, "ui-accordion-header-active", "ui-state-active" );
			if ( options.icons ) {
				clickedChildren = clicked.children( ".ui-accordion-header-icon" );
				this._removeClass( clickedChildren, null, options.icons.header )
					._addClass( clickedChildren, null, options.icons.activeHeader );
			}

			this._addClass( clicked.next(), "ui-accordion-content-active" );
		}
	},

	_toggle: function( data ) {
		var toShow = data.newPanel,
			toHide = this.prevShow.length ? this.prevShow : data.oldPanel;

		// Handle activating a panel during the animation for another activation
		this.prevShow.add( this.prevHide ).stop( true, true );
		this.prevShow = toShow;
		this.prevHide = toHide;

		if ( this.options.animate ) {
			this._animate( toShow, toHide, data );
		} else {
			toHide.hide();
			toShow.show();
			this._toggleComplete( data );
		}

		toHide.attr( {
			"aria-hidden": "true"
		} );
		toHide.prev().attr( {
			"aria-selected": "false",
			"aria-expanded": "false"
		} );

		// if we're switching panels, remove the old header from the tab order
		// if we're opening from collapsed state, remove the previous header from the tab order
		// if we're collapsing, then keep the collapsing header in the tab order
		if ( toShow.length && toHide.length ) {
			toHide.prev().attr( {
				"tabIndex": -1,
				"aria-expanded": "false"
			} );
		} else if ( toShow.length ) {
			this.headers.filter( function() {
				return parseInt( $( this ).attr( "tabIndex" ), 10 ) === 0;
			} )
				.attr( "tabIndex", -1 );
		}

		toShow
			.attr( "aria-hidden", "false" )
			.prev()
				.attr( {
					"aria-selected": "true",
					"aria-expanded": "true",
					tabIndex: 0
				} );
	},

	_animate: function( toShow, toHide, data ) {
		var total, easing, duration,
			that = this,
			adjust = 0,
			boxSizing = toShow.css( "box-sizing" ),
			down = toShow.length &&
				( !toHide.length || ( toShow.index() < toHide.index() ) ),
			animate = this.options.animate || {},
			options = down && animate.down || animate,
			complete = function() {
				that._toggleComplete( data );
			};

		if ( typeof options === "number" ) {
			duration = options;
		}
		if ( typeof options === "string" ) {
			easing = options;
		}

		// fall back from options to animation in case of partial down settings
		easing = easing || options.easing || animate.easing;
		duration = duration || options.duration || animate.duration;

		if ( !toHide.length ) {
			return toShow.animate( this.showProps, duration, easing, complete );
		}
		if ( !toShow.length ) {
			return toHide.animate( this.hideProps, duration, easing, complete );
		}

		total = toShow.show().outerHeight();
		toHide.animate( this.hideProps, {
			duration: duration,
			easing: easing,
			step: function( now, fx ) {
				fx.now = Math.round( now );
			}
		} );
		toShow
			.hide()
			.animate( this.showProps, {
				duration: duration,
				easing: easing,
				complete: complete,
				step: function( now, fx ) {
					fx.now = Math.round( now );
					if ( fx.prop !== "height" ) {
						if ( boxSizing === "content-box" ) {
							adjust += fx.now;
						}
					} else if ( that.options.heightStyle !== "content" ) {
						fx.now = Math.round( total - toHide.outerHeight() - adjust );
						adjust = 0;
					}
				}
			} );
	},

	_toggleComplete: function( data ) {
		var toHide = data.oldPanel,
			prev = toHide.prev();

		this._removeClass( toHide, "ui-accordion-content-active" );
		this._removeClass( prev, "ui-accordion-header-active" )
			._addClass( prev, "ui-accordion-header-collapsed" );

		// Work around for rendering bug in IE (#5421)
		if ( toHide.length ) {
			toHide.parent()[ 0 ].className = toHide.parent()[ 0 ].className;
		}
		this._trigger( "activate", null, data );
	}
} );


/*!
 * jQuery UI Menu 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Menu
//>>group: Widgets
//>>description: Creates nestable menus.
//>>docs: http://api.jqueryui.com/menu/
//>>demos: http://jqueryui.com/menu/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/menu.css
//>>css.theme: ../../themes/base/theme.css



var widgetsMenu = $.widget( "ui.menu", {
	version: "1.12.1",
	defaultElement: "<ul>",
	delay: 300,
	options: {
		icons: {
			submenu: "ui-icon-caret-1-e"
		},
		items: "> *",
		menus: "ul",
		position: {
			my: "left top",
			at: "right top"
		},
		role: "menu",

		// Callbacks
		blur: null,
		focus: null,
		select: null
	},

	_create: function() {
		this.activeMenu = this.element;

		// Flag used to prevent firing of the click handler
		// as the event bubbles up through nested menus
		this.mouseHandled = false;
		this.element
			.uniqueId()
			.attr( {
				role: this.options.role,
				tabIndex: 0
			} );

		this._addClass( "ui-menu", "ui-widget ui-widget-content" );
		this._on( {

			// Prevent focus from sticking to links inside menu after clicking
			// them (focus should always stay on UL during navigation).
			"mousedown .ui-menu-item": function( event ) {
				event.preventDefault();
			},
			"click .ui-menu-item": function( event ) {
				var target = $( event.target );
				var active = $( $.ui.safeActiveElement( this.document[ 0 ] ) );
				if ( !this.mouseHandled && target.not( ".ui-state-disabled" ).length ) {
					this.select( event );

					// Only set the mouseHandled flag if the event will bubble, see #9469.
					if ( !event.isPropagationStopped() ) {
						this.mouseHandled = true;
					}

					// Open submenu on click
					if ( target.has( ".ui-menu" ).length ) {
						this.expand( event );
					} else if ( !this.element.is( ":focus" ) &&
							active.closest( ".ui-menu" ).length ) {

						// Redirect focus to the menu
						this.element.trigger( "focus", [ true ] );

						// If the active item is on the top level, let it stay active.
						// Otherwise, blur the active item since it is no longer visible.
						if ( this.active && this.active.parents( ".ui-menu" ).length === 1 ) {
							clearTimeout( this.timer );
						}
					}
				}
			},
			"mouseenter .ui-menu-item": function( event ) {

				// Ignore mouse events while typeahead is active, see #10458.
				// Prevents focusing the wrong item when typeahead causes a scroll while the mouse
				// is over an item in the menu
				if ( this.previousFilter ) {
					return;
				}

				var actualTarget = $( event.target ).closest( ".ui-menu-item" ),
					target = $( event.currentTarget );

				// Ignore bubbled events on parent items, see #11641
				if ( actualTarget[ 0 ] !== target[ 0 ] ) {
					return;
				}

				// Remove ui-state-active class from siblings of the newly focused menu item
				// to avoid a jump caused by adjacent elements both having a class with a border
				this._removeClass( target.siblings().children( ".ui-state-active" ),
					null, "ui-state-active" );
				this.focus( event, target );
			},
			mouseleave: "collapseAll",
			"mouseleave .ui-menu": "collapseAll",
			focus: function( event, keepActiveItem ) {

				// If there's already an active item, keep it active
				// If not, activate the first item
				var item = this.active || this.element.find( this.options.items ).eq( 0 );

				if ( !keepActiveItem ) {
					this.focus( event, item );
				}
			},
			blur: function( event ) {
				this._delay( function() {
					var notContained = !$.contains(
						this.element[ 0 ],
						$.ui.safeActiveElement( this.document[ 0 ] )
					);
					if ( notContained ) {
						this.collapseAll( event );
					}
				} );
			},
			keydown: "_keydown"
		} );

		this.refresh();

		// Clicks outside of a menu collapse any open menus
		this._on( this.document, {
			click: function( event ) {
				if ( this._closeOnDocumentClick( event ) ) {
					this.collapseAll( event );
				}

				// Reset the mouseHandled flag
				this.mouseHandled = false;
			}
		} );
	},

	_destroy: function() {
		var items = this.element.find( ".ui-menu-item" )
				.removeAttr( "role aria-disabled" ),
			submenus = items.children( ".ui-menu-item-wrapper" )
				.removeUniqueId()
				.removeAttr( "tabIndex role aria-haspopup" );

		// Destroy (sub)menus
		this.element
			.removeAttr( "aria-activedescendant" )
			.find( ".ui-menu" ).addBack()
				.removeAttr( "role aria-labelledby aria-expanded aria-hidden aria-disabled " +
					"tabIndex" )
				.removeUniqueId()
				.show();

		submenus.children().each( function() {
			var elem = $( this );
			if ( elem.data( "ui-menu-submenu-caret" ) ) {
				elem.remove();
			}
		} );
	},

	_keydown: function( event ) {
		var match, prev, character, skip,
			preventDefault = true;

		switch ( event.keyCode ) {
		case $.ui.keyCode.PAGE_UP:
			this.previousPage( event );
			break;
		case $.ui.keyCode.PAGE_DOWN:
			this.nextPage( event );
			break;
		case $.ui.keyCode.HOME:
			this._move( "first", "first", event );
			break;
		case $.ui.keyCode.END:
			this._move( "last", "last", event );
			break;
		case $.ui.keyCode.UP:
			this.previous( event );
			break;
		case $.ui.keyCode.DOWN:
			this.next( event );
			break;
		case $.ui.keyCode.LEFT:
			this.collapse( event );
			break;
		case $.ui.keyCode.RIGHT:
			if ( this.active && !this.active.is( ".ui-state-disabled" ) ) {
				this.expand( event );
			}
			break;
		case $.ui.keyCode.ENTER:
		case $.ui.keyCode.SPACE:
			this._activate( event );
			break;
		case $.ui.keyCode.ESCAPE:
			this.collapse( event );
			break;
		default:
			preventDefault = false;
			prev = this.previousFilter || "";
			skip = false;

			// Support number pad values
			character = event.keyCode >= 96 && event.keyCode <= 105 ?
				( event.keyCode - 96 ).toString() : String.fromCharCode( event.keyCode );

			clearTimeout( this.filterTimer );

			if ( character === prev ) {
				skip = true;
			} else {
				character = prev + character;
			}

			match = this._filterMenuItems( character );
			match = skip && match.index( this.active.next() ) !== -1 ?
				this.active.nextAll( ".ui-menu-item" ) :
				match;

			// If no matches on the current filter, reset to the last character pressed
			// to move down the menu to the first item that starts with that character
			if ( !match.length ) {
				character = String.fromCharCode( event.keyCode );
				match = this._filterMenuItems( character );
			}

			if ( match.length ) {
				this.focus( event, match );
				this.previousFilter = character;
				this.filterTimer = this._delay( function() {
					delete this.previousFilter;
				}, 1000 );
			} else {
				delete this.previousFilter;
			}
		}

		if ( preventDefault ) {
			event.preventDefault();
		}
	},

	_activate: function( event ) {
		if ( this.active && !this.active.is( ".ui-state-disabled" ) ) {
			if ( this.active.children( "[aria-haspopup='true']" ).length ) {
				this.expand( event );
			} else {
				this.select( event );
			}
		}
	},

	refresh: function() {
		var menus, items, newSubmenus, newItems, newWrappers,
			that = this,
			icon = this.options.icons.submenu,
			submenus = this.element.find( this.options.menus );

		this._toggleClass( "ui-menu-icons", null, !!this.element.find( ".ui-icon" ).length );

		// Initialize nested menus
		newSubmenus = submenus.filter( ":not(.ui-menu)" )
			.hide()
			.attr( {
				role: this.options.role,
				"aria-hidden": "true",
				"aria-expanded": "false"
			} )
			.each( function() {
				var menu = $( this ),
					item = menu.prev(),
					submenuCaret = $( "<span>" ).data( "ui-menu-submenu-caret", true );

				that._addClass( submenuCaret, "ui-menu-icon", "ui-icon " + icon );
				item
					.attr( "aria-haspopup", "true" )
					.prepend( submenuCaret );
				menu.attr( "aria-labelledby", item.attr( "id" ) );
			} );

		this._addClass( newSubmenus, "ui-menu", "ui-widget ui-widget-content ui-front" );

		menus = submenus.add( this.element );
		items = menus.find( this.options.items );

		// Initialize menu-items containing spaces and/or dashes only as dividers
		items.not( ".ui-menu-item" ).each( function() {
			var item = $( this );
			if ( that._isDivider( item ) ) {
				that._addClass( item, "ui-menu-divider", "ui-widget-content" );
			}
		} );

		// Don't refresh list items that are already adapted
		newItems = items.not( ".ui-menu-item, .ui-menu-divider" );
		newWrappers = newItems.children()
			.not( ".ui-menu" )
				.uniqueId()
				.attr( {
					tabIndex: -1,
					role: this._itemRole()
				} );
		this._addClass( newItems, "ui-menu-item" )
			._addClass( newWrappers, "ui-menu-item-wrapper" );

		// Add aria-disabled attribute to any disabled menu item
		items.filter( ".ui-state-disabled" ).attr( "aria-disabled", "true" );

		// If the active item has been removed, blur the menu
		if ( this.active && !$.contains( this.element[ 0 ], this.active[ 0 ] ) ) {
			this.blur();
		}
	},

	_itemRole: function() {
		return {
			menu: "menuitem",
			listbox: "option"
		}[ this.options.role ];
	},

	_setOption: function( key, value ) {
		if ( key === "icons" ) {
			var icons = this.element.find( ".ui-menu-icon" );
			this._removeClass( icons, null, this.options.icons.submenu )
				._addClass( icons, null, value.submenu );
		}
		this._super( key, value );
	},

	_setOptionDisabled: function( value ) {
		this._super( value );

		this.element.attr( "aria-disabled", String( value ) );
		this._toggleClass( null, "ui-state-disabled", !!value );
	},

	focus: function( event, item ) {
		var nested, focused, activeParent;
		this.blur( event, event && event.type === "focus" );

		this._scrollIntoView( item );

		this.active = item.first();

		focused = this.active.children( ".ui-menu-item-wrapper" );
		this._addClass( focused, null, "ui-state-active" );

		// Only update aria-activedescendant if there's a role
		// otherwise we assume focus is managed elsewhere
		if ( this.options.role ) {
			this.element.attr( "aria-activedescendant", focused.attr( "id" ) );
		}

		// Highlight active parent menu item, if any
		activeParent = this.active
			.parent()
				.closest( ".ui-menu-item" )
					.children( ".ui-menu-item-wrapper" );
		this._addClass( activeParent, null, "ui-state-active" );

		if ( event && event.type === "keydown" ) {
			this._close();
		} else {
			this.timer = this._delay( function() {
				this._close();
			}, this.delay );
		}

		nested = item.children( ".ui-menu" );
		if ( nested.length && event && ( /^mouse/.test( event.type ) ) ) {
			this._startOpening( nested );
		}
		this.activeMenu = item.parent();

		this._trigger( "focus", event, { item: item } );
	},

	_scrollIntoView: function( item ) {
		var borderTop, paddingTop, offset, scroll, elementHeight, itemHeight;
		if ( this._hasScroll() ) {
			borderTop = parseFloat( $.css( this.activeMenu[ 0 ], "borderTopWidth" ) ) || 0;
			paddingTop = parseFloat( $.css( this.activeMenu[ 0 ], "paddingTop" ) ) || 0;
			offset = item.offset().top - this.activeMenu.offset().top - borderTop - paddingTop;
			scroll = this.activeMenu.scrollTop();
			elementHeight = this.activeMenu.height();
			itemHeight = item.outerHeight();

			if ( offset < 0 ) {
				this.activeMenu.scrollTop( scroll + offset );
			} else if ( offset + itemHeight > elementHeight ) {
				this.activeMenu.scrollTop( scroll + offset - elementHeight + itemHeight );
			}
		}
	},

	blur: function( event, fromFocus ) {
		if ( !fromFocus ) {
			clearTimeout( this.timer );
		}

		if ( !this.active ) {
			return;
		}

		this._removeClass( this.active.children( ".ui-menu-item-wrapper" ),
			null, "ui-state-active" );

		this._trigger( "blur", event, { item: this.active } );
		this.active = null;
	},

	_startOpening: function( submenu ) {
		clearTimeout( this.timer );

		// Don't open if already open fixes a Firefox bug that caused a .5 pixel
		// shift in the submenu position when mousing over the caret icon
		if ( submenu.attr( "aria-hidden" ) !== "true" ) {
			return;
		}

		this.timer = this._delay( function() {
			this._close();
			this._open( submenu );
		}, this.delay );
	},

	_open: function( submenu ) {
		var position = $.extend( {
			of: this.active
		}, this.options.position );

		clearTimeout( this.timer );
		this.element.find( ".ui-menu" ).not( submenu.parents( ".ui-menu" ) )
			.hide()
			.attr( "aria-hidden", "true" );

		submenu
			.show()
			.removeAttr( "aria-hidden" )
			.attr( "aria-expanded", "true" )
			.position( position );
	},

	collapseAll: function( event, all ) {
		clearTimeout( this.timer );
		this.timer = this._delay( function() {

			// If we were passed an event, look for the submenu that contains the event
			var currentMenu = all ? this.element :
				$( event && event.target ).closest( this.element.find( ".ui-menu" ) );

			// If we found no valid submenu ancestor, use the main menu to close all
			// sub menus anyway
			if ( !currentMenu.length ) {
				currentMenu = this.element;
			}

			this._close( currentMenu );

			this.blur( event );

			// Work around active item staying active after menu is blurred
			this._removeClass( currentMenu.find( ".ui-state-active" ), null, "ui-state-active" );

			this.activeMenu = currentMenu;
		}, this.delay );
	},

	// With no arguments, closes the currently active menu - if nothing is active
	// it closes all menus.  If passed an argument, it will search for menus BELOW
	_close: function( startMenu ) {
		if ( !startMenu ) {
			startMenu = this.active ? this.active.parent() : this.element;
		}

		startMenu.find( ".ui-menu" )
			.hide()
			.attr( "aria-hidden", "true" )
			.attr( "aria-expanded", "false" );
	},

	_closeOnDocumentClick: function( event ) {
		return !$( event.target ).closest( ".ui-menu" ).length;
	},

	_isDivider: function( item ) {

		// Match hyphen, em dash, en dash
		return !/[^\-\u2014\u2013\s]/.test( item.text() );
	},

	collapse: function( event ) {
		var newItem = this.active &&
			this.active.parent().closest( ".ui-menu-item", this.element );
		if ( newItem && newItem.length ) {
			this._close();
			this.focus( event, newItem );
		}
	},

	expand: function( event ) {
		var newItem = this.active &&
			this.active
				.children( ".ui-menu " )
					.find( this.options.items )
						.first();

		if ( newItem && newItem.length ) {
			this._open( newItem.parent() );

			// Delay so Firefox will not hide activedescendant change in expanding submenu from AT
			this._delay( function() {
				this.focus( event, newItem );
			} );
		}
	},

	next: function( event ) {
		this._move( "next", "first", event );
	},

	previous: function( event ) {
		this._move( "prev", "last", event );
	},

	isFirstItem: function() {
		return this.active && !this.active.prevAll( ".ui-menu-item" ).length;
	},

	isLastItem: function() {
		return this.active && !this.active.nextAll( ".ui-menu-item" ).length;
	},

	_move: function( direction, filter, event ) {
		var next;
		if ( this.active ) {
			if ( direction === "first" || direction === "last" ) {
				next = this.active
					[ direction === "first" ? "prevAll" : "nextAll" ]( ".ui-menu-item" )
					.eq( -1 );
			} else {
				next = this.active
					[ direction + "All" ]( ".ui-menu-item" )
					.eq( 0 );
			}
		}
		if ( !next || !next.length || !this.active ) {
			next = this.activeMenu.find( this.options.items )[ filter ]();
		}

		this.focus( event, next );
	},

	nextPage: function( event ) {
		var item, base, height;

		if ( !this.active ) {
			this.next( event );
			return;
		}
		if ( this.isLastItem() ) {
			return;
		}
		if ( this._hasScroll() ) {
			base = this.active.offset().top;
			height = this.element.height();
			this.active.nextAll( ".ui-menu-item" ).each( function() {
				item = $( this );
				return item.offset().top - base - height < 0;
			} );

			this.focus( event, item );
		} else {
			this.focus( event, this.activeMenu.find( this.options.items )
				[ !this.active ? "first" : "last" ]() );
		}
	},

	previousPage: function( event ) {
		var item, base, height;
		if ( !this.active ) {
			this.next( event );
			return;
		}
		if ( this.isFirstItem() ) {
			return;
		}
		if ( this._hasScroll() ) {
			base = this.active.offset().top;
			height = this.element.height();
			this.active.prevAll( ".ui-menu-item" ).each( function() {
				item = $( this );
				return item.offset().top - base + height > 0;
			} );

			this.focus( event, item );
		} else {
			this.focus( event, this.activeMenu.find( this.options.items ).first() );
		}
	},

	_hasScroll: function() {
		return this.element.outerHeight() < this.element.prop( "scrollHeight" );
	},

	select: function( event ) {

		// TODO: It should never be possible to not have an active item at this
		// point, but the tests don't trigger mouseenter before click.
		this.active = this.active || $( event.target ).closest( ".ui-menu-item" );
		var ui = { item: this.active };
		if ( !this.active.has( ".ui-menu" ).length ) {
			this.collapseAll( event, true );
		}
		this._trigger( "select", event, ui );
	},

	_filterMenuItems: function( character ) {
		var escapedCharacter = character.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&" ),
			regex = new RegExp( "^" + escapedCharacter, "i" );

		return this.activeMenu
			.find( this.options.items )

				// Only match on items, not dividers or other content (#10571)
				.filter( ".ui-menu-item" )
					.filter( function() {
						return regex.test(
							$.trim( $( this ).children( ".ui-menu-item-wrapper" ).text() ) );
					} );
	}
} );


/*!
 * jQuery UI Autocomplete 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Autocomplete
//>>group: Widgets
//>>description: Lists suggested words as the user is typing.
//>>docs: http://api.jqueryui.com/autocomplete/
//>>demos: http://jqueryui.com/autocomplete/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/autocomplete.css
//>>css.theme: ../../themes/base/theme.css



$.widget( "ui.autocomplete", {
	version: "1.12.1",
	defaultElement: "<input>",
	options: {
		appendTo: null,
		autoFocus: false,
		delay: 300,
		minLength: 1,
		position: {
			my: "left top",
			at: "left bottom",
			collision: "none"
		},
		source: null,

		// Callbacks
		change: null,
		close: null,
		focus: null,
		open: null,
		response: null,
		search: null,
		select: null
	},

	requestIndex: 0,
	pending: 0,

	_create: function() {

		// Some browsers only repeat keydown events, not keypress events,
		// so we use the suppressKeyPress flag to determine if we've already
		// handled the keydown event. #7269
		// Unfortunately the code for & in keypress is the same as the up arrow,
		// so we use the suppressKeyPressRepeat flag to avoid handling keypress
		// events when we know the keydown event was used to modify the
		// search term. #7799
		var suppressKeyPress, suppressKeyPressRepeat, suppressInput,
			nodeName = this.element[ 0 ].nodeName.toLowerCase(),
			isTextarea = nodeName === "textarea",
			isInput = nodeName === "input";

		// Textareas are always multi-line
		// Inputs are always single-line, even if inside a contentEditable element
		// IE also treats inputs as contentEditable
		// All other element types are determined by whether or not they're contentEditable
		this.isMultiLine = isTextarea || !isInput && this._isContentEditable( this.element );

		this.valueMethod = this.element[ isTextarea || isInput ? "val" : "text" ];
		this.isNewMenu = true;

		this._addClass( "ui-autocomplete-input" );
		this.element.attr( "autocomplete", "off" );

		this._on( this.element, {
			keydown: function( event ) {
				if ( this.element.prop( "readOnly" ) ) {
					suppressKeyPress = true;
					suppressInput = true;
					suppressKeyPressRepeat = true;
					return;
				}

				suppressKeyPress = false;
				suppressInput = false;
				suppressKeyPressRepeat = false;
				var keyCode = $.ui.keyCode;
				switch ( event.keyCode ) {
				case keyCode.PAGE_UP:
					suppressKeyPress = true;
					this._move( "previousPage", event );
					break;
				case keyCode.PAGE_DOWN:
					suppressKeyPress = true;
					this._move( "nextPage", event );
					break;
				case keyCode.UP:
					suppressKeyPress = true;
					this._keyEvent( "previous", event );
					break;
				case keyCode.DOWN:
					suppressKeyPress = true;
					this._keyEvent( "next", event );
					break;
				case keyCode.ENTER:

					// when menu is open and has focus
					if ( this.menu.active ) {

						// #6055 - Opera still allows the keypress to occur
						// which causes forms to submit
						suppressKeyPress = true;
						event.preventDefault();
						this.menu.select( event );
					}
					break;
				case keyCode.TAB:
					if ( this.menu.active ) {
						this.menu.select( event );
					}
					break;
				case keyCode.ESCAPE:
					if ( this.menu.element.is( ":visible" ) ) {
						if ( !this.isMultiLine ) {
							this._value( this.term );
						}
						this.close( event );

						// Different browsers have different default behavior for escape
						// Single press can mean undo or clear
						// Double press in IE means clear the whole form
						event.preventDefault();
					}
					break;
				default:
					suppressKeyPressRepeat = true;

					// search timeout should be triggered before the input value is changed
					this._searchTimeout( event );
					break;
				}
			},
			keypress: function( event ) {
				if ( suppressKeyPress ) {
					suppressKeyPress = false;
					if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {
						event.preventDefault();
					}
					return;
				}
				if ( suppressKeyPressRepeat ) {
					return;
				}

				// Replicate some key handlers to allow them to repeat in Firefox and Opera
				var keyCode = $.ui.keyCode;
				switch ( event.keyCode ) {
				case keyCode.PAGE_UP:
					this._move( "previousPage", event );
					break;
				case keyCode.PAGE_DOWN:
					this._move( "nextPage", event );
					break;
				case keyCode.UP:
					this._keyEvent( "previous", event );
					break;
				case keyCode.DOWN:
					this._keyEvent( "next", event );
					break;
				}
			},
			input: function( event ) {
				if ( suppressInput ) {
					suppressInput = false;
					event.preventDefault();
					return;
				}
				this._searchTimeout( event );
			},
			focus: function() {
				this.selectedItem = null;
				this.previous = this._value();
			},
			blur: function( event ) {
				if ( this.cancelBlur ) {
					delete this.cancelBlur;
					return;
				}

				clearTimeout( this.searching );
				this.close( event );
				this._change( event );
			}
		} );

		this._initSource();
		this.menu = $( "<ul>" )
			.appendTo( this._appendTo() )
			.menu( {

				// disable ARIA support, the live region takes care of that
				role: null
			} )
			.hide()
			.menu( "instance" );

		this._addClass( this.menu.element, "ui-autocomplete", "ui-front" );
		this._on( this.menu.element, {
			mousedown: function( event ) {

				// prevent moving focus out of the text field
				event.preventDefault();

				// IE doesn't prevent moving focus even with event.preventDefault()
				// so we set a flag to know when we should ignore the blur event
				this.cancelBlur = true;
				this._delay( function() {
					delete this.cancelBlur;

					// Support: IE 8 only
					// Right clicking a menu item or selecting text from the menu items will
					// result in focus moving out of the input. However, we've already received
					// and ignored the blur event because of the cancelBlur flag set above. So
					// we restore focus to ensure that the menu closes properly based on the user's
					// next actions.
					if ( this.element[ 0 ] !== $.ui.safeActiveElement( this.document[ 0 ] ) ) {
						this.element.trigger( "focus" );
					}
				} );
			},
			menufocus: function( event, ui ) {
				var label, item;

				// support: Firefox
				// Prevent accidental activation of menu items in Firefox (#7024 #9118)
				if ( this.isNewMenu ) {
					this.isNewMenu = false;
					if ( event.originalEvent && /^mouse/.test( event.originalEvent.type ) ) {
						this.menu.blur();

						this.document.one( "mousemove", function() {
							$( event.target ).trigger( event.originalEvent );
						} );

						return;
					}
				}

				item = ui.item.data( "ui-autocomplete-item" );
				if ( false !== this._trigger( "focus", event, { item: item } ) ) {

					// use value to match what will end up in the input, if it was a key event
					if ( event.originalEvent && /^key/.test( event.originalEvent.type ) ) {
						this._value( item.value );
					}
				}

				// Announce the value in the liveRegion
				label = ui.item.attr( "aria-label" ) || item.value;
				if ( label && $.trim( label ).length ) {
					this.liveRegion.children().hide();
					$( "<div>" ).text( label ).appendTo( this.liveRegion );
				}
			},
			menuselect: function( event, ui ) {
				var item = ui.item.data( "ui-autocomplete-item" ),
					previous = this.previous;

				// Only trigger when focus was lost (click on menu)
				if ( this.element[ 0 ] !== $.ui.safeActiveElement( this.document[ 0 ] ) ) {
					this.element.trigger( "focus" );
					this.previous = previous;

					// #6109 - IE triggers two focus events and the second
					// is asynchronous, so we need to reset the previous
					// term synchronously and asynchronously :-(
					this._delay( function() {
						this.previous = previous;
						this.selectedItem = item;
					} );
				}

				if ( false !== this._trigger( "select", event, { item: item } ) ) {
					this._value( item.value );
				}

				// reset the term after the select event
				// this allows custom select handling to work properly
				this.term = this._value();

				this.close( event );
				this.selectedItem = item;
			}
		} );

		this.liveRegion = $( "<div>", {
			role: "status",
			"aria-live": "assertive",
			"aria-relevant": "additions"
		} )
			.appendTo( this.document[ 0 ].body );

		this._addClass( this.liveRegion, null, "ui-helper-hidden-accessible" );

		// Turning off autocomplete prevents the browser from remembering the
		// value when navigating through history, so we re-enable autocomplete
		// if the page is unloaded before the widget is destroyed. #7790
		this._on( this.window, {
			beforeunload: function() {
				this.element.removeAttr( "autocomplete" );
			}
		} );
	},

	_destroy: function() {
		clearTimeout( this.searching );
		this.element.removeAttr( "autocomplete" );
		this.menu.element.remove();
		this.liveRegion.remove();
	},

	_setOption: function( key, value ) {
		this._super( key, value );
		if ( key === "source" ) {
			this._initSource();
		}
		if ( key === "appendTo" ) {
			this.menu.element.appendTo( this._appendTo() );
		}
		if ( key === "disabled" && value && this.xhr ) {
			this.xhr.abort();
		}
	},

	_isEventTargetInWidget: function( event ) {
		var menuElement = this.menu.element[ 0 ];

		return event.target === this.element[ 0 ] ||
			event.target === menuElement ||
			$.contains( menuElement, event.target );
	},

	_closeOnClickOutside: function( event ) {
		if ( !this._isEventTargetInWidget( event ) ) {
			this.close();
		}
	},

	_appendTo: function() {
		var element = this.options.appendTo;

		if ( element ) {
			element = element.jquery || element.nodeType ?
				$( element ) :
				this.document.find( element ).eq( 0 );
		}

		if ( !element || !element[ 0 ] ) {
			element = this.element.closest( ".ui-front, dialog" );
		}

		if ( !element.length ) {
			element = this.document[ 0 ].body;
		}

		return element;
	},

	_initSource: function() {
		var array, url,
			that = this;
		if ( $.isArray( this.options.source ) ) {
			array = this.options.source;
			this.source = function( request, response ) {
				response( $.ui.autocomplete.filter( array, request.term ) );
			};
		} else if ( typeof this.options.source === "string" ) {
			url = this.options.source;
			this.source = function( request, response ) {
				if ( that.xhr ) {
					that.xhr.abort();
				}
				that.xhr = $.ajax( {
					url: url,
					data: request,
					dataType: "json",
					success: function( data ) {
						response( data );
					},
					error: function() {
						response( [] );
					}
				} );
			};
		} else {
			this.source = this.options.source;
		}
	},

	_searchTimeout: function( event ) {
		clearTimeout( this.searching );
		this.searching = this._delay( function() {

			// Search if the value has changed, or if the user retypes the same value (see #7434)
			var equalValues = this.term === this._value(),
				menuVisible = this.menu.element.is( ":visible" ),
				modifierKey = event.altKey || event.ctrlKey || event.metaKey || event.shiftKey;

			if ( !equalValues || ( equalValues && !menuVisible && !modifierKey ) ) {
				this.selectedItem = null;
				this.search( null, event );
			}
		}, this.options.delay );
	},

	search: function( value, event ) {
		value = value != null ? value : this._value();

		// Always save the actual value, not the one passed as an argument
		this.term = this._value();

		if ( value.length < this.options.minLength ) {
			return this.close( event );
		}

		if ( this._trigger( "search", event ) === false ) {
			return;
		}

		return this._search( value );
	},

	_search: function( value ) {
		this.pending++;
		this._addClass( "ui-autocomplete-loading" );
		this.cancelSearch = false;

		this.source( { term: value }, this._response() );
	},

	_response: function() {
		var index = ++this.requestIndex;

		return $.proxy( function( content ) {
			if ( index === this.requestIndex ) {
				this.__response( content );
			}

			this.pending--;
			if ( !this.pending ) {
				this._removeClass( "ui-autocomplete-loading" );
			}
		}, this );
	},

	__response: function( content ) {
		if ( content ) {
			content = this._normalize( content );
		}
		this._trigger( "response", null, { content: content } );
		if ( !this.options.disabled && content && content.length && !this.cancelSearch ) {
			this._suggest( content );
			this._trigger( "open" );
		} else {

			// use ._close() instead of .close() so we don't cancel future searches
			this._close();
		}
	},

	close: function( event ) {
		this.cancelSearch = true;
		this._close( event );
	},

	_close: function( event ) {

		// Remove the handler that closes the menu on outside clicks
		this._off( this.document, "mousedown" );

		if ( this.menu.element.is( ":visible" ) ) {
			this.menu.element.hide();
			this.menu.blur();
			this.isNewMenu = true;
			this._trigger( "close", event );
		}
	},

	_change: function( event ) {
		if ( this.previous !== this._value() ) {
			this._trigger( "change", event, { item: this.selectedItem } );
		}
	},

	_normalize: function( items ) {

		// assume all items have the right format when the first item is complete
		if ( items.length && items[ 0 ].label && items[ 0 ].value ) {
			return items;
		}
		return $.map( items, function( item ) {
			if ( typeof item === "string" ) {
				return {
					label: item,
					value: item
				};
			}
			return $.extend( {}, item, {
				label: item.label || item.value,
				value: item.value || item.label
			} );
		} );
	},

	_suggest: function( items ) {
		var ul = this.menu.element.empty();
		this._renderMenu( ul, items );
		this.isNewMenu = true;
		this.menu.refresh();

		// Size and position menu
		ul.show();
		this._resizeMenu();
		ul.position( $.extend( {
			of: this.element
		}, this.options.position ) );

		if ( this.options.autoFocus ) {
			this.menu.next();
		}

		// Listen for interactions outside of the widget (#6642)
		this._on( this.document, {
			mousedown: "_closeOnClickOutside"
		} );
	},

	_resizeMenu: function() {
		var ul = this.menu.element;
		ul.outerWidth( Math.max(

			// Firefox wraps long text (possibly a rounding bug)
			// so we add 1px to avoid the wrapping (#7513)
			ul.width( "" ).outerWidth() + 1,
			this.element.outerWidth()
		) );
	},

	_renderMenu: function( ul, items ) {
		var that = this;
		$.each( items, function( index, item ) {
			that._renderItemData( ul, item );
		} );
	},

	_renderItemData: function( ul, item ) {
		return this._renderItem( ul, item ).data( "ui-autocomplete-item", item );
	},

	_renderItem: function( ul, item ) {
		return $( "<li>" )
			.append( $( "<div>" ).text( item.label ) )
			.appendTo( ul );
	},

	_move: function( direction, event ) {
		if ( !this.menu.element.is( ":visible" ) ) {
			this.search( null, event );
			return;
		}
		if ( this.menu.isFirstItem() && /^previous/.test( direction ) ||
				this.menu.isLastItem() && /^next/.test( direction ) ) {

			if ( !this.isMultiLine ) {
				this._value( this.term );
			}

			this.menu.blur();
			return;
		}
		this.menu[ direction ]( event );
	},

	widget: function() {
		return this.menu.element;
	},

	_value: function() {
		return this.valueMethod.apply( this.element, arguments );
	},

	_keyEvent: function( keyEvent, event ) {
		if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {
			this._move( keyEvent, event );

			// Prevents moving cursor to beginning/end of the text field in some browsers
			event.preventDefault();
		}
	},

	// Support: Chrome <=50
	// We should be able to just use this.element.prop( "isContentEditable" )
	// but hidden elements always report false in Chrome.
	// https://code.google.com/p/chromium/issues/detail?id=313082
	_isContentEditable: function( element ) {
		if ( !element.length ) {
			return false;
		}

		var editable = element.prop( "contentEditable" );

		if ( editable === "inherit" ) {
		  return this._isContentEditable( element.parent() );
		}

		return editable === "true";
	}
} );

$.extend( $.ui.autocomplete, {
	escapeRegex: function( value ) {
		return value.replace( /[\-\[\]{}()*+?.,\\\^$|#\s]/g, "\\$&" );
	},
	filter: function( array, term ) {
		var matcher = new RegExp( $.ui.autocomplete.escapeRegex( term ), "i" );
		return $.grep( array, function( value ) {
			return matcher.test( value.label || value.value || value );
		} );
	}
} );

// Live region extension, adding a `messages` option
// NOTE: This is an experimental API. We are still investigating
// a full solution for string manipulation and internationalization.
$.widget( "ui.autocomplete", $.ui.autocomplete, {
	options: {
		messages: {
			noResults: "No search results.",
			results: function( amount ) {
				return amount + ( amount > 1 ? " results are" : " result is" ) +
					" available, use up and down arrow keys to navigate.";
			}
		}
	},

	__response: function( content ) {
		var message;
		this._superApply( arguments );
		if ( this.options.disabled || this.cancelSearch ) {
			return;
		}
		if ( content && content.length ) {
			message = this.options.messages.results( content.length );
		} else {
			message = this.options.messages.noResults;
		}
		this.liveRegion.children().hide();
		$( "<div>" ).text( message ).appendTo( this.liveRegion );
	}
} );

var widgetsAutocomplete = $.ui.autocomplete;


/*!
 * jQuery UI Controlgroup 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Controlgroup
//>>group: Widgets
//>>description: Visually groups form control widgets
//>>docs: http://api.jqueryui.com/controlgroup/
//>>demos: http://jqueryui.com/controlgroup/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/controlgroup.css
//>>css.theme: ../../themes/base/theme.css


var controlgroupCornerRegex = /ui-corner-([a-z]){2,6}/g;

var widgetsControlgroup = $.widget( "ui.controlgroup", {
	version: "1.12.1",
	defaultElement: "<div>",
	options: {
		direction: "horizontal",
		disabled: null,
		onlyVisible: true,
		items: {
			"button": "input[type=button], input[type=submit], input[type=reset], button, a",
			"controlgroupLabel": ".ui-controlgroup-label",
			"checkboxradio": "input[type='checkbox'], input[type='radio']",
			"selectmenu": "select",
			"spinner": ".ui-spinner-input"
		}
	},

	_create: function() {
		this._enhance();
	},

	// To support the enhanced option in jQuery Mobile, we isolate DOM manipulation
	_enhance: function() {
		this.element.attr( "role", "toolbar" );
		this.refresh();
	},

	_destroy: function() {
		this._callChildMethod( "destroy" );
		this.childWidgets.removeData( "ui-controlgroup-data" );
		this.element.removeAttr( "role" );
		if ( this.options.items.controlgroupLabel ) {
			this.element
				.find( this.options.items.controlgroupLabel )
				.find( ".ui-controlgroup-label-contents" )
				.contents().unwrap();
		}
	},

	_initWidgets: function() {
		var that = this,
			childWidgets = [];

		// First we iterate over each of the items options
		$.each( this.options.items, function( widget, selector ) {
			var labels;
			var options = {};

			// Make sure the widget has a selector set
			if ( !selector ) {
				return;
			}

			if ( widget === "controlgroupLabel" ) {
				labels = that.element.find( selector );
				labels.each( function() {
					var element = $( this );

					if ( element.children( ".ui-controlgroup-label-contents" ).length ) {
						return;
					}
					element.contents()
						.wrapAll( "<span class='ui-controlgroup-label-contents'></span>" );
				} );
				that._addClass( labels, null, "ui-widget ui-widget-content ui-state-default" );
				childWidgets = childWidgets.concat( labels.get() );
				return;
			}

			// Make sure the widget actually exists
			if ( !$.fn[ widget ] ) {
				return;
			}

			// We assume everything is in the middle to start because we can't determine
			// first / last elements until all enhancments are done.
			if ( that[ "_" + widget + "Options" ] ) {
				options = that[ "_" + widget + "Options" ]( "middle" );
			} else {
				options = { classes: {} };
			}

			// Find instances of this widget inside controlgroup and init them
			that.element
				.find( selector )
				.each( function() {
					var element = $( this );
					var instance = element[ widget ]( "instance" );

					// We need to clone the default options for this type of widget to avoid
					// polluting the variable options which has a wider scope than a single widget.
					var instanceOptions = $.widget.extend( {}, options );

					// If the button is the child of a spinner ignore it
					// TODO: Find a more generic solution
					if ( widget === "button" && element.parent( ".ui-spinner" ).length ) {
						return;
					}

					// Create the widget if it doesn't exist
					if ( !instance ) {
						instance = element[ widget ]()[ widget ]( "instance" );
					}
					if ( instance ) {
						instanceOptions.classes =
							that._resolveClassesValues( instanceOptions.classes, instance );
					}
					element[ widget ]( instanceOptions );

					// Store an instance of the controlgroup to be able to reference
					// from the outermost element for changing options and refresh
					var widgetElement = element[ widget ]( "widget" );
					$.data( widgetElement[ 0 ], "ui-controlgroup-data",
						instance ? instance : element[ widget ]( "instance" ) );

					childWidgets.push( widgetElement[ 0 ] );
				} );
		} );

		this.childWidgets = $( $.uniqueSort( childWidgets ) );
		this._addClass( this.childWidgets, "ui-controlgroup-item" );
	},

	_callChildMethod: function( method ) {
		this.childWidgets.each( function() {
			var element = $( this ),
				data = element.data( "ui-controlgroup-data" );
			if ( data && data[ method ] ) {
				data[ method ]();
			}
		} );
	},

	_updateCornerClass: function( element, position ) {
		var remove = "ui-corner-top ui-corner-bottom ui-corner-left ui-corner-right ui-corner-all";
		var add = this._buildSimpleOptions( position, "label" ).classes.label;

		this._removeClass( element, null, remove );
		this._addClass( element, null, add );
	},

	_buildSimpleOptions: function( position, key ) {
		var direction = this.options.direction === "vertical";
		var result = {
			classes: {}
		};
		result.classes[ key ] = {
			"middle": "",
			"first": "ui-corner-" + ( direction ? "top" : "left" ),
			"last": "ui-corner-" + ( direction ? "bottom" : "right" ),
			"only": "ui-corner-all"
		}[ position ];

		return result;
	},

	_spinnerOptions: function( position ) {
		var options = this._buildSimpleOptions( position, "ui-spinner" );

		options.classes[ "ui-spinner-up" ] = "";
		options.classes[ "ui-spinner-down" ] = "";

		return options;
	},

	_buttonOptions: function( position ) {
		return this._buildSimpleOptions( position, "ui-button" );
	},

	_checkboxradioOptions: function( position ) {
		return this._buildSimpleOptions( position, "ui-checkboxradio-label" );
	},

	_selectmenuOptions: function( position ) {
		var direction = this.options.direction === "vertical";
		return {
			width: direction ? "auto" : false,
			classes: {
				middle: {
					"ui-selectmenu-button-open": "",
					"ui-selectmenu-button-closed": ""
				},
				first: {
					"ui-selectmenu-button-open": "ui-corner-" + ( direction ? "top" : "tl" ),
					"ui-selectmenu-button-closed": "ui-corner-" + ( direction ? "top" : "left" )
				},
				last: {
					"ui-selectmenu-button-open": direction ? "" : "ui-corner-tr",
					"ui-selectmenu-button-closed": "ui-corner-" + ( direction ? "bottom" : "right" )
				},
				only: {
					"ui-selectmenu-button-open": "ui-corner-top",
					"ui-selectmenu-button-closed": "ui-corner-all"
				}

			}[ position ]
		};
	},

	_resolveClassesValues: function( classes, instance ) {
		var result = {};
		$.each( classes, function( key ) {
			var current = instance.options.classes[ key ] || "";
			current = $.trim( current.replace( controlgroupCornerRegex, "" ) );
			result[ key ] = ( current + " " + classes[ key ] ).replace( /\s+/g, " " );
		} );
		return result;
	},

	_setOption: function( key, value ) {
		if ( key === "direction" ) {
			this._removeClass( "ui-controlgroup-" + this.options.direction );
		}

		this._super( key, value );
		if ( key === "disabled" ) {
			this._callChildMethod( value ? "disable" : "enable" );
			return;
		}

		this.refresh();
	},

	refresh: function() {
		var children,
			that = this;

		this._addClass( "ui-controlgroup ui-controlgroup-" + this.options.direction );

		if ( this.options.direction === "horizontal" ) {
			this._addClass( null, "ui-helper-clearfix" );
		}
		this._initWidgets();

		children = this.childWidgets;

		// We filter here because we need to track all childWidgets not just the visible ones
		if ( this.options.onlyVisible ) {
			children = children.filter( ":visible" );
		}

		if ( children.length ) {

			// We do this last because we need to make sure all enhancment is done
			// before determining first and last
			$.each( [ "first", "last" ], function( index, value ) {
				var instance = children[ value ]().data( "ui-controlgroup-data" );

				if ( instance && that[ "_" + instance.widgetName + "Options" ] ) {
					var options = that[ "_" + instance.widgetName + "Options" ](
						children.length === 1 ? "only" : value
					);
					options.classes = that._resolveClassesValues( options.classes, instance );
					instance.element[ instance.widgetName ]( options );
				} else {
					that._updateCornerClass( children[ value ](), value );
				}
			} );

			// Finally call the refresh method on each of the child widgets.
			this._callChildMethod( "refresh" );
		}
	}
} );

/*!
 * jQuery UI Checkboxradio 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Checkboxradio
//>>group: Widgets
//>>description: Enhances a form with multiple themeable checkboxes or radio buttons.
//>>docs: http://api.jqueryui.com/checkboxradio/
//>>demos: http://jqueryui.com/checkboxradio/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/button.css
//>>css.structure: ../../themes/base/checkboxradio.css
//>>css.theme: ../../themes/base/theme.css



$.widget( "ui.checkboxradio", [ $.ui.formResetMixin, {
	version: "1.12.1",
	options: {
		disabled: null,
		label: null,
		icon: true,
		classes: {
			"ui-checkboxradio-label": "ui-corner-all",
			"ui-checkboxradio-icon": "ui-corner-all"
		}
	},

	_getCreateOptions: function() {
		var disabled, labels;
		var that = this;
		var options = this._super() || {};

		// We read the type here, because it makes more sense to throw a element type error first,
		// rather then the error for lack of a label. Often if its the wrong type, it
		// won't have a label (e.g. calling on a div, btn, etc)
		this._readType();

		labels = this.element.labels();

		// If there are multiple labels, use the last one
		this.label = $( labels[ labels.length - 1 ] );
		if ( !this.label.length ) {
			$.error( "No label found for checkboxradio widget" );
		}

		this.originalLabel = "";

		// We need to get the label text but this may also need to make sure it does not contain the
		// input itself.
		this.label.contents().not( this.element[ 0 ] ).each( function() {

			// The label contents could be text, html, or a mix. We concat each element to get a
			// string representation of the label, without the input as part of it.
			that.originalLabel += this.nodeType === 3 ? $( this ).text() : this.outerHTML;
		} );

		// Set the label option if we found label text
		if ( this.originalLabel ) {
			options.label = this.originalLabel;
		}

		disabled = this.element[ 0 ].disabled;
		if ( disabled != null ) {
			options.disabled = disabled;
		}
		return options;
	},

	_create: function() {
		var checked = this.element[ 0 ].checked;

		this._bindFormResetHandler();

		if ( this.options.disabled == null ) {
			this.options.disabled = this.element[ 0 ].disabled;
		}

		this._setOption( "disabled", this.options.disabled );
		this._addClass( "ui-checkboxradio", "ui-helper-hidden-accessible" );
		this._addClass( this.label, "ui-checkboxradio-label", "ui-button ui-widget" );

		if ( this.type === "radio" ) {
			this._addClass( this.label, "ui-checkboxradio-radio-label" );
		}

		if ( this.options.label && this.options.label !== this.originalLabel ) {
			this._updateLabel();
		} else if ( this.originalLabel ) {
			this.options.label = this.originalLabel;
		}

		this._enhance();

		if ( checked ) {
			this._addClass( this.label, "ui-checkboxradio-checked", "ui-state-active" );
			if ( this.icon ) {
				this._addClass( this.icon, null, "ui-state-hover" );
			}
		}

		this._on( {
			change: "_toggleClasses",
			focus: function() {
				this._addClass( this.label, null, "ui-state-focus ui-visual-focus" );
			},
			blur: function() {
				this._removeClass( this.label, null, "ui-state-focus ui-visual-focus" );
			}
		} );
	},

	_readType: function() {
		var nodeName = this.element[ 0 ].nodeName.toLowerCase();
		this.type = this.element[ 0 ].type;
		if ( nodeName !== "input" || !/radio|checkbox/.test( this.type ) ) {
			$.error( "Can't create checkboxradio on element.nodeName=" + nodeName +
				" and element.type=" + this.type );
		}
	},

	// Support jQuery Mobile enhanced option
	_enhance: function() {
		this._updateIcon( this.element[ 0 ].checked );
	},

	widget: function() {
		return this.label;
	},

	_getRadioGroup: function() {
		var group;
		var name = this.element[ 0 ].name;
		var nameSelector = "input[name='" + $.ui.escapeSelector( name ) + "']";

		if ( !name ) {
			return $( [] );
		}

		if ( this.form.length ) {
			group = $( this.form[ 0 ].elements ).filter( nameSelector );
		} else {

			// Not inside a form, check all inputs that also are not inside a form
			group = $( nameSelector ).filter( function() {
				return $( this ).form().length === 0;
			} );
		}

		return group.not( this.element );
	},

	_toggleClasses: function() {
		var checked = this.element[ 0 ].checked;
		this._toggleClass( this.label, "ui-checkboxradio-checked", "ui-state-active", checked );

		if ( this.options.icon && this.type === "checkbox" ) {
			this._toggleClass( this.icon, null, "ui-icon-check ui-state-checked", checked )
				._toggleClass( this.icon, null, "ui-icon-blank", !checked );
		}

		if ( this.type === "radio" ) {
			this._getRadioGroup()
				.each( function() {
					var instance = $( this ).checkboxradio( "instance" );

					if ( instance ) {
						instance._removeClass( instance.label,
							"ui-checkboxradio-checked", "ui-state-active" );
					}
				} );
		}
	},

	_destroy: function() {
		this._unbindFormResetHandler();

		if ( this.icon ) {
			this.icon.remove();
			this.iconSpace.remove();
		}
	},

	_setOption: function( key, value ) {

		// We don't allow the value to be set to nothing
		if ( key === "label" && !value ) {
			return;
		}

		this._super( key, value );

		if ( key === "disabled" ) {
			this._toggleClass( this.label, null, "ui-state-disabled", value );
			this.element[ 0 ].disabled = value;

			// Don't refresh when setting disabled
			return;
		}
		this.refresh();
	},

	_updateIcon: function( checked ) {
		var toAdd = "ui-icon ui-icon-background ";

		if ( this.options.icon ) {
			if ( !this.icon ) {
				this.icon = $( "<span>" );
				this.iconSpace = $( "<span> </span>" );
				this._addClass( this.iconSpace, "ui-checkboxradio-icon-space" );
			}

			if ( this.type === "checkbox" ) {
				toAdd += checked ? "ui-icon-check ui-state-checked" : "ui-icon-blank";
				this._removeClass( this.icon, null, checked ? "ui-icon-blank" : "ui-icon-check" );
			} else {
				toAdd += "ui-icon-blank";
			}
			this._addClass( this.icon, "ui-checkboxradio-icon", toAdd );
			if ( !checked ) {
				this._removeClass( this.icon, null, "ui-icon-check ui-state-checked" );
			}
			this.icon.prependTo( this.label ).after( this.iconSpace );
		} else if ( this.icon !== undefined ) {
			this.icon.remove();
			this.iconSpace.remove();
			delete this.icon;
		}
	},

	_updateLabel: function() {

		// Remove the contents of the label ( minus the icon, icon space, and input )
		var contents = this.label.contents().not( this.element[ 0 ] );
		if ( this.icon ) {
			contents = contents.not( this.icon[ 0 ] );
		}
		if ( this.iconSpace ) {
			contents = contents.not( this.iconSpace[ 0 ] );
		}
		contents.remove();

		this.label.append( this.options.label );
	},

	refresh: function() {
		var checked = this.element[ 0 ].checked,
			isDisabled = this.element[ 0 ].disabled;

		this._updateIcon( checked );
		this._toggleClass( this.label, "ui-checkboxradio-checked", "ui-state-active", checked );
		if ( this.options.label !== null ) {
			this._updateLabel();
		}

		if ( isDisabled !== this.options.disabled ) {
			this._setOptions( { "disabled": isDisabled } );
		}
	}

} ] );

var widgetsCheckboxradio = $.ui.checkboxradio;


/*!
 * jQuery UI Button 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Button
//>>group: Widgets
//>>description: Enhances a form with themeable buttons.
//>>docs: http://api.jqueryui.com/button/
//>>demos: http://jqueryui.com/button/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/button.css
//>>css.theme: ../../themes/base/theme.css



$.widget( "ui.button", {
	version: "1.12.1",
	defaultElement: "<button>",
	options: {
		classes: {
			"ui-button": "ui-corner-all"
		},
		disabled: null,
		icon: null,
		iconPosition: "beginning",
		label: null,
		showLabel: true
	},

	_getCreateOptions: function() {
		var disabled,

			// This is to support cases like in jQuery Mobile where the base widget does have
			// an implementation of _getCreateOptions
			options = this._super() || {};

		this.isInput = this.element.is( "input" );

		disabled = this.element[ 0 ].disabled;
		if ( disabled != null ) {
			options.disabled = disabled;
		}

		this.originalLabel = this.isInput ? this.element.val() : this.element.html();
		if ( this.originalLabel ) {
			options.label = this.originalLabel;
		}

		return options;
	},

	_create: function() {
		if ( !this.option.showLabel & !this.options.icon ) {
			this.options.showLabel = true;
		}

		// We have to check the option again here even though we did in _getCreateOptions,
		// because null may have been passed on init which would override what was set in
		// _getCreateOptions
		if ( this.options.disabled == null ) {
			this.options.disabled = this.element[ 0 ].disabled || false;
		}

		this.hasTitle = !!this.element.attr( "title" );

		// Check to see if the label needs to be set or if its already correct
		if ( this.options.label && this.options.label !== this.originalLabel ) {
			if ( this.isInput ) {
				this.element.val( this.options.label );
			} else {
				this.element.html( this.options.label );
			}
		}
		this._addClass( "ui-button", "ui-widget" );
		this._setOption( "disabled", this.options.disabled );
		this._enhance();

		if ( this.element.is( "a" ) ) {
			this._on( {
				"keyup": function( event ) {
					if ( event.keyCode === $.ui.keyCode.SPACE ) {
						event.preventDefault();

						// Support: PhantomJS <= 1.9, IE 8 Only
						// If a native click is available use it so we actually cause navigation
						// otherwise just trigger a click event
						if ( this.element[ 0 ].click ) {
							this.element[ 0 ].click();
						} else {
							this.element.trigger( "click" );
						}
					}
				}
			} );
		}
	},

	_enhance: function() {
		if ( !this.element.is( "button" ) ) {
			this.element.attr( "role", "button" );
		}

		if ( this.options.icon ) {
			this._updateIcon( "icon", this.options.icon );
			this._updateTooltip();
		}
	},

	_updateTooltip: function() {
		this.title = this.element.attr( "title" );

		if ( !this.options.showLabel && !this.title ) {
			this.element.attr( "title", this.options.label );
		}
	},

	_updateIcon: function( option, value ) {
		var icon = option !== "iconPosition",
			position = icon ? this.options.iconPosition : value,
			displayBlock = position === "top" || position === "bottom";

		// Create icon
		if ( !this.icon ) {
			this.icon = $( "<span>" );

			this._addClass( this.icon, "ui-button-icon", "ui-icon" );

			if ( !this.options.showLabel ) {
				this._addClass( "ui-button-icon-only" );
			}
		} else if ( icon ) {

			// If we are updating the icon remove the old icon class
			this._removeClass( this.icon, null, this.options.icon );
		}

		// If we are updating the icon add the new icon class
		if ( icon ) {
			this._addClass( this.icon, null, value );
		}

		this._attachIcon( position );

		// If the icon is on top or bottom we need to add the ui-widget-icon-block class and remove
		// the iconSpace if there is one.
		if ( displayBlock ) {
			this._addClass( this.icon, null, "ui-widget-icon-block" );
			if ( this.iconSpace ) {
				this.iconSpace.remove();
			}
		} else {

			// Position is beginning or end so remove the ui-widget-icon-block class and add the
			// space if it does not exist
			if ( !this.iconSpace ) {
				this.iconSpace = $( "<span> </span>" );
				this._addClass( this.iconSpace, "ui-button-icon-space" );
			}
			this._removeClass( this.icon, null, "ui-wiget-icon-block" );
			this._attachIconSpace( position );
		}
	},

	_destroy: function() {
		this.element.removeAttr( "role" );

		if ( this.icon ) {
			this.icon.remove();
		}
		if ( this.iconSpace ) {
			this.iconSpace.remove();
		}
		if ( !this.hasTitle ) {
			this.element.removeAttr( "title" );
		}
	},

	_attachIconSpace: function( iconPosition ) {
		this.icon[ /^(?:end|bottom)/.test( iconPosition ) ? "before" : "after" ]( this.iconSpace );
	},

	_attachIcon: function( iconPosition ) {
		this.element[ /^(?:end|bottom)/.test( iconPosition ) ? "append" : "prepend" ]( this.icon );
	},

	_setOptions: function( options ) {
		var newShowLabel = options.showLabel === undefined ?
				this.options.showLabel :
				options.showLabel,
			newIcon = options.icon === undefined ? this.options.icon : options.icon;

		if ( !newShowLabel && !newIcon ) {
			options.showLabel = true;
		}
		this._super( options );
	},

	_setOption: function( key, value ) {
		if ( key === "icon" ) {
			if ( value ) {
				this._updateIcon( key, value );
			} else if ( this.icon ) {
				this.icon.remove();
				if ( this.iconSpace ) {
					this.iconSpace.remove();
				}
			}
		}

		if ( key === "iconPosition" ) {
			this._updateIcon( key, value );
		}

		// Make sure we can't end up with a button that has neither text nor icon
		if ( key === "showLabel" ) {
				this._toggleClass( "ui-button-icon-only", null, !value );
				this._updateTooltip();
		}

		if ( key === "label" ) {
			if ( this.isInput ) {
				this.element.val( value );
			} else {

				// If there is an icon, append it, else nothing then append the value
				// this avoids removal of the icon when setting label text
				this.element.html( value );
				if ( this.icon ) {
					this._attachIcon( this.options.iconPosition );
					this._attachIconSpace( this.options.iconPosition );
				}
			}
		}

		this._super( key, value );

		if ( key === "disabled" ) {
			this._toggleClass( null, "ui-state-disabled", value );
			this.element[ 0 ].disabled = value;
			if ( value ) {
				this.element.blur();
			}
		}
	},

	refresh: function() {

		// Make sure to only check disabled if its an element that supports this otherwise
		// check for the disabled class to determine state
		var isDisabled = this.element.is( "input, button" ) ?
			this.element[ 0 ].disabled : this.element.hasClass( "ui-button-disabled" );

		if ( isDisabled !== this.options.disabled ) {
			this._setOptions( { disabled: isDisabled } );
		}

		this._updateTooltip();
	}
} );

// DEPRECATED
if ( $.uiBackCompat !== false ) {

	// Text and Icons options
	$.widget( "ui.button", $.ui.button, {
		options: {
			text: true,
			icons: {
				primary: null,
				secondary: null
			}
		},

		_create: function() {
			if ( this.options.showLabel && !this.options.text ) {
				this.options.showLabel = this.options.text;
			}
			if ( !this.options.showLabel && this.options.text ) {
				this.options.text = this.options.showLabel;
			}
			if ( !this.options.icon && ( this.options.icons.primary ||
					this.options.icons.secondary ) ) {
				if ( this.options.icons.primary ) {
					this.options.icon = this.options.icons.primary;
				} else {
					this.options.icon = this.options.icons.secondary;
					this.options.iconPosition = "end";
				}
			} else if ( this.options.icon ) {
				this.options.icons.primary = this.options.icon;
			}
			this._super();
		},

		_setOption: function( key, value ) {
			if ( key === "text" ) {
				this._super( "showLabel", value );
				return;
			}
			if ( key === "showLabel" ) {
				this.options.text = value;
			}
			if ( key === "icon" ) {
				this.options.icons.primary = value;
			}
			if ( key === "icons" ) {
				if ( value.primary ) {
					this._super( "icon", value.primary );
					this._super( "iconPosition", "beginning" );
				} else if ( value.secondary ) {
					this._super( "icon", value.secondary );
					this._super( "iconPosition", "end" );
				}
			}
			this._superApply( arguments );
		}
	} );

	$.fn.button = ( function( orig ) {
		return function() {
			if ( !this.length || ( this.length && this[ 0 ].tagName !== "INPUT" ) ||
					( this.length && this[ 0 ].tagName === "INPUT" && (
						this.attr( "type" ) !== "checkbox" && this.attr( "type" ) !== "radio"
					) ) ) {
				return orig.apply( this, arguments );
			}
			if ( !$.ui.checkboxradio ) {
				$.error( "Checkboxradio widget missing" );
			}
			if ( arguments.length === 0 ) {
				return this.checkboxradio( {
					"icon": false
				} );
			}
			return this.checkboxradio.apply( this, arguments );
		};
	} )( $.fn.button );

	$.fn.buttonset = function() {
		if ( !$.ui.controlgroup ) {
			$.error( "Controlgroup widget missing" );
		}
		if ( arguments[ 0 ] === "option" && arguments[ 1 ] === "items" && arguments[ 2 ] ) {
			return this.controlgroup.apply( this,
				[ arguments[ 0 ], "items.button", arguments[ 2 ] ] );
		}
		if ( arguments[ 0 ] === "option" && arguments[ 1 ] === "items" ) {
			return this.controlgroup.apply( this, [ arguments[ 0 ], "items.button" ] );
		}
		if ( typeof arguments[ 0 ] === "object" && arguments[ 0 ].items ) {
			arguments[ 0 ].items = {
				button: arguments[ 0 ].items
			};
		}
		return this.controlgroup.apply( this, arguments );
	};
}

var widgetsButton = $.ui.button;


// jscs:disable maximumLineLength
/* jscs:disable requireCamelCaseOrUpperCaseIdentifiers */
/*!
 * jQuery UI Datepicker 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Datepicker
//>>group: Widgets
//>>description: Displays a calendar from an input or inline for selecting dates.
//>>docs: http://api.jqueryui.com/datepicker/
//>>demos: http://jqueryui.com/datepicker/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/datepicker.css
//>>css.theme: ../../themes/base/theme.css



$.extend( $.ui, { datepicker: { version: "1.12.1" } } );

var datepicker_instActive;

function datepicker_getZindex( elem ) {
	var position, value;
	while ( elem.length && elem[ 0 ] !== document ) {

		// Ignore z-index if position is set to a value where z-index is ignored by the browser
		// This makes behavior of this function consistent across browsers
		// WebKit always returns auto if the element is positioned
		position = elem.css( "position" );
		if ( position === "absolute" || position === "relative" || position === "fixed" ) {

			// IE returns 0 when zIndex is not specified
			// other browsers return a string
			// we ignore the case of nested elements with an explicit value of 0
			// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
			value = parseInt( elem.css( "zIndex" ), 10 );
			if ( !isNaN( value ) && value !== 0 ) {
				return value;
			}
		}
		elem = elem.parent();
	}

	return 0;
}
/* Date picker manager.
   Use the singleton instance of this class, $.datepicker, to interact with the date picker.
   Settings for (groups of) date pickers are maintained in an instance object,
   allowing multiple different settings on the same page. */

function Datepicker() {
	this._curInst = null; // The current instance in use
	this._keyEvent = false; // If the last event was a key event
	this._disabledInputs = []; // List of date picker inputs that have been disabled
	this._datepickerShowing = false; // True if the popup picker is showing , false if not
	this._inDialog = false; // True if showing within a "dialog", false if not
	this._mainDivId = "ui-datepicker-div"; // The ID of the main datepicker division
	this._inlineClass = "ui-datepicker-inline"; // The name of the inline marker class
	this._appendClass = "ui-datepicker-append"; // The name of the append marker class
	this._triggerClass = "ui-datepicker-trigger"; // The name of the trigger marker class
	this._dialogClass = "ui-datepicker-dialog"; // The name of the dialog marker class
	this._disableClass = "ui-datepicker-disabled"; // The name of the disabled covering marker class
	this._unselectableClass = "ui-datepicker-unselectable"; // The name of the unselectable cell marker class
	this._currentClass = "ui-datepicker-current-day"; // The name of the current day marker class
	this._dayOverClass = "ui-datepicker-days-cell-over"; // The name of the day hover marker class
	this.regional = []; // Available regional settings, indexed by language code
	this.regional[ "" ] = { // Default regional settings
		closeText: "Done", // Display text for close link
		prevText: "Prev", // Display text for previous month link
		nextText: "Next", // Display text for next month link
		currentText: "Today", // Display text for current month link
		monthNames: [ "January","February","March","April","May","June",
			"July","August","September","October","November","December" ], // Names of months for drop-down and formatting
		monthNamesShort: [ "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" ], // For formatting
		dayNames: [ "Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday" ], // For formatting
		dayNamesShort: [ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" ], // For formatting
		dayNamesMin: [ "Su","Mo","Tu","We","Th","Fr","Sa" ], // Column headings for days starting at Sunday
		weekHeader: "Wk", // Column header for week of the year
		dateFormat: "mm/dd/yy", // See format options on parseDate
		firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
		isRTL: false, // True if right-to-left language, false if left-to-right
		showMonthAfterYear: false, // True if the year select precedes month, false for month then year
		yearSuffix: "" // Additional text to append to the year in the month headers
	};
	this._defaults = { // Global defaults for all the date picker instances
		showOn: "focus", // "focus" for popup on focus,
			// "button" for trigger button, or "both" for either
		showAnim: "fadeIn", // Name of jQuery animation for popup
		showOptions: {}, // Options for enhanced animations
		defaultDate: null, // Used when field is blank: actual date,
			// +/-number for offset from today, null for today
		appendText: "", // Display text following the input box, e.g. showing the format
		buttonText: "...", // Text for trigger button
		buttonImage: "", // URL for trigger button image
		buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
		hideIfNoPrevNext: false, // True to hide next/previous month links
			// if not applicable, false to just disable them
		navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
		gotoCurrent: false, // True if today link goes back to current selection instead
		changeMonth: false, // True if month can be selected directly, false if only prev/next
		changeYear: false, // True if year can be selected directly, false if only prev/next
		yearRange: "c-10:c+10", // Range of years to display in drop-down,
			// either relative to today's year (-nn:+nn), relative to currently displayed year
			// (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
		showOtherMonths: false, // True to show dates in other months, false to leave blank
		selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
		showWeek: false, // True to show week of the year, false to not show it
		calculateWeek: this.iso8601Week, // How to calculate the week of the year,
			// takes a Date and returns the number of the week for it
		shortYearCutoff: "+10", // Short year values < this are in the current century,
			// > this are in the previous century,
			// string value starting with "+" for current year + value
		minDate: null, // The earliest selectable date, or null for no limit
		maxDate: null, // The latest selectable date, or null for no limit
		duration: "fast", // Duration of display/closure
		beforeShowDay: null, // Function that takes a date and returns an array with
			// [0] = true if selectable, false if not, [1] = custom CSS class name(s) or "",
			// [2] = cell title (optional), e.g. $.datepicker.noWeekends
		beforeShow: null, // Function that takes an input field and
			// returns a set of custom settings for the date picker
		onSelect: null, // Define a callback function when a date is selected
		onChangeMonthYear: null, // Define a callback function when the month or year is changed
		onClose: null, // Define a callback function when the datepicker is closed
		numberOfMonths: 1, // Number of months to show at a time
		showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
		stepMonths: 1, // Number of months to step back/forward
		stepBigMonths: 12, // Number of months to step back/forward for the big links
		altField: "", // Selector for an alternate field to store selected dates into
		altFormat: "", // The date format to use for the alternate field
		constrainInput: true, // The input is constrained by the current date format
		showButtonPanel: false, // True to show button panel, false to not show it
		autoSize: false, // True to size the input for the date format, false to leave as is
		disabled: false // The initial disabled state
	};
	$.extend( this._defaults, this.regional[ "" ] );
	this.regional.en = $.extend( true, {}, this.regional[ "" ] );
	this.regional[ "en-US" ] = $.extend( true, {}, this.regional.en );
	this.dpDiv = datepicker_bindHover( $( "<div id='" + this._mainDivId + "' class='ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>" ) );
}

$.extend( Datepicker.prototype, {
	/* Class name added to elements to indicate already configured with a date picker. */
	markerClassName: "hasDatepicker",

	//Keep track of the maximum number of rows displayed (see #7043)
	maxRows: 4,

	// TODO rename to "widget" when switching to widget factory
	_widgetDatepicker: function() {
		return this.dpDiv;
	},

	/* Override the default settings for all instances of the date picker.
	 * @param  settings  object - the new settings to use as defaults (anonymous object)
	 * @return the manager object
	 */
	setDefaults: function( settings ) {
		datepicker_extendRemove( this._defaults, settings || {} );
		return this;
	},

	/* Attach the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 * @param  settings  object - the new settings to use for this date picker instance (anonymous)
	 */
	_attachDatepicker: function( target, settings ) {
		var nodeName, inline, inst;
		nodeName = target.nodeName.toLowerCase();
		inline = ( nodeName === "div" || nodeName === "span" );
		if ( !target.id ) {
			this.uuid += 1;
			target.id = "dp" + this.uuid;
		}
		inst = this._newInst( $( target ), inline );
		inst.settings = $.extend( {}, settings || {} );
		if ( nodeName === "input" ) {
			this._connectDatepicker( target, inst );
		} else if ( inline ) {
			this._inlineDatepicker( target, inst );
		}
	},

	/* Create a new instance object. */
	_newInst: function( target, inline ) {
		var id = target[ 0 ].id.replace( /([^A-Za-z0-9_\-])/g, "\\\\$1" ); // escape jQuery meta chars
		return { id: id, input: target, // associated target
			selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
			drawMonth: 0, drawYear: 0, // month being drawn
			inline: inline, // is datepicker inline or not
			dpDiv: ( !inline ? this.dpDiv : // presentation div
			datepicker_bindHover( $( "<div class='" + this._inlineClass + " ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all'></div>" ) ) ) };
	},

	/* Attach the date picker to an input field. */
	_connectDatepicker: function( target, inst ) {
		var input = $( target );
		inst.append = $( [] );
		inst.trigger = $( [] );
		if ( input.hasClass( this.markerClassName ) ) {
			return;
		}
		this._attachments( input, inst );
		input.addClass( this.markerClassName ).on( "keydown", this._doKeyDown ).
			on( "keypress", this._doKeyPress ).on( "keyup", this._doKeyUp );
		this._autoSize( inst );
		$.data( target, "datepicker", inst );

		//If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
		if ( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
	},

	/* Make attachments based on settings. */
	_attachments: function( input, inst ) {
		var showOn, buttonText, buttonImage,
			appendText = this._get( inst, "appendText" ),
			isRTL = this._get( inst, "isRTL" );

		if ( inst.append ) {
			inst.append.remove();
		}
		if ( appendText ) {
			inst.append = $( "<span class='" + this._appendClass + "'>" + appendText + "</span>" );
			input[ isRTL ? "before" : "after" ]( inst.append );
		}

		input.off( "focus", this._showDatepicker );

		if ( inst.trigger ) {
			inst.trigger.remove();
		}

		showOn = this._get( inst, "showOn" );
		if ( showOn === "focus" || showOn === "both" ) { // pop-up date picker when in the marked field
			input.on( "focus", this._showDatepicker );
		}
		if ( showOn === "button" || showOn === "both" ) { // pop-up date picker when button clicked
			buttonText = this._get( inst, "buttonText" );
			buttonImage = this._get( inst, "buttonImage" );
			inst.trigger = $( this._get( inst, "buttonImageOnly" ) ?
				$( "<img/>" ).addClass( this._triggerClass ).
					attr( { src: buttonImage, alt: buttonText, title: buttonText } ) :
				$( "<button type='button'></button>" ).addClass( this._triggerClass ).
					html( !buttonImage ? buttonText : $( "<img/>" ).attr(
					{ src:buttonImage, alt:buttonText, title:buttonText } ) ) );
			input[ isRTL ? "before" : "after" ]( inst.trigger );
			inst.trigger.on( "click", function() {
				if ( $.datepicker._datepickerShowing && $.datepicker._lastInput === input[ 0 ] ) {
					$.datepicker._hideDatepicker();
				} else if ( $.datepicker._datepickerShowing && $.datepicker._lastInput !== input[ 0 ] ) {
					$.datepicker._hideDatepicker();
					$.datepicker._showDatepicker( input[ 0 ] );
				} else {
					$.datepicker._showDatepicker( input[ 0 ] );
				}
				return false;
			} );
		}
	},

	/* Apply the maximum length for the date format. */
	_autoSize: function( inst ) {
		if ( this._get( inst, "autoSize" ) && !inst.inline ) {
			var findMax, max, maxI, i,
				date = new Date( 2009, 12 - 1, 20 ), // Ensure double digits
				dateFormat = this._get( inst, "dateFormat" );

			if ( dateFormat.match( /[DM]/ ) ) {
				findMax = function( names ) {
					max = 0;
					maxI = 0;
					for ( i = 0; i < names.length; i++ ) {
						if ( names[ i ].length > max ) {
							max = names[ i ].length;
							maxI = i;
						}
					}
					return maxI;
				};
				date.setMonth( findMax( this._get( inst, ( dateFormat.match( /MM/ ) ?
					"monthNames" : "monthNamesShort" ) ) ) );
				date.setDate( findMax( this._get( inst, ( dateFormat.match( /DD/ ) ?
					"dayNames" : "dayNamesShort" ) ) ) + 20 - date.getDay() );
			}
			inst.input.attr( "size", this._formatDate( inst, date ).length );
		}
	},

	/* Attach an inline date picker to a div. */
	_inlineDatepicker: function( target, inst ) {
		var divSpan = $( target );
		if ( divSpan.hasClass( this.markerClassName ) ) {
			return;
		}
		divSpan.addClass( this.markerClassName ).append( inst.dpDiv );
		$.data( target, "datepicker", inst );
		this._setDate( inst, this._getDefaultDate( inst ), true );
		this._updateDatepicker( inst );
		this._updateAlternate( inst );

		//If disabled option is true, disable the datepicker before showing it (see ticket #5665)
		if ( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}

		// Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
		// http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
		inst.dpDiv.css( "display", "block" );
	},

	/* Pop-up the date picker in a "dialog" box.
	 * @param  input element - ignored
	 * @param  date	string or Date - the initial date to display
	 * @param  onSelect  function - the function to call when a date is selected
	 * @param  settings  object - update the dialog date picker instance's settings (anonymous object)
	 * @param  pos int[2] - coordinates for the dialog's position within the screen or
	 *					event - with x/y coordinates or
	 *					leave empty for default (screen centre)
	 * @return the manager object
	 */
	_dialogDatepicker: function( input, date, onSelect, settings, pos ) {
		var id, browserWidth, browserHeight, scrollX, scrollY,
			inst = this._dialogInst; // internal instance

		if ( !inst ) {
			this.uuid += 1;
			id = "dp" + this.uuid;
			this._dialogInput = $( "<input type='text' id='" + id +
				"' style='position: absolute; top: -100px; width: 0px;'/>" );
			this._dialogInput.on( "keydown", this._doKeyDown );
			$( "body" ).append( this._dialogInput );
			inst = this._dialogInst = this._newInst( this._dialogInput, false );
			inst.settings = {};
			$.data( this._dialogInput[ 0 ], "datepicker", inst );
		}
		datepicker_extendRemove( inst.settings, settings || {} );
		date = ( date && date.constructor === Date ? this._formatDate( inst, date ) : date );
		this._dialogInput.val( date );

		this._pos = ( pos ? ( pos.length ? pos : [ pos.pageX, pos.pageY ] ) : null );
		if ( !this._pos ) {
			browserWidth = document.documentElement.clientWidth;
			browserHeight = document.documentElement.clientHeight;
			scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
			scrollY = document.documentElement.scrollTop || document.body.scrollTop;
			this._pos = // should use actual width/height below
				[ ( browserWidth / 2 ) - 100 + scrollX, ( browserHeight / 2 ) - 150 + scrollY ];
		}

		// Move input on screen for focus, but hidden behind dialog
		this._dialogInput.css( "left", ( this._pos[ 0 ] + 20 ) + "px" ).css( "top", this._pos[ 1 ] + "px" );
		inst.settings.onSelect = onSelect;
		this._inDialog = true;
		this.dpDiv.addClass( this._dialogClass );
		this._showDatepicker( this._dialogInput[ 0 ] );
		if ( $.blockUI ) {
			$.blockUI( this.dpDiv );
		}
		$.data( this._dialogInput[ 0 ], "datepicker", inst );
		return this;
	},

	/* Detach a datepicker from its control.
	 * @param  target	element - the target input field or division or span
	 */
	_destroyDatepicker: function( target ) {
		var nodeName,
			$target = $( target ),
			inst = $.data( target, "datepicker" );

		if ( !$target.hasClass( this.markerClassName ) ) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		$.removeData( target, "datepicker" );
		if ( nodeName === "input" ) {
			inst.append.remove();
			inst.trigger.remove();
			$target.removeClass( this.markerClassName ).
				off( "focus", this._showDatepicker ).
				off( "keydown", this._doKeyDown ).
				off( "keypress", this._doKeyPress ).
				off( "keyup", this._doKeyUp );
		} else if ( nodeName === "div" || nodeName === "span" ) {
			$target.removeClass( this.markerClassName ).empty();
		}

		if ( datepicker_instActive === inst ) {
			datepicker_instActive = null;
		}
	},

	/* Enable the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 */
	_enableDatepicker: function( target ) {
		var nodeName, inline,
			$target = $( target ),
			inst = $.data( target, "datepicker" );

		if ( !$target.hasClass( this.markerClassName ) ) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		if ( nodeName === "input" ) {
			target.disabled = false;
			inst.trigger.filter( "button" ).
				each( function() { this.disabled = false; } ).end().
				filter( "img" ).css( { opacity: "1.0", cursor: "" } );
		} else if ( nodeName === "div" || nodeName === "span" ) {
			inline = $target.children( "." + this._inlineClass );
			inline.children().removeClass( "ui-state-disabled" );
			inline.find( "select.ui-datepicker-month, select.ui-datepicker-year" ).
				prop( "disabled", false );
		}
		this._disabledInputs = $.map( this._disabledInputs,
			function( value ) { return ( value === target ? null : value ); } ); // delete entry
	},

	/* Disable the date picker to a jQuery selection.
	 * @param  target	element - the target input field or division or span
	 */
	_disableDatepicker: function( target ) {
		var nodeName, inline,
			$target = $( target ),
			inst = $.data( target, "datepicker" );

		if ( !$target.hasClass( this.markerClassName ) ) {
			return;
		}

		nodeName = target.nodeName.toLowerCase();
		if ( nodeName === "input" ) {
			target.disabled = true;
			inst.trigger.filter( "button" ).
				each( function() { this.disabled = true; } ).end().
				filter( "img" ).css( { opacity: "0.5", cursor: "default" } );
		} else if ( nodeName === "div" || nodeName === "span" ) {
			inline = $target.children( "." + this._inlineClass );
			inline.children().addClass( "ui-state-disabled" );
			inline.find( "select.ui-datepicker-month, select.ui-datepicker-year" ).
				prop( "disabled", true );
		}
		this._disabledInputs = $.map( this._disabledInputs,
			function( value ) { return ( value === target ? null : value ); } ); // delete entry
		this._disabledInputs[ this._disabledInputs.length ] = target;
	},

	/* Is the first field in a jQuery collection disabled as a datepicker?
	 * @param  target	element - the target input field or division or span
	 * @return boolean - true if disabled, false if enabled
	 */
	_isDisabledDatepicker: function( target ) {
		if ( !target ) {
			return false;
		}
		for ( var i = 0; i < this._disabledInputs.length; i++ ) {
			if ( this._disabledInputs[ i ] === target ) {
				return true;
			}
		}
		return false;
	},

	/* Retrieve the instance data for the target control.
	 * @param  target  element - the target input field or division or span
	 * @return  object - the associated instance data
	 * @throws  error if a jQuery problem getting data
	 */
	_getInst: function( target ) {
		try {
			return $.data( target, "datepicker" );
		}
		catch ( err ) {
			throw "Missing instance data for this datepicker";
		}
	},

	/* Update or retrieve the settings for a date picker attached to an input field or division.
	 * @param  target  element - the target input field or division or span
	 * @param  name	object - the new settings to update or
	 *				string - the name of the setting to change or retrieve,
	 *				when retrieving also "all" for all instance settings or
	 *				"defaults" for all global defaults
	 * @param  value   any - the new value for the setting
	 *				(omit if above is an object or to retrieve a value)
	 */
	_optionDatepicker: function( target, name, value ) {
		var settings, date, minDate, maxDate,
			inst = this._getInst( target );

		if ( arguments.length === 2 && typeof name === "string" ) {
			return ( name === "defaults" ? $.extend( {}, $.datepicker._defaults ) :
				( inst ? ( name === "all" ? $.extend( {}, inst.settings ) :
				this._get( inst, name ) ) : null ) );
		}

		settings = name || {};
		if ( typeof name === "string" ) {
			settings = {};
			settings[ name ] = value;
		}

		if ( inst ) {
			if ( this._curInst === inst ) {
				this._hideDatepicker();
			}

			date = this._getDateDatepicker( target, true );
			minDate = this._getMinMaxDate( inst, "min" );
			maxDate = this._getMinMaxDate( inst, "max" );
			datepicker_extendRemove( inst.settings, settings );

			// reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
			if ( minDate !== null && settings.dateFormat !== undefined && settings.minDate === undefined ) {
				inst.settings.minDate = this._formatDate( inst, minDate );
			}
			if ( maxDate !== null && settings.dateFormat !== undefined && settings.maxDate === undefined ) {
				inst.settings.maxDate = this._formatDate( inst, maxDate );
			}
			if ( "disabled" in settings ) {
				if ( settings.disabled ) {
					this._disableDatepicker( target );
				} else {
					this._enableDatepicker( target );
				}
			}
			this._attachments( $( target ), inst );
			this._autoSize( inst );
			this._setDate( inst, date );
			this._updateAlternate( inst );
			this._updateDatepicker( inst );
		}
	},

	// Change method deprecated
	_changeDatepicker: function( target, name, value ) {
		this._optionDatepicker( target, name, value );
	},

	/* Redraw the date picker attached to an input field or division.
	 * @param  target  element - the target input field or division or span
	 */
	_refreshDatepicker: function( target ) {
		var inst = this._getInst( target );
		if ( inst ) {
			this._updateDatepicker( inst );
		}
	},

	/* Set the dates for a jQuery selection.
	 * @param  target element - the target input field or division or span
	 * @param  date	Date - the new date
	 */
	_setDateDatepicker: function( target, date ) {
		var inst = this._getInst( target );
		if ( inst ) {
			this._setDate( inst, date );
			this._updateDatepicker( inst );
			this._updateAlternate( inst );
		}
	},

	/* Get the date(s) for the first entry in a jQuery selection.
	 * @param  target element - the target input field or division or span
	 * @param  noDefault boolean - true if no default date is to be used
	 * @return Date - the current date
	 */
	_getDateDatepicker: function( target, noDefault ) {
		var inst = this._getInst( target );
		if ( inst && !inst.inline ) {
			this._setDateFromField( inst, noDefault );
		}
		return ( inst ? this._getDate( inst ) : null );
	},

	/* Handle keystrokes. */
	_doKeyDown: function( event ) {
		var onSelect, dateStr, sel,
			inst = $.datepicker._getInst( event.target ),
			handled = true,
			isRTL = inst.dpDiv.is( ".ui-datepicker-rtl" );

		inst._keyEvent = true;
		if ( $.datepicker._datepickerShowing ) {
			switch ( event.keyCode ) {
				case 9: $.datepicker._hideDatepicker();
						handled = false;
						break; // hide on tab out
				case 13: sel = $( "td." + $.datepicker._dayOverClass + ":not(." +
									$.datepicker._currentClass + ")", inst.dpDiv );
						if ( sel[ 0 ] ) {
							$.datepicker._selectDay( event.target, inst.selectedMonth, inst.selectedYear, sel[ 0 ] );
						}

						onSelect = $.datepicker._get( inst, "onSelect" );
						if ( onSelect ) {
							dateStr = $.datepicker._formatDate( inst );

							// Trigger custom callback
							onSelect.apply( ( inst.input ? inst.input[ 0 ] : null ), [ dateStr, inst ] );
						} else {
							$.datepicker._hideDatepicker();
						}

						return false; // don't submit the form
				case 27: $.datepicker._hideDatepicker();
						break; // hide on escape
				case 33: $.datepicker._adjustDate( event.target, ( event.ctrlKey ?
							-$.datepicker._get( inst, "stepBigMonths" ) :
							-$.datepicker._get( inst, "stepMonths" ) ), "M" );
						break; // previous month/year on page up/+ ctrl
				case 34: $.datepicker._adjustDate( event.target, ( event.ctrlKey ?
							+$.datepicker._get( inst, "stepBigMonths" ) :
							+$.datepicker._get( inst, "stepMonths" ) ), "M" );
						break; // next month/year on page down/+ ctrl
				case 35: if ( event.ctrlKey || event.metaKey ) {
							$.datepicker._clearDate( event.target );
						}
						handled = event.ctrlKey || event.metaKey;
						break; // clear on ctrl or command +end
				case 36: if ( event.ctrlKey || event.metaKey ) {
							$.datepicker._gotoToday( event.target );
						}
						handled = event.ctrlKey || event.metaKey;
						break; // current on ctrl or command +home
				case 37: if ( event.ctrlKey || event.metaKey ) {
							$.datepicker._adjustDate( event.target, ( isRTL ? +1 : -1 ), "D" );
						}
						handled = event.ctrlKey || event.metaKey;

						// -1 day on ctrl or command +left
						if ( event.originalEvent.altKey ) {
							$.datepicker._adjustDate( event.target, ( event.ctrlKey ?
								-$.datepicker._get( inst, "stepBigMonths" ) :
								-$.datepicker._get( inst, "stepMonths" ) ), "M" );
						}

						// next month/year on alt +left on Mac
						break;
				case 38: if ( event.ctrlKey || event.metaKey ) {
							$.datepicker._adjustDate( event.target, -7, "D" );
						}
						handled = event.ctrlKey || event.metaKey;
						break; // -1 week on ctrl or command +up
				case 39: if ( event.ctrlKey || event.metaKey ) {
							$.datepicker._adjustDate( event.target, ( isRTL ? -1 : +1 ), "D" );
						}
						handled = event.ctrlKey || event.metaKey;

						// +1 day on ctrl or command +right
						if ( event.originalEvent.altKey ) {
							$.datepicker._adjustDate( event.target, ( event.ctrlKey ?
								+$.datepicker._get( inst, "stepBigMonths" ) :
								+$.datepicker._get( inst, "stepMonths" ) ), "M" );
						}

						// next month/year on alt +right
						break;
				case 40: if ( event.ctrlKey || event.metaKey ) {
							$.datepicker._adjustDate( event.target, +7, "D" );
						}
						handled = event.ctrlKey || event.metaKey;
						break; // +1 week on ctrl or command +down
				default: handled = false;
			}
		} else if ( event.keyCode === 36 && event.ctrlKey ) { // display the date picker on ctrl+home
			$.datepicker._showDatepicker( this );
		} else {
			handled = false;
		}

		if ( handled ) {
			event.preventDefault();
			event.stopPropagation();
		}
	},

	/* Filter entered characters - based on date format. */
	_doKeyPress: function( event ) {
		var chars, chr,
			inst = $.datepicker._getInst( event.target );

		if ( $.datepicker._get( inst, "constrainInput" ) ) {
			chars = $.datepicker._possibleChars( $.datepicker._get( inst, "dateFormat" ) );
			chr = String.fromCharCode( event.charCode == null ? event.keyCode : event.charCode );
			return event.ctrlKey || event.metaKey || ( chr < " " || !chars || chars.indexOf( chr ) > -1 );
		}
	},

	/* Synchronise manual entry and field/alternate field. */
	_doKeyUp: function( event ) {
		var date,
			inst = $.datepicker._getInst( event.target );

		if ( inst.input.val() !== inst.lastVal ) {
			try {
				date = $.datepicker.parseDate( $.datepicker._get( inst, "dateFormat" ),
					( inst.input ? inst.input.val() : null ),
					$.datepicker._getFormatConfig( inst ) );

				if ( date ) { // only if valid
					$.datepicker._setDateFromField( inst );
					$.datepicker._updateAlternate( inst );
					$.datepicker._updateDatepicker( inst );
				}
			}
			catch ( err ) {
			}
		}
		return true;
	},

	/* Pop-up the date picker for a given input field.
	 * If false returned from beforeShow event handler do not show.
	 * @param  input  element - the input field attached to the date picker or
	 *					event - if triggered by focus
	 */
	_showDatepicker: function( input ) {
		input = input.target || input;
		if ( input.nodeName.toLowerCase() !== "input" ) { // find from button/image trigger
			input = $( "input", input.parentNode )[ 0 ];
		}

		if ( $.datepicker._isDisabledDatepicker( input ) || $.datepicker._lastInput === input ) { // already here
			return;
		}

		var inst, beforeShow, beforeShowSettings, isFixed,
			offset, showAnim, duration;

		inst = $.datepicker._getInst( input );
		if ( $.datepicker._curInst && $.datepicker._curInst !== inst ) {
			$.datepicker._curInst.dpDiv.stop( true, true );
			if ( inst && $.datepicker._datepickerShowing ) {
				$.datepicker._hideDatepicker( $.datepicker._curInst.input[ 0 ] );
			}
		}

		beforeShow = $.datepicker._get( inst, "beforeShow" );
		beforeShowSettings = beforeShow ? beforeShow.apply( input, [ input, inst ] ) : {};
		if ( beforeShowSettings === false ) {
			return;
		}
		datepicker_extendRemove( inst.settings, beforeShowSettings );

		inst.lastVal = null;
		$.datepicker._lastInput = input;
		$.datepicker._setDateFromField( inst );

		if ( $.datepicker._inDialog ) { // hide cursor
			input.value = "";
		}
		if ( !$.datepicker._pos ) { // position below input
			$.datepicker._pos = $.datepicker._findPos( input );
			$.datepicker._pos[ 1 ] += input.offsetHeight; // add the height
		}

		isFixed = false;
		$( input ).parents().each( function() {
			isFixed |= $( this ).css( "position" ) === "fixed";
			return !isFixed;
		} );

		offset = { left: $.datepicker._pos[ 0 ], top: $.datepicker._pos[ 1 ] };
		$.datepicker._pos = null;

		//to avoid flashes on Firefox
		inst.dpDiv.empty();

		// determine sizing offscreen
		inst.dpDiv.css( { position: "absolute", display: "block", top: "-1000px" } );
		$.datepicker._updateDatepicker( inst );

		// fix width for dynamic number of date pickers
		// and adjust position before showing
		offset = $.datepicker._checkOffset( inst, offset, isFixed );
		inst.dpDiv.css( { position: ( $.datepicker._inDialog && $.blockUI ?
			"static" : ( isFixed ? "fixed" : "absolute" ) ), display: "none",
			left: offset.left + "px", top: offset.top + "px" } );

		if ( !inst.inline ) {
			showAnim = $.datepicker._get( inst, "showAnim" );
			duration = $.datepicker._get( inst, "duration" );
			inst.dpDiv.css( "z-index", datepicker_getZindex( $( input ) ) + 1 );
			$.datepicker._datepickerShowing = true;

			if ( $.effects && $.effects.effect[ showAnim ] ) {
				inst.dpDiv.show( showAnim, $.datepicker._get( inst, "showOptions" ), duration );
			} else {
				inst.dpDiv[ showAnim || "show" ]( showAnim ? duration : null );
			}

			if ( $.datepicker._shouldFocusInput( inst ) ) {
				inst.input.trigger( "focus" );
			}

			$.datepicker._curInst = inst;
		}
	},

	/* Generate the date picker content. */
	_updateDatepicker: function( inst ) {
		this.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
		datepicker_instActive = inst; // for delegate hover events
		inst.dpDiv.empty().append( this._generateHTML( inst ) );
		this._attachHandlers( inst );

		var origyearshtml,
			numMonths = this._getNumberOfMonths( inst ),
			cols = numMonths[ 1 ],
			width = 17,
			activeCell = inst.dpDiv.find( "." + this._dayOverClass + " a" );

		if ( activeCell.length > 0 ) {
			datepicker_handleMouseover.apply( activeCell.get( 0 ) );
		}

		inst.dpDiv.removeClass( "ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4" ).width( "" );
		if ( cols > 1 ) {
			inst.dpDiv.addClass( "ui-datepicker-multi-" + cols ).css( "width", ( width * cols ) + "em" );
		}
		inst.dpDiv[ ( numMonths[ 0 ] !== 1 || numMonths[ 1 ] !== 1 ? "add" : "remove" ) +
			"Class" ]( "ui-datepicker-multi" );
		inst.dpDiv[ ( this._get( inst, "isRTL" ) ? "add" : "remove" ) +
			"Class" ]( "ui-datepicker-rtl" );

		if ( inst === $.datepicker._curInst && $.datepicker._datepickerShowing && $.datepicker._shouldFocusInput( inst ) ) {
			inst.input.trigger( "focus" );
		}

		// Deffered render of the years select (to avoid flashes on Firefox)
		if ( inst.yearshtml ) {
			origyearshtml = inst.yearshtml;
			setTimeout( function() {

				//assure that inst.yearshtml didn't change.
				if ( origyearshtml === inst.yearshtml && inst.yearshtml ) {
					inst.dpDiv.find( "select.ui-datepicker-year:first" ).replaceWith( inst.yearshtml );
				}
				origyearshtml = inst.yearshtml = null;
			}, 0 );
		}
	},

	// #6694 - don't focus the input if it's already focused
	// this breaks the change event in IE
	// Support: IE and jQuery <1.9
	_shouldFocusInput: function( inst ) {
		return inst.input && inst.input.is( ":visible" ) && !inst.input.is( ":disabled" ) && !inst.input.is( ":focus" );
	},

	/* Check positioning to remain on screen. */
	_checkOffset: function( inst, offset, isFixed ) {
		var dpWidth = inst.dpDiv.outerWidth(),
			dpHeight = inst.dpDiv.outerHeight(),
			inputWidth = inst.input ? inst.input.outerWidth() : 0,
			inputHeight = inst.input ? inst.input.outerHeight() : 0,
			viewWidth = document.documentElement.clientWidth + ( isFixed ? 0 : $( document ).scrollLeft() ),
			viewHeight = document.documentElement.clientHeight + ( isFixed ? 0 : $( document ).scrollTop() );

		offset.left -= ( this._get( inst, "isRTL" ) ? ( dpWidth - inputWidth ) : 0 );
		offset.left -= ( isFixed && offset.left === inst.input.offset().left ) ? $( document ).scrollLeft() : 0;
		offset.top -= ( isFixed && offset.top === ( inst.input.offset().top + inputHeight ) ) ? $( document ).scrollTop() : 0;

		// Now check if datepicker is showing outside window viewport - move to a better place if so.
		offset.left -= Math.min( offset.left, ( offset.left + dpWidth > viewWidth && viewWidth > dpWidth ) ?
			Math.abs( offset.left + dpWidth - viewWidth ) : 0 );
		offset.top -= Math.min( offset.top, ( offset.top + dpHeight > viewHeight && viewHeight > dpHeight ) ?
			Math.abs( dpHeight + inputHeight ) : 0 );

		return offset;
	},

	/* Find an object's position on the screen. */
	_findPos: function( obj ) {
		var position,
			inst = this._getInst( obj ),
			isRTL = this._get( inst, "isRTL" );

		while ( obj && ( obj.type === "hidden" || obj.nodeType !== 1 || $.expr.pseudos.hidden( obj ) ) ) {
			obj = obj[ isRTL ? "previousSibling" : "nextSibling" ];
		}

		position = $( obj ).offset();
		return [ position.left, position.top ];
	},

	/* Hide the date picker from view.
	 * @param  input  element - the input field attached to the date picker
	 */
	_hideDatepicker: function( input ) {
		var showAnim, duration, postProcess, onClose,
			inst = this._curInst;

		if ( !inst || ( input && inst !== $.data( input, "datepicker" ) ) ) {
			return;
		}

		if ( this._datepickerShowing ) {
			showAnim = this._get( inst, "showAnim" );
			duration = this._get( inst, "duration" );
			postProcess = function() {
				$.datepicker._tidyDialog( inst );
			};

			// DEPRECATED: after BC for 1.8.x $.effects[ showAnim ] is not needed
			if ( $.effects && ( $.effects.effect[ showAnim ] || $.effects[ showAnim ] ) ) {
				inst.dpDiv.hide( showAnim, $.datepicker._get( inst, "showOptions" ), duration, postProcess );
			} else {
				inst.dpDiv[ ( showAnim === "slideDown" ? "slideUp" :
					( showAnim === "fadeIn" ? "fadeOut" : "hide" ) ) ]( ( showAnim ? duration : null ), postProcess );
			}

			if ( !showAnim ) {
				postProcess();
			}
			this._datepickerShowing = false;

			onClose = this._get( inst, "onClose" );
			if ( onClose ) {
				onClose.apply( ( inst.input ? inst.input[ 0 ] : null ), [ ( inst.input ? inst.input.val() : "" ), inst ] );
			}

			this._lastInput = null;
			if ( this._inDialog ) {
				this._dialogInput.css( { position: "absolute", left: "0", top: "-100px" } );
				if ( $.blockUI ) {
					$.unblockUI();
					$( "body" ).append( this.dpDiv );
				}
			}
			this._inDialog = false;
		}
	},

	/* Tidy up after a dialog display. */
	_tidyDialog: function( inst ) {
		inst.dpDiv.removeClass( this._dialogClass ).off( ".ui-datepicker-calendar" );
	},

	/* Close date picker if clicked elsewhere. */
	_checkExternalClick: function( event ) {
		if ( !$.datepicker._curInst ) {
			return;
		}

		var $target = $( event.target ),
			inst = $.datepicker._getInst( $target[ 0 ] );

		if ( ( ( $target[ 0 ].id !== $.datepicker._mainDivId &&
				$target.parents( "#" + $.datepicker._mainDivId ).length === 0 &&
				!$target.hasClass( $.datepicker.markerClassName ) &&
				!$target.closest( "." + $.datepicker._triggerClass ).length &&
				$.datepicker._datepickerShowing && !( $.datepicker._inDialog && $.blockUI ) ) ) ||
			( $target.hasClass( $.datepicker.markerClassName ) && $.datepicker._curInst !== inst ) ) {
				$.datepicker._hideDatepicker();
		}
	},

	/* Adjust one of the date sub-fields. */
	_adjustDate: function( id, offset, period ) {
		var target = $( id ),
			inst = this._getInst( target[ 0 ] );

		if ( this._isDisabledDatepicker( target[ 0 ] ) ) {
			return;
		}
		this._adjustInstDate( inst, offset +
			( period === "M" ? this._get( inst, "showCurrentAtPos" ) : 0 ), // undo positioning
			period );
		this._updateDatepicker( inst );
	},

	/* Action for current link. */
	_gotoToday: function( id ) {
		var date,
			target = $( id ),
			inst = this._getInst( target[ 0 ] );

		if ( this._get( inst, "gotoCurrent" ) && inst.currentDay ) {
			inst.selectedDay = inst.currentDay;
			inst.drawMonth = inst.selectedMonth = inst.currentMonth;
			inst.drawYear = inst.selectedYear = inst.currentYear;
		} else {
			date = new Date();
			inst.selectedDay = date.getDate();
			inst.drawMonth = inst.selectedMonth = date.getMonth();
			inst.drawYear = inst.selectedYear = date.getFullYear();
		}
		this._notifyChange( inst );
		this._adjustDate( target );
	},

	/* Action for selecting a new month/year. */
	_selectMonthYear: function( id, select, period ) {
		var target = $( id ),
			inst = this._getInst( target[ 0 ] );

		inst[ "selected" + ( period === "M" ? "Month" : "Year" ) ] =
		inst[ "draw" + ( period === "M" ? "Month" : "Year" ) ] =
			parseInt( select.options[ select.selectedIndex ].value, 10 );

		this._notifyChange( inst );
		this._adjustDate( target );
	},

	/* Action for selecting a day. */
	_selectDay: function( id, month, year, td ) {
		var inst,
			target = $( id );

		if ( $( td ).hasClass( this._unselectableClass ) || this._isDisabledDatepicker( target[ 0 ] ) ) {
			return;
		}

		inst = this._getInst( target[ 0 ] );
		inst.selectedDay = inst.currentDay = $( "a", td ).html();
		inst.selectedMonth = inst.currentMonth = month;
		inst.selectedYear = inst.currentYear = year;
		this._selectDate( id, this._formatDate( inst,
			inst.currentDay, inst.currentMonth, inst.currentYear ) );
	},

	/* Erase the input field and hide the date picker. */
	_clearDate: function( id ) {
		var target = $( id );
		this._selectDate( target, "" );
	},

	/* Update the input field with the selected date. */
	_selectDate: function( id, dateStr ) {
		var onSelect,
			target = $( id ),
			inst = this._getInst( target[ 0 ] );

		dateStr = ( dateStr != null ? dateStr : this._formatDate( inst ) );
		if ( inst.input ) {
			inst.input.val( dateStr );
		}
		this._updateAlternate( inst );

		onSelect = this._get( inst, "onSelect" );
		if ( onSelect ) {
			onSelect.apply( ( inst.input ? inst.input[ 0 ] : null ), [ dateStr, inst ] );  // trigger custom callback
		} else if ( inst.input ) {
			inst.input.trigger( "change" ); // fire the change event
		}

		if ( inst.inline ) {
			this._updateDatepicker( inst );
		} else {
			this._hideDatepicker();
			this._lastInput = inst.input[ 0 ];
			if ( typeof( inst.input[ 0 ] ) !== "object" ) {
				inst.input.trigger( "focus" ); // restore focus
			}
			this._lastInput = null;
		}
	},

	/* Update any alternate field to synchronise with the main field. */
	_updateAlternate: function( inst ) {
		var altFormat, date, dateStr,
			altField = this._get( inst, "altField" );

		if ( altField ) { // update alternate field too
			altFormat = this._get( inst, "altFormat" ) || this._get( inst, "dateFormat" );
			date = this._getDate( inst );
			dateStr = this.formatDate( altFormat, date, this._getFormatConfig( inst ) );
			$( altField ).val( dateStr );
		}
	},

	/* Set as beforeShowDay function to prevent selection of weekends.
	 * @param  date  Date - the date to customise
	 * @return [boolean, string] - is this date selectable?, what is its CSS class?
	 */
	noWeekends: function( date ) {
		var day = date.getDay();
		return [ ( day > 0 && day < 6 ), "" ];
	},

	/* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
	 * @param  date  Date - the date to get the week for
	 * @return  number - the number of the week within the year that contains this date
	 */
	iso8601Week: function( date ) {
		var time,
			checkDate = new Date( date.getTime() );

		// Find Thursday of this week starting on Monday
		checkDate.setDate( checkDate.getDate() + 4 - ( checkDate.getDay() || 7 ) );

		time = checkDate.getTime();
		checkDate.setMonth( 0 ); // Compare with Jan 1
		checkDate.setDate( 1 );
		return Math.floor( Math.round( ( time - checkDate ) / 86400000 ) / 7 ) + 1;
	},

	/* Parse a string value into a date object.
	 * See formatDate below for the possible formats.
	 *
	 * @param  format string - the expected format of the date
	 * @param  value string - the date in the above format
	 * @param  settings Object - attributes include:
	 *					shortYearCutoff  number - the cutoff year for determining the century (optional)
	 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
	 *					dayNames		string[7] - names of the days from Sunday (optional)
	 *					monthNamesShort string[12] - abbreviated names of the months (optional)
	 *					monthNames		string[12] - names of the months (optional)
	 * @return  Date - the extracted date value or null if value is blank
	 */
	parseDate: function( format, value, settings ) {
		if ( format == null || value == null ) {
			throw "Invalid arguments";
		}

		value = ( typeof value === "object" ? value.toString() : value + "" );
		if ( value === "" ) {
			return null;
		}

		var iFormat, dim, extra,
			iValue = 0,
			shortYearCutoffTemp = ( settings ? settings.shortYearCutoff : null ) || this._defaults.shortYearCutoff,
			shortYearCutoff = ( typeof shortYearCutoffTemp !== "string" ? shortYearCutoffTemp :
				new Date().getFullYear() % 100 + parseInt( shortYearCutoffTemp, 10 ) ),
			dayNamesShort = ( settings ? settings.dayNamesShort : null ) || this._defaults.dayNamesShort,
			dayNames = ( settings ? settings.dayNames : null ) || this._defaults.dayNames,
			monthNamesShort = ( settings ? settings.monthNamesShort : null ) || this._defaults.monthNamesShort,
			monthNames = ( settings ? settings.monthNames : null ) || this._defaults.monthNames,
			year = -1,
			month = -1,
			day = -1,
			doy = -1,
			literal = false,
			date,

			// Check whether a format character is doubled
			lookAhead = function( match ) {
				var matches = ( iFormat + 1 < format.length && format.charAt( iFormat + 1 ) === match );
				if ( matches ) {
					iFormat++;
				}
				return matches;
			},

			// Extract a number from the string value
			getNumber = function( match ) {
				var isDoubled = lookAhead( match ),
					size = ( match === "@" ? 14 : ( match === "!" ? 20 :
					( match === "y" && isDoubled ? 4 : ( match === "o" ? 3 : 2 ) ) ) ),
					minSize = ( match === "y" ? size : 1 ),
					digits = new RegExp( "^\\d{" + minSize + "," + size + "}" ),
					num = value.substring( iValue ).match( digits );
				if ( !num ) {
					throw "Missing number at position " + iValue;
				}
				iValue += num[ 0 ].length;
				return parseInt( num[ 0 ], 10 );
			},

			// Extract a name from the string value and convert to an index
			getName = function( match, shortNames, longNames ) {
				var index = -1,
					names = $.map( lookAhead( match ) ? longNames : shortNames, function( v, k ) {
						return [ [ k, v ] ];
					} ).sort( function( a, b ) {
						return -( a[ 1 ].length - b[ 1 ].length );
					} );

				$.each( names, function( i, pair ) {
					var name = pair[ 1 ];
					if ( value.substr( iValue, name.length ).toLowerCase() === name.toLowerCase() ) {
						index = pair[ 0 ];
						iValue += name.length;
						return false;
					}
				} );
				if ( index !== -1 ) {
					return index + 1;
				} else {
					throw "Unknown name at position " + iValue;
				}
			},

			// Confirm that a literal character matches the string value
			checkLiteral = function() {
				if ( value.charAt( iValue ) !== format.charAt( iFormat ) ) {
					throw "Unexpected literal at position " + iValue;
				}
				iValue++;
			};

		for ( iFormat = 0; iFormat < format.length; iFormat++ ) {
			if ( literal ) {
				if ( format.charAt( iFormat ) === "'" && !lookAhead( "'" ) ) {
					literal = false;
				} else {
					checkLiteral();
				}
			} else {
				switch ( format.charAt( iFormat ) ) {
					case "d":
						day = getNumber( "d" );
						break;
					case "D":
						getName( "D", dayNamesShort, dayNames );
						break;
					case "o":
						doy = getNumber( "o" );
						break;
					case "m":
						month = getNumber( "m" );
						break;
					case "M":
						month = getName( "M", monthNamesShort, monthNames );
						break;
					case "y":
						year = getNumber( "y" );
						break;
					case "@":
						date = new Date( getNumber( "@" ) );
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case "!":
						date = new Date( ( getNumber( "!" ) - this._ticksTo1970 ) / 10000 );
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case "'":
						if ( lookAhead( "'" ) ) {
							checkLiteral();
						} else {
							literal = true;
						}
						break;
					default:
						checkLiteral();
				}
			}
		}

		if ( iValue < value.length ) {
			extra = value.substr( iValue );
			if ( !/^\s+/.test( extra ) ) {
				throw "Extra/unparsed characters found in date: " + extra;
			}
		}

		if ( year === -1 ) {
			year = new Date().getFullYear();
		} else if ( year < 100 ) {
			year += new Date().getFullYear() - new Date().getFullYear() % 100 +
				( year <= shortYearCutoff ? 0 : -100 );
		}

		if ( doy > -1 ) {
			month = 1;
			day = doy;
			do {
				dim = this._getDaysInMonth( year, month - 1 );
				if ( day <= dim ) {
					break;
				}
				month++;
				day -= dim;
			} while ( true );
		}

		date = this._daylightSavingAdjust( new Date( year, month - 1, day ) );
		if ( date.getFullYear() !== year || date.getMonth() + 1 !== month || date.getDate() !== day ) {
			throw "Invalid date"; // E.g. 31/02/00
		}
		return date;
	},

	/* Standard date formats. */
	ATOM: "yy-mm-dd", // RFC 3339 (ISO 8601)
	COOKIE: "D, dd M yy",
	ISO_8601: "yy-mm-dd",
	RFC_822: "D, d M y",
	RFC_850: "DD, dd-M-y",
	RFC_1036: "D, d M y",
	RFC_1123: "D, d M yy",
	RFC_2822: "D, d M yy",
	RSS: "D, d M y", // RFC 822
	TICKS: "!",
	TIMESTAMP: "@",
	W3C: "yy-mm-dd", // ISO 8601

	_ticksTo1970: ( ( ( 1970 - 1 ) * 365 + Math.floor( 1970 / 4 ) - Math.floor( 1970 / 100 ) +
		Math.floor( 1970 / 400 ) ) * 24 * 60 * 60 * 10000000 ),

	/* Format a date object into a string value.
	 * The format can be combinations of the following:
	 * d  - day of month (no leading zero)
	 * dd - day of month (two digit)
	 * o  - day of year (no leading zeros)
	 * oo - day of year (three digit)
	 * D  - day name short
	 * DD - day name long
	 * m  - month of year (no leading zero)
	 * mm - month of year (two digit)
	 * M  - month name short
	 * MM - month name long
	 * y  - year (two digit)
	 * yy - year (four digit)
	 * @ - Unix timestamp (ms since 01/01/1970)
	 * ! - Windows ticks (100ns since 01/01/0001)
	 * "..." - literal text
	 * '' - single quote
	 *
	 * @param  format string - the desired format of the date
	 * @param  date Date - the date value to format
	 * @param  settings Object - attributes include:
	 *					dayNamesShort	string[7] - abbreviated names of the days from Sunday (optional)
	 *					dayNames		string[7] - names of the days from Sunday (optional)
	 *					monthNamesShort string[12] - abbreviated names of the months (optional)
	 *					monthNames		string[12] - names of the months (optional)
	 * @return  string - the date in the above format
	 */
	formatDate: function( format, date, settings ) {
		if ( !date ) {
			return "";
		}

		var iFormat,
			dayNamesShort = ( settings ? settings.dayNamesShort : null ) || this._defaults.dayNamesShort,
			dayNames = ( settings ? settings.dayNames : null ) || this._defaults.dayNames,
			monthNamesShort = ( settings ? settings.monthNamesShort : null ) || this._defaults.monthNamesShort,
			monthNames = ( settings ? settings.monthNames : null ) || this._defaults.monthNames,

			// Check whether a format character is doubled
			lookAhead = function( match ) {
				var matches = ( iFormat + 1 < format.length && format.charAt( iFormat + 1 ) === match );
				if ( matches ) {
					iFormat++;
				}
				return matches;
			},

			// Format a number, with leading zero if necessary
			formatNumber = function( match, value, len ) {
				var num = "" + value;
				if ( lookAhead( match ) ) {
					while ( num.length < len ) {
						num = "0" + num;
					}
				}
				return num;
			},

			// Format a name, short or long as requested
			formatName = function( match, value, shortNames, longNames ) {
				return ( lookAhead( match ) ? longNames[ value ] : shortNames[ value ] );
			},
			output = "",
			literal = false;

		if ( date ) {
			for ( iFormat = 0; iFormat < format.length; iFormat++ ) {
				if ( literal ) {
					if ( format.charAt( iFormat ) === "'" && !lookAhead( "'" ) ) {
						literal = false;
					} else {
						output += format.charAt( iFormat );
					}
				} else {
					switch ( format.charAt( iFormat ) ) {
						case "d":
							output += formatNumber( "d", date.getDate(), 2 );
							break;
						case "D":
							output += formatName( "D", date.getDay(), dayNamesShort, dayNames );
							break;
						case "o":
							output += formatNumber( "o",
								Math.round( ( new Date( date.getFullYear(), date.getMonth(), date.getDate() ).getTime() - new Date( date.getFullYear(), 0, 0 ).getTime() ) / 86400000 ), 3 );
							break;
						case "m":
							output += formatNumber( "m", date.getMonth() + 1, 2 );
							break;
						case "M":
							output += formatName( "M", date.getMonth(), monthNamesShort, monthNames );
							break;
						case "y":
							output += ( lookAhead( "y" ) ? date.getFullYear() :
								( date.getFullYear() % 100 < 10 ? "0" : "" ) + date.getFullYear() % 100 );
							break;
						case "@":
							output += date.getTime();
							break;
						case "!":
							output += date.getTime() * 10000 + this._ticksTo1970;
							break;
						case "'":
							if ( lookAhead( "'" ) ) {
								output += "'";
							} else {
								literal = true;
							}
							break;
						default:
							output += format.charAt( iFormat );
					}
				}
			}
		}
		return output;
	},

	/* Extract all possible characters from the date format. */
	_possibleChars: function( format ) {
		var iFormat,
			chars = "",
			literal = false,

			// Check whether a format character is doubled
			lookAhead = function( match ) {
				var matches = ( iFormat + 1 < format.length && format.charAt( iFormat + 1 ) === match );
				if ( matches ) {
					iFormat++;
				}
				return matches;
			};

		for ( iFormat = 0; iFormat < format.length; iFormat++ ) {
			if ( literal ) {
				if ( format.charAt( iFormat ) === "'" && !lookAhead( "'" ) ) {
					literal = false;
				} else {
					chars += format.charAt( iFormat );
				}
			} else {
				switch ( format.charAt( iFormat ) ) {
					case "d": case "m": case "y": case "@":
						chars += "0123456789";
						break;
					case "D": case "M":
						return null; // Accept anything
					case "'":
						if ( lookAhead( "'" ) ) {
							chars += "'";
						} else {
							literal = true;
						}
						break;
					default:
						chars += format.charAt( iFormat );
				}
			}
		}
		return chars;
	},

	/* Get a setting value, defaulting if necessary. */
	_get: function( inst, name ) {
		return inst.settings[ name ] !== undefined ?
			inst.settings[ name ] : this._defaults[ name ];
	},

	/* Parse existing date and initialise date picker. */
	_setDateFromField: function( inst, noDefault ) {
		if ( inst.input.val() === inst.lastVal ) {
			return;
		}

		var dateFormat = this._get( inst, "dateFormat" ),
			dates = inst.lastVal = inst.input ? inst.input.val() : null,
			defaultDate = this._getDefaultDate( inst ),
			date = defaultDate,
			settings = this._getFormatConfig( inst );

		try {
			date = this.parseDate( dateFormat, dates, settings ) || defaultDate;
		} catch ( event ) {
			dates = ( noDefault ? "" : dates );
		}
		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		inst.currentDay = ( dates ? date.getDate() : 0 );
		inst.currentMonth = ( dates ? date.getMonth() : 0 );
		inst.currentYear = ( dates ? date.getFullYear() : 0 );
		this._adjustInstDate( inst );
	},

	/* Retrieve the default date shown on opening. */
	_getDefaultDate: function( inst ) {
		return this._restrictMinMax( inst,
			this._determineDate( inst, this._get( inst, "defaultDate" ), new Date() ) );
	},

	/* A date may be specified as an exact value or a relative one. */
	_determineDate: function( inst, date, defaultDate ) {
		var offsetNumeric = function( offset ) {
				var date = new Date();
				date.setDate( date.getDate() + offset );
				return date;
			},
			offsetString = function( offset ) {
				try {
					return $.datepicker.parseDate( $.datepicker._get( inst, "dateFormat" ),
						offset, $.datepicker._getFormatConfig( inst ) );
				}
				catch ( e ) {

					// Ignore
				}

				var date = ( offset.toLowerCase().match( /^c/ ) ?
					$.datepicker._getDate( inst ) : null ) || new Date(),
					year = date.getFullYear(),
					month = date.getMonth(),
					day = date.getDate(),
					pattern = /([+\-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g,
					matches = pattern.exec( offset );

				while ( matches ) {
					switch ( matches[ 2 ] || "d" ) {
						case "d" : case "D" :
							day += parseInt( matches[ 1 ], 10 ); break;
						case "w" : case "W" :
							day += parseInt( matches[ 1 ], 10 ) * 7; break;
						case "m" : case "M" :
							month += parseInt( matches[ 1 ], 10 );
							day = Math.min( day, $.datepicker._getDaysInMonth( year, month ) );
							break;
						case "y": case "Y" :
							year += parseInt( matches[ 1 ], 10 );
							day = Math.min( day, $.datepicker._getDaysInMonth( year, month ) );
							break;
					}
					matches = pattern.exec( offset );
				}
				return new Date( year, month, day );
			},
			newDate = ( date == null || date === "" ? defaultDate : ( typeof date === "string" ? offsetString( date ) :
				( typeof date === "number" ? ( isNaN( date ) ? defaultDate : offsetNumeric( date ) ) : new Date( date.getTime() ) ) ) );

		newDate = ( newDate && newDate.toString() === "Invalid Date" ? defaultDate : newDate );
		if ( newDate ) {
			newDate.setHours( 0 );
			newDate.setMinutes( 0 );
			newDate.setSeconds( 0 );
			newDate.setMilliseconds( 0 );
		}
		return this._daylightSavingAdjust( newDate );
	},

	/* Handle switch to/from daylight saving.
	 * Hours may be non-zero on daylight saving cut-over:
	 * > 12 when midnight changeover, but then cannot generate
	 * midnight datetime, so jump to 1AM, otherwise reset.
	 * @param  date  (Date) the date to check
	 * @return  (Date) the corrected date
	 */
	_daylightSavingAdjust: function( date ) {
		if ( !date ) {
			return null;
		}
		date.setHours( date.getHours() > 12 ? date.getHours() + 2 : 0 );
		return date;
	},

	/* Set the date(s) directly. */
	_setDate: function( inst, date, noChange ) {
		var clear = !date,
			origMonth = inst.selectedMonth,
			origYear = inst.selectedYear,
			newDate = this._restrictMinMax( inst, this._determineDate( inst, date, new Date() ) );

		inst.selectedDay = inst.currentDay = newDate.getDate();
		inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
		inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
		if ( ( origMonth !== inst.selectedMonth || origYear !== inst.selectedYear ) && !noChange ) {
			this._notifyChange( inst );
		}
		this._adjustInstDate( inst );
		if ( inst.input ) {
			inst.input.val( clear ? "" : this._formatDate( inst ) );
		}
	},

	/* Retrieve the date(s) directly. */
	_getDate: function( inst ) {
		var startDate = ( !inst.currentYear || ( inst.input && inst.input.val() === "" ) ? null :
			this._daylightSavingAdjust( new Date(
			inst.currentYear, inst.currentMonth, inst.currentDay ) ) );
			return startDate;
	},

	/* Attach the onxxx handlers.  These are declared statically so
	 * they work with static code transformers like Caja.
	 */
	_attachHandlers: function( inst ) {
		var stepMonths = this._get( inst, "stepMonths" ),
			id = "#" + inst.id.replace( /\\\\/g, "\\" );
		inst.dpDiv.find( "[data-handler]" ).map( function() {
			var handler = {
				prev: function() {
					$.datepicker._adjustDate( id, -stepMonths, "M" );
				},
				next: function() {
					$.datepicker._adjustDate( id, +stepMonths, "M" );
				},
				hide: function() {
					$.datepicker._hideDatepicker();
				},
				today: function() {
					$.datepicker._gotoToday( id );
				},
				selectDay: function() {
					$.datepicker._selectDay( id, +this.getAttribute( "data-month" ), +this.getAttribute( "data-year" ), this );
					return false;
				},
				selectMonth: function() {
					$.datepicker._selectMonthYear( id, this, "M" );
					return false;
				},
				selectYear: function() {
					$.datepicker._selectMonthYear( id, this, "Y" );
					return false;
				}
			};
			$( this ).on( this.getAttribute( "data-event" ), handler[ this.getAttribute( "data-handler" ) ] );
		} );
	},

	/* Generate the HTML for the current state of the date picker. */
	_generateHTML: function( inst ) {
		var maxDraw, prevText, prev, nextText, next, currentText, gotoDate,
			controls, buttonPanel, firstDay, showWeek, dayNames, dayNamesMin,
			monthNames, monthNamesShort, beforeShowDay, showOtherMonths,
			selectOtherMonths, defaultDate, html, dow, row, group, col, selectedDate,
			cornerClass, calender, thead, day, daysInMonth, leadDays, curRows, numRows,
			printDate, dRow, tbody, daySettings, otherMonth, unselectable,
			tempDate = new Date(),
			today = this._daylightSavingAdjust(
				new Date( tempDate.getFullYear(), tempDate.getMonth(), tempDate.getDate() ) ), // clear time
			isRTL = this._get( inst, "isRTL" ),
			showButtonPanel = this._get( inst, "showButtonPanel" ),
			hideIfNoPrevNext = this._get( inst, "hideIfNoPrevNext" ),
			navigationAsDateFormat = this._get( inst, "navigationAsDateFormat" ),
			numMonths = this._getNumberOfMonths( inst ),
			showCurrentAtPos = this._get( inst, "showCurrentAtPos" ),
			stepMonths = this._get( inst, "stepMonths" ),
			isMultiMonth = ( numMonths[ 0 ] !== 1 || numMonths[ 1 ] !== 1 ),
			currentDate = this._daylightSavingAdjust( ( !inst.currentDay ? new Date( 9999, 9, 9 ) :
				new Date( inst.currentYear, inst.currentMonth, inst.currentDay ) ) ),
			minDate = this._getMinMaxDate( inst, "min" ),
			maxDate = this._getMinMaxDate( inst, "max" ),
			drawMonth = inst.drawMonth - showCurrentAtPos,
			drawYear = inst.drawYear;

		if ( drawMonth < 0 ) {
			drawMonth += 12;
			drawYear--;
		}
		if ( maxDate ) {
			maxDraw = this._daylightSavingAdjust( new Date( maxDate.getFullYear(),
				maxDate.getMonth() - ( numMonths[ 0 ] * numMonths[ 1 ] ) + 1, maxDate.getDate() ) );
			maxDraw = ( minDate && maxDraw < minDate ? minDate : maxDraw );
			while ( this._daylightSavingAdjust( new Date( drawYear, drawMonth, 1 ) ) > maxDraw ) {
				drawMonth--;
				if ( drawMonth < 0 ) {
					drawMonth = 11;
					drawYear--;
				}
			}
		}
		inst.drawMonth = drawMonth;
		inst.drawYear = drawYear;

		prevText = this._get( inst, "prevText" );
		prevText = ( !navigationAsDateFormat ? prevText : this.formatDate( prevText,
			this._daylightSavingAdjust( new Date( drawYear, drawMonth - stepMonths, 1 ) ),
			this._getFormatConfig( inst ) ) );

		prev = ( this._canAdjustMonth( inst, -1, drawYear, drawMonth ) ?
			"<a class='ui-datepicker-prev ui-corner-all' data-handler='prev' data-event='click'" +
			" title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w" ) + "'>" + prevText + "</span></a>" :
			( hideIfNoPrevNext ? "" : "<a class='ui-datepicker-prev ui-corner-all ui-state-disabled' title='" + prevText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "e" : "w" ) + "'>" + prevText + "</span></a>" ) );

		nextText = this._get( inst, "nextText" );
		nextText = ( !navigationAsDateFormat ? nextText : this.formatDate( nextText,
			this._daylightSavingAdjust( new Date( drawYear, drawMonth + stepMonths, 1 ) ),
			this._getFormatConfig( inst ) ) );

		next = ( this._canAdjustMonth( inst, +1, drawYear, drawMonth ) ?
			"<a class='ui-datepicker-next ui-corner-all' data-handler='next' data-event='click'" +
			" title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e" ) + "'>" + nextText + "</span></a>" :
			( hideIfNoPrevNext ? "" : "<a class='ui-datepicker-next ui-corner-all ui-state-disabled' title='" + nextText + "'><span class='ui-icon ui-icon-circle-triangle-" + ( isRTL ? "w" : "e" ) + "'>" + nextText + "</span></a>" ) );

		currentText = this._get( inst, "currentText" );
		gotoDate = ( this._get( inst, "gotoCurrent" ) && inst.currentDay ? currentDate : today );
		currentText = ( !navigationAsDateFormat ? currentText :
			this.formatDate( currentText, gotoDate, this._getFormatConfig( inst ) ) );

		controls = ( !inst.inline ? "<button type='button' class='ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all' data-handler='hide' data-event='click'>" +
			this._get( inst, "closeText" ) + "</button>" : "" );

		buttonPanel = ( showButtonPanel ) ? "<div class='ui-datepicker-buttonpane ui-widget-content'>" + ( isRTL ? controls : "" ) +
			( this._isInRange( inst, gotoDate ) ? "<button type='button' class='ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all' data-handler='today' data-event='click'" +
			">" + currentText + "</button>" : "" ) + ( isRTL ? "" : controls ) + "</div>" : "";

		firstDay = parseInt( this._get( inst, "firstDay" ), 10 );
		firstDay = ( isNaN( firstDay ) ? 0 : firstDay );

		showWeek = this._get( inst, "showWeek" );
		dayNames = this._get( inst, "dayNames" );
		dayNamesMin = this._get( inst, "dayNamesMin" );
		monthNames = this._get( inst, "monthNames" );
		monthNamesShort = this._get( inst, "monthNamesShort" );
		beforeShowDay = this._get( inst, "beforeShowDay" );
		showOtherMonths = this._get( inst, "showOtherMonths" );
		selectOtherMonths = this._get( inst, "selectOtherMonths" );
		defaultDate = this._getDefaultDate( inst );
		html = "";

		for ( row = 0; row < numMonths[ 0 ]; row++ ) {
			group = "";
			this.maxRows = 4;
			for ( col = 0; col < numMonths[ 1 ]; col++ ) {
				selectedDate = this._daylightSavingAdjust( new Date( drawYear, drawMonth, inst.selectedDay ) );
				cornerClass = " ui-corner-all";
				calender = "";
				if ( isMultiMonth ) {
					calender += "<div class='ui-datepicker-group";
					if ( numMonths[ 1 ] > 1 ) {
						switch ( col ) {
							case 0: calender += " ui-datepicker-group-first";
								cornerClass = " ui-corner-" + ( isRTL ? "right" : "left" ); break;
							case numMonths[ 1 ] - 1: calender += " ui-datepicker-group-last";
								cornerClass = " ui-corner-" + ( isRTL ? "left" : "right" ); break;
							default: calender += " ui-datepicker-group-middle"; cornerClass = ""; break;
						}
					}
					calender += "'>";
				}
				calender += "<div class='ui-datepicker-header ui-widget-header ui-helper-clearfix" + cornerClass + "'>" +
					( /all|left/.test( cornerClass ) && row === 0 ? ( isRTL ? next : prev ) : "" ) +
					( /all|right/.test( cornerClass ) && row === 0 ? ( isRTL ? prev : next ) : "" ) +
					this._generateMonthYearHeader( inst, drawMonth, drawYear, minDate, maxDate,
					row > 0 || col > 0, monthNames, monthNamesShort ) + // draw month headers
					"</div><table class='ui-datepicker-calendar'><thead>" +
					"<tr>";
				thead = ( showWeek ? "<th class='ui-datepicker-week-col'>" + this._get( inst, "weekHeader" ) + "</th>" : "" );
				for ( dow = 0; dow < 7; dow++ ) { // days of the week
					day = ( dow + firstDay ) % 7;
					thead += "<th scope='col'" + ( ( dow + firstDay + 6 ) % 7 >= 5 ? " class='ui-datepicker-week-end'" : "" ) + ">" +
						"<span title='" + dayNames[ day ] + "'>" + dayNamesMin[ day ] + "</span></th>";
				}
				calender += thead + "</tr></thead><tbody>";
				daysInMonth = this._getDaysInMonth( drawYear, drawMonth );
				if ( drawYear === inst.selectedYear && drawMonth === inst.selectedMonth ) {
					inst.selectedDay = Math.min( inst.selectedDay, daysInMonth );
				}
				leadDays = ( this._getFirstDayOfMonth( drawYear, drawMonth ) - firstDay + 7 ) % 7;
				curRows = Math.ceil( ( leadDays + daysInMonth ) / 7 ); // calculate the number of rows to generate
				numRows = ( isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows ); //If multiple months, use the higher number of rows (see #7043)
				this.maxRows = numRows;
				printDate = this._daylightSavingAdjust( new Date( drawYear, drawMonth, 1 - leadDays ) );
				for ( dRow = 0; dRow < numRows; dRow++ ) { // create date picker rows
					calender += "<tr>";
					tbody = ( !showWeek ? "" : "<td class='ui-datepicker-week-col'>" +
						this._get( inst, "calculateWeek" )( printDate ) + "</td>" );
					for ( dow = 0; dow < 7; dow++ ) { // create date picker days
						daySettings = ( beforeShowDay ?
							beforeShowDay.apply( ( inst.input ? inst.input[ 0 ] : null ), [ printDate ] ) : [ true, "" ] );
						otherMonth = ( printDate.getMonth() !== drawMonth );
						unselectable = ( otherMonth && !selectOtherMonths ) || !daySettings[ 0 ] ||
							( minDate && printDate < minDate ) || ( maxDate && printDate > maxDate );
						tbody += "<td class='" +
							( ( dow + firstDay + 6 ) % 7 >= 5 ? " ui-datepicker-week-end" : "" ) + // highlight weekends
							( otherMonth ? " ui-datepicker-other-month" : "" ) + // highlight days from other months
							( ( printDate.getTime() === selectedDate.getTime() && drawMonth === inst.selectedMonth && inst._keyEvent ) || // user pressed key
							( defaultDate.getTime() === printDate.getTime() && defaultDate.getTime() === selectedDate.getTime() ) ?

							// or defaultDate is current printedDate and defaultDate is selectedDate
							" " + this._dayOverClass : "" ) + // highlight selected day
							( unselectable ? " " + this._unselectableClass + " ui-state-disabled" : "" ) +  // highlight unselectable days
							( otherMonth && !showOtherMonths ? "" : " " + daySettings[ 1 ] + // highlight custom dates
							( printDate.getTime() === currentDate.getTime() ? " " + this._currentClass : "" ) + // highlight selected day
							( printDate.getTime() === today.getTime() ? " ui-datepicker-today" : "" ) ) + "'" + // highlight today (if different)
							( ( !otherMonth || showOtherMonths ) && daySettings[ 2 ] ? " title='" + daySettings[ 2 ].replace( /'/g, "&#39;" ) + "'" : "" ) + // cell title
							( unselectable ? "" : " data-handler='selectDay' data-event='click' data-month='" + printDate.getMonth() + "' data-year='" + printDate.getFullYear() + "'" ) + ">" + // actions
							( otherMonth && !showOtherMonths ? "&#xa0;" : // display for other months
							( unselectable ? "<span class='ui-state-default'>" + printDate.getDate() + "</span>" : "<a class='ui-state-default" +
							( printDate.getTime() === today.getTime() ? " ui-state-highlight" : "" ) +
							( printDate.getTime() === currentDate.getTime() ? " ui-state-active" : "" ) + // highlight selected day
							( otherMonth ? " ui-priority-secondary" : "" ) + // distinguish dates from other months
							"' href='#'>" + printDate.getDate() + "</a>" ) ) + "</td>"; // display selectable date
						printDate.setDate( printDate.getDate() + 1 );
						printDate = this._daylightSavingAdjust( printDate );
					}
					calender += tbody + "</tr>";
				}
				drawMonth++;
				if ( drawMonth > 11 ) {
					drawMonth = 0;
					drawYear++;
				}
				calender += "</tbody></table>" + ( isMultiMonth ? "</div>" +
							( ( numMonths[ 0 ] > 0 && col === numMonths[ 1 ] - 1 ) ? "<div class='ui-datepicker-row-break'></div>" : "" ) : "" );
				group += calender;
			}
			html += group;
		}
		html += buttonPanel;
		inst._keyEvent = false;
		return html;
	},

	/* Generate the month and year header. */
	_generateMonthYearHeader: function( inst, drawMonth, drawYear, minDate, maxDate,
			secondary, monthNames, monthNamesShort ) {

		var inMinYear, inMaxYear, month, years, thisYear, determineYear, year, endYear,
			changeMonth = this._get( inst, "changeMonth" ),
			changeYear = this._get( inst, "changeYear" ),
			showMonthAfterYear = this._get( inst, "showMonthAfterYear" ),
			html = "<div class='ui-datepicker-title'>",
			monthHtml = "";

		// Month selection
		if ( secondary || !changeMonth ) {
			monthHtml += "<span class='ui-datepicker-month'>" + monthNames[ drawMonth ] + "</span>";
		} else {
			inMinYear = ( minDate && minDate.getFullYear() === drawYear );
			inMaxYear = ( maxDate && maxDate.getFullYear() === drawYear );
			monthHtml += "<select class='ui-datepicker-month' data-handler='selectMonth' data-event='change'>";
			for ( month = 0; month < 12; month++ ) {
				if ( ( !inMinYear || month >= minDate.getMonth() ) && ( !inMaxYear || month <= maxDate.getMonth() ) ) {
					monthHtml += "<option value='" + month + "'" +
						( month === drawMonth ? " selected='selected'" : "" ) +
						">" + monthNamesShort[ month ] + "</option>";
				}
			}
			monthHtml += "</select>";
		}

		if ( !showMonthAfterYear ) {
			html += monthHtml + ( secondary || !( changeMonth && changeYear ) ? "&#xa0;" : "" );
		}

		// Year selection
		if ( !inst.yearshtml ) {
			inst.yearshtml = "";
			if ( secondary || !changeYear ) {
				html += "<span class='ui-datepicker-year'>" + drawYear + "</span>";
			} else {

				// determine range of years to display
				years = this._get( inst, "yearRange" ).split( ":" );
				thisYear = new Date().getFullYear();
				determineYear = function( value ) {
					var year = ( value.match( /c[+\-].*/ ) ? drawYear + parseInt( value.substring( 1 ), 10 ) :
						( value.match( /[+\-].*/ ) ? thisYear + parseInt( value, 10 ) :
						parseInt( value, 10 ) ) );
					return ( isNaN( year ) ? thisYear : year );
				};
				year = determineYear( years[ 0 ] );
				endYear = Math.max( year, determineYear( years[ 1 ] || "" ) );
				year = ( minDate ? Math.max( year, minDate.getFullYear() ) : year );
				endYear = ( maxDate ? Math.min( endYear, maxDate.getFullYear() ) : endYear );
				inst.yearshtml += "<select class='ui-datepicker-year' data-handler='selectYear' data-event='change'>";
				for ( ; year <= endYear; year++ ) {
					inst.yearshtml += "<option value='" + year + "'" +
						( year === drawYear ? " selected='selected'" : "" ) +
						">" + year + "</option>";
				}
				inst.yearshtml += "</select>";

				html += inst.yearshtml;
				inst.yearshtml = null;
			}
		}

		html += this._get( inst, "yearSuffix" );
		if ( showMonthAfterYear ) {
			html += ( secondary || !( changeMonth && changeYear ) ? "&#xa0;" : "" ) + monthHtml;
		}
		html += "</div>"; // Close datepicker_header
		return html;
	},

	/* Adjust one of the date sub-fields. */
	_adjustInstDate: function( inst, offset, period ) {
		var year = inst.selectedYear + ( period === "Y" ? offset : 0 ),
			month = inst.selectedMonth + ( period === "M" ? offset : 0 ),
			day = Math.min( inst.selectedDay, this._getDaysInMonth( year, month ) ) + ( period === "D" ? offset : 0 ),
			date = this._restrictMinMax( inst, this._daylightSavingAdjust( new Date( year, month, day ) ) );

		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		if ( period === "M" || period === "Y" ) {
			this._notifyChange( inst );
		}
	},

	/* Ensure a date is within any min/max bounds. */
	_restrictMinMax: function( inst, date ) {
		var minDate = this._getMinMaxDate( inst, "min" ),
			maxDate = this._getMinMaxDate( inst, "max" ),
			newDate = ( minDate && date < minDate ? minDate : date );
		return ( maxDate && newDate > maxDate ? maxDate : newDate );
	},

	/* Notify change of month/year. */
	_notifyChange: function( inst ) {
		var onChange = this._get( inst, "onChangeMonthYear" );
		if ( onChange ) {
			onChange.apply( ( inst.input ? inst.input[ 0 ] : null ),
				[ inst.selectedYear, inst.selectedMonth + 1, inst ] );
		}
	},

	/* Determine the number of months to show. */
	_getNumberOfMonths: function( inst ) {
		var numMonths = this._get( inst, "numberOfMonths" );
		return ( numMonths == null ? [ 1, 1 ] : ( typeof numMonths === "number" ? [ 1, numMonths ] : numMonths ) );
	},

	/* Determine the current maximum date - ensure no time components are set. */
	_getMinMaxDate: function( inst, minMax ) {
		return this._determineDate( inst, this._get( inst, minMax + "Date" ), null );
	},

	/* Find the number of days in a given month. */
	_getDaysInMonth: function( year, month ) {
		return 32 - this._daylightSavingAdjust( new Date( year, month, 32 ) ).getDate();
	},

	/* Find the day of the week of the first of a month. */
	_getFirstDayOfMonth: function( year, month ) {
		return new Date( year, month, 1 ).getDay();
	},

	/* Determines if we should allow a "next/prev" month display change. */
	_canAdjustMonth: function( inst, offset, curYear, curMonth ) {
		var numMonths = this._getNumberOfMonths( inst ),
			date = this._daylightSavingAdjust( new Date( curYear,
			curMonth + ( offset < 0 ? offset : numMonths[ 0 ] * numMonths[ 1 ] ), 1 ) );

		if ( offset < 0 ) {
			date.setDate( this._getDaysInMonth( date.getFullYear(), date.getMonth() ) );
		}
		return this._isInRange( inst, date );
	},

	/* Is the given date in the accepted range? */
	_isInRange: function( inst, date ) {
		var yearSplit, currentYear,
			minDate = this._getMinMaxDate( inst, "min" ),
			maxDate = this._getMinMaxDate( inst, "max" ),
			minYear = null,
			maxYear = null,
			years = this._get( inst, "yearRange" );
			if ( years ) {
				yearSplit = years.split( ":" );
				currentYear = new Date().getFullYear();
				minYear = parseInt( yearSplit[ 0 ], 10 );
				maxYear = parseInt( yearSplit[ 1 ], 10 );
				if ( yearSplit[ 0 ].match( /[+\-].*/ ) ) {
					minYear += currentYear;
				}
				if ( yearSplit[ 1 ].match( /[+\-].*/ ) ) {
					maxYear += currentYear;
				}
			}

		return ( ( !minDate || date.getTime() >= minDate.getTime() ) &&
			( !maxDate || date.getTime() <= maxDate.getTime() ) &&
			( !minYear || date.getFullYear() >= minYear ) &&
			( !maxYear || date.getFullYear() <= maxYear ) );
	},

	/* Provide the configuration settings for formatting/parsing. */
	_getFormatConfig: function( inst ) {
		var shortYearCutoff = this._get( inst, "shortYearCutoff" );
		shortYearCutoff = ( typeof shortYearCutoff !== "string" ? shortYearCutoff :
			new Date().getFullYear() % 100 + parseInt( shortYearCutoff, 10 ) );
		return { shortYearCutoff: shortYearCutoff,
			dayNamesShort: this._get( inst, "dayNamesShort" ), dayNames: this._get( inst, "dayNames" ),
			monthNamesShort: this._get( inst, "monthNamesShort" ), monthNames: this._get( inst, "monthNames" ) };
	},

	/* Format the given date for display. */
	_formatDate: function( inst, day, month, year ) {
		if ( !day ) {
			inst.currentDay = inst.selectedDay;
			inst.currentMonth = inst.selectedMonth;
			inst.currentYear = inst.selectedYear;
		}
		var date = ( day ? ( typeof day === "object" ? day :
			this._daylightSavingAdjust( new Date( year, month, day ) ) ) :
			this._daylightSavingAdjust( new Date( inst.currentYear, inst.currentMonth, inst.currentDay ) ) );
		return this.formatDate( this._get( inst, "dateFormat" ), date, this._getFormatConfig( inst ) );
	}
} );

/*
 * Bind hover events for datepicker elements.
 * Done via delegate so the binding only occurs once in the lifetime of the parent div.
 * Global datepicker_instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
 */
function datepicker_bindHover( dpDiv ) {
	var selector = "button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a";
	return dpDiv.on( "mouseout", selector, function() {
			$( this ).removeClass( "ui-state-hover" );
			if ( this.className.indexOf( "ui-datepicker-prev" ) !== -1 ) {
				$( this ).removeClass( "ui-datepicker-prev-hover" );
			}
			if ( this.className.indexOf( "ui-datepicker-next" ) !== -1 ) {
				$( this ).removeClass( "ui-datepicker-next-hover" );
			}
		} )
		.on( "mouseover", selector, datepicker_handleMouseover );
}

function datepicker_handleMouseover() {
	if ( !$.datepicker._isDisabledDatepicker( datepicker_instActive.inline ? datepicker_instActive.dpDiv.parent()[ 0 ] : datepicker_instActive.input[ 0 ] ) ) {
		$( this ).parents( ".ui-datepicker-calendar" ).find( "a" ).removeClass( "ui-state-hover" );
		$( this ).addClass( "ui-state-hover" );
		if ( this.className.indexOf( "ui-datepicker-prev" ) !== -1 ) {
			$( this ).addClass( "ui-datepicker-prev-hover" );
		}
		if ( this.className.indexOf( "ui-datepicker-next" ) !== -1 ) {
			$( this ).addClass( "ui-datepicker-next-hover" );
		}
	}
}

/* jQuery extend now ignores nulls! */
function datepicker_extendRemove( target, props ) {
	$.extend( target, props );
	for ( var name in props ) {
		if ( props[ name ] == null ) {
			target[ name ] = props[ name ];
		}
	}
	return target;
}

/* Invoke the datepicker functionality.
   @param  options  string - a command, optionally followed by additional parameters or
					Object - settings for attaching new datepicker functionality
   @return  jQuery object */
$.fn.datepicker = function( options ) {

	/* Verify an empty collection wasn't passed - Fixes #6976 */
	if ( !this.length ) {
		return this;
	}

	/* Initialise the date picker. */
	if ( !$.datepicker.initialized ) {
		$( document ).on( "mousedown", $.datepicker._checkExternalClick );
		$.datepicker.initialized = true;
	}

	/* Append datepicker main container to body if not exist. */
	if ( $( "#" + $.datepicker._mainDivId ).length === 0 ) {
		$( "body" ).append( $.datepicker.dpDiv );
	}

	var otherArgs = Array.prototype.slice.call( arguments, 1 );
	if ( typeof options === "string" && ( options === "isDisabled" || options === "getDate" || options === "widget" ) ) {
		return $.datepicker[ "_" + options + "Datepicker" ].
			apply( $.datepicker, [ this[ 0 ] ].concat( otherArgs ) );
	}
	if ( options === "option" && arguments.length === 2 && typeof arguments[ 1 ] === "string" ) {
		return $.datepicker[ "_" + options + "Datepicker" ].
			apply( $.datepicker, [ this[ 0 ] ].concat( otherArgs ) );
	}
	return this.each( function() {
		typeof options === "string" ?
			$.datepicker[ "_" + options + "Datepicker" ].
				apply( $.datepicker, [ this ].concat( otherArgs ) ) :
			$.datepicker._attachDatepicker( this, options );
	} );
};

$.datepicker = new Datepicker(); // singleton instance
$.datepicker.initialized = false;
$.datepicker.uuid = new Date().getTime();
$.datepicker.version = "1.12.1";

var widgetsDatepicker = $.datepicker;


/*!
 * jQuery UI Dialog 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Dialog
//>>group: Widgets
//>>description: Displays customizable dialog windows.
//>>docs: http://api.jqueryui.com/dialog/
//>>demos: http://jqueryui.com/dialog/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/dialog.css
//>>css.theme: ../../themes/base/theme.css



$.widget( "ui.dialog", {
	version: "1.12.1",
	options: {
		appendTo: "body",
		autoOpen: true,
		buttons: [],
		classes: {
			"ui-dialog": "ui-corner-all",
			"ui-dialog-titlebar": "ui-corner-all"
		},
		closeOnEscape: true,
		closeText: "Close",
		draggable: true,
		hide: null,
		height: "auto",
		maxHeight: null,
		maxWidth: null,
		minHeight: 150,
		minWidth: 150,
		modal: false,
		position: {
			my: "center",
			at: "center",
			of: window,
			collision: "fit",

			// Ensure the titlebar is always visible
			using: function( pos ) {
				var topOffset = $( this ).css( pos ).offset().top;
				if ( topOffset < 0 ) {
					$( this ).css( "top", pos.top - topOffset );
				}
			}
		},
		resizable: true,
		show: null,
		title: null,
		width: 300,

		// Callbacks
		beforeClose: null,
		close: null,
		drag: null,
		dragStart: null,
		dragStop: null,
		focus: null,
		open: null,
		resize: null,
		resizeStart: null,
		resizeStop: null
	},

	sizeRelatedOptions: {
		buttons: true,
		height: true,
		maxHeight: true,
		maxWidth: true,
		minHeight: true,
		minWidth: true,
		width: true
	},

	resizableRelatedOptions: {
		maxHeight: true,
		maxWidth: true,
		minHeight: true,
		minWidth: true
	},

	_create: function() {
		this.originalCss = {
			display: this.element[ 0 ].style.display,
			width: this.element[ 0 ].style.width,
			minHeight: this.element[ 0 ].style.minHeight,
			maxHeight: this.element[ 0 ].style.maxHeight,
			height: this.element[ 0 ].style.height
		};
		this.originalPosition = {
			parent: this.element.parent(),
			index: this.element.parent().children().index( this.element )
		};
		this.originalTitle = this.element.attr( "title" );
		if ( this.options.title == null && this.originalTitle != null ) {
			this.options.title = this.originalTitle;
		}

		// Dialogs can't be disabled
		if ( this.options.disabled ) {
			this.options.disabled = false;
		}

		this._createWrapper();

		this.element
			.show()
			.removeAttr( "title" )
			.appendTo( this.uiDialog );

		this._addClass( "ui-dialog-content", "ui-widget-content" );

		this._createTitlebar();
		this._createButtonPane();

		if ( this.options.draggable && $.fn.draggable ) {
			this._makeDraggable();
		}
		if ( this.options.resizable && $.fn.resizable ) {
			this._makeResizable();
		}

		this._isOpen = false;

		this._trackFocus();
	},

	_init: function() {
		if ( this.options.autoOpen ) {
			this.open();
		}
	},

	_appendTo: function() {
		var element = this.options.appendTo;
		if ( element && ( element.jquery || element.nodeType ) ) {
			return $( element );
		}
		return this.document.find( element || "body" ).eq( 0 );
	},

	_destroy: function() {
		var next,
			originalPosition = this.originalPosition;

		this._untrackInstance();
		this._destroyOverlay();

		this.element
			.removeUniqueId()
			.css( this.originalCss )

			// Without detaching first, the following becomes really slow
			.detach();

		this.uiDialog.remove();

		if ( this.originalTitle ) {
			this.element.attr( "title", this.originalTitle );
		}

		next = originalPosition.parent.children().eq( originalPosition.index );

		// Don't try to place the dialog next to itself (#8613)
		if ( next.length && next[ 0 ] !== this.element[ 0 ] ) {
			next.before( this.element );
		} else {
			originalPosition.parent.append( this.element );
		}
	},

	widget: function() {
		return this.uiDialog;
	},

	disable: $.noop,
	enable: $.noop,

	close: function( event ) {
		var that = this;

		if ( !this._isOpen || this._trigger( "beforeClose", event ) === false ) {
			return;
		}

		this._isOpen = false;
		this._focusedElement = null;
		this._destroyOverlay();
		this._untrackInstance();

		if ( !this.opener.filter( ":focusable" ).trigger( "focus" ).length ) {

			// Hiding a focused element doesn't trigger blur in WebKit
			// so in case we have nothing to focus on, explicitly blur the active element
			// https://bugs.webkit.org/show_bug.cgi?id=47182
			$.ui.safeBlur( $.ui.safeActiveElement( this.document[ 0 ] ) );
		}

		this._hide( this.uiDialog, this.options.hide, function() {
			that._trigger( "close", event );
		} );
	},

	isOpen: function() {
		return this._isOpen;
	},

	moveToTop: function() {
		this._moveToTop();
	},

	_moveToTop: function( event, silent ) {
		var moved = false,
			zIndices = this.uiDialog.siblings( ".ui-front:visible" ).map( function() {
				return +$( this ).css( "z-index" );
			} ).get(),
			zIndexMax = Math.max.apply( null, zIndices );

		if ( zIndexMax >= +this.uiDialog.css( "z-index" ) ) {
			this.uiDialog.css( "z-index", zIndexMax + 1 );
			moved = true;
		}

		if ( moved && !silent ) {
			this._trigger( "focus", event );
		}
		return moved;
	},

	open: function() {
		var that = this;
		if ( this._isOpen ) {
			if ( this._moveToTop() ) {
				this._focusTabbable();
			}
			return;
		}

		this._isOpen = true;
		this.opener = $( $.ui.safeActiveElement( this.document[ 0 ] ) );

		this._size();
		this._position();
		this._createOverlay();
		this._moveToTop( null, true );

		// Ensure the overlay is moved to the top with the dialog, but only when
		// opening. The overlay shouldn't move after the dialog is open so that
		// modeless dialogs opened after the modal dialog stack properly.
		if ( this.overlay ) {
			this.overlay.css( "z-index", this.uiDialog.css( "z-index" ) - 1 );
		}

		this._show( this.uiDialog, this.options.show, function() {
			that._focusTabbable();
			that._trigger( "focus" );
		} );

		// Track the dialog immediately upon openening in case a focus event
		// somehow occurs outside of the dialog before an element inside the
		// dialog is focused (#10152)
		this._makeFocusTarget();

		this._trigger( "open" );
	},

	_focusTabbable: function() {

		// Set focus to the first match:
		// 1. An element that was focused previously
		// 2. First element inside the dialog matching [autofocus]
		// 3. Tabbable element inside the content element
		// 4. Tabbable element inside the buttonpane
		// 5. The close button
		// 6. The dialog itself
		var hasFocus = this._focusedElement;
		if ( !hasFocus ) {
			hasFocus = this.element.find( "[autofocus]" );
		}
		if ( !hasFocus.length ) {
			hasFocus = this.element.find( ":tabbable" );
		}
		if ( !hasFocus.length ) {
			hasFocus = this.uiDialogButtonPane.find( ":tabbable" );
		}
		if ( !hasFocus.length ) {
			hasFocus = this.uiDialogTitlebarClose.filter( ":tabbable" );
		}
		if ( !hasFocus.length ) {
			hasFocus = this.uiDialog;
		}
		hasFocus.eq( 0 ).trigger( "focus" );
	},

	_keepFocus: function( event ) {
		function checkFocus() {
			var activeElement = $.ui.safeActiveElement( this.document[ 0 ] ),
				isActive = this.uiDialog[ 0 ] === activeElement ||
					$.contains( this.uiDialog[ 0 ], activeElement );
			if ( !isActive ) {
				this._focusTabbable();
			}
		}
		event.preventDefault();
		checkFocus.call( this );

		// support: IE
		// IE <= 8 doesn't prevent moving focus even with event.preventDefault()
		// so we check again later
		this._delay( checkFocus );
	},

	_createWrapper: function() {
		this.uiDialog = $( "<div>" )
			.hide()
			.attr( {

				// Setting tabIndex makes the div focusable
				tabIndex: -1,
				role: "dialog"
			} )
			.appendTo( this._appendTo() );

		this._addClass( this.uiDialog, "ui-dialog", "ui-widget ui-widget-content ui-front" );
		this._on( this.uiDialog, {
			keydown: function( event ) {
				if ( this.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode &&
						event.keyCode === $.ui.keyCode.ESCAPE ) {
					event.preventDefault();
					this.close( event );
					return;
				}

				// Prevent tabbing out of dialogs
				if ( event.keyCode !== $.ui.keyCode.TAB || event.isDefaultPrevented() ) {
					return;
				}
				var tabbables = this.uiDialog.find( ":tabbable" ),
					first = tabbables.filter( ":first" ),
					last = tabbables.filter( ":last" );

				if ( ( event.target === last[ 0 ] || event.target === this.uiDialog[ 0 ] ) &&
						!event.shiftKey ) {
					this._delay( function() {
						first.trigger( "focus" );
					} );
					event.preventDefault();
				} else if ( ( event.target === first[ 0 ] ||
						event.target === this.uiDialog[ 0 ] ) && event.shiftKey ) {
					this._delay( function() {
						last.trigger( "focus" );
					} );
					event.preventDefault();
				}
			},
			mousedown: function( event ) {
				if ( this._moveToTop( event ) ) {
					this._focusTabbable();
				}
			}
		} );

		// We assume that any existing aria-describedby attribute means
		// that the dialog content is marked up properly
		// otherwise we brute force the content as the description
		if ( !this.element.find( "[aria-describedby]" ).length ) {
			this.uiDialog.attr( {
				"aria-describedby": this.element.uniqueId().attr( "id" )
			} );
		}
	},

	_createTitlebar: function() {
		var uiDialogTitle;

		this.uiDialogTitlebar = $( "<div>" );
		this._addClass( this.uiDialogTitlebar,
			"ui-dialog-titlebar", "ui-widget-header ui-helper-clearfix" );
		this._on( this.uiDialogTitlebar, {
			mousedown: function( event ) {

				// Don't prevent click on close button (#8838)
				// Focusing a dialog that is partially scrolled out of view
				// causes the browser to scroll it into view, preventing the click event
				if ( !$( event.target ).closest( ".ui-dialog-titlebar-close" ) ) {

					// Dialog isn't getting focus when dragging (#8063)
					this.uiDialog.trigger( "focus" );
				}
			}
		} );

		// Support: IE
		// Use type="button" to prevent enter keypresses in textboxes from closing the
		// dialog in IE (#9312)
		this.uiDialogTitlebarClose = $( "<button type='button'></button>" )
			.button( {
				label: $( "<a>" ).text( this.options.closeText ).html(),
				icon: "ui-icon-closethick",
				showLabel: false
			} )
			.appendTo( this.uiDialogTitlebar );

		this._addClass( this.uiDialogTitlebarClose, "ui-dialog-titlebar-close" );
		this._on( this.uiDialogTitlebarClose, {
			click: function( event ) {
				event.preventDefault();
				this.close( event );
			}
		} );

		uiDialogTitle = $( "<span>" ).uniqueId().prependTo( this.uiDialogTitlebar );
		this._addClass( uiDialogTitle, "ui-dialog-title" );
		this._title( uiDialogTitle );

		this.uiDialogTitlebar.prependTo( this.uiDialog );

		this.uiDialog.attr( {
			"aria-labelledby": uiDialogTitle.attr( "id" )
		} );
	},

	_title: function( title ) {
		if ( this.options.title ) {
			title.text( this.options.title );
		} else {
			title.html( "&#160;" );
		}
	},

	_createButtonPane: function() {
		this.uiDialogButtonPane = $( "<div>" );
		this._addClass( this.uiDialogButtonPane, "ui-dialog-buttonpane",
			"ui-widget-content ui-helper-clearfix" );

		this.uiButtonSet = $( "<div>" )
			.appendTo( this.uiDialogButtonPane );
		this._addClass( this.uiButtonSet, "ui-dialog-buttonset" );

		this._createButtons();
	},

	_createButtons: function() {
		var that = this,
			buttons = this.options.buttons;

		// If we already have a button pane, remove it
		this.uiDialogButtonPane.remove();
		this.uiButtonSet.empty();

		if ( $.isEmptyObject( buttons ) || ( $.isArray( buttons ) && !buttons.length ) ) {
			this._removeClass( this.uiDialog, "ui-dialog-buttons" );
			return;
		}

		$.each( buttons, function( name, props ) {
			var click, buttonOptions;
			props = $.isFunction( props ) ?
				{ click: props, text: name } :
				props;

			// Default to a non-submitting button
			props = $.extend( { type: "button" }, props );

			// Change the context for the click callback to be the main element
			click = props.click;
			buttonOptions = {
				icon: props.icon,
				iconPosition: props.iconPosition,
				showLabel: props.showLabel,

				// Deprecated options
				icons: props.icons,
				text: props.text
			};

			delete props.click;
			delete props.icon;
			delete props.iconPosition;
			delete props.showLabel;

			// Deprecated options
			delete props.icons;
			if ( typeof props.text === "boolean" ) {
				delete props.text;
			}

			$( "<button></button>", props )
				.button( buttonOptions )
				.appendTo( that.uiButtonSet )
				.on( "click", function() {
					click.apply( that.element[ 0 ], arguments );
				} );
		} );
		this._addClass( this.uiDialog, "ui-dialog-buttons" );
		this.uiDialogButtonPane.appendTo( this.uiDialog );
	},

	_makeDraggable: function() {
		var that = this,
			options = this.options;

		function filteredUi( ui ) {
			return {
				position: ui.position,
				offset: ui.offset
			};
		}

		this.uiDialog.draggable( {
			cancel: ".ui-dialog-content, .ui-dialog-titlebar-close",
			handle: ".ui-dialog-titlebar",
			containment: "document",
			start: function( event, ui ) {
				that._addClass( $( this ), "ui-dialog-dragging" );
				that._blockFrames();
				that._trigger( "dragStart", event, filteredUi( ui ) );
			},
			drag: function( event, ui ) {
				that._trigger( "drag", event, filteredUi( ui ) );
			},
			stop: function( event, ui ) {
				var left = ui.offset.left - that.document.scrollLeft(),
					top = ui.offset.top - that.document.scrollTop();

				options.position = {
					my: "left top",
					at: "left" + ( left >= 0 ? "+" : "" ) + left + " " +
						"top" + ( top >= 0 ? "+" : "" ) + top,
					of: that.window
				};
				that._removeClass( $( this ), "ui-dialog-dragging" );
				that._unblockFrames();
				that._trigger( "dragStop", event, filteredUi( ui ) );
			}
		} );
	},

	_makeResizable: function() {
		var that = this,
			options = this.options,
			handles = options.resizable,

			// .ui-resizable has position: relative defined in the stylesheet
			// but dialogs have to use absolute or fixed positioning
			position = this.uiDialog.css( "position" ),
			resizeHandles = typeof handles === "string" ?
				handles :
				"n,e,s,w,se,sw,ne,nw";

		function filteredUi( ui ) {
			return {
				originalPosition: ui.originalPosition,
				originalSize: ui.originalSize,
				position: ui.position,
				size: ui.size
			};
		}

		this.uiDialog.resizable( {
			cancel: ".ui-dialog-content",
			containment: "document",
			alsoResize: this.element,
			maxWidth: options.maxWidth,
			maxHeight: options.maxHeight,
			minWidth: options.minWidth,
			minHeight: this._minHeight(),
			handles: resizeHandles,
			start: function( event, ui ) {
				that._addClass( $( this ), "ui-dialog-resizing" );
				that._blockFrames();
				that._trigger( "resizeStart", event, filteredUi( ui ) );
			},
			resize: function( event, ui ) {
				that._trigger( "resize", event, filteredUi( ui ) );
			},
			stop: function( event, ui ) {
				var offset = that.uiDialog.offset(),
					left = offset.left - that.document.scrollLeft(),
					top = offset.top - that.document.scrollTop();

				options.height = that.uiDialog.height();
				options.width = that.uiDialog.width();
				options.position = {
					my: "left top",
					at: "left" + ( left >= 0 ? "+" : "" ) + left + " " +
						"top" + ( top >= 0 ? "+" : "" ) + top,
					of: that.window
				};
				that._removeClass( $( this ), "ui-dialog-resizing" );
				that._unblockFrames();
				that._trigger( "resizeStop", event, filteredUi( ui ) );
			}
		} )
			.css( "position", position );
	},

	_trackFocus: function() {
		this._on( this.widget(), {
			focusin: function( event ) {
				this._makeFocusTarget();
				this._focusedElement = $( event.target );
			}
		} );
	},

	_makeFocusTarget: function() {
		this._untrackInstance();
		this._trackingInstances().unshift( this );
	},

	_untrackInstance: function() {
		var instances = this._trackingInstances(),
			exists = $.inArray( this, instances );
		if ( exists !== -1 ) {
			instances.splice( exists, 1 );
		}
	},

	_trackingInstances: function() {
		var instances = this.document.data( "ui-dialog-instances" );
		if ( !instances ) {
			instances = [];
			this.document.data( "ui-dialog-instances", instances );
		}
		return instances;
	},

	_minHeight: function() {
		var options = this.options;

		return options.height === "auto" ?
			options.minHeight :
			Math.min( options.minHeight, options.height );
	},

	_position: function() {

		// Need to show the dialog to get the actual offset in the position plugin
		var isVisible = this.uiDialog.is( ":visible" );
		if ( !isVisible ) {
			this.uiDialog.show();
		}
		this.uiDialog.position( this.options.position );
		if ( !isVisible ) {
			this.uiDialog.hide();
		}
	},

	_setOptions: function( options ) {
		var that = this,
			resize = false,
			resizableOptions = {};

		$.each( options, function( key, value ) {
			that._setOption( key, value );

			if ( key in that.sizeRelatedOptions ) {
				resize = true;
			}
			if ( key in that.resizableRelatedOptions ) {
				resizableOptions[ key ] = value;
			}
		} );

		if ( resize ) {
			this._size();
			this._position();
		}
		if ( this.uiDialog.is( ":data(ui-resizable)" ) ) {
			this.uiDialog.resizable( "option", resizableOptions );
		}
	},

	_setOption: function( key, value ) {
		var isDraggable, isResizable,
			uiDialog = this.uiDialog;

		if ( key === "disabled" ) {
			return;
		}

		this._super( key, value );

		if ( key === "appendTo" ) {
			this.uiDialog.appendTo( this._appendTo() );
		}

		if ( key === "buttons" ) {
			this._createButtons();
		}

		if ( key === "closeText" ) {
			this.uiDialogTitlebarClose.button( {

				// Ensure that we always pass a string
				label: $( "<a>" ).text( "" + this.options.closeText ).html()
			} );
		}

		if ( key === "draggable" ) {
			isDraggable = uiDialog.is( ":data(ui-draggable)" );
			if ( isDraggable && !value ) {
				uiDialog.draggable( "destroy" );
			}

			if ( !isDraggable && value ) {
				this._makeDraggable();
			}
		}

		if ( key === "position" ) {
			this._position();
		}

		if ( key === "resizable" ) {

			// currently resizable, becoming non-resizable
			isResizable = uiDialog.is( ":data(ui-resizable)" );
			if ( isResizable && !value ) {
				uiDialog.resizable( "destroy" );
			}

			// Currently resizable, changing handles
			if ( isResizable && typeof value === "string" ) {
				uiDialog.resizable( "option", "handles", value );
			}

			// Currently non-resizable, becoming resizable
			if ( !isResizable && value !== false ) {
				this._makeResizable();
			}
		}

		if ( key === "title" ) {
			this._title( this.uiDialogTitlebar.find( ".ui-dialog-title" ) );
		}
	},

	_size: function() {

		// If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
		// divs will both have width and height set, so we need to reset them
		var nonContentHeight, minContentHeight, maxContentHeight,
			options = this.options;

		// Reset content sizing
		this.element.show().css( {
			width: "auto",
			minHeight: 0,
			maxHeight: "none",
			height: 0
		} );

		if ( options.minWidth > options.width ) {
			options.width = options.minWidth;
		}

		// Reset wrapper sizing
		// determine the height of all the non-content elements
		nonContentHeight = this.uiDialog.css( {
			height: "auto",
			width: options.width
		} )
			.outerHeight();
		minContentHeight = Math.max( 0, options.minHeight - nonContentHeight );
		maxContentHeight = typeof options.maxHeight === "number" ?
			Math.max( 0, options.maxHeight - nonContentHeight ) :
			"none";

		if ( options.height === "auto" ) {
			this.element.css( {
				minHeight: minContentHeight,
				maxHeight: maxContentHeight,
				height: "auto"
			} );
		} else {
			this.element.height( Math.max( 0, options.height - nonContentHeight ) );
		}

		if ( this.uiDialog.is( ":data(ui-resizable)" ) ) {
			this.uiDialog.resizable( "option", "minHeight", this._minHeight() );
		}
	},

	_blockFrames: function() {
		this.iframeBlocks = this.document.find( "iframe" ).map( function() {
			var iframe = $( this );

			return $( "<div>" )
				.css( {
					position: "absolute",
					width: iframe.outerWidth(),
					height: iframe.outerHeight()
				} )
				.appendTo( iframe.parent() )
				.offset( iframe.offset() )[ 0 ];
		} );
	},

	_unblockFrames: function() {
		if ( this.iframeBlocks ) {
			this.iframeBlocks.remove();
			delete this.iframeBlocks;
		}
	},

	_allowInteraction: function( event ) {
		if ( $( event.target ).closest( ".ui-dialog" ).length ) {
			return true;
		}

		// TODO: Remove hack when datepicker implements
		// the .ui-front logic (#8989)
		return !!$( event.target ).closest( ".ui-datepicker" ).length;
	},

	_createOverlay: function() {
		if ( !this.options.modal ) {
			return;
		}

		// We use a delay in case the overlay is created from an
		// event that we're going to be cancelling (#2804)
		var isOpening = true;
		this._delay( function() {
			isOpening = false;
		} );

		if ( !this.document.data( "ui-dialog-overlays" ) ) {

			// Prevent use of anchors and inputs
			// Using _on() for an event handler shared across many instances is
			// safe because the dialogs stack and must be closed in reverse order
			this._on( this.document, {
				focusin: function( event ) {
					if ( isOpening ) {
						return;
					}

					if ( !this._allowInteraction( event ) ) {
						event.preventDefault();
						this._trackingInstances()[ 0 ]._focusTabbable();
					}
				}
			} );
		}

		this.overlay = $( "<div>" )
			.appendTo( this._appendTo() );

		this._addClass( this.overlay, null, "ui-widget-overlay ui-front" );
		this._on( this.overlay, {
			mousedown: "_keepFocus"
		} );
		this.document.data( "ui-dialog-overlays",
			( this.document.data( "ui-dialog-overlays" ) || 0 ) + 1 );
	},

	_destroyOverlay: function() {
		if ( !this.options.modal ) {
			return;
		}

		if ( this.overlay ) {
			var overlays = this.document.data( "ui-dialog-overlays" ) - 1;

			if ( !overlays ) {
				this._off( this.document, "focusin" );
				this.document.removeData( "ui-dialog-overlays" );
			} else {
				this.document.data( "ui-dialog-overlays", overlays );
			}

			this.overlay.remove();
			this.overlay = null;
		}
	}
} );

// DEPRECATED
// TODO: switch return back to widget declaration at top of file when this is removed
if ( $.uiBackCompat !== false ) {

	// Backcompat for dialogClass option
	$.widget( "ui.dialog", $.ui.dialog, {
		options: {
			dialogClass: ""
		},
		_createWrapper: function() {
			this._super();
			this.uiDialog.addClass( this.options.dialogClass );
		},
		_setOption: function( key, value ) {
			if ( key === "dialogClass" ) {
				this.uiDialog
					.removeClass( this.options.dialogClass )
					.addClass( value );
			}
			this._superApply( arguments );
		}
	} );
}

var widgetsDialog = $.ui.dialog;


/*!
 * jQuery UI Progressbar 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Progressbar
//>>group: Widgets
// jscs:disable maximumLineLength
//>>description: Displays a status indicator for loading state, standard percentage, and other progress indicators.
// jscs:enable maximumLineLength
//>>docs: http://api.jqueryui.com/progressbar/
//>>demos: http://jqueryui.com/progressbar/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/progressbar.css
//>>css.theme: ../../themes/base/theme.css



var widgetsProgressbar = $.widget( "ui.progressbar", {
	version: "1.12.1",
	options: {
		classes: {
			"ui-progressbar": "ui-corner-all",
			"ui-progressbar-value": "ui-corner-left",
			"ui-progressbar-complete": "ui-corner-right"
		},
		max: 100,
		value: 0,

		change: null,
		complete: null
	},

	min: 0,

	_create: function() {

		// Constrain initial value
		this.oldValue = this.options.value = this._constrainedValue();

		this.element.attr( {

			// Only set static values; aria-valuenow and aria-valuemax are
			// set inside _refreshValue()
			role: "progressbar",
			"aria-valuemin": this.min
		} );
		this._addClass( "ui-progressbar", "ui-widget ui-widget-content" );

		this.valueDiv = $( "<div>" ).appendTo( this.element );
		this._addClass( this.valueDiv, "ui-progressbar-value", "ui-widget-header" );
		this._refreshValue();
	},

	_destroy: function() {
		this.element.removeAttr( "role aria-valuemin aria-valuemax aria-valuenow" );

		this.valueDiv.remove();
	},

	value: function( newValue ) {
		if ( newValue === undefined ) {
			return this.options.value;
		}

		this.options.value = this._constrainedValue( newValue );
		this._refreshValue();
	},

	_constrainedValue: function( newValue ) {
		if ( newValue === undefined ) {
			newValue = this.options.value;
		}

		this.indeterminate = newValue === false;

		// Sanitize value
		if ( typeof newValue !== "number" ) {
			newValue = 0;
		}

		return this.indeterminate ? false :
			Math.min( this.options.max, Math.max( this.min, newValue ) );
	},

	_setOptions: function( options ) {

		// Ensure "value" option is set after other values (like max)
		var value = options.value;
		delete options.value;

		this._super( options );

		this.options.value = this._constrainedValue( value );
		this._refreshValue();
	},

	_setOption: function( key, value ) {
		if ( key === "max" ) {

			// Don't allow a max less than min
			value = Math.max( this.min, value );
		}
		this._super( key, value );
	},

	_setOptionDisabled: function( value ) {
		this._super( value );

		this.element.attr( "aria-disabled", value );
		this._toggleClass( null, "ui-state-disabled", !!value );
	},

	_percentage: function() {
		return this.indeterminate ?
			100 :
			100 * ( this.options.value - this.min ) / ( this.options.max - this.min );
	},

	_refreshValue: function() {
		var value = this.options.value,
			percentage = this._percentage();

		this.valueDiv
			.toggle( this.indeterminate || value > this.min )
			.width( percentage.toFixed( 0 ) + "%" );

		this
			._toggleClass( this.valueDiv, "ui-progressbar-complete", null,
				value === this.options.max )
			._toggleClass( "ui-progressbar-indeterminate", null, this.indeterminate );

		if ( this.indeterminate ) {
			this.element.removeAttr( "aria-valuenow" );
			if ( !this.overlayDiv ) {
				this.overlayDiv = $( "<div>" ).appendTo( this.valueDiv );
				this._addClass( this.overlayDiv, "ui-progressbar-overlay" );
			}
		} else {
			this.element.attr( {
				"aria-valuemax": this.options.max,
				"aria-valuenow": value
			} );
			if ( this.overlayDiv ) {
				this.overlayDiv.remove();
				this.overlayDiv = null;
			}
		}

		if ( this.oldValue !== value ) {
			this.oldValue = value;
			this._trigger( "change" );
		}
		if ( value === this.options.max ) {
			this._trigger( "complete" );
		}
	}
} );


/*!
 * jQuery UI Selectmenu 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Selectmenu
//>>group: Widgets
// jscs:disable maximumLineLength
//>>description: Duplicates and extends the functionality of a native HTML select element, allowing it to be customizable in behavior and appearance far beyond the limitations of a native select.
// jscs:enable maximumLineLength
//>>docs: http://api.jqueryui.com/selectmenu/
//>>demos: http://jqueryui.com/selectmenu/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/selectmenu.css, ../../themes/base/button.css
//>>css.theme: ../../themes/base/theme.css



var widgetsSelectmenu = $.widget( "ui.selectmenu", [ $.ui.formResetMixin, {
	version: "1.12.1",
	defaultElement: "<select>",
	options: {
		appendTo: null,
		classes: {
			"ui-selectmenu-button-open": "ui-corner-top",
			"ui-selectmenu-button-closed": "ui-corner-all"
		},
		disabled: null,
		icons: {
			button: "ui-icon-triangle-1-s"
		},
		position: {
			my: "left top",
			at: "left bottom",
			collision: "none"
		},
		width: false,

		// Callbacks
		change: null,
		close: null,
		focus: null,
		open: null,
		select: null
	},

	_create: function() {
		var selectmenuId = this.element.uniqueId().attr( "id" );
		this.ids = {
			element: selectmenuId,
			button: selectmenuId + "-button",
			menu: selectmenuId + "-menu"
		};

		this._drawButton();
		this._drawMenu();
		this._bindFormResetHandler();

		this._rendered = false;
		this.menuItems = $();
	},

	_drawButton: function() {
		var icon,
			that = this,
			item = this._parseOption(
				this.element.find( "option:selected" ),
				this.element[ 0 ].selectedIndex
			);

		// Associate existing label with the new button
		this.labels = this.element.labels().attr( "for", this.ids.button );
		this._on( this.labels, {
			click: function( event ) {
				this.button.focus();
				event.preventDefault();
			}
		} );

		// Hide original select element
		this.element.hide();

		// Create button
		this.button = $( "<span>", {
			tabindex: this.options.disabled ? -1 : 0,
			id: this.ids.button,
			role: "combobox",
			"aria-expanded": "false",
			"aria-autocomplete": "list",
			"aria-owns": this.ids.menu,
			"aria-haspopup": "true",
			title: this.element.attr( "title" )
		} )
			.insertAfter( this.element );

		this._addClass( this.button, "ui-selectmenu-button ui-selectmenu-button-closed",
			"ui-button ui-widget" );

		icon = $( "<span>" ).appendTo( this.button );
		this._addClass( icon, "ui-selectmenu-icon", "ui-icon " + this.options.icons.button );
		this.buttonItem = this._renderButtonItem( item )
			.appendTo( this.button );

		if ( this.options.width !== false ) {
			this._resizeButton();
		}

		this._on( this.button, this._buttonEvents );
		this.button.one( "focusin", function() {

			// Delay rendering the menu items until the button receives focus.
			// The menu may have already been rendered via a programmatic open.
			if ( !that._rendered ) {
				that._refreshMenu();
			}
		} );
	},

	_drawMenu: function() {
		var that = this;

		// Create menu
		this.menu = $( "<ul>", {
			"aria-hidden": "true",
			"aria-labelledby": this.ids.button,
			id: this.ids.menu
		} );

		// Wrap menu
		this.menuWrap = $( "<div>" ).append( this.menu );
		this._addClass( this.menuWrap, "ui-selectmenu-menu", "ui-front" );
		this.menuWrap.appendTo( this._appendTo() );

		// Initialize menu widget
		this.menuInstance = this.menu
			.menu( {
				classes: {
					"ui-menu": "ui-corner-bottom"
				},
				role: "listbox",
				select: function( event, ui ) {
					event.preventDefault();

					// Support: IE8
					// If the item was selected via a click, the text selection
					// will be destroyed in IE
					that._setSelection();

					that._select( ui.item.data( "ui-selectmenu-item" ), event );
				},
				focus: function( event, ui ) {
					var item = ui.item.data( "ui-selectmenu-item" );

					// Prevent inital focus from firing and check if its a newly focused item
					if ( that.focusIndex != null && item.index !== that.focusIndex ) {
						that._trigger( "focus", event, { item: item } );
						if ( !that.isOpen ) {
							that._select( item, event );
						}
					}
					that.focusIndex = item.index;

					that.button.attr( "aria-activedescendant",
						that.menuItems.eq( item.index ).attr( "id" ) );
				}
			} )
			.menu( "instance" );

		// Don't close the menu on mouseleave
		this.menuInstance._off( this.menu, "mouseleave" );

		// Cancel the menu's collapseAll on document click
		this.menuInstance._closeOnDocumentClick = function() {
			return false;
		};

		// Selects often contain empty items, but never contain dividers
		this.menuInstance._isDivider = function() {
			return false;
		};
	},

	refresh: function() {
		this._refreshMenu();
		this.buttonItem.replaceWith(
			this.buttonItem = this._renderButtonItem(

				// Fall back to an empty object in case there are no options
				this._getSelectedItem().data( "ui-selectmenu-item" ) || {}
			)
		);
		if ( this.options.width === null ) {
			this._resizeButton();
		}
	},

	_refreshMenu: function() {
		var item,
			options = this.element.find( "option" );

		this.menu.empty();

		this._parseOptions( options );
		this._renderMenu( this.menu, this.items );

		this.menuInstance.refresh();
		this.menuItems = this.menu.find( "li" )
			.not( ".ui-selectmenu-optgroup" )
				.find( ".ui-menu-item-wrapper" );

		this._rendered = true;

		if ( !options.length ) {
			return;
		}

		item = this._getSelectedItem();

		// Update the menu to have the correct item focused
		this.menuInstance.focus( null, item );
		this._setAria( item.data( "ui-selectmenu-item" ) );

		// Set disabled state
		this._setOption( "disabled", this.element.prop( "disabled" ) );
	},

	open: function( event ) {
		if ( this.options.disabled ) {
			return;
		}

		// If this is the first time the menu is being opened, render the items
		if ( !this._rendered ) {
			this._refreshMenu();
		} else {

			// Menu clears focus on close, reset focus to selected item
			this._removeClass( this.menu.find( ".ui-state-active" ), null, "ui-state-active" );
			this.menuInstance.focus( null, this._getSelectedItem() );
		}

		// If there are no options, don't open the menu
		if ( !this.menuItems.length ) {
			return;
		}

		this.isOpen = true;
		this._toggleAttr();
		this._resizeMenu();
		this._position();

		this._on( this.document, this._documentClick );

		this._trigger( "open", event );
	},

	_position: function() {
		this.menuWrap.position( $.extend( { of: this.button }, this.options.position ) );
	},

	close: function( event ) {
		if ( !this.isOpen ) {
			return;
		}

		this.isOpen = false;
		this._toggleAttr();

		this.range = null;
		this._off( this.document );

		this._trigger( "close", event );
	},

	widget: function() {
		return this.button;
	},

	menuWidget: function() {
		return this.menu;
	},

	_renderButtonItem: function( item ) {
		var buttonItem = $( "<span>" );

		this._setText( buttonItem, item.label );
		this._addClass( buttonItem, "ui-selectmenu-text" );

		return buttonItem;
	},

	_renderMenu: function( ul, items ) {
		var that = this,
			currentOptgroup = "";

		$.each( items, function( index, item ) {
			var li;

			if ( item.optgroup !== currentOptgroup ) {
				li = $( "<li>", {
					text: item.optgroup
				} );
				that._addClass( li, "ui-selectmenu-optgroup", "ui-menu-divider" +
					( item.element.parent( "optgroup" ).prop( "disabled" ) ?
						" ui-state-disabled" :
						"" ) );

				li.appendTo( ul );

				currentOptgroup = item.optgroup;
			}

			that._renderItemData( ul, item );
		} );
	},

	_renderItemData: function( ul, item ) {
		return this._renderItem( ul, item ).data( "ui-selectmenu-item", item );
	},

	_renderItem: function( ul, item ) {
		var li = $( "<li>" ),
			wrapper = $( "<div>", {
				title: item.element.attr( "title" )
			} );

		if ( item.disabled ) {
			this._addClass( li, null, "ui-state-disabled" );
		}
		this._setText( wrapper, item.label );

		return li.append( wrapper ).appendTo( ul );
	},

	_setText: function( element, value ) {
		if ( value ) {
			element.text( value );
		} else {
			element.html( "&#160;" );
		}
	},

	_move: function( direction, event ) {
		var item, next,
			filter = ".ui-menu-item";

		if ( this.isOpen ) {
			item = this.menuItems.eq( this.focusIndex ).parent( "li" );
		} else {
			item = this.menuItems.eq( this.element[ 0 ].selectedIndex ).parent( "li" );
			filter += ":not(.ui-state-disabled)";
		}

		if ( direction === "first" || direction === "last" ) {
			next = item[ direction === "first" ? "prevAll" : "nextAll" ]( filter ).eq( -1 );
		} else {
			next = item[ direction + "All" ]( filter ).eq( 0 );
		}

		if ( next.length ) {
			this.menuInstance.focus( event, next );
		}
	},

	_getSelectedItem: function() {
		return this.menuItems.eq( this.element[ 0 ].selectedIndex ).parent( "li" );
	},

	_toggle: function( event ) {
		this[ this.isOpen ? "close" : "open" ]( event );
	},

	_setSelection: function() {
		var selection;

		if ( !this.range ) {
			return;
		}

		if ( window.getSelection ) {
			selection = window.getSelection();
			selection.removeAllRanges();
			selection.addRange( this.range );

		// Support: IE8
		} else {
			this.range.select();
		}

		// Support: IE
		// Setting the text selection kills the button focus in IE, but
		// restoring the focus doesn't kill the selection.
		this.button.focus();
	},

	_documentClick: {
		mousedown: function( event ) {
			if ( !this.isOpen ) {
				return;
			}

			if ( !$( event.target ).closest( ".ui-selectmenu-menu, #" +
					$.ui.escapeSelector( this.ids.button ) ).length ) {
				this.close( event );
			}
		}
	},

	_buttonEvents: {

		// Prevent text selection from being reset when interacting with the selectmenu (#10144)
		mousedown: function() {
			var selection;

			if ( window.getSelection ) {
				selection = window.getSelection();
				if ( selection.rangeCount ) {
					this.range = selection.getRangeAt( 0 );
				}

			// Support: IE8
			} else {
				this.range = document.selection.createRange();
			}
		},

		click: function( event ) {
			this._setSelection();
			this._toggle( event );
		},

		keydown: function( event ) {
			var preventDefault = true;
			switch ( event.keyCode ) {
			case $.ui.keyCode.TAB:
			case $.ui.keyCode.ESCAPE:
				this.close( event );
				preventDefault = false;
				break;
			case $.ui.keyCode.ENTER:
				if ( this.isOpen ) {
					this._selectFocusedItem( event );
				}
				break;
			case $.ui.keyCode.UP:
				if ( event.altKey ) {
					this._toggle( event );
				} else {
					this._move( "prev", event );
				}
				break;
			case $.ui.keyCode.DOWN:
				if ( event.altKey ) {
					this._toggle( event );
				} else {
					this._move( "next", event );
				}
				break;
			case $.ui.keyCode.SPACE:
				if ( this.isOpen ) {
					this._selectFocusedItem( event );
				} else {
					this._toggle( event );
				}
				break;
			case $.ui.keyCode.LEFT:
				this._move( "prev", event );
				break;
			case $.ui.keyCode.RIGHT:
				this._move( "next", event );
				break;
			case $.ui.keyCode.HOME:
			case $.ui.keyCode.PAGE_UP:
				this._move( "first", event );
				break;
			case $.ui.keyCode.END:
			case $.ui.keyCode.PAGE_DOWN:
				this._move( "last", event );
				break;
			default:
				this.menu.trigger( event );
				preventDefault = false;
			}

			if ( preventDefault ) {
				event.preventDefault();
			}
		}
	},

	_selectFocusedItem: function( event ) {
		var item = this.menuItems.eq( this.focusIndex ).parent( "li" );
		if ( !item.hasClass( "ui-state-disabled" ) ) {
			this._select( item.data( "ui-selectmenu-item" ), event );
		}
	},

	_select: function( item, event ) {
		var oldIndex = this.element[ 0 ].selectedIndex;

		// Change native select element
		this.element[ 0 ].selectedIndex = item.index;
		this.buttonItem.replaceWith( this.buttonItem = this._renderButtonItem( item ) );
		this._setAria( item );
		this._trigger( "select", event, { item: item } );

		if ( item.index !== oldIndex ) {
			this._trigger( "change", event, { item: item } );
		}

		this.close( event );
	},

	_setAria: function( item ) {
		var id = this.menuItems.eq( item.index ).attr( "id" );

		this.button.attr( {
			"aria-labelledby": id,
			"aria-activedescendant": id
		} );
		this.menu.attr( "aria-activedescendant", id );
	},

	_setOption: function( key, value ) {
		if ( key === "icons" ) {
			var icon = this.button.find( "span.ui-icon" );
			this._removeClass( icon, null, this.options.icons.button )
				._addClass( icon, null, value.button );
		}

		this._super( key, value );

		if ( key === "appendTo" ) {
			this.menuWrap.appendTo( this._appendTo() );
		}

		if ( key === "width" ) {
			this._resizeButton();
		}
	},

	_setOptionDisabled: function( value ) {
		this._super( value );

		this.menuInstance.option( "disabled", value );
		this.button.attr( "aria-disabled", value );
		this._toggleClass( this.button, null, "ui-state-disabled", value );

		this.element.prop( "disabled", value );
		if ( value ) {
			this.button.attr( "tabindex", -1 );
			this.close();
		} else {
			this.button.attr( "tabindex", 0 );
		}
	},

	_appendTo: function() {
		var element = this.options.appendTo;

		if ( element ) {
			element = element.jquery || element.nodeType ?
				$( element ) :
				this.document.find( element ).eq( 0 );
		}

		if ( !element || !element[ 0 ] ) {
			element = this.element.closest( ".ui-front, dialog" );
		}

		if ( !element.length ) {
			element = this.document[ 0 ].body;
		}

		return element;
	},

	_toggleAttr: function() {
		this.button.attr( "aria-expanded", this.isOpen );

		// We can't use two _toggleClass() calls here, because we need to make sure
		// we always remove classes first and add them second, otherwise if both classes have the
		// same theme class, it will be removed after we add it.
		this._removeClass( this.button, "ui-selectmenu-button-" +
			( this.isOpen ? "closed" : "open" ) )
			._addClass( this.button, "ui-selectmenu-button-" +
				( this.isOpen ? "open" : "closed" ) )
			._toggleClass( this.menuWrap, "ui-selectmenu-open", null, this.isOpen );

		this.menu.attr( "aria-hidden", !this.isOpen );
	},

	_resizeButton: function() {
		var width = this.options.width;

		// For `width: false`, just remove inline style and stop
		if ( width === false ) {
			this.button.css( "width", "" );
			return;
		}

		// For `width: null`, match the width of the original element
		if ( width === null ) {
			width = this.element.show().outerWidth();
			this.element.hide();
		}

		this.button.outerWidth( width );
	},

	_resizeMenu: function() {
		this.menu.outerWidth( Math.max(
			this.button.outerWidth(),

			// Support: IE10
			// IE10 wraps long text (possibly a rounding bug)
			// so we add 1px to avoid the wrapping
			this.menu.width( "" ).outerWidth() + 1
		) );
	},

	_getCreateOptions: function() {
		var options = this._super();

		options.disabled = this.element.prop( "disabled" );

		return options;
	},

	_parseOptions: function( options ) {
		var that = this,
			data = [];
		options.each( function( index, item ) {
			data.push( that._parseOption( $( item ), index ) );
		} );
		this.items = data;
	},

	_parseOption: function( option, index ) {
		var optgroup = option.parent( "optgroup" );

		return {
			element: option,
			index: index,
			value: option.val(),
			label: option.text(),
			optgroup: optgroup.attr( "label" ) || "",
			disabled: optgroup.prop( "disabled" ) || option.prop( "disabled" )
		};
	},

	_destroy: function() {
		this._unbindFormResetHandler();
		this.menuWrap.remove();
		this.button.remove();
		this.element.show();
		this.element.removeUniqueId();
		this.labels.attr( "for", this.ids.element );
	}
} ] );


/*!
 * jQuery UI Slider 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Slider
//>>group: Widgets
//>>description: Displays a flexible slider with ranges and accessibility via keyboard.
//>>docs: http://api.jqueryui.com/slider/
//>>demos: http://jqueryui.com/slider/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/slider.css
//>>css.theme: ../../themes/base/theme.css



var widgetsSlider = $.widget( "ui.slider", $.ui.mouse, {
	version: "1.12.1",
	widgetEventPrefix: "slide",

	options: {
		animate: false,
		classes: {
			"ui-slider": "ui-corner-all",
			"ui-slider-handle": "ui-corner-all",

			// Note: ui-widget-header isn't the most fittingly semantic framework class for this
			// element, but worked best visually with a variety of themes
			"ui-slider-range": "ui-corner-all ui-widget-header"
		},
		distance: 0,
		max: 100,
		min: 0,
		orientation: "horizontal",
		range: false,
		step: 1,
		value: 0,
		values: null,

		// Callbacks
		change: null,
		slide: null,
		start: null,
		stop: null
	},

	// Number of pages in a slider
	// (how many times can you page up/down to go through the whole range)
	numPages: 5,

	_create: function() {
		this._keySliding = false;
		this._mouseSliding = false;
		this._animateOff = true;
		this._handleIndex = null;
		this._detectOrientation();
		this._mouseInit();
		this._calculateNewMax();

		this._addClass( "ui-slider ui-slider-" + this.orientation,
			"ui-widget ui-widget-content" );

		this._refresh();

		this._animateOff = false;
	},

	_refresh: function() {
		this._createRange();
		this._createHandles();
		this._setupEvents();
		this._refreshValue();
	},

	_createHandles: function() {
		var i, handleCount,
			options = this.options,
			existingHandles = this.element.find( ".ui-slider-handle" ),
			handle = "<span tabindex='0'></span>",
			handles = [];

		handleCount = ( options.values && options.values.length ) || 1;

		if ( existingHandles.length > handleCount ) {
			existingHandles.slice( handleCount ).remove();
			existingHandles = existingHandles.slice( 0, handleCount );
		}

		for ( i = existingHandles.length; i < handleCount; i++ ) {
			handles.push( handle );
		}

		this.handles = existingHandles.add( $( handles.join( "" ) ).appendTo( this.element ) );

		this._addClass( this.handles, "ui-slider-handle", "ui-state-default" );

		this.handle = this.handles.eq( 0 );

		this.handles.each( function( i ) {
			$( this )
				.data( "ui-slider-handle-index", i )
				.attr( "tabIndex", 0 );
		} );
	},

	_createRange: function() {
		var options = this.options;

		if ( options.range ) {
			if ( options.range === true ) {
				if ( !options.values ) {
					options.values = [ this._valueMin(), this._valueMin() ];
				} else if ( options.values.length && options.values.length !== 2 ) {
					options.values = [ options.values[ 0 ], options.values[ 0 ] ];
				} else if ( $.isArray( options.values ) ) {
					options.values = options.values.slice( 0 );
				}
			}

			if ( !this.range || !this.range.length ) {
				this.range = $( "<div>" )
					.appendTo( this.element );

				this._addClass( this.range, "ui-slider-range" );
			} else {
				this._removeClass( this.range, "ui-slider-range-min ui-slider-range-max" );

				// Handle range switching from true to min/max
				this.range.css( {
					"left": "",
					"bottom": ""
				} );
			}
			if ( options.range === "min" || options.range === "max" ) {
				this._addClass( this.range, "ui-slider-range-" + options.range );
			}
		} else {
			if ( this.range ) {
				this.range.remove();
			}
			this.range = null;
		}
	},

	_setupEvents: function() {
		this._off( this.handles );
		this._on( this.handles, this._handleEvents );
		this._hoverable( this.handles );
		this._focusable( this.handles );
	},

	_destroy: function() {
		this.handles.remove();
		if ( this.range ) {
			this.range.remove();
		}

		this._mouseDestroy();
	},

	_mouseCapture: function( event ) {
		var position, normValue, distance, closestHandle, index, allowed, offset, mouseOverHandle,
			that = this,
			o = this.options;

		if ( o.disabled ) {
			return false;
		}

		this.elementSize = {
			width: this.element.outerWidth(),
			height: this.element.outerHeight()
		};
		this.elementOffset = this.element.offset();

		position = { x: event.pageX, y: event.pageY };
		normValue = this._normValueFromMouse( position );
		distance = this._valueMax() - this._valueMin() + 1;
		this.handles.each( function( i ) {
			var thisDistance = Math.abs( normValue - that.values( i ) );
			if ( ( distance > thisDistance ) ||
				( distance === thisDistance &&
					( i === that._lastChangedValue || that.values( i ) === o.min ) ) ) {
				distance = thisDistance;
				closestHandle = $( this );
				index = i;
			}
		} );

		allowed = this._start( event, index );
		if ( allowed === false ) {
			return false;
		}
		this._mouseSliding = true;

		this._handleIndex = index;

		this._addClass( closestHandle, null, "ui-state-active" );
		closestHandle.trigger( "focus" );

		offset = closestHandle.offset();
		mouseOverHandle = !$( event.target ).parents().addBack().is( ".ui-slider-handle" );
		this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {
			left: event.pageX - offset.left - ( closestHandle.width() / 2 ),
			top: event.pageY - offset.top -
				( closestHandle.height() / 2 ) -
				( parseInt( closestHandle.css( "borderTopWidth" ), 10 ) || 0 ) -
				( parseInt( closestHandle.css( "borderBottomWidth" ), 10 ) || 0 ) +
				( parseInt( closestHandle.css( "marginTop" ), 10 ) || 0 )
		};

		if ( !this.handles.hasClass( "ui-state-hover" ) ) {
			this._slide( event, index, normValue );
		}
		this._animateOff = true;
		return true;
	},

	_mouseStart: function() {
		return true;
	},

	_mouseDrag: function( event ) {
		var position = { x: event.pageX, y: event.pageY },
			normValue = this._normValueFromMouse( position );

		this._slide( event, this._handleIndex, normValue );

		return false;
	},

	_mouseStop: function( event ) {
		this._removeClass( this.handles, null, "ui-state-active" );
		this._mouseSliding = false;

		this._stop( event, this._handleIndex );
		this._change( event, this._handleIndex );

		this._handleIndex = null;
		this._clickOffset = null;
		this._animateOff = false;

		return false;
	},

	_detectOrientation: function() {
		this.orientation = ( this.options.orientation === "vertical" ) ? "vertical" : "horizontal";
	},

	_normValueFromMouse: function( position ) {
		var pixelTotal,
			pixelMouse,
			percentMouse,
			valueTotal,
			valueMouse;

		if ( this.orientation === "horizontal" ) {
			pixelTotal = this.elementSize.width;
			pixelMouse = position.x - this.elementOffset.left -
				( this._clickOffset ? this._clickOffset.left : 0 );
		} else {
			pixelTotal = this.elementSize.height;
			pixelMouse = position.y - this.elementOffset.top -
				( this._clickOffset ? this._clickOffset.top : 0 );
		}

		percentMouse = ( pixelMouse / pixelTotal );
		if ( percentMouse > 1 ) {
			percentMouse = 1;
		}
		if ( percentMouse < 0 ) {
			percentMouse = 0;
		}
		if ( this.orientation === "vertical" ) {
			percentMouse = 1 - percentMouse;
		}

		valueTotal = this._valueMax() - this._valueMin();
		valueMouse = this._valueMin() + percentMouse * valueTotal;

		return this._trimAlignValue( valueMouse );
	},

	_uiHash: function( index, value, values ) {
		var uiHash = {
			handle: this.handles[ index ],
			handleIndex: index,
			value: value !== undefined ? value : this.value()
		};

		if ( this._hasMultipleValues() ) {
			uiHash.value = value !== undefined ? value : this.values( index );
			uiHash.values = values || this.values();
		}

		return uiHash;
	},

	_hasMultipleValues: function() {
		return this.options.values && this.options.values.length;
	},

	_start: function( event, index ) {
		return this._trigger( "start", event, this._uiHash( index ) );
	},

	_slide: function( event, index, newVal ) {
		var allowed, otherVal,
			currentValue = this.value(),
			newValues = this.values();

		if ( this._hasMultipleValues() ) {
			otherVal = this.values( index ? 0 : 1 );
			currentValue = this.values( index );

			if ( this.options.values.length === 2 && this.options.range === true ) {
				newVal =  index === 0 ? Math.min( otherVal, newVal ) : Math.max( otherVal, newVal );
			}

			newValues[ index ] = newVal;
		}

		if ( newVal === currentValue ) {
			return;
		}

		allowed = this._trigger( "slide", event, this._uiHash( index, newVal, newValues ) );

		// A slide can be canceled by returning false from the slide callback
		if ( allowed === false ) {
			return;
		}

		if ( this._hasMultipleValues() ) {
			this.values( index, newVal );
		} else {
			this.value( newVal );
		}
	},

	_stop: function( event, index ) {
		this._trigger( "stop", event, this._uiHash( index ) );
	},

	_change: function( event, index ) {
		if ( !this._keySliding && !this._mouseSliding ) {

			//store the last changed value index for reference when handles overlap
			this._lastChangedValue = index;
			this._trigger( "change", event, this._uiHash( index ) );
		}
	},

	value: function( newValue ) {
		if ( arguments.length ) {
			this.options.value = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, 0 );
			return;
		}

		return this._value();
	},

	values: function( index, newValue ) {
		var vals,
			newValues,
			i;

		if ( arguments.length > 1 ) {
			this.options.values[ index ] = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, index );
			return;
		}

		if ( arguments.length ) {
			if ( $.isArray( arguments[ 0 ] ) ) {
				vals = this.options.values;
				newValues = arguments[ 0 ];
				for ( i = 0; i < vals.length; i += 1 ) {
					vals[ i ] = this._trimAlignValue( newValues[ i ] );
					this._change( null, i );
				}
				this._refreshValue();
			} else {
				if ( this._hasMultipleValues() ) {
					return this._values( index );
				} else {
					return this.value();
				}
			}
		} else {
			return this._values();
		}
	},

	_setOption: function( key, value ) {
		var i,
			valsLength = 0;

		if ( key === "range" && this.options.range === true ) {
			if ( value === "min" ) {
				this.options.value = this._values( 0 );
				this.options.values = null;
			} else if ( value === "max" ) {
				this.options.value = this._values( this.options.values.length - 1 );
				this.options.values = null;
			}
		}

		if ( $.isArray( this.options.values ) ) {
			valsLength = this.options.values.length;
		}

		this._super( key, value );

		switch ( key ) {
			case "orientation":
				this._detectOrientation();
				this._removeClass( "ui-slider-horizontal ui-slider-vertical" )
					._addClass( "ui-slider-" + this.orientation );
				this._refreshValue();
				if ( this.options.range ) {
					this._refreshRange( value );
				}

				// Reset positioning from previous orientation
				this.handles.css( value === "horizontal" ? "bottom" : "left", "" );
				break;
			case "value":
				this._animateOff = true;
				this._refreshValue();
				this._change( null, 0 );
				this._animateOff = false;
				break;
			case "values":
				this._animateOff = true;
				this._refreshValue();

				// Start from the last handle to prevent unreachable handles (#9046)
				for ( i = valsLength - 1; i >= 0; i-- ) {
					this._change( null, i );
				}
				this._animateOff = false;
				break;
			case "step":
			case "min":
			case "max":
				this._animateOff = true;
				this._calculateNewMax();
				this._refreshValue();
				this._animateOff = false;
				break;
			case "range":
				this._animateOff = true;
				this._refresh();
				this._animateOff = false;
				break;
		}
	},

	_setOptionDisabled: function( value ) {
		this._super( value );

		this._toggleClass( null, "ui-state-disabled", !!value );
	},

	//internal value getter
	// _value() returns value trimmed by min and max, aligned by step
	_value: function() {
		var val = this.options.value;
		val = this._trimAlignValue( val );

		return val;
	},

	//internal values getter
	// _values() returns array of values trimmed by min and max, aligned by step
	// _values( index ) returns single value trimmed by min and max, aligned by step
	_values: function( index ) {
		var val,
			vals,
			i;

		if ( arguments.length ) {
			val = this.options.values[ index ];
			val = this._trimAlignValue( val );

			return val;
		} else if ( this._hasMultipleValues() ) {

			// .slice() creates a copy of the array
			// this copy gets trimmed by min and max and then returned
			vals = this.options.values.slice();
			for ( i = 0; i < vals.length; i += 1 ) {
				vals[ i ] = this._trimAlignValue( vals[ i ] );
			}

			return vals;
		} else {
			return [];
		}
	},

	// Returns the step-aligned value that val is closest to, between (inclusive) min and max
	_trimAlignValue: function( val ) {
		if ( val <= this._valueMin() ) {
			return this._valueMin();
		}
		if ( val >= this._valueMax() ) {
			return this._valueMax();
		}
		var step = ( this.options.step > 0 ) ? this.options.step : 1,
			valModStep = ( val - this._valueMin() ) % step,
			alignValue = val - valModStep;

		if ( Math.abs( valModStep ) * 2 >= step ) {
			alignValue += ( valModStep > 0 ) ? step : ( -step );
		}

		// Since JavaScript has problems with large floats, round
		// the final value to 5 digits after the decimal point (see #4124)
		return parseFloat( alignValue.toFixed( 5 ) );
	},

	_calculateNewMax: function() {
		var max = this.options.max,
			min = this._valueMin(),
			step = this.options.step,
			aboveMin = Math.round( ( max - min ) / step ) * step;
		max = aboveMin + min;
		if ( max > this.options.max ) {

			//If max is not divisible by step, rounding off may increase its value
			max -= step;
		}
		this.max = parseFloat( max.toFixed( this._precision() ) );
	},

	_precision: function() {
		var precision = this._precisionOf( this.options.step );
		if ( this.options.min !== null ) {
			precision = Math.max( precision, this._precisionOf( this.options.min ) );
		}
		return precision;
	},

	_precisionOf: function( num ) {
		var str = num.toString(),
			decimal = str.indexOf( "." );
		return decimal === -1 ? 0 : str.length - decimal - 1;
	},

	_valueMin: function() {
		return this.options.min;
	},

	_valueMax: function() {
		return this.max;
	},

	_refreshRange: function( orientation ) {
		if ( orientation === "vertical" ) {
			this.range.css( { "width": "", "left": "" } );
		}
		if ( orientation === "horizontal" ) {
			this.range.css( { "height": "", "bottom": "" } );
		}
	},

	_refreshValue: function() {
		var lastValPercent, valPercent, value, valueMin, valueMax,
			oRange = this.options.range,
			o = this.options,
			that = this,
			animate = ( !this._animateOff ) ? o.animate : false,
			_set = {};

		if ( this._hasMultipleValues() ) {
			this.handles.each( function( i ) {
				valPercent = ( that.values( i ) - that._valueMin() ) / ( that._valueMax() -
					that._valueMin() ) * 100;
				_set[ that.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
				$( this ).stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );
				if ( that.options.range === true ) {
					if ( that.orientation === "horizontal" ) {
						if ( i === 0 ) {
							that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
								left: valPercent + "%"
							}, o.animate );
						}
						if ( i === 1 ) {
							that.range[ animate ? "animate" : "css" ]( {
								width: ( valPercent - lastValPercent ) + "%"
							}, {
								queue: false,
								duration: o.animate
							} );
						}
					} else {
						if ( i === 0 ) {
							that.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
								bottom: ( valPercent ) + "%"
							}, o.animate );
						}
						if ( i === 1 ) {
							that.range[ animate ? "animate" : "css" ]( {
								height: ( valPercent - lastValPercent ) + "%"
							}, {
								queue: false,
								duration: o.animate
							} );
						}
					}
				}
				lastValPercent = valPercent;
			} );
		} else {
			value = this.value();
			valueMin = this._valueMin();
			valueMax = this._valueMax();
			valPercent = ( valueMax !== valueMin ) ?
					( value - valueMin ) / ( valueMax - valueMin ) * 100 :
					0;
			_set[ this.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
			this.handle.stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );

			if ( oRange === "min" && this.orientation === "horizontal" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
					width: valPercent + "%"
				}, o.animate );
			}
			if ( oRange === "max" && this.orientation === "horizontal" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
					width: ( 100 - valPercent ) + "%"
				}, o.animate );
			}
			if ( oRange === "min" && this.orientation === "vertical" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
					height: valPercent + "%"
				}, o.animate );
			}
			if ( oRange === "max" && this.orientation === "vertical" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( {
					height: ( 100 - valPercent ) + "%"
				}, o.animate );
			}
		}
	},

	_handleEvents: {
		keydown: function( event ) {
			var allowed, curVal, newVal, step,
				index = $( event.target ).data( "ui-slider-handle-index" );

			switch ( event.keyCode ) {
				case $.ui.keyCode.HOME:
				case $.ui.keyCode.END:
				case $.ui.keyCode.PAGE_UP:
				case $.ui.keyCode.PAGE_DOWN:
				case $.ui.keyCode.UP:
				case $.ui.keyCode.RIGHT:
				case $.ui.keyCode.DOWN:
				case $.ui.keyCode.LEFT:
					event.preventDefault();
					if ( !this._keySliding ) {
						this._keySliding = true;
						this._addClass( $( event.target ), null, "ui-state-active" );
						allowed = this._start( event, index );
						if ( allowed === false ) {
							return;
						}
					}
					break;
			}

			step = this.options.step;
			if ( this._hasMultipleValues() ) {
				curVal = newVal = this.values( index );
			} else {
				curVal = newVal = this.value();
			}

			switch ( event.keyCode ) {
				case $.ui.keyCode.HOME:
					newVal = this._valueMin();
					break;
				case $.ui.keyCode.END:
					newVal = this._valueMax();
					break;
				case $.ui.keyCode.PAGE_UP:
					newVal = this._trimAlignValue(
						curVal + ( ( this._valueMax() - this._valueMin() ) / this.numPages )
					);
					break;
				case $.ui.keyCode.PAGE_DOWN:
					newVal = this._trimAlignValue(
						curVal - ( ( this._valueMax() - this._valueMin() ) / this.numPages ) );
					break;
				case $.ui.keyCode.UP:
				case $.ui.keyCode.RIGHT:
					if ( curVal === this._valueMax() ) {
						return;
					}
					newVal = this._trimAlignValue( curVal + step );
					break;
				case $.ui.keyCode.DOWN:
				case $.ui.keyCode.LEFT:
					if ( curVal === this._valueMin() ) {
						return;
					}
					newVal = this._trimAlignValue( curVal - step );
					break;
			}

			this._slide( event, index, newVal );
		},
		keyup: function( event ) {
			var index = $( event.target ).data( "ui-slider-handle-index" );

			if ( this._keySliding ) {
				this._keySliding = false;
				this._stop( event, index );
				this._change( event, index );
				this._removeClass( $( event.target ), null, "ui-state-active" );
			}
		}
	}
} );


/*!
 * jQuery UI Spinner 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Spinner
//>>group: Widgets
//>>description: Displays buttons to easily input numbers via the keyboard or mouse.
//>>docs: http://api.jqueryui.com/spinner/
//>>demos: http://jqueryui.com/spinner/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/spinner.css
//>>css.theme: ../../themes/base/theme.css



function spinnerModifer( fn ) {
	return function() {
		var previous = this.element.val();
		fn.apply( this, arguments );
		this._refresh();
		if ( previous !== this.element.val() ) {
			this._trigger( "change" );
		}
	};
}

$.widget( "ui.spinner", {
	version: "1.12.1",
	defaultElement: "<input>",
	widgetEventPrefix: "spin",
	options: {
		classes: {
			"ui-spinner": "ui-corner-all",
			"ui-spinner-down": "ui-corner-br",
			"ui-spinner-up": "ui-corner-tr"
		},
		culture: null,
		icons: {
			down: "ui-icon-triangle-1-s",
			up: "ui-icon-triangle-1-n"
		},
		incremental: true,
		max: null,
		min: null,
		numberFormat: null,
		page: 10,
		step: 1,

		change: null,
		spin: null,
		start: null,
		stop: null
	},

	_create: function() {

		// handle string values that need to be parsed
		this._setOption( "max", this.options.max );
		this._setOption( "min", this.options.min );
		this._setOption( "step", this.options.step );

		// Only format if there is a value, prevents the field from being marked
		// as invalid in Firefox, see #9573.
		if ( this.value() !== "" ) {

			// Format the value, but don't constrain.
			this._value( this.element.val(), true );
		}

		this._draw();
		this._on( this._events );
		this._refresh();

		// Turning off autocomplete prevents the browser from remembering the
		// value when navigating through history, so we re-enable autocomplete
		// if the page is unloaded before the widget is destroyed. #7790
		this._on( this.window, {
			beforeunload: function() {
				this.element.removeAttr( "autocomplete" );
			}
		} );
	},

	_getCreateOptions: function() {
		var options = this._super();
		var element = this.element;

		$.each( [ "min", "max", "step" ], function( i, option ) {
			var value = element.attr( option );
			if ( value != null && value.length ) {
				options[ option ] = value;
			}
		} );

		return options;
	},

	_events: {
		keydown: function( event ) {
			if ( this._start( event ) && this._keydown( event ) ) {
				event.preventDefault();
			}
		},
		keyup: "_stop",
		focus: function() {
			this.previous = this.element.val();
		},
		blur: function( event ) {
			if ( this.cancelBlur ) {
				delete this.cancelBlur;
				return;
			}

			this._stop();
			this._refresh();
			if ( this.previous !== this.element.val() ) {
				this._trigger( "change", event );
			}
		},
		mousewheel: function( event, delta ) {
			if ( !delta ) {
				return;
			}
			if ( !this.spinning && !this._start( event ) ) {
				return false;
			}

			this._spin( ( delta > 0 ? 1 : -1 ) * this.options.step, event );
			clearTimeout( this.mousewheelTimer );
			this.mousewheelTimer = this._delay( function() {
				if ( this.spinning ) {
					this._stop( event );
				}
			}, 100 );
			event.preventDefault();
		},
		"mousedown .ui-spinner-button": function( event ) {
			var previous;

			// We never want the buttons to have focus; whenever the user is
			// interacting with the spinner, the focus should be on the input.
			// If the input is focused then this.previous is properly set from
			// when the input first received focus. If the input is not focused
			// then we need to set this.previous based on the value before spinning.
			previous = this.element[ 0 ] === $.ui.safeActiveElement( this.document[ 0 ] ) ?
				this.previous : this.element.val();
			function checkFocus() {
				var isActive = this.element[ 0 ] === $.ui.safeActiveElement( this.document[ 0 ] );
				if ( !isActive ) {
					this.element.trigger( "focus" );
					this.previous = previous;

					// support: IE
					// IE sets focus asynchronously, so we need to check if focus
					// moved off of the input because the user clicked on the button.
					this._delay( function() {
						this.previous = previous;
					} );
				}
			}

			// Ensure focus is on (or stays on) the text field
			event.preventDefault();
			checkFocus.call( this );

			// Support: IE
			// IE doesn't prevent moving focus even with event.preventDefault()
			// so we set a flag to know when we should ignore the blur event
			// and check (again) if focus moved off of the input.
			this.cancelBlur = true;
			this._delay( function() {
				delete this.cancelBlur;
				checkFocus.call( this );
			} );

			if ( this._start( event ) === false ) {
				return;
			}

			this._repeat( null, $( event.currentTarget )
				.hasClass( "ui-spinner-up" ) ? 1 : -1, event );
		},
		"mouseup .ui-spinner-button": "_stop",
		"mouseenter .ui-spinner-button": function( event ) {

			// button will add ui-state-active if mouse was down while mouseleave and kept down
			if ( !$( event.currentTarget ).hasClass( "ui-state-active" ) ) {
				return;
			}

			if ( this._start( event ) === false ) {
				return false;
			}
			this._repeat( null, $( event.currentTarget )
				.hasClass( "ui-spinner-up" ) ? 1 : -1, event );
		},

		// TODO: do we really want to consider this a stop?
		// shouldn't we just stop the repeater and wait until mouseup before
		// we trigger the stop event?
		"mouseleave .ui-spinner-button": "_stop"
	},

	// Support mobile enhanced option and make backcompat more sane
	_enhance: function() {
		this.uiSpinner = this.element
			.attr( "autocomplete", "off" )
			.wrap( "<span>" )
			.parent()

				// Add buttons
				.append(
					"<a></a><a></a>"
				);
	},

	_draw: function() {
		this._enhance();

		this._addClass( this.uiSpinner, "ui-spinner", "ui-widget ui-widget-content" );
		this._addClass( "ui-spinner-input" );

		this.element.attr( "role", "spinbutton" );

		// Button bindings
		this.buttons = this.uiSpinner.children( "a" )
			.attr( "tabIndex", -1 )
			.attr( "aria-hidden", true )
			.button( {
				classes: {
					"ui-button": ""
				}
			} );

		// TODO: Right now button does not support classes this is already updated in button PR
		this._removeClass( this.buttons, "ui-corner-all" );

		this._addClass( this.buttons.first(), "ui-spinner-button ui-spinner-up" );
		this._addClass( this.buttons.last(), "ui-spinner-button ui-spinner-down" );
		this.buttons.first().button( {
			"icon": this.options.icons.up,
			"showLabel": false
		} );
		this.buttons.last().button( {
			"icon": this.options.icons.down,
			"showLabel": false
		} );

		// IE 6 doesn't understand height: 50% for the buttons
		// unless the wrapper has an explicit height
		if ( this.buttons.height() > Math.ceil( this.uiSpinner.height() * 0.5 ) &&
				this.uiSpinner.height() > 0 ) {
			this.uiSpinner.height( this.uiSpinner.height() );
		}
	},

	_keydown: function( event ) {
		var options = this.options,
			keyCode = $.ui.keyCode;

		switch ( event.keyCode ) {
		case keyCode.UP:
			this._repeat( null, 1, event );
			return true;
		case keyCode.DOWN:
			this._repeat( null, -1, event );
			return true;
		case keyCode.PAGE_UP:
			this._repeat( null, options.page, event );
			return true;
		case keyCode.PAGE_DOWN:
			this._repeat( null, -options.page, event );
			return true;
		}

		return false;
	},

	_start: function( event ) {
		if ( !this.spinning && this._trigger( "start", event ) === false ) {
			return false;
		}

		if ( !this.counter ) {
			this.counter = 1;
		}
		this.spinning = true;
		return true;
	},

	_repeat: function( i, steps, event ) {
		i = i || 500;

		clearTimeout( this.timer );
		this.timer = this._delay( function() {
			this._repeat( 40, steps, event );
		}, i );

		this._spin( steps * this.options.step, event );
	},

	_spin: function( step, event ) {
		var value = this.value() || 0;

		if ( !this.counter ) {
			this.counter = 1;
		}

		value = this._adjustValue( value + step * this._increment( this.counter ) );

		if ( !this.spinning || this._trigger( "spin", event, { value: value } ) !== false ) {
			this._value( value );
			this.counter++;
		}
	},

	_increment: function( i ) {
		var incremental = this.options.incremental;

		if ( incremental ) {
			return $.isFunction( incremental ) ?
				incremental( i ) :
				Math.floor( i * i * i / 50000 - i * i / 500 + 17 * i / 200 + 1 );
		}

		return 1;
	},

	_precision: function() {
		var precision = this._precisionOf( this.options.step );
		if ( this.options.min !== null ) {
			precision = Math.max( precision, this._precisionOf( this.options.min ) );
		}
		return precision;
	},

	_precisionOf: function( num ) {
		var str = num.toString(),
			decimal = str.indexOf( "." );
		return decimal === -1 ? 0 : str.length - decimal - 1;
	},

	_adjustValue: function( value ) {
		var base, aboveMin,
			options = this.options;

		// Make sure we're at a valid step
		// - find out where we are relative to the base (min or 0)
		base = options.min !== null ? options.min : 0;
		aboveMin = value - base;

		// - round to the nearest step
		aboveMin = Math.round( aboveMin / options.step ) * options.step;

		// - rounding is based on 0, so adjust back to our base
		value = base + aboveMin;

		// Fix precision from bad JS floating point math
		value = parseFloat( value.toFixed( this._precision() ) );

		// Clamp the value
		if ( options.max !== null && value > options.max ) {
			return options.max;
		}
		if ( options.min !== null && value < options.min ) {
			return options.min;
		}

		return value;
	},

	_stop: function( event ) {
		if ( !this.spinning ) {
			return;
		}

		clearTimeout( this.timer );
		clearTimeout( this.mousewheelTimer );
		this.counter = 0;
		this.spinning = false;
		this._trigger( "stop", event );
	},

	_setOption: function( key, value ) {
		var prevValue, first, last;

		if ( key === "culture" || key === "numberFormat" ) {
			prevValue = this._parse( this.element.val() );
			this.options[ key ] = value;
			this.element.val( this._format( prevValue ) );
			return;
		}

		if ( key === "max" || key === "min" || key === "step" ) {
			if ( typeof value === "string" ) {
				value = this._parse( value );
			}
		}
		if ( key === "icons" ) {
			first = this.buttons.first().find( ".ui-icon" );
			this._removeClass( first, null, this.options.icons.up );
			this._addClass( first, null, value.up );
			last = this.buttons.last().find( ".ui-icon" );
			this._removeClass( last, null, this.options.icons.down );
			this._addClass( last, null, value.down );
		}

		this._super( key, value );
	},

	_setOptionDisabled: function( value ) {
		this._super( value );

		this._toggleClass( this.uiSpinner, null, "ui-state-disabled", !!value );
		this.element.prop( "disabled", !!value );
		this.buttons.button( value ? "disable" : "enable" );
	},

	_setOptions: spinnerModifer( function( options ) {
		this._super( options );
	} ),

	_parse: function( val ) {
		if ( typeof val === "string" && val !== "" ) {
			val = window.Globalize && this.options.numberFormat ?
				Globalize.parseFloat( val, 10, this.options.culture ) : +val;
		}
		return val === "" || isNaN( val ) ? null : val;
	},

	_format: function( value ) {
		if ( value === "" ) {
			return "";
		}
		return window.Globalize && this.options.numberFormat ?
			Globalize.format( value, this.options.numberFormat, this.options.culture ) :
			value;
	},

	_refresh: function() {
		this.element.attr( {
			"aria-valuemin": this.options.min,
			"aria-valuemax": this.options.max,

			// TODO: what should we do with values that can't be parsed?
			"aria-valuenow": this._parse( this.element.val() )
		} );
	},

	isValid: function() {
		var value = this.value();

		// Null is invalid
		if ( value === null ) {
			return false;
		}

		// If value gets adjusted, it's invalid
		return value === this._adjustValue( value );
	},

	// Update the value without triggering change
	_value: function( value, allowAny ) {
		var parsed;
		if ( value !== "" ) {
			parsed = this._parse( value );
			if ( parsed !== null ) {
				if ( !allowAny ) {
					parsed = this._adjustValue( parsed );
				}
				value = this._format( parsed );
			}
		}
		this.element.val( value );
		this._refresh();
	},

	_destroy: function() {
		this.element
			.prop( "disabled", false )
			.removeAttr( "autocomplete role aria-valuemin aria-valuemax aria-valuenow" );

		this.uiSpinner.replaceWith( this.element );
	},

	stepUp: spinnerModifer( function( steps ) {
		this._stepUp( steps );
	} ),
	_stepUp: function( steps ) {
		if ( this._start() ) {
			this._spin( ( steps || 1 ) * this.options.step );
			this._stop();
		}
	},

	stepDown: spinnerModifer( function( steps ) {
		this._stepDown( steps );
	} ),
	_stepDown: function( steps ) {
		if ( this._start() ) {
			this._spin( ( steps || 1 ) * -this.options.step );
			this._stop();
		}
	},

	pageUp: spinnerModifer( function( pages ) {
		this._stepUp( ( pages || 1 ) * this.options.page );
	} ),

	pageDown: spinnerModifer( function( pages ) {
		this._stepDown( ( pages || 1 ) * this.options.page );
	} ),

	value: function( newVal ) {
		if ( !arguments.length ) {
			return this._parse( this.element.val() );
		}
		spinnerModifer( this._value ).call( this, newVal );
	},

	widget: function() {
		return this.uiSpinner;
	}
} );

// DEPRECATED
// TODO: switch return back to widget declaration at top of file when this is removed
if ( $.uiBackCompat !== false ) {

	// Backcompat for spinner html extension points
	$.widget( "ui.spinner", $.ui.spinner, {
		_enhance: function() {
			this.uiSpinner = this.element
				.attr( "autocomplete", "off" )
				.wrap( this._uiSpinnerHtml() )
				.parent()

					// Add buttons
					.append( this._buttonHtml() );
		},
		_uiSpinnerHtml: function() {
			return "<span>";
		},

		_buttonHtml: function() {
			return "<a></a><a></a>";
		}
	} );
}

var widgetsSpinner = $.ui.spinner;


/*!
 * jQuery UI Tabs 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Tabs
//>>group: Widgets
//>>description: Transforms a set of container elements into a tab structure.
//>>docs: http://api.jqueryui.com/tabs/
//>>demos: http://jqueryui.com/tabs/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/tabs.css
//>>css.theme: ../../themes/base/theme.css



$.widget( "ui.tabs", {
	version: "1.12.1",
	delay: 300,
	options: {
		active: null,
		classes: {
			"ui-tabs": "ui-corner-all",
			"ui-tabs-nav": "ui-corner-all",
			"ui-tabs-panel": "ui-corner-bottom",
			"ui-tabs-tab": "ui-corner-top"
		},
		collapsible: false,
		event: "click",
		heightStyle: "content",
		hide: null,
		show: null,

		// Callbacks
		activate: null,
		beforeActivate: null,
		beforeLoad: null,
		load: null
	},

	_isLocal: ( function() {
		var rhash = /#.*$/;

		return function( anchor ) {
			var anchorUrl, locationUrl;

			anchorUrl = anchor.href.replace( rhash, "" );
			locationUrl = location.href.replace( rhash, "" );

			// Decoding may throw an error if the URL isn't UTF-8 (#9518)
			try {
				anchorUrl = decodeURIComponent( anchorUrl );
			} catch ( error ) {}
			try {
				locationUrl = decodeURIComponent( locationUrl );
			} catch ( error ) {}

			return anchor.hash.length > 1 && anchorUrl === locationUrl;
		};
	} )(),

	_create: function() {
		var that = this,
			options = this.options;

		this.running = false;

		this._addClass( "ui-tabs", "ui-widget ui-widget-content" );
		this._toggleClass( "ui-tabs-collapsible", null, options.collapsible );

		this._processTabs();
		options.active = this._initialActive();

		// Take disabling tabs via class attribute from HTML
		// into account and update option properly.
		if ( $.isArray( options.disabled ) ) {
			options.disabled = $.unique( options.disabled.concat(
				$.map( this.tabs.filter( ".ui-state-disabled" ), function( li ) {
					return that.tabs.index( li );
				} )
			) ).sort();
		}

		// Check for length avoids error when initializing empty list
		if ( this.options.active !== false && this.anchors.length ) {
			this.active = this._findActive( options.active );
		} else {
			this.active = $();
		}

		this._refresh();

		if ( this.active.length ) {
			this.load( options.active );
		}
	},

	_initialActive: function() {
		var active = this.options.active,
			collapsible = this.options.collapsible,
			locationHash = location.hash.substring( 1 );

		if ( active === null ) {

			// check the fragment identifier in the URL
			if ( locationHash ) {
				this.tabs.each( function( i, tab ) {
					if ( $( tab ).attr( "aria-controls" ) === locationHash ) {
						active = i;
						return false;
					}
				} );
			}

			// Check for a tab marked active via a class
			if ( active === null ) {
				active = this.tabs.index( this.tabs.filter( ".ui-tabs-active" ) );
			}

			// No active tab, set to false
			if ( active === null || active === -1 ) {
				active = this.tabs.length ? 0 : false;
			}
		}

		// Handle numbers: negative, out of range
		if ( active !== false ) {
			active = this.tabs.index( this.tabs.eq( active ) );
			if ( active === -1 ) {
				active = collapsible ? false : 0;
			}
		}

		// Don't allow collapsible: false and active: false
		if ( !collapsible && active === false && this.anchors.length ) {
			active = 0;
		}

		return active;
	},

	_getCreateEventData: function() {
		return {
			tab: this.active,
			panel: !this.active.length ? $() : this._getPanelForTab( this.active )
		};
	},

	_tabKeydown: function( event ) {
		var focusedTab = $( $.ui.safeActiveElement( this.document[ 0 ] ) ).closest( "li" ),
			selectedIndex = this.tabs.index( focusedTab ),
			goingForward = true;

		if ( this._handlePageNav( event ) ) {
			return;
		}

		switch ( event.keyCode ) {
		case $.ui.keyCode.RIGHT:
		case $.ui.keyCode.DOWN:
			selectedIndex++;
			break;
		case $.ui.keyCode.UP:
		case $.ui.keyCode.LEFT:
			goingForward = false;
			selectedIndex--;
			break;
		case $.ui.keyCode.END:
			selectedIndex = this.anchors.length - 1;
			break;
		case $.ui.keyCode.HOME:
			selectedIndex = 0;
			break;
		case $.ui.keyCode.SPACE:

			// Activate only, no collapsing
			event.preventDefault();
			clearTimeout( this.activating );
			this._activate( selectedIndex );
			return;
		case $.ui.keyCode.ENTER:

			// Toggle (cancel delayed activation, allow collapsing)
			event.preventDefault();
			clearTimeout( this.activating );

			// Determine if we should collapse or activate
			this._activate( selectedIndex === this.options.active ? false : selectedIndex );
			return;
		default:
			return;
		}

		// Focus the appropriate tab, based on which key was pressed
		event.preventDefault();
		clearTimeout( this.activating );
		selectedIndex = this._focusNextTab( selectedIndex, goingForward );

		// Navigating with control/command key will prevent automatic activation
		if ( !event.ctrlKey && !event.metaKey ) {

			// Update aria-selected immediately so that AT think the tab is already selected.
			// Otherwise AT may confuse the user by stating that they need to activate the tab,
			// but the tab will already be activated by the time the announcement finishes.
			focusedTab.attr( "aria-selected", "false" );
			this.tabs.eq( selectedIndex ).attr( "aria-selected", "true" );

			this.activating = this._delay( function() {
				this.option( "active", selectedIndex );
			}, this.delay );
		}
	},

	_panelKeydown: function( event ) {
		if ( this._handlePageNav( event ) ) {
			return;
		}

		// Ctrl+up moves focus to the current tab
		if ( event.ctrlKey && event.keyCode === $.ui.keyCode.UP ) {
			event.preventDefault();
			this.active.trigger( "focus" );
		}
	},

	// Alt+page up/down moves focus to the previous/next tab (and activates)
	_handlePageNav: function( event ) {
		if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_UP ) {
			this._activate( this._focusNextTab( this.options.active - 1, false ) );
			return true;
		}
		if ( event.altKey && event.keyCode === $.ui.keyCode.PAGE_DOWN ) {
			this._activate( this._focusNextTab( this.options.active + 1, true ) );
			return true;
		}
	},

	_findNextTab: function( index, goingForward ) {
		var lastTabIndex = this.tabs.length - 1;

		function constrain() {
			if ( index > lastTabIndex ) {
				index = 0;
			}
			if ( index < 0 ) {
				index = lastTabIndex;
			}
			return index;
		}

		while ( $.inArray( constrain(), this.options.disabled ) !== -1 ) {
			index = goingForward ? index + 1 : index - 1;
		}

		return index;
	},

	_focusNextTab: function( index, goingForward ) {
		index = this._findNextTab( index, goingForward );
		this.tabs.eq( index ).trigger( "focus" );
		return index;
	},

	_setOption: function( key, value ) {
		if ( key === "active" ) {

			// _activate() will handle invalid values and update this.options
			this._activate( value );
			return;
		}

		this._super( key, value );

		if ( key === "collapsible" ) {
			this._toggleClass( "ui-tabs-collapsible", null, value );

			// Setting collapsible: false while collapsed; open first panel
			if ( !value && this.options.active === false ) {
				this._activate( 0 );
			}
		}

		if ( key === "event" ) {
			this._setupEvents( value );
		}

		if ( key === "heightStyle" ) {
			this._setupHeightStyle( value );
		}
	},

	_sanitizeSelector: function( hash ) {
		return hash ? hash.replace( /[!"$%&'()*+,.\/:;<=>?@\[\]\^`{|}~]/g, "\\$&" ) : "";
	},

	refresh: function() {
		var options = this.options,
			lis = this.tablist.children( ":has(a[href])" );

		// Get disabled tabs from class attribute from HTML
		// this will get converted to a boolean if needed in _refresh()
		options.disabled = $.map( lis.filter( ".ui-state-disabled" ), function( tab ) {
			return lis.index( tab );
		} );

		this._processTabs();

		// Was collapsed or no tabs
		if ( options.active === false || !this.anchors.length ) {
			options.active = false;
			this.active = $();

		// was active, but active tab is gone
		} else if ( this.active.length && !$.contains( this.tablist[ 0 ], this.active[ 0 ] ) ) {

			// all remaining tabs are disabled
			if ( this.tabs.length === options.disabled.length ) {
				options.active = false;
				this.active = $();

			// activate previous tab
			} else {
				this._activate( this._findNextTab( Math.max( 0, options.active - 1 ), false ) );
			}

		// was active, active tab still exists
		} else {

			// make sure active index is correct
			options.active = this.tabs.index( this.active );
		}

		this._refresh();
	},

	_refresh: function() {
		this._setOptionDisabled( this.options.disabled );
		this._setupEvents( this.options.event );
		this._setupHeightStyle( this.options.heightStyle );

		this.tabs.not( this.active ).attr( {
			"aria-selected": "false",
			"aria-expanded": "false",
			tabIndex: -1
		} );
		this.panels.not( this._getPanelForTab( this.active ) )
			.hide()
			.attr( {
				"aria-hidden": "true"
			} );

		// Make sure one tab is in the tab order
		if ( !this.active.length ) {
			this.tabs.eq( 0 ).attr( "tabIndex", 0 );
		} else {
			this.active
				.attr( {
					"aria-selected": "true",
					"aria-expanded": "true",
					tabIndex: 0
				} );
			this._addClass( this.active, "ui-tabs-active", "ui-state-active" );
			this._getPanelForTab( this.active )
				.show()
				.attr( {
					"aria-hidden": "false"
				} );
		}
	},

	_processTabs: function() {
		var that = this,
			prevTabs = this.tabs,
			prevAnchors = this.anchors,
			prevPanels = this.panels;

		this.tablist = this._getList().attr( "role", "tablist" );
		this._addClass( this.tablist, "ui-tabs-nav",
			"ui-helper-reset ui-helper-clearfix ui-widget-header" );

		// Prevent users from focusing disabled tabs via click
		this.tablist
			.on( "mousedown" + this.eventNamespace, "> li", function( event ) {
				if ( $( this ).is( ".ui-state-disabled" ) ) {
					event.preventDefault();
				}
			} )

			// Support: IE <9
			// Preventing the default action in mousedown doesn't prevent IE
			// from focusing the element, so if the anchor gets focused, blur.
			// We don't have to worry about focusing the previously focused
			// element since clicking on a non-focusable element should focus
			// the body anyway.
			.on( "focus" + this.eventNamespace, ".ui-tabs-anchor", function() {
				if ( $( this ).closest( "li" ).is( ".ui-state-disabled" ) ) {
					this.blur();
				}
			} );

		this.tabs = this.tablist.find( "> li:has(a[href])" )
			.attr( {
				role: "tab",
				tabIndex: -1
			} );
		this._addClass( this.tabs, "ui-tabs-tab", "ui-state-default" );

		this.anchors = this.tabs.map( function() {
			return $( "a", this )[ 0 ];
		} )
			.attr( {
				role: "presentation",
				tabIndex: -1
			} );
		this._addClass( this.anchors, "ui-tabs-anchor" );

		this.panels = $();

		this.anchors.each( function( i, anchor ) {
			var selector, panel, panelId,
				anchorId = $( anchor ).uniqueId().attr( "id" ),
				tab = $( anchor ).closest( "li" ),
				originalAriaControls = tab.attr( "aria-controls" );

			// Inline tab
			if ( that._isLocal( anchor ) ) {
				selector = anchor.hash;
				panelId = selector.substring( 1 );
				panel = that.element.find( that._sanitizeSelector( selector ) );

			// remote tab
			} else {

				// If the tab doesn't already have aria-controls,
				// generate an id by using a throw-away element
				panelId = tab.attr( "aria-controls" ) || $( {} ).uniqueId()[ 0 ].id;
				selector = "#" + panelId;
				panel = that.element.find( selector );
				if ( !panel.length ) {
					panel = that._createPanel( panelId );
					panel.insertAfter( that.panels[ i - 1 ] || that.tablist );
				}
				panel.attr( "aria-live", "polite" );
			}

			if ( panel.length ) {
				that.panels = that.panels.add( panel );
			}
			if ( originalAriaControls ) {
				tab.data( "ui-tabs-aria-controls", originalAriaControls );
			}
			tab.attr( {
				"aria-controls": panelId,
				"aria-labelledby": anchorId
			} );
			panel.attr( "aria-labelledby", anchorId );
		} );

		this.panels.attr( "role", "tabpanel" );
		this._addClass( this.panels, "ui-tabs-panel", "ui-widget-content" );

		// Avoid memory leaks (#10056)
		if ( prevTabs ) {
			this._off( prevTabs.not( this.tabs ) );
			this._off( prevAnchors.not( this.anchors ) );
			this._off( prevPanels.not( this.panels ) );
		}
	},

	// Allow overriding how to find the list for rare usage scenarios (#7715)
	_getList: function() {
		return this.tablist || this.element.find( "ol, ul" ).eq( 0 );
	},

	_createPanel: function( id ) {
		return $( "<div>" )
			.attr( "id", id )
			.data( "ui-tabs-destroy", true );
	},

	_setOptionDisabled: function( disabled ) {
		var currentItem, li, i;

		if ( $.isArray( disabled ) ) {
			if ( !disabled.length ) {
				disabled = false;
			} else if ( disabled.length === this.anchors.length ) {
				disabled = true;
			}
		}

		// Disable tabs
		for ( i = 0; ( li = this.tabs[ i ] ); i++ ) {
			currentItem = $( li );
			if ( disabled === true || $.inArray( i, disabled ) !== -1 ) {
				currentItem.attr( "aria-disabled", "true" );
				this._addClass( currentItem, null, "ui-state-disabled" );
			} else {
				currentItem.removeAttr( "aria-disabled" );
				this._removeClass( currentItem, null, "ui-state-disabled" );
			}
		}

		this.options.disabled = disabled;

		this._toggleClass( this.widget(), this.widgetFullName + "-disabled", null,
			disabled === true );
	},

	_setupEvents: function( event ) {
		var events = {};
		if ( event ) {
			$.each( event.split( " " ), function( index, eventName ) {
				events[ eventName ] = "_eventHandler";
			} );
		}

		this._off( this.anchors.add( this.tabs ).add( this.panels ) );

		// Always prevent the default action, even when disabled
		this._on( true, this.anchors, {
			click: function( event ) {
				event.preventDefault();
			}
		} );
		this._on( this.anchors, events );
		this._on( this.tabs, { keydown: "_tabKeydown" } );
		this._on( this.panels, { keydown: "_panelKeydown" } );

		this._focusable( this.tabs );
		this._hoverable( this.tabs );
	},

	_setupHeightStyle: function( heightStyle ) {
		var maxHeight,
			parent = this.element.parent();

		if ( heightStyle === "fill" ) {
			maxHeight = parent.height();
			maxHeight -= this.element.outerHeight() - this.element.height();

			this.element.siblings( ":visible" ).each( function() {
				var elem = $( this ),
					position = elem.css( "position" );

				if ( position === "absolute" || position === "fixed" ) {
					return;
				}
				maxHeight -= elem.outerHeight( true );
			} );

			this.element.children().not( this.panels ).each( function() {
				maxHeight -= $( this ).outerHeight( true );
			} );

			this.panels.each( function() {
				$( this ).height( Math.max( 0, maxHeight -
					$( this ).innerHeight() + $( this ).height() ) );
			} )
				.css( "overflow", "auto" );
		} else if ( heightStyle === "auto" ) {
			maxHeight = 0;
			this.panels.each( function() {
				maxHeight = Math.max( maxHeight, $( this ).height( "" ).height() );
			} ).height( maxHeight );
		}
	},

	_eventHandler: function( event ) {
		var options = this.options,
			active = this.active,
			anchor = $( event.currentTarget ),
			tab = anchor.closest( "li" ),
			clickedIsActive = tab[ 0 ] === active[ 0 ],
			collapsing = clickedIsActive && options.collapsible,
			toShow = collapsing ? $() : this._getPanelForTab( tab ),
			toHide = !active.length ? $() : this._getPanelForTab( active ),
			eventData = {
				oldTab: active,
				oldPanel: toHide,
				newTab: collapsing ? $() : tab,
				newPanel: toShow
			};

		event.preventDefault();

		if ( tab.hasClass( "ui-state-disabled" ) ||

				// tab is already loading
				tab.hasClass( "ui-tabs-loading" ) ||

				// can't switch durning an animation
				this.running ||

				// click on active header, but not collapsible
				( clickedIsActive && !options.collapsible ) ||

				// allow canceling activation
				( this._trigger( "beforeActivate", event, eventData ) === false ) ) {
			return;
		}

		options.active = collapsing ? false : this.tabs.index( tab );

		this.active = clickedIsActive ? $() : tab;
		if ( this.xhr ) {
			this.xhr.abort();
		}

		if ( !toHide.length && !toShow.length ) {
			$.error( "jQuery UI Tabs: Mismatching fragment identifier." );
		}

		if ( toShow.length ) {
			this.load( this.tabs.index( tab ), event );
		}
		this._toggle( event, eventData );
	},

	// Handles show/hide for selecting tabs
	_toggle: function( event, eventData ) {
		var that = this,
			toShow = eventData.newPanel,
			toHide = eventData.oldPanel;

		this.running = true;

		function complete() {
			that.running = false;
			that._trigger( "activate", event, eventData );
		}

		function show() {
			that._addClass( eventData.newTab.closest( "li" ), "ui-tabs-active", "ui-state-active" );

			if ( toShow.length && that.options.show ) {
				that._show( toShow, that.options.show, complete );
			} else {
				toShow.show();
				complete();
			}
		}

		// Start out by hiding, then showing, then completing
		if ( toHide.length && this.options.hide ) {
			this._hide( toHide, this.options.hide, function() {
				that._removeClass( eventData.oldTab.closest( "li" ),
					"ui-tabs-active", "ui-state-active" );
				show();
			} );
		} else {
			this._removeClass( eventData.oldTab.closest( "li" ),
				"ui-tabs-active", "ui-state-active" );
			toHide.hide();
			show();
		}

		toHide.attr( "aria-hidden", "true" );
		eventData.oldTab.attr( {
			"aria-selected": "false",
			"aria-expanded": "false"
		} );

		// If we're switching tabs, remove the old tab from the tab order.
		// If we're opening from collapsed state, remove the previous tab from the tab order.
		// If we're collapsing, then keep the collapsing tab in the tab order.
		if ( toShow.length && toHide.length ) {
			eventData.oldTab.attr( "tabIndex", -1 );
		} else if ( toShow.length ) {
			this.tabs.filter( function() {
				return $( this ).attr( "tabIndex" ) === 0;
			} )
				.attr( "tabIndex", -1 );
		}

		toShow.attr( "aria-hidden", "false" );
		eventData.newTab.attr( {
			"aria-selected": "true",
			"aria-expanded": "true",
			tabIndex: 0
		} );
	},

	_activate: function( index ) {
		var anchor,
			active = this._findActive( index );

		// Trying to activate the already active panel
		if ( active[ 0 ] === this.active[ 0 ] ) {
			return;
		}

		// Trying to collapse, simulate a click on the current active header
		if ( !active.length ) {
			active = this.active;
		}

		anchor = active.find( ".ui-tabs-anchor" )[ 0 ];
		this._eventHandler( {
			target: anchor,
			currentTarget: anchor,
			preventDefault: $.noop
		} );
	},

	_findActive: function( index ) {
		return index === false ? $() : this.tabs.eq( index );
	},

	_getIndex: function( index ) {

		// meta-function to give users option to provide a href string instead of a numerical index.
		if ( typeof index === "string" ) {
			index = this.anchors.index( this.anchors.filter( "[href$='" +
				$.ui.escapeSelector( index ) + "']" ) );
		}

		return index;
	},

	_destroy: function() {
		if ( this.xhr ) {
			this.xhr.abort();
		}

		this.tablist
			.removeAttr( "role" )
			.off( this.eventNamespace );

		this.anchors
			.removeAttr( "role tabIndex" )
			.removeUniqueId();

		this.tabs.add( this.panels ).each( function() {
			if ( $.data( this, "ui-tabs-destroy" ) ) {
				$( this ).remove();
			} else {
				$( this ).removeAttr( "role tabIndex " +
					"aria-live aria-busy aria-selected aria-labelledby aria-hidden aria-expanded" );
			}
		} );

		this.tabs.each( function() {
			var li = $( this ),
				prev = li.data( "ui-tabs-aria-controls" );
			if ( prev ) {
				li
					.attr( "aria-controls", prev )
					.removeData( "ui-tabs-aria-controls" );
			} else {
				li.removeAttr( "aria-controls" );
			}
		} );

		this.panels.show();

		if ( this.options.heightStyle !== "content" ) {
			this.panels.css( "height", "" );
		}
	},

	enable: function( index ) {
		var disabled = this.options.disabled;
		if ( disabled === false ) {
			return;
		}

		if ( index === undefined ) {
			disabled = false;
		} else {
			index = this._getIndex( index );
			if ( $.isArray( disabled ) ) {
				disabled = $.map( disabled, function( num ) {
					return num !== index ? num : null;
				} );
			} else {
				disabled = $.map( this.tabs, function( li, num ) {
					return num !== index ? num : null;
				} );
			}
		}
		this._setOptionDisabled( disabled );
	},

	disable: function( index ) {
		var disabled = this.options.disabled;
		if ( disabled === true ) {
			return;
		}

		if ( index === undefined ) {
			disabled = true;
		} else {
			index = this._getIndex( index );
			if ( $.inArray( index, disabled ) !== -1 ) {
				return;
			}
			if ( $.isArray( disabled ) ) {
				disabled = $.merge( [ index ], disabled ).sort();
			} else {
				disabled = [ index ];
			}
		}
		this._setOptionDisabled( disabled );
	},

	load: function( index, event ) {
		index = this._getIndex( index );
		var that = this,
			tab = this.tabs.eq( index ),
			anchor = tab.find( ".ui-tabs-anchor" ),
			panel = this._getPanelForTab( tab ),
			eventData = {
				tab: tab,
				panel: panel
			},
			complete = function( jqXHR, status ) {
				if ( status === "abort" ) {
					that.panels.stop( false, true );
				}

				that._removeClass( tab, "ui-tabs-loading" );
				panel.removeAttr( "aria-busy" );

				if ( jqXHR === that.xhr ) {
					delete that.xhr;
				}
			};

		// Not remote
		if ( this._isLocal( anchor[ 0 ] ) ) {
			return;
		}

		this.xhr = $.ajax( this._ajaxSettings( anchor, event, eventData ) );

		// Support: jQuery <1.8
		// jQuery <1.8 returns false if the request is canceled in beforeSend,
		// but as of 1.8, $.ajax() always returns a jqXHR object.
		if ( this.xhr && this.xhr.statusText !== "canceled" ) {
			this._addClass( tab, "ui-tabs-loading" );
			panel.attr( "aria-busy", "true" );

			this.xhr
				.done( function( response, status, jqXHR ) {

					// support: jQuery <1.8
					// http://bugs.jquery.com/ticket/11778
					setTimeout( function() {
						panel.html( response );
						that._trigger( "load", event, eventData );

						complete( jqXHR, status );
					}, 1 );
				} )
				.fail( function( jqXHR, status ) {

					// support: jQuery <1.8
					// http://bugs.jquery.com/ticket/11778
					setTimeout( function() {
						complete( jqXHR, status );
					}, 1 );
				} );
		}
	},

	_ajaxSettings: function( anchor, event, eventData ) {
		var that = this;
		return {

			// Support: IE <11 only
			// Strip any hash that exists to prevent errors with the Ajax request
			url: anchor.attr( "href" ).replace( /#.*$/, "" ),
			beforeSend: function( jqXHR, settings ) {
				return that._trigger( "beforeLoad", event,
					$.extend( { jqXHR: jqXHR, ajaxSettings: settings }, eventData ) );
			}
		};
	},

	_getPanelForTab: function( tab ) {
		var id = $( tab ).attr( "aria-controls" );
		return this.element.find( this._sanitizeSelector( "#" + id ) );
	}
} );

// DEPRECATED
// TODO: Switch return back to widget declaration at top of file when this is removed
if ( $.uiBackCompat !== false ) {

	// Backcompat for ui-tab class (now ui-tabs-tab)
	$.widget( "ui.tabs", $.ui.tabs, {
		_processTabs: function() {
			this._superApply( arguments );
			this._addClass( this.tabs, "ui-tab" );
		}
	} );
}

var widgetsTabs = $.ui.tabs;


/*!
 * jQuery UI Tooltip 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Tooltip
//>>group: Widgets
//>>description: Shows additional information for any element on hover or focus.
//>>docs: http://api.jqueryui.com/tooltip/
//>>demos: http://jqueryui.com/tooltip/
//>>css.structure: ../../themes/base/core.css
//>>css.structure: ../../themes/base/tooltip.css
//>>css.theme: ../../themes/base/theme.css



$.widget( "ui.tooltip", {
	version: "1.12.1",
	options: {
		classes: {
			"ui-tooltip": "ui-corner-all ui-widget-shadow"
		},
		content: function() {

			// support: IE<9, Opera in jQuery <1.7
			// .text() can't accept undefined, so coerce to a string
			var title = $( this ).attr( "title" ) || "";

			// Escape title, since we're going from an attribute to raw HTML
			return $( "<a>" ).text( title ).html();
		},
		hide: true,

		// Disabled elements have inconsistent behavior across browsers (#8661)
		items: "[title]:not([disabled])",
		position: {
			my: "left top+15",
			at: "left bottom",
			collision: "flipfit flip"
		},
		show: true,
		track: false,

		// Callbacks
		close: null,
		open: null
	},

	_addDescribedBy: function( elem, id ) {
		var describedby = ( elem.attr( "aria-describedby" ) || "" ).split( /\s+/ );
		describedby.push( id );
		elem
			.data( "ui-tooltip-id", id )
			.attr( "aria-describedby", $.trim( describedby.join( " " ) ) );
	},

	_removeDescribedBy: function( elem ) {
		var id = elem.data( "ui-tooltip-id" ),
			describedby = ( elem.attr( "aria-describedby" ) || "" ).split( /\s+/ ),
			index = $.inArray( id, describedby );

		if ( index !== -1 ) {
			describedby.splice( index, 1 );
		}

		elem.removeData( "ui-tooltip-id" );
		describedby = $.trim( describedby.join( " " ) );
		if ( describedby ) {
			elem.attr( "aria-describedby", describedby );
		} else {
			elem.removeAttr( "aria-describedby" );
		}
	},

	_create: function() {
		this._on( {
			mouseover: "open",
			focusin: "open"
		} );

		// IDs of generated tooltips, needed for destroy
		this.tooltips = {};

		// IDs of parent tooltips where we removed the title attribute
		this.parents = {};

		// Append the aria-live region so tooltips announce correctly
		this.liveRegion = $( "<div>" )
			.attr( {
				role: "log",
				"aria-live": "assertive",
				"aria-relevant": "additions"
			} )
			.appendTo( this.document[ 0 ].body );
		this._addClass( this.liveRegion, null, "ui-helper-hidden-accessible" );

		this.disabledTitles = $( [] );
	},

	_setOption: function( key, value ) {
		var that = this;

		this._super( key, value );

		if ( key === "content" ) {
			$.each( this.tooltips, function( id, tooltipData ) {
				that._updateContent( tooltipData.element );
			} );
		}
	},

	_setOptionDisabled: function( value ) {
		this[ value ? "_disable" : "_enable" ]();
	},

	_disable: function() {
		var that = this;

		// Close open tooltips
		$.each( this.tooltips, function( id, tooltipData ) {
			var event = $.Event( "blur" );
			event.target = event.currentTarget = tooltipData.element[ 0 ];
			that.close( event, true );
		} );

		// Remove title attributes to prevent native tooltips
		this.disabledTitles = this.disabledTitles.add(
			this.element.find( this.options.items ).addBack()
				.filter( function() {
					var element = $( this );
					if ( element.is( "[title]" ) ) {
						return element
							.data( "ui-tooltip-title", element.attr( "title" ) )
							.removeAttr( "title" );
					}
				} )
		);
	},

	_enable: function() {

		// restore title attributes
		this.disabledTitles.each( function() {
			var element = $( this );
			if ( element.data( "ui-tooltip-title" ) ) {
				element.attr( "title", element.data( "ui-tooltip-title" ) );
			}
		} );
		this.disabledTitles = $( [] );
	},

	open: function( event ) {
		var that = this,
			target = $( event ? event.target : this.element )

				// we need closest here due to mouseover bubbling,
				// but always pointing at the same event target
				.closest( this.options.items );

		// No element to show a tooltip for or the tooltip is already open
		if ( !target.length || target.data( "ui-tooltip-id" ) ) {
			return;
		}

		if ( target.attr( "title" ) ) {
			target.data( "ui-tooltip-title", target.attr( "title" ) );
		}

		target.data( "ui-tooltip-open", true );

		// Kill parent tooltips, custom or native, for hover
		if ( event && event.type === "mouseover" ) {
			target.parents().each( function() {
				var parent = $( this ),
					blurEvent;
				if ( parent.data( "ui-tooltip-open" ) ) {
					blurEvent = $.Event( "blur" );
					blurEvent.target = blurEvent.currentTarget = this;
					that.close( blurEvent, true );
				}
				if ( parent.attr( "title" ) ) {
					parent.uniqueId();
					that.parents[ this.id ] = {
						element: this,
						title: parent.attr( "title" )
					};
					parent.attr( "title", "" );
				}
			} );
		}

		this._registerCloseHandlers( event, target );
		this._updateContent( target, event );
	},

	_updateContent: function( target, event ) {
		var content,
			contentOption = this.options.content,
			that = this,
			eventType = event ? event.type : null;

		if ( typeof contentOption === "string" || contentOption.nodeType ||
				contentOption.jquery ) {
			return this._open( event, target, contentOption );
		}

		content = contentOption.call( target[ 0 ], function( response ) {

			// IE may instantly serve a cached response for ajax requests
			// delay this call to _open so the other call to _open runs first
			that._delay( function() {

				// Ignore async response if tooltip was closed already
				if ( !target.data( "ui-tooltip-open" ) ) {
					return;
				}

				// JQuery creates a special event for focusin when it doesn't
				// exist natively. To improve performance, the native event
				// object is reused and the type is changed. Therefore, we can't
				// rely on the type being correct after the event finished
				// bubbling, so we set it back to the previous value. (#8740)
				if ( event ) {
					event.type = eventType;
				}
				this._open( event, target, response );
			} );
		} );
		if ( content ) {
			this._open( event, target, content );
		}
	},

	_open: function( event, target, content ) {
		var tooltipData, tooltip, delayedShow, a11yContent,
			positionOption = $.extend( {}, this.options.position );

		if ( !content ) {
			return;
		}

		// Content can be updated multiple times. If the tooltip already
		// exists, then just update the content and bail.
		tooltipData = this._find( target );
		if ( tooltipData ) {
			tooltipData.tooltip.find( ".ui-tooltip-content" ).html( content );
			return;
		}

		// If we have a title, clear it to prevent the native tooltip
		// we have to check first to avoid defining a title if none exists
		// (we don't want to cause an element to start matching [title])
		//
		// We use removeAttr only for key events, to allow IE to export the correct
		// accessible attributes. For mouse events, set to empty string to avoid
		// native tooltip showing up (happens only when removing inside mouseover).
		if ( target.is( "[title]" ) ) {
			if ( event && event.type === "mouseover" ) {
				target.attr( "title", "" );
			} else {
				target.removeAttr( "title" );
			}
		}

		tooltipData = this._tooltip( target );
		tooltip = tooltipData.tooltip;
		this._addDescribedBy( target, tooltip.attr( "id" ) );
		tooltip.find( ".ui-tooltip-content" ).html( content );

		// Support: Voiceover on OS X, JAWS on IE <= 9
		// JAWS announces deletions even when aria-relevant="additions"
		// Voiceover will sometimes re-read the entire log region's contents from the beginning
		this.liveRegion.children().hide();
		a11yContent = $( "<div>" ).html( tooltip.find( ".ui-tooltip-content" ).html() );
		a11yContent.removeAttr( "name" ).find( "[name]" ).removeAttr( "name" );
		a11yContent.removeAttr( "id" ).find( "[id]" ).removeAttr( "id" );
		a11yContent.appendTo( this.liveRegion );

		function position( event ) {
			positionOption.of = event;
			if ( tooltip.is( ":hidden" ) ) {
				return;
			}
			tooltip.position( positionOption );
		}
		if ( this.options.track && event && /^mouse/.test( event.type ) ) {
			this._on( this.document, {
				mousemove: position
			} );

			// trigger once to override element-relative positioning
			position( event );
		} else {
			tooltip.position( $.extend( {
				of: target
			}, this.options.position ) );
		}

		tooltip.hide();

		this._show( tooltip, this.options.show );

		// Handle tracking tooltips that are shown with a delay (#8644). As soon
		// as the tooltip is visible, position the tooltip using the most recent
		// event.
		// Adds the check to add the timers only when both delay and track options are set (#14682)
		if ( this.options.track && this.options.show && this.options.show.delay ) {
			delayedShow = this.delayedShow = setInterval( function() {
				if ( tooltip.is( ":visible" ) ) {
					position( positionOption.of );
					clearInterval( delayedShow );
				}
			}, $.fx.interval );
		}

		this._trigger( "open", event, { tooltip: tooltip } );
	},

	_registerCloseHandlers: function( event, target ) {
		var events = {
			keyup: function( event ) {
				if ( event.keyCode === $.ui.keyCode.ESCAPE ) {
					var fakeEvent = $.Event( event );
					fakeEvent.currentTarget = target[ 0 ];
					this.close( fakeEvent, true );
				}
			}
		};

		// Only bind remove handler for delegated targets. Non-delegated
		// tooltips will handle this in destroy.
		if ( target[ 0 ] !== this.element[ 0 ] ) {
			events.remove = function() {
				this._removeTooltip( this._find( target ).tooltip );
			};
		}

		if ( !event || event.type === "mouseover" ) {
			events.mouseleave = "close";
		}
		if ( !event || event.type === "focusin" ) {
			events.focusout = "close";
		}
		this._on( true, target, events );
	},

	close: function( event ) {
		var tooltip,
			that = this,
			target = $( event ? event.currentTarget : this.element ),
			tooltipData = this._find( target );

		// The tooltip may already be closed
		if ( !tooltipData ) {

			// We set ui-tooltip-open immediately upon open (in open()), but only set the
			// additional data once there's actually content to show (in _open()). So even if the
			// tooltip doesn't have full data, we always remove ui-tooltip-open in case we're in
			// the period between open() and _open().
			target.removeData( "ui-tooltip-open" );
			return;
		}

		tooltip = tooltipData.tooltip;

		// Disabling closes the tooltip, so we need to track when we're closing
		// to avoid an infinite loop in case the tooltip becomes disabled on close
		if ( tooltipData.closing ) {
			return;
		}

		// Clear the interval for delayed tracking tooltips
		clearInterval( this.delayedShow );

		// Only set title if we had one before (see comment in _open())
		// If the title attribute has changed since open(), don't restore
		if ( target.data( "ui-tooltip-title" ) && !target.attr( "title" ) ) {
			target.attr( "title", target.data( "ui-tooltip-title" ) );
		}

		this._removeDescribedBy( target );

		tooltipData.hiding = true;
		tooltip.stop( true );
		this._hide( tooltip, this.options.hide, function() {
			that._removeTooltip( $( this ) );
		} );

		target.removeData( "ui-tooltip-open" );
		this._off( target, "mouseleave focusout keyup" );

		// Remove 'remove' binding only on delegated targets
		if ( target[ 0 ] !== this.element[ 0 ] ) {
			this._off( target, "remove" );
		}
		this._off( this.document, "mousemove" );

		if ( event && event.type === "mouseleave" ) {
			$.each( this.parents, function( id, parent ) {
				$( parent.element ).attr( "title", parent.title );
				delete that.parents[ id ];
			} );
		}

		tooltipData.closing = true;
		this._trigger( "close", event, { tooltip: tooltip } );
		if ( !tooltipData.hiding ) {
			tooltipData.closing = false;
		}
	},

	_tooltip: function( element ) {
		var tooltip = $( "<div>" ).attr( "role", "tooltip" ),
			content = $( "<div>" ).appendTo( tooltip ),
			id = tooltip.uniqueId().attr( "id" );

		this._addClass( content, "ui-tooltip-content" );
		this._addClass( tooltip, "ui-tooltip", "ui-widget ui-widget-content" );

		tooltip.appendTo( this._appendTo( element ) );

		return this.tooltips[ id ] = {
			element: element,
			tooltip: tooltip
		};
	},

	_find: function( target ) {
		var id = target.data( "ui-tooltip-id" );
		return id ? this.tooltips[ id ] : null;
	},

	_removeTooltip: function( tooltip ) {
		tooltip.remove();
		delete this.tooltips[ tooltip.attr( "id" ) ];
	},

	_appendTo: function( target ) {
		var element = target.closest( ".ui-front, dialog" );

		if ( !element.length ) {
			element = this.document[ 0 ].body;
		}

		return element;
	},

	_destroy: function() {
		var that = this;

		// Close open tooltips
		$.each( this.tooltips, function( id, tooltipData ) {

			// Delegate to close method to handle common cleanup
			var event = $.Event( "blur" ),
				element = tooltipData.element;
			event.target = event.currentTarget = element[ 0 ];
			that.close( event, true );

			// Remove immediately; destroying an open tooltip doesn't use the
			// hide animation
			$( "#" + id ).remove();

			// Restore the title
			if ( element.data( "ui-tooltip-title" ) ) {

				// If the title attribute has changed since open(), don't restore
				if ( !element.attr( "title" ) ) {
					element.attr( "title", element.data( "ui-tooltip-title" ) );
				}
				element.removeData( "ui-tooltip-title" );
			}
		} );
		this.liveRegion.remove();
	}
} );

// DEPRECATED
// TODO: Switch return back to widget declaration at top of file when this is removed
if ( $.uiBackCompat !== false ) {

	// Backcompat for tooltipClass option
	$.widget( "ui.tooltip", $.ui.tooltip, {
		options: {
			tooltipClass: null
		},
		_tooltip: function() {
			var tooltipData = this._superApply( arguments );
			if ( this.options.tooltipClass ) {
				tooltipData.tooltip.addClass( this.options.tooltipClass );
			}
			return tooltipData;
		}
	} );
}

var widgetsTooltip = $.ui.tooltip;


/*!
 * jQuery UI Effects 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Effects Core
//>>group: Effects
// jscs:disable maximumLineLength
//>>description: Extends the internal jQuery effects. Includes morphing and easing. Required by all other effects.
// jscs:enable maximumLineLength
//>>docs: http://api.jqueryui.com/category/effects-core/
//>>demos: http://jqueryui.com/effect/



var dataSpace = "ui-effects-",
	dataSpaceStyle = "ui-effects-style",
	dataSpaceAnimated = "ui-effects-animated",

	// Create a local jQuery because jQuery Color relies on it and the
	// global may not exist with AMD and a custom build (#10199)
	jQuery = $;

$.effects = {
	effect: {}
};

/*!
 * jQuery Color Animations v2.1.2
 * https://github.com/jquery/jquery-color
 *
 * Copyright 2014 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * Date: Wed Jan 16 08:47:09 2013 -0600
 */
( function( jQuery, undefined ) {

	var stepHooks = "backgroundColor borderBottomColor borderLeftColor borderRightColor " +
		"borderTopColor color columnRuleColor outlineColor textDecorationColor textEmphasisColor",

	// Plusequals test for += 100 -= 100
	rplusequals = /^([\-+])=\s*(\d+\.?\d*)/,

	// A set of RE's that can match strings and generate color tuples.
	stringParsers = [ {
			re: /rgba?\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
			parse: function( execResult ) {
				return [
					execResult[ 1 ],
					execResult[ 2 ],
					execResult[ 3 ],
					execResult[ 4 ]
				];
			}
		}, {
			re: /rgba?\(\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
			parse: function( execResult ) {
				return [
					execResult[ 1 ] * 2.55,
					execResult[ 2 ] * 2.55,
					execResult[ 3 ] * 2.55,
					execResult[ 4 ]
				];
			}
		}, {

			// This regex ignores A-F because it's compared against an already lowercased string
			re: /#([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})/,
			parse: function( execResult ) {
				return [
					parseInt( execResult[ 1 ], 16 ),
					parseInt( execResult[ 2 ], 16 ),
					parseInt( execResult[ 3 ], 16 )
				];
			}
		}, {

			// This regex ignores A-F because it's compared against an already lowercased string
			re: /#([a-f0-9])([a-f0-9])([a-f0-9])/,
			parse: function( execResult ) {
				return [
					parseInt( execResult[ 1 ] + execResult[ 1 ], 16 ),
					parseInt( execResult[ 2 ] + execResult[ 2 ], 16 ),
					parseInt( execResult[ 3 ] + execResult[ 3 ], 16 )
				];
			}
		}, {
			re: /hsla?\(\s*(\d+(?:\.\d+)?)\s*,\s*(\d+(?:\.\d+)?)\%\s*,\s*(\d+(?:\.\d+)?)\%\s*(?:,\s*(\d?(?:\.\d+)?)\s*)?\)/,
			space: "hsla",
			parse: function( execResult ) {
				return [
					execResult[ 1 ],
					execResult[ 2 ] / 100,
					execResult[ 3 ] / 100,
					execResult[ 4 ]
				];
			}
		} ],

	// JQuery.Color( )
	color = jQuery.Color = function( color, green, blue, alpha ) {
		return new jQuery.Color.fn.parse( color, green, blue, alpha );
	},
	spaces = {
		rgba: {
			props: {
				red: {
					idx: 0,
					type: "byte"
				},
				green: {
					idx: 1,
					type: "byte"
				},
				blue: {
					idx: 2,
					type: "byte"
				}
			}
		},

		hsla: {
			props: {
				hue: {
					idx: 0,
					type: "degrees"
				},
				saturation: {
					idx: 1,
					type: "percent"
				},
				lightness: {
					idx: 2,
					type: "percent"
				}
			}
		}
	},
	propTypes = {
		"byte": {
			floor: true,
			max: 255
		},
		"percent": {
			max: 1
		},
		"degrees": {
			mod: 360,
			floor: true
		}
	},
	support = color.support = {},

	// Element for support tests
	supportElem = jQuery( "<p>" )[ 0 ],

	// Colors = jQuery.Color.names
	colors,

	// Local aliases of functions called often
	each = jQuery.each;

// Determine rgba support immediately
supportElem.style.cssText = "background-color:rgba(1,1,1,.5)";
support.rgba = supportElem.style.backgroundColor.indexOf( "rgba" ) > -1;

// Define cache name and alpha properties
// for rgba and hsla spaces
each( spaces, function( spaceName, space ) {
	space.cache = "_" + spaceName;
	space.props.alpha = {
		idx: 3,
		type: "percent",
		def: 1
	};
} );

function clamp( value, prop, allowEmpty ) {
	var type = propTypes[ prop.type ] || {};

	if ( value == null ) {
		return ( allowEmpty || !prop.def ) ? null : prop.def;
	}

	// ~~ is an short way of doing floor for positive numbers
	value = type.floor ? ~~value : parseFloat( value );

	// IE will pass in empty strings as value for alpha,
	// which will hit this case
	if ( isNaN( value ) ) {
		return prop.def;
	}

	if ( type.mod ) {

		// We add mod before modding to make sure that negatives values
		// get converted properly: -10 -> 350
		return ( value + type.mod ) % type.mod;
	}

	// For now all property types without mod have min and max
	return 0 > value ? 0 : type.max < value ? type.max : value;
}

function stringParse( string ) {
	var inst = color(),
		rgba = inst._rgba = [];

	string = string.toLowerCase();

	each( stringParsers, function( i, parser ) {
		var parsed,
			match = parser.re.exec( string ),
			values = match && parser.parse( match ),
			spaceName = parser.space || "rgba";

		if ( values ) {
			parsed = inst[ spaceName ]( values );

			// If this was an rgba parse the assignment might happen twice
			// oh well....
			inst[ spaces[ spaceName ].cache ] = parsed[ spaces[ spaceName ].cache ];
			rgba = inst._rgba = parsed._rgba;

			// Exit each( stringParsers ) here because we matched
			return false;
		}
	} );

	// Found a stringParser that handled it
	if ( rgba.length ) {

		// If this came from a parsed string, force "transparent" when alpha is 0
		// chrome, (and maybe others) return "transparent" as rgba(0,0,0,0)
		if ( rgba.join() === "0,0,0,0" ) {
			jQuery.extend( rgba, colors.transparent );
		}
		return inst;
	}

	// Named colors
	return colors[ string ];
}

color.fn = jQuery.extend( color.prototype, {
	parse: function( red, green, blue, alpha ) {
		if ( red === undefined ) {
			this._rgba = [ null, null, null, null ];
			return this;
		}
		if ( red.jquery || red.nodeType ) {
			red = jQuery( red ).css( green );
			green = undefined;
		}

		var inst = this,
			type = jQuery.type( red ),
			rgba = this._rgba = [];

		// More than 1 argument specified - assume ( red, green, blue, alpha )
		if ( green !== undefined ) {
			red = [ red, green, blue, alpha ];
			type = "array";
		}

		if ( type === "string" ) {
			return this.parse( stringParse( red ) || colors._default );
		}

		if ( type === "array" ) {
			each( spaces.rgba.props, function( key, prop ) {
				rgba[ prop.idx ] = clamp( red[ prop.idx ], prop );
			} );
			return this;
		}

		if ( type === "object" ) {
			if ( red instanceof color ) {
				each( spaces, function( spaceName, space ) {
					if ( red[ space.cache ] ) {
						inst[ space.cache ] = red[ space.cache ].slice();
					}
				} );
			} else {
				each( spaces, function( spaceName, space ) {
					var cache = space.cache;
					each( space.props, function( key, prop ) {

						// If the cache doesn't exist, and we know how to convert
						if ( !inst[ cache ] && space.to ) {

							// If the value was null, we don't need to copy it
							// if the key was alpha, we don't need to copy it either
							if ( key === "alpha" || red[ key ] == null ) {
								return;
							}
							inst[ cache ] = space.to( inst._rgba );
						}

						// This is the only case where we allow nulls for ALL properties.
						// call clamp with alwaysAllowEmpty
						inst[ cache ][ prop.idx ] = clamp( red[ key ], prop, true );
					} );

					// Everything defined but alpha?
					if ( inst[ cache ] &&
							jQuery.inArray( null, inst[ cache ].slice( 0, 3 ) ) < 0 ) {

						// Use the default of 1
						inst[ cache ][ 3 ] = 1;
						if ( space.from ) {
							inst._rgba = space.from( inst[ cache ] );
						}
					}
				} );
			}
			return this;
		}
	},
	is: function( compare ) {
		var is = color( compare ),
			same = true,
			inst = this;

		each( spaces, function( _, space ) {
			var localCache,
				isCache = is[ space.cache ];
			if ( isCache ) {
				localCache = inst[ space.cache ] || space.to && space.to( inst._rgba ) || [];
				each( space.props, function( _, prop ) {
					if ( isCache[ prop.idx ] != null ) {
						same = ( isCache[ prop.idx ] === localCache[ prop.idx ] );
						return same;
					}
				} );
			}
			return same;
		} );
		return same;
	},
	_space: function() {
		var used = [],
			inst = this;
		each( spaces, function( spaceName, space ) {
			if ( inst[ space.cache ] ) {
				used.push( spaceName );
			}
		} );
		return used.pop();
	},
	transition: function( other, distance ) {
		var end = color( other ),
			spaceName = end._space(),
			space = spaces[ spaceName ],
			startColor = this.alpha() === 0 ? color( "transparent" ) : this,
			start = startColor[ space.cache ] || space.to( startColor._rgba ),
			result = start.slice();

		end = end[ space.cache ];
		each( space.props, function( key, prop ) {
			var index = prop.idx,
				startValue = start[ index ],
				endValue = end[ index ],
				type = propTypes[ prop.type ] || {};

			// If null, don't override start value
			if ( endValue === null ) {
				return;
			}

			// If null - use end
			if ( startValue === null ) {
				result[ index ] = endValue;
			} else {
				if ( type.mod ) {
					if ( endValue - startValue > type.mod / 2 ) {
						startValue += type.mod;
					} else if ( startValue - endValue > type.mod / 2 ) {
						startValue -= type.mod;
					}
				}
				result[ index ] = clamp( ( endValue - startValue ) * distance + startValue, prop );
			}
		} );
		return this[ spaceName ]( result );
	},
	blend: function( opaque ) {

		// If we are already opaque - return ourself
		if ( this._rgba[ 3 ] === 1 ) {
			return this;
		}

		var rgb = this._rgba.slice(),
			a = rgb.pop(),
			blend = color( opaque )._rgba;

		return color( jQuery.map( rgb, function( v, i ) {
			return ( 1 - a ) * blend[ i ] + a * v;
		} ) );
	},
	toRgbaString: function() {
		var prefix = "rgba(",
			rgba = jQuery.map( this._rgba, function( v, i ) {
				return v == null ? ( i > 2 ? 1 : 0 ) : v;
			} );

		if ( rgba[ 3 ] === 1 ) {
			rgba.pop();
			prefix = "rgb(";
		}

		return prefix + rgba.join() + ")";
	},
	toHslaString: function() {
		var prefix = "hsla(",
			hsla = jQuery.map( this.hsla(), function( v, i ) {
				if ( v == null ) {
					v = i > 2 ? 1 : 0;
				}

				// Catch 1 and 2
				if ( i && i < 3 ) {
					v = Math.round( v * 100 ) + "%";
				}
				return v;
			} );

		if ( hsla[ 3 ] === 1 ) {
			hsla.pop();
			prefix = "hsl(";
		}
		return prefix + hsla.join() + ")";
	},
	toHexString: function( includeAlpha ) {
		var rgba = this._rgba.slice(),
			alpha = rgba.pop();

		if ( includeAlpha ) {
			rgba.push( ~~( alpha * 255 ) );
		}

		return "#" + jQuery.map( rgba, function( v ) {

			// Default to 0 when nulls exist
			v = ( v || 0 ).toString( 16 );
			return v.length === 1 ? "0" + v : v;
		} ).join( "" );
	},
	toString: function() {
		return this._rgba[ 3 ] === 0 ? "transparent" : this.toRgbaString();
	}
} );
color.fn.parse.prototype = color.fn;

// Hsla conversions adapted from:
// https://code.google.com/p/maashaack/source/browse/packages/graphics/trunk/src/graphics/colors/HUE2RGB.as?r=5021

function hue2rgb( p, q, h ) {
	h = ( h + 1 ) % 1;
	if ( h * 6 < 1 ) {
		return p + ( q - p ) * h * 6;
	}
	if ( h * 2 < 1 ) {
		return q;
	}
	if ( h * 3 < 2 ) {
		return p + ( q - p ) * ( ( 2 / 3 ) - h ) * 6;
	}
	return p;
}

spaces.hsla.to = function( rgba ) {
	if ( rgba[ 0 ] == null || rgba[ 1 ] == null || rgba[ 2 ] == null ) {
		return [ null, null, null, rgba[ 3 ] ];
	}
	var r = rgba[ 0 ] / 255,
		g = rgba[ 1 ] / 255,
		b = rgba[ 2 ] / 255,
		a = rgba[ 3 ],
		max = Math.max( r, g, b ),
		min = Math.min( r, g, b ),
		diff = max - min,
		add = max + min,
		l = add * 0.5,
		h, s;

	if ( min === max ) {
		h = 0;
	} else if ( r === max ) {
		h = ( 60 * ( g - b ) / diff ) + 360;
	} else if ( g === max ) {
		h = ( 60 * ( b - r ) / diff ) + 120;
	} else {
		h = ( 60 * ( r - g ) / diff ) + 240;
	}

	// Chroma (diff) == 0 means greyscale which, by definition, saturation = 0%
	// otherwise, saturation is based on the ratio of chroma (diff) to lightness (add)
	if ( diff === 0 ) {
		s = 0;
	} else if ( l <= 0.5 ) {
		s = diff / add;
	} else {
		s = diff / ( 2 - add );
	}
	return [ Math.round( h ) % 360, s, l, a == null ? 1 : a ];
};

spaces.hsla.from = function( hsla ) {
	if ( hsla[ 0 ] == null || hsla[ 1 ] == null || hsla[ 2 ] == null ) {
		return [ null, null, null, hsla[ 3 ] ];
	}
	var h = hsla[ 0 ] / 360,
		s = hsla[ 1 ],
		l = hsla[ 2 ],
		a = hsla[ 3 ],
		q = l <= 0.5 ? l * ( 1 + s ) : l + s - l * s,
		p = 2 * l - q;

	return [
		Math.round( hue2rgb( p, q, h + ( 1 / 3 ) ) * 255 ),
		Math.round( hue2rgb( p, q, h ) * 255 ),
		Math.round( hue2rgb( p, q, h - ( 1 / 3 ) ) * 255 ),
		a
	];
};

each( spaces, function( spaceName, space ) {
	var props = space.props,
		cache = space.cache,
		to = space.to,
		from = space.from;

	// Makes rgba() and hsla()
	color.fn[ spaceName ] = function( value ) {

		// Generate a cache for this space if it doesn't exist
		if ( to && !this[ cache ] ) {
			this[ cache ] = to( this._rgba );
		}
		if ( value === undefined ) {
			return this[ cache ].slice();
		}

		var ret,
			type = jQuery.type( value ),
			arr = ( type === "array" || type === "object" ) ? value : arguments,
			local = this[ cache ].slice();

		each( props, function( key, prop ) {
			var val = arr[ type === "object" ? key : prop.idx ];
			if ( val == null ) {
				val = local[ prop.idx ];
			}
			local[ prop.idx ] = clamp( val, prop );
		} );

		if ( from ) {
			ret = color( from( local ) );
			ret[ cache ] = local;
			return ret;
		} else {
			return color( local );
		}
	};

	// Makes red() green() blue() alpha() hue() saturation() lightness()
	each( props, function( key, prop ) {

		// Alpha is included in more than one space
		if ( color.fn[ key ] ) {
			return;
		}
		color.fn[ key ] = function( value ) {
			var vtype = jQuery.type( value ),
				fn = ( key === "alpha" ? ( this._hsla ? "hsla" : "rgba" ) : spaceName ),
				local = this[ fn ](),
				cur = local[ prop.idx ],
				match;

			if ( vtype === "undefined" ) {
				return cur;
			}

			if ( vtype === "function" ) {
				value = value.call( this, cur );
				vtype = jQuery.type( value );
			}
			if ( value == null && prop.empty ) {
				return this;
			}
			if ( vtype === "string" ) {
				match = rplusequals.exec( value );
				if ( match ) {
					value = cur + parseFloat( match[ 2 ] ) * ( match[ 1 ] === "+" ? 1 : -1 );
				}
			}
			local[ prop.idx ] = value;
			return this[ fn ]( local );
		};
	} );
} );

// Add cssHook and .fx.step function for each named hook.
// accept a space separated string of properties
color.hook = function( hook ) {
	var hooks = hook.split( " " );
	each( hooks, function( i, hook ) {
		jQuery.cssHooks[ hook ] = {
			set: function( elem, value ) {
				var parsed, curElem,
					backgroundColor = "";

				if ( value !== "transparent" && ( jQuery.type( value ) !== "string" ||
						( parsed = stringParse( value ) ) ) ) {
					value = color( parsed || value );
					if ( !support.rgba && value._rgba[ 3 ] !== 1 ) {
						curElem = hook === "backgroundColor" ? elem.parentNode : elem;
						while (
							( backgroundColor === "" || backgroundColor === "transparent" ) &&
							curElem && curElem.style
						) {
							try {
								backgroundColor = jQuery.css( curElem, "backgroundColor" );
								curElem = curElem.parentNode;
							} catch ( e ) {
							}
						}

						value = value.blend( backgroundColor && backgroundColor !== "transparent" ?
							backgroundColor :
							"_default" );
					}

					value = value.toRgbaString();
				}
				try {
					elem.style[ hook ] = value;
				} catch ( e ) {

					// Wrapped to prevent IE from throwing errors on "invalid" values like
					// 'auto' or 'inherit'
				}
			}
		};
		jQuery.fx.step[ hook ] = function( fx ) {
			if ( !fx.colorInit ) {
				fx.start = color( fx.elem, hook );
				fx.end = color( fx.end );
				fx.colorInit = true;
			}
			jQuery.cssHooks[ hook ].set( fx.elem, fx.start.transition( fx.end, fx.pos ) );
		};
	} );

};

color.hook( stepHooks );

jQuery.cssHooks.borderColor = {
	expand: function( value ) {
		var expanded = {};

		each( [ "Top", "Right", "Bottom", "Left" ], function( i, part ) {
			expanded[ "border" + part + "Color" ] = value;
		} );
		return expanded;
	}
};

// Basic color names only.
// Usage of any of the other color names requires adding yourself or including
// jquery.color.svg-names.js.
colors = jQuery.Color.names = {

	// 4.1. Basic color keywords
	aqua: "#00ffff",
	black: "#000000",
	blue: "#0000ff",
	fuchsia: "#ff00ff",
	gray: "#808080",
	green: "#008000",
	lime: "#00ff00",
	maroon: "#800000",
	navy: "#000080",
	olive: "#808000",
	purple: "#800080",
	red: "#ff0000",
	silver: "#c0c0c0",
	teal: "#008080",
	white: "#ffffff",
	yellow: "#ffff00",

	// 4.2.3. "transparent" color keyword
	transparent: [ null, null, null, 0 ],

	_default: "#ffffff"
};

} )( jQuery );

/******************************************************************************/
/****************************** CLASS ANIMATIONS ******************************/
/******************************************************************************/
( function() {

var classAnimationActions = [ "add", "remove", "toggle" ],
	shorthandStyles = {
		border: 1,
		borderBottom: 1,
		borderColor: 1,
		borderLeft: 1,
		borderRight: 1,
		borderTop: 1,
		borderWidth: 1,
		margin: 1,
		padding: 1
	};

$.each(
	[ "borderLeftStyle", "borderRightStyle", "borderBottomStyle", "borderTopStyle" ],
	function( _, prop ) {
		$.fx.step[ prop ] = function( fx ) {
			if ( fx.end !== "none" && !fx.setAttr || fx.pos === 1 && !fx.setAttr ) {
				jQuery.style( fx.elem, prop, fx.end );
				fx.setAttr = true;
			}
		};
	}
);

function getElementStyles( elem ) {
	var key, len,
		style = elem.ownerDocument.defaultView ?
			elem.ownerDocument.defaultView.getComputedStyle( elem, null ) :
			elem.currentStyle,
		styles = {};

	if ( style && style.length && style[ 0 ] && style[ style[ 0 ] ] ) {
		len = style.length;
		while ( len-- ) {
			key = style[ len ];
			if ( typeof style[ key ] === "string" ) {
				styles[ $.camelCase( key ) ] = style[ key ];
			}
		}

	// Support: Opera, IE <9
	} else {
		for ( key in style ) {
			if ( typeof style[ key ] === "string" ) {
				styles[ key ] = style[ key ];
			}
		}
	}

	return styles;
}

function styleDifference( oldStyle, newStyle ) {
	var diff = {},
		name, value;

	for ( name in newStyle ) {
		value = newStyle[ name ];
		if ( oldStyle[ name ] !== value ) {
			if ( !shorthandStyles[ name ] ) {
				if ( $.fx.step[ name ] || !isNaN( parseFloat( value ) ) ) {
					diff[ name ] = value;
				}
			}
		}
	}

	return diff;
}

// Support: jQuery <1.8
if ( !$.fn.addBack ) {
	$.fn.addBack = function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	};
}

$.effects.animateClass = function( value, duration, easing, callback ) {
	var o = $.speed( duration, easing, callback );

	return this.queue( function() {
		var animated = $( this ),
			baseClass = animated.attr( "class" ) || "",
			applyClassChange,
			allAnimations = o.children ? animated.find( "*" ).addBack() : animated;

		// Map the animated objects to store the original styles.
		allAnimations = allAnimations.map( function() {
			var el = $( this );
			return {
				el: el,
				start: getElementStyles( this )
			};
		} );

		// Apply class change
		applyClassChange = function() {
			$.each( classAnimationActions, function( i, action ) {
				if ( value[ action ] ) {
					animated[ action + "Class" ]( value[ action ] );
				}
			} );
		};
		applyClassChange();

		// Map all animated objects again - calculate new styles and diff
		allAnimations = allAnimations.map( function() {
			this.end = getElementStyles( this.el[ 0 ] );
			this.diff = styleDifference( this.start, this.end );
			return this;
		} );

		// Apply original class
		animated.attr( "class", baseClass );

		// Map all animated objects again - this time collecting a promise
		allAnimations = allAnimations.map( function() {
			var styleInfo = this,
				dfd = $.Deferred(),
				opts = $.extend( {}, o, {
					queue: false,
					complete: function() {
						dfd.resolve( styleInfo );
					}
				} );

			this.el.animate( this.diff, opts );
			return dfd.promise();
		} );

		// Once all animations have completed:
		$.when.apply( $, allAnimations.get() ).done( function() {

			// Set the final class
			applyClassChange();

			// For each animated element,
			// clear all css properties that were animated
			$.each( arguments, function() {
				var el = this.el;
				$.each( this.diff, function( key ) {
					el.css( key, "" );
				} );
			} );

			// This is guarnteed to be there if you use jQuery.speed()
			// it also handles dequeuing the next anim...
			o.complete.call( animated[ 0 ] );
		} );
	} );
};

$.fn.extend( {
	addClass: ( function( orig ) {
		return function( classNames, speed, easing, callback ) {
			return speed ?
				$.effects.animateClass.call( this,
					{ add: classNames }, speed, easing, callback ) :
				orig.apply( this, arguments );
		};
	} )( $.fn.addClass ),

	removeClass: ( function( orig ) {
		return function( classNames, speed, easing, callback ) {
			return arguments.length > 1 ?
				$.effects.animateClass.call( this,
					{ remove: classNames }, speed, easing, callback ) :
				orig.apply( this, arguments );
		};
	} )( $.fn.removeClass ),

	toggleClass: ( function( orig ) {
		return function( classNames, force, speed, easing, callback ) {
			if ( typeof force === "boolean" || force === undefined ) {
				if ( !speed ) {

					// Without speed parameter
					return orig.apply( this, arguments );
				} else {
					return $.effects.animateClass.call( this,
						( force ? { add: classNames } : { remove: classNames } ),
						speed, easing, callback );
				}
			} else {

				// Without force parameter
				return $.effects.animateClass.call( this,
					{ toggle: classNames }, force, speed, easing );
			}
		};
	} )( $.fn.toggleClass ),

	switchClass: function( remove, add, speed, easing, callback ) {
		return $.effects.animateClass.call( this, {
			add: add,
			remove: remove
		}, speed, easing, callback );
	}
} );

} )();

/******************************************************************************/
/*********************************** EFFECTS **********************************/
/******************************************************************************/

( function() {

if ( $.expr && $.expr.pseudos && $.expr.pseudos.animated ) {
	$.expr.pseudos.animated = ( function( orig ) {
		return function( elem ) {
			return !!$( elem ).data( dataSpaceAnimated ) || orig( elem );
		};
	} )( $.expr.pseudos.animated );
}

if ( $.uiBackCompat !== false ) {
	$.extend( $.effects, {

		// Saves a set of properties in a data storage
		save: function( element, set ) {
			var i = 0, length = set.length;
			for ( ; i < length; i++ ) {
				if ( set[ i ] !== null ) {
					element.data( dataSpace + set[ i ], element[ 0 ].style[ set[ i ] ] );
				}
			}
		},

		// Restores a set of previously saved properties from a data storage
		restore: function( element, set ) {
			var val, i = 0, length = set.length;
			for ( ; i < length; i++ ) {
				if ( set[ i ] !== null ) {
					val = element.data( dataSpace + set[ i ] );
					element.css( set[ i ], val );
				}
			}
		},

		setMode: function( el, mode ) {
			if ( mode === "toggle" ) {
				mode = el.is( ":hidden" ) ? "show" : "hide";
			}
			return mode;
		},

		// Wraps the element around a wrapper that copies position properties
		createWrapper: function( element ) {

			// If the element is already wrapped, return it
			if ( element.parent().is( ".ui-effects-wrapper" ) ) {
				return element.parent();
			}

			// Wrap the element
			var props = {
					width: element.outerWidth( true ),
					height: element.outerHeight( true ),
					"float": element.css( "float" )
				},
				wrapper = $( "<div></div>" )
					.addClass( "ui-effects-wrapper" )
					.css( {
						fontSize: "100%",
						background: "transparent",
						border: "none",
						margin: 0,
						padding: 0
					} ),

				// Store the size in case width/height are defined in % - Fixes #5245
				size = {
					width: element.width(),
					height: element.height()
				},
				active = document.activeElement;

			// Support: Firefox
			// Firefox incorrectly exposes anonymous content
			// https://bugzilla.mozilla.org/show_bug.cgi?id=561664
			try {
				active.id;
			} catch ( e ) {
				active = document.body;
			}

			element.wrap( wrapper );

			// Fixes #7595 - Elements lose focus when wrapped.
			if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
				$( active ).trigger( "focus" );
			}

			// Hotfix for jQuery 1.4 since some change in wrap() seems to actually
			// lose the reference to the wrapped element
			wrapper = element.parent();

			// Transfer positioning properties to the wrapper
			if ( element.css( "position" ) === "static" ) {
				wrapper.css( { position: "relative" } );
				element.css( { position: "relative" } );
			} else {
				$.extend( props, {
					position: element.css( "position" ),
					zIndex: element.css( "z-index" )
				} );
				$.each( [ "top", "left", "bottom", "right" ], function( i, pos ) {
					props[ pos ] = element.css( pos );
					if ( isNaN( parseInt( props[ pos ], 10 ) ) ) {
						props[ pos ] = "auto";
					}
				} );
				element.css( {
					position: "relative",
					top: 0,
					left: 0,
					right: "auto",
					bottom: "auto"
				} );
			}
			element.css( size );

			return wrapper.css( props ).show();
		},

		removeWrapper: function( element ) {
			var active = document.activeElement;

			if ( element.parent().is( ".ui-effects-wrapper" ) ) {
				element.parent().replaceWith( element );

				// Fixes #7595 - Elements lose focus when wrapped.
				if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
					$( active ).trigger( "focus" );
				}
			}

			return element;
		}
	} );
}

$.extend( $.effects, {
	version: "1.12.1",

	define: function( name, mode, effect ) {
		if ( !effect ) {
			effect = mode;
			mode = "effect";
		}

		$.effects.effect[ name ] = effect;
		$.effects.effect[ name ].mode = mode;

		return effect;
	},

	scaledDimensions: function( element, percent, direction ) {
		if ( percent === 0 ) {
			return {
				height: 0,
				width: 0,
				outerHeight: 0,
				outerWidth: 0
			};
		}

		var x = direction !== "horizontal" ? ( ( percent || 100 ) / 100 ) : 1,
			y = direction !== "vertical" ? ( ( percent || 100 ) / 100 ) : 1;

		return {
			height: element.height() * y,
			width: element.width() * x,
			outerHeight: element.outerHeight() * y,
			outerWidth: element.outerWidth() * x
		};

	},

	clipToBox: function( animation ) {
		return {
			width: animation.clip.right - animation.clip.left,
			height: animation.clip.bottom - animation.clip.top,
			left: animation.clip.left,
			top: animation.clip.top
		};
	},

	// Injects recently queued functions to be first in line (after "inprogress")
	unshift: function( element, queueLength, count ) {
		var queue = element.queue();

		if ( queueLength > 1 ) {
			queue.splice.apply( queue,
				[ 1, 0 ].concat( queue.splice( queueLength, count ) ) );
		}
		element.dequeue();
	},

	saveStyle: function( element ) {
		element.data( dataSpaceStyle, element[ 0 ].style.cssText );
	},

	restoreStyle: function( element ) {
		element[ 0 ].style.cssText = element.data( dataSpaceStyle ) || "";
		element.removeData( dataSpaceStyle );
	},

	mode: function( element, mode ) {
		var hidden = element.is( ":hidden" );

		if ( mode === "toggle" ) {
			mode = hidden ? "show" : "hide";
		}
		if ( hidden ? mode === "hide" : mode === "show" ) {
			mode = "none";
		}
		return mode;
	},

	// Translates a [top,left] array into a baseline value
	getBaseline: function( origin, original ) {
		var y, x;

		switch ( origin[ 0 ] ) {
		case "top":
			y = 0;
			break;
		case "middle":
			y = 0.5;
			break;
		case "bottom":
			y = 1;
			break;
		default:
			y = origin[ 0 ] / original.height;
		}

		switch ( origin[ 1 ] ) {
		case "left":
			x = 0;
			break;
		case "center":
			x = 0.5;
			break;
		case "right":
			x = 1;
			break;
		default:
			x = origin[ 1 ] / original.width;
		}

		return {
			x: x,
			y: y
		};
	},

	// Creates a placeholder element so that the original element can be made absolute
	createPlaceholder: function( element ) {
		var placeholder,
			cssPosition = element.css( "position" ),
			position = element.position();

		// Lock in margins first to account for form elements, which
		// will change margin if you explicitly set height
		// see: http://jsfiddle.net/JZSMt/3/ https://bugs.webkit.org/show_bug.cgi?id=107380
		// Support: Safari
		element.css( {
			marginTop: element.css( "marginTop" ),
			marginBottom: element.css( "marginBottom" ),
			marginLeft: element.css( "marginLeft" ),
			marginRight: element.css( "marginRight" )
		} )
		.outerWidth( element.outerWidth() )
		.outerHeight( element.outerHeight() );

		if ( /^(static|relative)/.test( cssPosition ) ) {
			cssPosition = "absolute";

			placeholder = $( "<" + element[ 0 ].nodeName + ">" ).insertAfter( element ).css( {

				// Convert inline to inline block to account for inline elements
				// that turn to inline block based on content (like img)
				display: /^(inline|ruby)/.test( element.css( "display" ) ) ?
					"inline-block" :
					"block",
				visibility: "hidden",

				// Margins need to be set to account for margin collapse
				marginTop: element.css( "marginTop" ),
				marginBottom: element.css( "marginBottom" ),
				marginLeft: element.css( "marginLeft" ),
				marginRight: element.css( "marginRight" ),
				"float": element.css( "float" )
			} )
			.outerWidth( element.outerWidth() )
			.outerHeight( element.outerHeight() )
			.addClass( "ui-effects-placeholder" );

			element.data( dataSpace + "placeholder", placeholder );
		}

		element.css( {
			position: cssPosition,
			left: position.left,
			top: position.top
		} );

		return placeholder;
	},

	removePlaceholder: function( element ) {
		var dataKey = dataSpace + "placeholder",
				placeholder = element.data( dataKey );

		if ( placeholder ) {
			placeholder.remove();
			element.removeData( dataKey );
		}
	},

	// Removes a placeholder if it exists and restores
	// properties that were modified during placeholder creation
	cleanUp: function( element ) {
		$.effects.restoreStyle( element );
		$.effects.removePlaceholder( element );
	},

	setTransition: function( element, list, factor, value ) {
		value = value || {};
		$.each( list, function( i, x ) {
			var unit = element.cssUnit( x );
			if ( unit[ 0 ] > 0 ) {
				value[ x ] = unit[ 0 ] * factor + unit[ 1 ];
			}
		} );
		return value;
	}
} );

// Return an effect options object for the given parameters:
function _normalizeArguments( effect, options, speed, callback ) {

	// Allow passing all options as the first parameter
	if ( $.isPlainObject( effect ) ) {
		options = effect;
		effect = effect.effect;
	}

	// Convert to an object
	effect = { effect: effect };

	// Catch (effect, null, ...)
	if ( options == null ) {
		options = {};
	}

	// Catch (effect, callback)
	if ( $.isFunction( options ) ) {
		callback = options;
		speed = null;
		options = {};
	}

	// Catch (effect, speed, ?)
	if ( typeof options === "number" || $.fx.speeds[ options ] ) {
		callback = speed;
		speed = options;
		options = {};
	}

	// Catch (effect, options, callback)
	if ( $.isFunction( speed ) ) {
		callback = speed;
		speed = null;
	}

	// Add options to effect
	if ( options ) {
		$.extend( effect, options );
	}

	speed = speed || options.duration;
	effect.duration = $.fx.off ? 0 :
		typeof speed === "number" ? speed :
		speed in $.fx.speeds ? $.fx.speeds[ speed ] :
		$.fx.speeds._default;

	effect.complete = callback || options.complete;

	return effect;
}

function standardAnimationOption( option ) {

	// Valid standard speeds (nothing, number, named speed)
	if ( !option || typeof option === "number" || $.fx.speeds[ option ] ) {
		return true;
	}

	// Invalid strings - treat as "normal" speed
	if ( typeof option === "string" && !$.effects.effect[ option ] ) {
		return true;
	}

	// Complete callback
	if ( $.isFunction( option ) ) {
		return true;
	}

	// Options hash (but not naming an effect)
	if ( typeof option === "object" && !option.effect ) {
		return true;
	}

	// Didn't match any standard API
	return false;
}

$.fn.extend( {
	effect: function( /* effect, options, speed, callback */ ) {
		var args = _normalizeArguments.apply( this, arguments ),
			effectMethod = $.effects.effect[ args.effect ],
			defaultMode = effectMethod.mode,
			queue = args.queue,
			queueName = queue || "fx",
			complete = args.complete,
			mode = args.mode,
			modes = [],
			prefilter = function( next ) {
				var el = $( this ),
					normalizedMode = $.effects.mode( el, mode ) || defaultMode;

				// Sentinel for duck-punching the :animated psuedo-selector
				el.data( dataSpaceAnimated, true );

				// Save effect mode for later use,
				// we can't just call $.effects.mode again later,
				// as the .show() below destroys the initial state
				modes.push( normalizedMode );

				// See $.uiBackCompat inside of run() for removal of defaultMode in 1.13
				if ( defaultMode && ( normalizedMode === "show" ||
						( normalizedMode === defaultMode && normalizedMode === "hide" ) ) ) {
					el.show();
				}

				if ( !defaultMode || normalizedMode !== "none" ) {
					$.effects.saveStyle( el );
				}

				if ( $.isFunction( next ) ) {
					next();
				}
			};

		if ( $.fx.off || !effectMethod ) {

			// Delegate to the original method (e.g., .show()) if possible
			if ( mode ) {
				return this[ mode ]( args.duration, complete );
			} else {
				return this.each( function() {
					if ( complete ) {
						complete.call( this );
					}
				} );
			}
		}

		function run( next ) {
			var elem = $( this );

			function cleanup() {
				elem.removeData( dataSpaceAnimated );

				$.effects.cleanUp( elem );

				if ( args.mode === "hide" ) {
					elem.hide();
				}

				done();
			}

			function done() {
				if ( $.isFunction( complete ) ) {
					complete.call( elem[ 0 ] );
				}

				if ( $.isFunction( next ) ) {
					next();
				}
			}

			// Override mode option on a per element basis,
			// as toggle can be either show or hide depending on element state
			args.mode = modes.shift();

			if ( $.uiBackCompat !== false && !defaultMode ) {
				if ( elem.is( ":hidden" ) ? mode === "hide" : mode === "show" ) {

					// Call the core method to track "olddisplay" properly
					elem[ mode ]();
					done();
				} else {
					effectMethod.call( elem[ 0 ], args, done );
				}
			} else {
				if ( args.mode === "none" ) {

					// Call the core method to track "olddisplay" properly
					elem[ mode ]();
					done();
				} else {
					effectMethod.call( elem[ 0 ], args, cleanup );
				}
			}
		}

		// Run prefilter on all elements first to ensure that
		// any showing or hiding happens before placeholder creation,
		// which ensures that any layout changes are correctly captured.
		return queue === false ?
			this.each( prefilter ).each( run ) :
			this.queue( queueName, prefilter ).queue( queueName, run );
	},

	show: ( function( orig ) {
		return function( option ) {
			if ( standardAnimationOption( option ) ) {
				return orig.apply( this, arguments );
			} else {
				var args = _normalizeArguments.apply( this, arguments );
				args.mode = "show";
				return this.effect.call( this, args );
			}
		};
	} )( $.fn.show ),

	hide: ( function( orig ) {
		return function( option ) {
			if ( standardAnimationOption( option ) ) {
				return orig.apply( this, arguments );
			} else {
				var args = _normalizeArguments.apply( this, arguments );
				args.mode = "hide";
				return this.effect.call( this, args );
			}
		};
	} )( $.fn.hide ),

	toggle: ( function( orig ) {
		return function( option ) {
			if ( standardAnimationOption( option ) || typeof option === "boolean" ) {
				return orig.apply( this, arguments );
			} else {
				var args = _normalizeArguments.apply( this, arguments );
				args.mode = "toggle";
				return this.effect.call( this, args );
			}
		};
	} )( $.fn.toggle ),

	cssUnit: function( key ) {
		var style = this.css( key ),
			val = [];

		$.each( [ "em", "px", "%", "pt" ], function( i, unit ) {
			if ( style.indexOf( unit ) > 0 ) {
				val = [ parseFloat( style ), unit ];
			}
		} );
		return val;
	},

	cssClip: function( clipObj ) {
		if ( clipObj ) {
			return this.css( "clip", "rect(" + clipObj.top + "px " + clipObj.right + "px " +
				clipObj.bottom + "px " + clipObj.left + "px)" );
		}
		return parseClip( this.css( "clip" ), this );
	},

	transfer: function( options, done ) {
		var element = $( this ),
			target = $( options.to ),
			targetFixed = target.css( "position" ) === "fixed",
			body = $( "body" ),
			fixTop = targetFixed ? body.scrollTop() : 0,
			fixLeft = targetFixed ? body.scrollLeft() : 0,
			endPosition = target.offset(),
			animation = {
				top: endPosition.top - fixTop,
				left: endPosition.left - fixLeft,
				height: target.innerHeight(),
				width: target.innerWidth()
			},
			startPosition = element.offset(),
			transfer = $( "<div class='ui-effects-transfer'></div>" )
				.appendTo( "body" )
				.addClass( options.className )
				.css( {
					top: startPosition.top - fixTop,
					left: startPosition.left - fixLeft,
					height: element.innerHeight(),
					width: element.innerWidth(),
					position: targetFixed ? "fixed" : "absolute"
				} )
				.animate( animation, options.duration, options.easing, function() {
					transfer.remove();
					if ( $.isFunction( done ) ) {
						done();
					}
				} );
	}
} );

function parseClip( str, element ) {
		var outerWidth = element.outerWidth(),
			outerHeight = element.outerHeight(),
			clipRegex = /^rect\((-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto),?\s*(-?\d*\.?\d*px|-?\d+%|auto)\)$/,
			values = clipRegex.exec( str ) || [ "", 0, outerWidth, outerHeight, 0 ];

		return {
			top: parseFloat( values[ 1 ] ) || 0,
			right: values[ 2 ] === "auto" ? outerWidth : parseFloat( values[ 2 ] ),
			bottom: values[ 3 ] === "auto" ? outerHeight : parseFloat( values[ 3 ] ),
			left: parseFloat( values[ 4 ] ) || 0
		};
}

$.fx.step.clip = function( fx ) {
	if ( !fx.clipInit ) {
		fx.start = $( fx.elem ).cssClip();
		if ( typeof fx.end === "string" ) {
			fx.end = parseClip( fx.end, fx.elem );
		}
		fx.clipInit = true;
	}

	$( fx.elem ).cssClip( {
		top: fx.pos * ( fx.end.top - fx.start.top ) + fx.start.top,
		right: fx.pos * ( fx.end.right - fx.start.right ) + fx.start.right,
		bottom: fx.pos * ( fx.end.bottom - fx.start.bottom ) + fx.start.bottom,
		left: fx.pos * ( fx.end.left - fx.start.left ) + fx.start.left
	} );
};

} )();

/******************************************************************************/
/*********************************** EASING ***********************************/
/******************************************************************************/

( function() {

// Based on easing equations from Robert Penner (http://www.robertpenner.com/easing)

var baseEasings = {};

$.each( [ "Quad", "Cubic", "Quart", "Quint", "Expo" ], function( i, name ) {
	baseEasings[ name ] = function( p ) {
		return Math.pow( p, i + 2 );
	};
} );

$.extend( baseEasings, {
	Sine: function( p ) {
		return 1 - Math.cos( p * Math.PI / 2 );
	},
	Circ: function( p ) {
		return 1 - Math.sqrt( 1 - p * p );
	},
	Elastic: function( p ) {
		return p === 0 || p === 1 ? p :
			-Math.pow( 2, 8 * ( p - 1 ) ) * Math.sin( ( ( p - 1 ) * 80 - 7.5 ) * Math.PI / 15 );
	},
	Back: function( p ) {
		return p * p * ( 3 * p - 2 );
	},
	Bounce: function( p ) {
		var pow2,
			bounce = 4;

		while ( p < ( ( pow2 = Math.pow( 2, --bounce ) ) - 1 ) / 11 ) {}
		return 1 / Math.pow( 4, 3 - bounce ) - 7.5625 * Math.pow( ( pow2 * 3 - 2 ) / 22 - p, 2 );
	}
} );

$.each( baseEasings, function( name, easeIn ) {
	$.easing[ "easeIn" + name ] = easeIn;
	$.easing[ "easeOut" + name ] = function( p ) {
		return 1 - easeIn( 1 - p );
	};
	$.easing[ "easeInOut" + name ] = function( p ) {
		return p < 0.5 ?
			easeIn( p * 2 ) / 2 :
			1 - easeIn( p * -2 + 2 ) / 2;
	};
} );

} )();

var effect = $.effects;


/*!
 * jQuery UI Effects Blind 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Blind Effect
//>>group: Effects
//>>description: Blinds the element.
//>>docs: http://api.jqueryui.com/blind-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectBlind = $.effects.define( "blind", "hide", function( options, done ) {
	var map = {
			up: [ "bottom", "top" ],
			vertical: [ "bottom", "top" ],
			down: [ "top", "bottom" ],
			left: [ "right", "left" ],
			horizontal: [ "right", "left" ],
			right: [ "left", "right" ]
		},
		element = $( this ),
		direction = options.direction || "up",
		start = element.cssClip(),
		animate = { clip: $.extend( {}, start ) },
		placeholder = $.effects.createPlaceholder( element );

	animate.clip[ map[ direction ][ 0 ] ] = animate.clip[ map[ direction ][ 1 ] ];

	if ( options.mode === "show" ) {
		element.cssClip( animate.clip );
		if ( placeholder ) {
			placeholder.css( $.effects.clipToBox( animate ) );
		}

		animate.clip = start;
	}

	if ( placeholder ) {
		placeholder.animate( $.effects.clipToBox( animate ), options.duration, options.easing );
	}

	element.animate( animate, {
		queue: false,
		duration: options.duration,
		easing: options.easing,
		complete: done
	} );
} );


/*!
 * jQuery UI Effects Bounce 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Bounce Effect
//>>group: Effects
//>>description: Bounces an element horizontally or vertically n times.
//>>docs: http://api.jqueryui.com/bounce-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectBounce = $.effects.define( "bounce", function( options, done ) {
	var upAnim, downAnim, refValue,
		element = $( this ),

		// Defaults:
		mode = options.mode,
		hide = mode === "hide",
		show = mode === "show",
		direction = options.direction || "up",
		distance = options.distance,
		times = options.times || 5,

		// Number of internal animations
		anims = times * 2 + ( show || hide ? 1 : 0 ),
		speed = options.duration / anims,
		easing = options.easing,

		// Utility:
		ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
		motion = ( direction === "up" || direction === "left" ),
		i = 0,

		queuelen = element.queue().length;

	$.effects.createPlaceholder( element );

	refValue = element.css( ref );

	// Default distance for the BIGGEST bounce is the outer Distance / 3
	if ( !distance ) {
		distance = element[ ref === "top" ? "outerHeight" : "outerWidth" ]() / 3;
	}

	if ( show ) {
		downAnim = { opacity: 1 };
		downAnim[ ref ] = refValue;

		// If we are showing, force opacity 0 and set the initial position
		// then do the "first" animation
		element
			.css( "opacity", 0 )
			.css( ref, motion ? -distance * 2 : distance * 2 )
			.animate( downAnim, speed, easing );
	}

	// Start at the smallest distance if we are hiding
	if ( hide ) {
		distance = distance / Math.pow( 2, times - 1 );
	}

	downAnim = {};
	downAnim[ ref ] = refValue;

	// Bounces up/down/left/right then back to 0 -- times * 2 animations happen here
	for ( ; i < times; i++ ) {
		upAnim = {};
		upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;

		element
			.animate( upAnim, speed, easing )
			.animate( downAnim, speed, easing );

		distance = hide ? distance * 2 : distance / 2;
	}

	// Last Bounce when Hiding
	if ( hide ) {
		upAnim = { opacity: 0 };
		upAnim[ ref ] = ( motion ? "-=" : "+=" ) + distance;

		element.animate( upAnim, speed, easing );
	}

	element.queue( done );

	$.effects.unshift( element, queuelen, anims + 1 );
} );


/*!
 * jQuery UI Effects Clip 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Clip Effect
//>>group: Effects
//>>description: Clips the element on and off like an old TV.
//>>docs: http://api.jqueryui.com/clip-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectClip = $.effects.define( "clip", "hide", function( options, done ) {
	var start,
		animate = {},
		element = $( this ),
		direction = options.direction || "vertical",
		both = direction === "both",
		horizontal = both || direction === "horizontal",
		vertical = both || direction === "vertical";

	start = element.cssClip();
	animate.clip = {
		top: vertical ? ( start.bottom - start.top ) / 2 : start.top,
		right: horizontal ? ( start.right - start.left ) / 2 : start.right,
		bottom: vertical ? ( start.bottom - start.top ) / 2 : start.bottom,
		left: horizontal ? ( start.right - start.left ) / 2 : start.left
	};

	$.effects.createPlaceholder( element );

	if ( options.mode === "show" ) {
		element.cssClip( animate.clip );
		animate.clip = start;
	}

	element.animate( animate, {
		queue: false,
		duration: options.duration,
		easing: options.easing,
		complete: done
	} );

} );


/*!
 * jQuery UI Effects Drop 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Drop Effect
//>>group: Effects
//>>description: Moves an element in one direction and hides it at the same time.
//>>docs: http://api.jqueryui.com/drop-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectDrop = $.effects.define( "drop", "hide", function( options, done ) {

	var distance,
		element = $( this ),
		mode = options.mode,
		show = mode === "show",
		direction = options.direction || "left",
		ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
		motion = ( direction === "up" || direction === "left" ) ? "-=" : "+=",
		oppositeMotion = ( motion === "+=" ) ? "-=" : "+=",
		animation = {
			opacity: 0
		};

	$.effects.createPlaceholder( element );

	distance = options.distance ||
		element[ ref === "top" ? "outerHeight" : "outerWidth" ]( true ) / 2;

	animation[ ref ] = motion + distance;

	if ( show ) {
		element.css( animation );

		animation[ ref ] = oppositeMotion + distance;
		animation.opacity = 1;
	}

	// Animate
	element.animate( animation, {
		queue: false,
		duration: options.duration,
		easing: options.easing,
		complete: done
	} );
} );


/*!
 * jQuery UI Effects Explode 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Explode Effect
//>>group: Effects
// jscs:disable maximumLineLength
//>>description: Explodes an element in all directions into n pieces. Implodes an element to its original wholeness.
// jscs:enable maximumLineLength
//>>docs: http://api.jqueryui.com/explode-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectExplode = $.effects.define( "explode", "hide", function( options, done ) {

	var i, j, left, top, mx, my,
		rows = options.pieces ? Math.round( Math.sqrt( options.pieces ) ) : 3,
		cells = rows,
		element = $( this ),
		mode = options.mode,
		show = mode === "show",

		// Show and then visibility:hidden the element before calculating offset
		offset = element.show().css( "visibility", "hidden" ).offset(),

		// Width and height of a piece
		width = Math.ceil( element.outerWidth() / cells ),
		height = Math.ceil( element.outerHeight() / rows ),
		pieces = [];

	// Children animate complete:
	function childComplete() {
		pieces.push( this );
		if ( pieces.length === rows * cells ) {
			animComplete();
		}
	}

	// Clone the element for each row and cell.
	for ( i = 0; i < rows; i++ ) { // ===>
		top = offset.top + i * height;
		my = i - ( rows - 1 ) / 2;

		for ( j = 0; j < cells; j++ ) { // |||
			left = offset.left + j * width;
			mx = j - ( cells - 1 ) / 2;

			// Create a clone of the now hidden main element that will be absolute positioned
			// within a wrapper div off the -left and -top equal to size of our pieces
			element
				.clone()
				.appendTo( "body" )
				.wrap( "<div></div>" )
				.css( {
					position: "absolute",
					visibility: "visible",
					left: -j * width,
					top: -i * height
				} )

				// Select the wrapper - make it overflow: hidden and absolute positioned based on
				// where the original was located +left and +top equal to the size of pieces
				.parent()
					.addClass( "ui-effects-explode" )
					.css( {
						position: "absolute",
						overflow: "hidden",
						width: width,
						height: height,
						left: left + ( show ? mx * width : 0 ),
						top: top + ( show ? my * height : 0 ),
						opacity: show ? 0 : 1
					} )
					.animate( {
						left: left + ( show ? 0 : mx * width ),
						top: top + ( show ? 0 : my * height ),
						opacity: show ? 1 : 0
					}, options.duration || 500, options.easing, childComplete );
		}
	}

	function animComplete() {
		element.css( {
			visibility: "visible"
		} );
		$( pieces ).remove();
		done();
	}
} );


/*!
 * jQuery UI Effects Fade 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Fade Effect
//>>group: Effects
//>>description: Fades the element.
//>>docs: http://api.jqueryui.com/fade-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectFade = $.effects.define( "fade", "toggle", function( options, done ) {
	var show = options.mode === "show";

	$( this )
		.css( "opacity", show ? 0 : 1 )
		.animate( {
			opacity: show ? 1 : 0
		}, {
			queue: false,
			duration: options.duration,
			easing: options.easing,
			complete: done
		} );
} );


/*!
 * jQuery UI Effects Fold 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Fold Effect
//>>group: Effects
//>>description: Folds an element first horizontally and then vertically.
//>>docs: http://api.jqueryui.com/fold-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectFold = $.effects.define( "fold", "hide", function( options, done ) {

	// Create element
	var element = $( this ),
		mode = options.mode,
		show = mode === "show",
		hide = mode === "hide",
		size = options.size || 15,
		percent = /([0-9]+)%/.exec( size ),
		horizFirst = !!options.horizFirst,
		ref = horizFirst ? [ "right", "bottom" ] : [ "bottom", "right" ],
		duration = options.duration / 2,

		placeholder = $.effects.createPlaceholder( element ),

		start = element.cssClip(),
		animation1 = { clip: $.extend( {}, start ) },
		animation2 = { clip: $.extend( {}, start ) },

		distance = [ start[ ref[ 0 ] ], start[ ref[ 1 ] ] ],

		queuelen = element.queue().length;

	if ( percent ) {
		size = parseInt( percent[ 1 ], 10 ) / 100 * distance[ hide ? 0 : 1 ];
	}
	animation1.clip[ ref[ 0 ] ] = size;
	animation2.clip[ ref[ 0 ] ] = size;
	animation2.clip[ ref[ 1 ] ] = 0;

	if ( show ) {
		element.cssClip( animation2.clip );
		if ( placeholder ) {
			placeholder.css( $.effects.clipToBox( animation2 ) );
		}

		animation2.clip = start;
	}

	// Animate
	element
		.queue( function( next ) {
			if ( placeholder ) {
				placeholder
					.animate( $.effects.clipToBox( animation1 ), duration, options.easing )
					.animate( $.effects.clipToBox( animation2 ), duration, options.easing );
			}

			next();
		} )
		.animate( animation1, duration, options.easing )
		.animate( animation2, duration, options.easing )
		.queue( done );

	$.effects.unshift( element, queuelen, 4 );
} );


/*!
 * jQuery UI Effects Highlight 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Highlight Effect
//>>group: Effects
//>>description: Highlights the background of an element in a defined color for a custom duration.
//>>docs: http://api.jqueryui.com/highlight-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectHighlight = $.effects.define( "highlight", "show", function( options, done ) {
	var element = $( this ),
		animation = {
			backgroundColor: element.css( "backgroundColor" )
		};

	if ( options.mode === "hide" ) {
		animation.opacity = 0;
	}

	$.effects.saveStyle( element );

	element
		.css( {
			backgroundImage: "none",
			backgroundColor: options.color || "#ffff99"
		} )
		.animate( animation, {
			queue: false,
			duration: options.duration,
			easing: options.easing,
			complete: done
		} );
} );


/*!
 * jQuery UI Effects Size 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Size Effect
//>>group: Effects
//>>description: Resize an element to a specified width and height.
//>>docs: http://api.jqueryui.com/size-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectSize = $.effects.define( "size", function( options, done ) {

	// Create element
	var baseline, factor, temp,
		element = $( this ),

		// Copy for children
		cProps = [ "fontSize" ],
		vProps = [ "borderTopWidth", "borderBottomWidth", "paddingTop", "paddingBottom" ],
		hProps = [ "borderLeftWidth", "borderRightWidth", "paddingLeft", "paddingRight" ],

		// Set options
		mode = options.mode,
		restore = mode !== "effect",
		scale = options.scale || "both",
		origin = options.origin || [ "middle", "center" ],
		position = element.css( "position" ),
		pos = element.position(),
		original = $.effects.scaledDimensions( element ),
		from = options.from || original,
		to = options.to || $.effects.scaledDimensions( element, 0 );

	$.effects.createPlaceholder( element );

	if ( mode === "show" ) {
		temp = from;
		from = to;
		to = temp;
	}

	// Set scaling factor
	factor = {
		from: {
			y: from.height / original.height,
			x: from.width / original.width
		},
		to: {
			y: to.height / original.height,
			x: to.width / original.width
		}
	};

	// Scale the css box
	if ( scale === "box" || scale === "both" ) {

		// Vertical props scaling
		if ( factor.from.y !== factor.to.y ) {
			from = $.effects.setTransition( element, vProps, factor.from.y, from );
			to = $.effects.setTransition( element, vProps, factor.to.y, to );
		}

		// Horizontal props scaling
		if ( factor.from.x !== factor.to.x ) {
			from = $.effects.setTransition( element, hProps, factor.from.x, from );
			to = $.effects.setTransition( element, hProps, factor.to.x, to );
		}
	}

	// Scale the content
	if ( scale === "content" || scale === "both" ) {

		// Vertical props scaling
		if ( factor.from.y !== factor.to.y ) {
			from = $.effects.setTransition( element, cProps, factor.from.y, from );
			to = $.effects.setTransition( element, cProps, factor.to.y, to );
		}
	}

	// Adjust the position properties based on the provided origin points
	if ( origin ) {
		baseline = $.effects.getBaseline( origin, original );
		from.top = ( original.outerHeight - from.outerHeight ) * baseline.y + pos.top;
		from.left = ( original.outerWidth - from.outerWidth ) * baseline.x + pos.left;
		to.top = ( original.outerHeight - to.outerHeight ) * baseline.y + pos.top;
		to.left = ( original.outerWidth - to.outerWidth ) * baseline.x + pos.left;
	}
	element.css( from );

	// Animate the children if desired
	if ( scale === "content" || scale === "both" ) {

		vProps = vProps.concat( [ "marginTop", "marginBottom" ] ).concat( cProps );
		hProps = hProps.concat( [ "marginLeft", "marginRight" ] );

		// Only animate children with width attributes specified
		// TODO: is this right? should we include anything with css width specified as well
		element.find( "*[width]" ).each( function() {
			var child = $( this ),
				childOriginal = $.effects.scaledDimensions( child ),
				childFrom = {
					height: childOriginal.height * factor.from.y,
					width: childOriginal.width * factor.from.x,
					outerHeight: childOriginal.outerHeight * factor.from.y,
					outerWidth: childOriginal.outerWidth * factor.from.x
				},
				childTo = {
					height: childOriginal.height * factor.to.y,
					width: childOriginal.width * factor.to.x,
					outerHeight: childOriginal.height * factor.to.y,
					outerWidth: childOriginal.width * factor.to.x
				};

			// Vertical props scaling
			if ( factor.from.y !== factor.to.y ) {
				childFrom = $.effects.setTransition( child, vProps, factor.from.y, childFrom );
				childTo = $.effects.setTransition( child, vProps, factor.to.y, childTo );
			}

			// Horizontal props scaling
			if ( factor.from.x !== factor.to.x ) {
				childFrom = $.effects.setTransition( child, hProps, factor.from.x, childFrom );
				childTo = $.effects.setTransition( child, hProps, factor.to.x, childTo );
			}

			if ( restore ) {
				$.effects.saveStyle( child );
			}

			// Animate children
			child.css( childFrom );
			child.animate( childTo, options.duration, options.easing, function() {

				// Restore children
				if ( restore ) {
					$.effects.restoreStyle( child );
				}
			} );
		} );
	}

	// Animate
	element.animate( to, {
		queue: false,
		duration: options.duration,
		easing: options.easing,
		complete: function() {

			var offset = element.offset();

			if ( to.opacity === 0 ) {
				element.css( "opacity", from.opacity );
			}

			if ( !restore ) {
				element
					.css( "position", position === "static" ? "relative" : position )
					.offset( offset );

				// Need to save style here so that automatic style restoration
				// doesn't restore to the original styles from before the animation.
				$.effects.saveStyle( element );
			}

			done();
		}
	} );

} );


/*!
 * jQuery UI Effects Scale 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Scale Effect
//>>group: Effects
//>>description: Grows or shrinks an element and its content.
//>>docs: http://api.jqueryui.com/scale-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectScale = $.effects.define( "scale", function( options, done ) {

	// Create element
	var el = $( this ),
		mode = options.mode,
		percent = parseInt( options.percent, 10 ) ||
			( parseInt( options.percent, 10 ) === 0 ? 0 : ( mode !== "effect" ? 0 : 100 ) ),

		newOptions = $.extend( true, {
			from: $.effects.scaledDimensions( el ),
			to: $.effects.scaledDimensions( el, percent, options.direction || "both" ),
			origin: options.origin || [ "middle", "center" ]
		}, options );

	// Fade option to support puff
	if ( options.fade ) {
		newOptions.from.opacity = 1;
		newOptions.to.opacity = 0;
	}

	$.effects.effect.size.call( this, newOptions, done );
} );


/*!
 * jQuery UI Effects Puff 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Puff Effect
//>>group: Effects
//>>description: Creates a puff effect by scaling the element up and hiding it at the same time.
//>>docs: http://api.jqueryui.com/puff-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectPuff = $.effects.define( "puff", "hide", function( options, done ) {
	var newOptions = $.extend( true, {}, options, {
		fade: true,
		percent: parseInt( options.percent, 10 ) || 150
	} );

	$.effects.effect.scale.call( this, newOptions, done );
} );


/*!
 * jQuery UI Effects Pulsate 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Pulsate Effect
//>>group: Effects
//>>description: Pulsates an element n times by changing the opacity to zero and back.
//>>docs: http://api.jqueryui.com/pulsate-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectPulsate = $.effects.define( "pulsate", "show", function( options, done ) {
	var element = $( this ),
		mode = options.mode,
		show = mode === "show",
		hide = mode === "hide",
		showhide = show || hide,

		// Showing or hiding leaves off the "last" animation
		anims = ( ( options.times || 5 ) * 2 ) + ( showhide ? 1 : 0 ),
		duration = options.duration / anims,
		animateTo = 0,
		i = 1,
		queuelen = element.queue().length;

	if ( show || !element.is( ":visible" ) ) {
		element.css( "opacity", 0 ).show();
		animateTo = 1;
	}

	// Anims - 1 opacity "toggles"
	for ( ; i < anims; i++ ) {
		element.animate( { opacity: animateTo }, duration, options.easing );
		animateTo = 1 - animateTo;
	}

	element.animate( { opacity: animateTo }, duration, options.easing );

	element.queue( done );

	$.effects.unshift( element, queuelen, anims + 1 );
} );


/*!
 * jQuery UI Effects Shake 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Shake Effect
//>>group: Effects
//>>description: Shakes an element horizontally or vertically n times.
//>>docs: http://api.jqueryui.com/shake-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectShake = $.effects.define( "shake", function( options, done ) {

	var i = 1,
		element = $( this ),
		direction = options.direction || "left",
		distance = options.distance || 20,
		times = options.times || 3,
		anims = times * 2 + 1,
		speed = Math.round( options.duration / anims ),
		ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
		positiveMotion = ( direction === "up" || direction === "left" ),
		animation = {},
		animation1 = {},
		animation2 = {},

		queuelen = element.queue().length;

	$.effects.createPlaceholder( element );

	// Animation
	animation[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance;
	animation1[ ref ] = ( positiveMotion ? "+=" : "-=" ) + distance * 2;
	animation2[ ref ] = ( positiveMotion ? "-=" : "+=" ) + distance * 2;

	// Animate
	element.animate( animation, speed, options.easing );

	// Shakes
	for ( ; i < times; i++ ) {
		element
			.animate( animation1, speed, options.easing )
			.animate( animation2, speed, options.easing );
	}

	element
		.animate( animation1, speed, options.easing )
		.animate( animation, speed / 2, options.easing )
		.queue( done );

	$.effects.unshift( element, queuelen, anims + 1 );
} );


/*!
 * jQuery UI Effects Slide 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Slide Effect
//>>group: Effects
//>>description: Slides an element in and out of the viewport.
//>>docs: http://api.jqueryui.com/slide-effect/
//>>demos: http://jqueryui.com/effect/



var effectsEffectSlide = $.effects.define( "slide", "show", function( options, done ) {
	var startClip, startRef,
		element = $( this ),
		map = {
			up: [ "bottom", "top" ],
			down: [ "top", "bottom" ],
			left: [ "right", "left" ],
			right: [ "left", "right" ]
		},
		mode = options.mode,
		direction = options.direction || "left",
		ref = ( direction === "up" || direction === "down" ) ? "top" : "left",
		positiveMotion = ( direction === "up" || direction === "left" ),
		distance = options.distance ||
			element[ ref === "top" ? "outerHeight" : "outerWidth" ]( true ),
		animation = {};

	$.effects.createPlaceholder( element );

	startClip = element.cssClip();
	startRef = element.position()[ ref ];

	// Define hide animation
	animation[ ref ] = ( positiveMotion ? -1 : 1 ) * distance + startRef;
	animation.clip = element.cssClip();
	animation.clip[ map[ direction ][ 1 ] ] = animation.clip[ map[ direction ][ 0 ] ];

	// Reverse the animation if we're showing
	if ( mode === "show" ) {
		element.cssClip( animation.clip );
		element.css( ref, animation[ ref ] );
		animation.clip = startClip;
		animation[ ref ] = startRef;
	}

	// Actually animate
	element.animate( animation, {
		queue: false,
		duration: options.duration,
		easing: options.easing,
		complete: done
	} );
} );


/*!
 * jQuery UI Effects Transfer 1.12.1
 * http://jqueryui.com
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 */

//>>label: Transfer Effect
//>>group: Effects
//>>description: Displays a transfer effect from one element to another.
//>>docs: http://api.jqueryui.com/transfer-effect/
//>>demos: http://jqueryui.com/effect/



var effect;
if ( $.uiBackCompat !== false ) {
	effect = $.effects.define( "transfer", function( options, done ) {
		$( this ).transfer( options, done );
	} );
}
var effectsEffectTransfer = effect;




}));
},{}],"kDs4":[function(require,module,exports) {
/* ========================================================================
 * Bootstrap: transition.js v3.4.1
 * https://getbootstrap.com/docs/3.4/javascript/#transitions
 * ========================================================================
 * Copyright 2011-2019 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict'; // CSS TRANSITION SUPPORT (Shoutout: https://modernizr.com/)
  // ============================================================

  function transitionEnd() {
    var el = document.createElement('bootstrap');
    var transEndEventNames = {
      WebkitTransition: 'webkitTransitionEnd',
      MozTransition: 'transitionend',
      OTransition: 'oTransitionEnd otransitionend',
      transition: 'transitionend'
    };

    for (var name in transEndEventNames) {
      if (el.style[name] !== undefined) {
        return {
          end: transEndEventNames[name]
        };
      }
    }

    return false; // explicit for ie8 (  ._.)
  } // https://blog.alexmaccaw.com/css-transitions


  $.fn.emulateTransitionEnd = function (duration) {
    var called = false;
    var $el = this;
    $(this).one('bsTransitionEnd', function () {
      called = true;
    });

    var callback = function () {
      if (!called) $($el).trigger($.support.transition.end);
    };

    setTimeout(callback, duration);
    return this;
  };

  $(function () {
    $.support.transition = transitionEnd();
    if (!$.support.transition) return;
    $.event.special.bsTransitionEnd = {
      bindType: $.support.transition.end,
      delegateType: $.support.transition.end,
      handle: function (e) {
        if ($(e.target).is(this)) return e.handleObj.handler.apply(this, arguments);
      }
    };
  });
}(jQuery);
},{}],"UId9":[function(require,module,exports) {
/* ========================================================================
 * Bootstrap: alert.js v3.4.1
 * https://getbootstrap.com/docs/3.4/javascript/#alerts
 * ========================================================================
 * Copyright 2011-2019 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict'; // ALERT CLASS DEFINITION
  // ======================

  var dismiss = '[data-dismiss="alert"]';

  var Alert = function (el) {
    $(el).on('click', dismiss, this.close);
  };

  Alert.VERSION = '3.4.1';
  Alert.TRANSITION_DURATION = 150;

  Alert.prototype.close = function (e) {
    var $this = $(this);
    var selector = $this.attr('data-target');

    if (!selector) {
      selector = $this.attr('href');
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, ''); // strip for ie7
    }

    selector = selector === '#' ? [] : selector;
    var $parent = $(document).find(selector);
    if (e) e.preventDefault();

    if (!$parent.length) {
      $parent = $this.closest('.alert');
    }

    $parent.trigger(e = $.Event('close.bs.alert'));
    if (e.isDefaultPrevented()) return;
    $parent.removeClass('in');

    function removeElement() {
      // detach from parent, fire event then clean up data
      $parent.detach().trigger('closed.bs.alert').remove();
    }

    $.support.transition && $parent.hasClass('fade') ? $parent.one('bsTransitionEnd', removeElement).emulateTransitionEnd(Alert.TRANSITION_DURATION) : removeElement();
  }; // ALERT PLUGIN DEFINITION
  // =======================


  function Plugin(option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data('bs.alert');
      if (!data) $this.data('bs.alert', data = new Alert(this));
      if (typeof option == 'string') data[option].call($this);
    });
  }

  var old = $.fn.alert;
  $.fn.alert = Plugin;
  $.fn.alert.Constructor = Alert; // ALERT NO CONFLICT
  // =================

  $.fn.alert.noConflict = function () {
    $.fn.alert = old;
    return this;
  }; // ALERT DATA-API
  // ==============


  $(document).on('click.bs.alert.data-api', dismiss, Alert.prototype.close);
}(jQuery);
},{}],"kLSm":[function(require,module,exports) {
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* ========================================================================
 * Bootstrap: button.js v3.4.1
 * https://getbootstrap.com/docs/3.4/javascript/#buttons
 * ========================================================================
 * Copyright 2011-2019 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict'; // BUTTON PUBLIC CLASS DEFINITION
  // ==============================

  var Button = function (element, options) {
    this.$element = $(element);
    this.options = $.extend({}, Button.DEFAULTS, options);
    this.isLoading = false;
  };

  Button.VERSION = '3.4.1';
  Button.DEFAULTS = {
    loadingText: 'loading...'
  };

  Button.prototype.setState = function (state) {
    var d = 'disabled';
    var $el = this.$element;
    var val = $el.is('input') ? 'val' : 'html';
    var data = $el.data();
    state += 'Text';
    if (data.resetText == null) $el.data('resetText', $el[val]()); // push to event loop to allow forms to submit

    setTimeout($.proxy(function () {
      $el[val](data[state] == null ? this.options[state] : data[state]);

      if (state == 'loadingText') {
        this.isLoading = true;
        $el.addClass(d).attr(d, d).prop(d, true);
      } else if (this.isLoading) {
        this.isLoading = false;
        $el.removeClass(d).removeAttr(d).prop(d, false);
      }
    }, this), 0);
  };

  Button.prototype.toggle = function () {
    var changed = true;
    var $parent = this.$element.closest('[data-toggle="buttons"]');

    if ($parent.length) {
      var $input = this.$element.find('input');

      if ($input.prop('type') == 'radio') {
        if ($input.prop('checked')) changed = false;
        $parent.find('.active').removeClass('active');
        this.$element.addClass('active');
      } else if ($input.prop('type') == 'checkbox') {
        if ($input.prop('checked') !== this.$element.hasClass('active')) changed = false;
        this.$element.toggleClass('active');
      }

      $input.prop('checked', this.$element.hasClass('active'));
      if (changed) $input.trigger('change');
    } else {
      this.$element.attr('aria-pressed', !this.$element.hasClass('active'));
      this.$element.toggleClass('active');
    }
  }; // BUTTON PLUGIN DEFINITION
  // ========================


  function Plugin(option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data('bs.button');
      var options = _typeof(option) == 'object' && option;
      if (!data) $this.data('bs.button', data = new Button(this, options));
      if (option == 'toggle') data.toggle();else if (option) data.setState(option);
    });
  }

  var old = $.fn.button;
  $.fn.button = Plugin;
  $.fn.button.Constructor = Button; // BUTTON NO CONFLICT
  // ==================

  $.fn.button.noConflict = function () {
    $.fn.button = old;
    return this;
  }; // BUTTON DATA-API
  // ===============


  $(document).on('click.bs.button.data-api', '[data-toggle^="button"]', function (e) {
    var $btn = $(e.target).closest('.btn');
    Plugin.call($btn, 'toggle');

    if (!$(e.target).is('input[type="radio"], input[type="checkbox"]')) {
      // Prevent double click on radios, and the double selections (so cancellation) on checkboxes
      e.preventDefault(); // The target component still receive the focus

      if ($btn.is('input,button')) $btn.trigger('focus');else $btn.find('input:visible,button:visible').first().trigger('focus');
    }
  }).on('focus.bs.button.data-api blur.bs.button.data-api', '[data-toggle^="button"]', function (e) {
    $(e.target).closest('.btn').toggleClass('focus', /^focus(in)?$/.test(e.type));
  });
}(jQuery);
},{}],"H0Sg":[function(require,module,exports) {
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* ========================================================================
 * Bootstrap: carousel.js v3.4.1
 * https://getbootstrap.com/docs/3.4/javascript/#carousel
 * ========================================================================
 * Copyright 2011-2019 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict'; // CAROUSEL CLASS DEFINITION
  // =========================

  var Carousel = function (element, options) {
    this.$element = $(element);
    this.$indicators = this.$element.find('.carousel-indicators');
    this.options = options;
    this.paused = null;
    this.sliding = null;
    this.interval = null;
    this.$active = null;
    this.$items = null;
    this.options.keyboard && this.$element.on('keydown.bs.carousel', $.proxy(this.keydown, this));
    this.options.pause == 'hover' && !('ontouchstart' in document.documentElement) && this.$element.on('mouseenter.bs.carousel', $.proxy(this.pause, this)).on('mouseleave.bs.carousel', $.proxy(this.cycle, this));
  };

  Carousel.VERSION = '3.4.1';
  Carousel.TRANSITION_DURATION = 600;
  Carousel.DEFAULTS = {
    interval: 5000,
    pause: 'hover',
    wrap: true,
    keyboard: true
  };

  Carousel.prototype.keydown = function (e) {
    if (/input|textarea/i.test(e.target.tagName)) return;

    switch (e.which) {
      case 37:
        this.prev();
        break;

      case 39:
        this.next();
        break;

      default:
        return;
    }

    e.preventDefault();
  };

  Carousel.prototype.cycle = function (e) {
    e || (this.paused = false);
    this.interval && clearInterval(this.interval);
    this.options.interval && !this.paused && (this.interval = setInterval($.proxy(this.next, this), this.options.interval));
    return this;
  };

  Carousel.prototype.getItemIndex = function (item) {
    this.$items = item.parent().children('.item');
    return this.$items.index(item || this.$active);
  };

  Carousel.prototype.getItemForDirection = function (direction, active) {
    var activeIndex = this.getItemIndex(active);
    var willWrap = direction == 'prev' && activeIndex === 0 || direction == 'next' && activeIndex == this.$items.length - 1;
    if (willWrap && !this.options.wrap) return active;
    var delta = direction == 'prev' ? -1 : 1;
    var itemIndex = (activeIndex + delta) % this.$items.length;
    return this.$items.eq(itemIndex);
  };

  Carousel.prototype.to = function (pos) {
    var that = this;
    var activeIndex = this.getItemIndex(this.$active = this.$element.find('.item.active'));
    if (pos > this.$items.length - 1 || pos < 0) return;
    if (this.sliding) return this.$element.one('slid.bs.carousel', function () {
      that.to(pos);
    }); // yes, "slid"

    if (activeIndex == pos) return this.pause().cycle();
    return this.slide(pos > activeIndex ? 'next' : 'prev', this.$items.eq(pos));
  };

  Carousel.prototype.pause = function (e) {
    e || (this.paused = true);

    if (this.$element.find('.next, .prev').length && $.support.transition) {
      this.$element.trigger($.support.transition.end);
      this.cycle(true);
    }

    this.interval = clearInterval(this.interval);
    return this;
  };

  Carousel.prototype.next = function () {
    if (this.sliding) return;
    return this.slide('next');
  };

  Carousel.prototype.prev = function () {
    if (this.sliding) return;
    return this.slide('prev');
  };

  Carousel.prototype.slide = function (type, next) {
    var $active = this.$element.find('.item.active');
    var $next = next || this.getItemForDirection(type, $active);
    var isCycling = this.interval;
    var direction = type == 'next' ? 'left' : 'right';
    var that = this;
    if ($next.hasClass('active')) return this.sliding = false;
    var relatedTarget = $next[0];
    var slideEvent = $.Event('slide.bs.carousel', {
      relatedTarget: relatedTarget,
      direction: direction
    });
    this.$element.trigger(slideEvent);
    if (slideEvent.isDefaultPrevented()) return;
    this.sliding = true;
    isCycling && this.pause();

    if (this.$indicators.length) {
      this.$indicators.find('.active').removeClass('active');
      var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)]);
      $nextIndicator && $nextIndicator.addClass('active');
    }

    var slidEvent = $.Event('slid.bs.carousel', {
      relatedTarget: relatedTarget,
      direction: direction
    }); // yes, "slid"

    if ($.support.transition && this.$element.hasClass('slide')) {
      $next.addClass(type);

      if (_typeof($next) === 'object' && $next.length) {
        $next[0].offsetWidth; // force reflow
      }

      $active.addClass(direction);
      $next.addClass(direction);
      $active.one('bsTransitionEnd', function () {
        $next.removeClass([type, direction].join(' ')).addClass('active');
        $active.removeClass(['active', direction].join(' '));
        that.sliding = false;
        setTimeout(function () {
          that.$element.trigger(slidEvent);
        }, 0);
      }).emulateTransitionEnd(Carousel.TRANSITION_DURATION);
    } else {
      $active.removeClass('active');
      $next.addClass('active');
      this.sliding = false;
      this.$element.trigger(slidEvent);
    }

    isCycling && this.cycle();
    return this;
  }; // CAROUSEL PLUGIN DEFINITION
  // ==========================


  function Plugin(option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data('bs.carousel');
      var options = $.extend({}, Carousel.DEFAULTS, $this.data(), _typeof(option) == 'object' && option);
      var action = typeof option == 'string' ? option : options.slide;
      if (!data) $this.data('bs.carousel', data = new Carousel(this, options));
      if (typeof option == 'number') data.to(option);else if (action) data[action]();else if (options.interval) data.pause().cycle();
    });
  }

  var old = $.fn.carousel;
  $.fn.carousel = Plugin;
  $.fn.carousel.Constructor = Carousel; // CAROUSEL NO CONFLICT
  // ====================

  $.fn.carousel.noConflict = function () {
    $.fn.carousel = old;
    return this;
  }; // CAROUSEL DATA-API
  // =================


  var clickHandler = function (e) {
    var $this = $(this);
    var href = $this.attr('href');

    if (href) {
      href = href.replace(/.*(?=#[^\s]+$)/, ''); // strip for ie7
    }

    var target = $this.attr('data-target') || href;
    var $target = $(document).find(target);
    if (!$target.hasClass('carousel')) return;
    var options = $.extend({}, $target.data(), $this.data());
    var slideIndex = $this.attr('data-slide-to');
    if (slideIndex) options.interval = false;
    Plugin.call($target, options);

    if (slideIndex) {
      $target.data('bs.carousel').to(slideIndex);
    }

    e.preventDefault();
  };

  $(document).on('click.bs.carousel.data-api', '[data-slide]', clickHandler).on('click.bs.carousel.data-api', '[data-slide-to]', clickHandler);
  $(window).on('load', function () {
    $('[data-ride="carousel"]').each(function () {
      var $carousel = $(this);
      Plugin.call($carousel, $carousel.data());
    });
  });
}(jQuery);
},{}],"JIxA":[function(require,module,exports) {
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* ========================================================================
 * Bootstrap: collapse.js v3.4.1
 * https://getbootstrap.com/docs/3.4/javascript/#collapse
 * ========================================================================
 * Copyright 2011-2019 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */

/* jshint latedef: false */
+function ($) {
  'use strict'; // COLLAPSE PUBLIC CLASS DEFINITION
  // ================================

  var Collapse = function (element, options) {
    this.$element = $(element);
    this.options = $.extend({}, Collapse.DEFAULTS, options);
    this.$trigger = $('[data-toggle="collapse"][href="#' + element.id + '"],' + '[data-toggle="collapse"][data-target="#' + element.id + '"]');
    this.transitioning = null;

    if (this.options.parent) {
      this.$parent = this.getParent();
    } else {
      this.addAriaAndCollapsedClass(this.$element, this.$trigger);
    }

    if (this.options.toggle) this.toggle();
  };

  Collapse.VERSION = '3.4.1';
  Collapse.TRANSITION_DURATION = 350;
  Collapse.DEFAULTS = {
    toggle: true
  };

  Collapse.prototype.dimension = function () {
    var hasWidth = this.$element.hasClass('width');
    return hasWidth ? 'width' : 'height';
  };

  Collapse.prototype.show = function () {
    if (this.transitioning || this.$element.hasClass('in')) return;
    var activesData;
    var actives = this.$parent && this.$parent.children('.panel').children('.in, .collapsing');

    if (actives && actives.length) {
      activesData = actives.data('bs.collapse');
      if (activesData && activesData.transitioning) return;
    }

    var startEvent = $.Event('show.bs.collapse');
    this.$element.trigger(startEvent);
    if (startEvent.isDefaultPrevented()) return;

    if (actives && actives.length) {
      Plugin.call(actives, 'hide');
      activesData || actives.data('bs.collapse', null);
    }

    var dimension = this.dimension();
    this.$element.removeClass('collapse').addClass('collapsing')[dimension](0).attr('aria-expanded', true);
    this.$trigger.removeClass('collapsed').attr('aria-expanded', true);
    this.transitioning = 1;

    var complete = function () {
      this.$element.removeClass('collapsing').addClass('collapse in')[dimension]('');
      this.transitioning = 0;
      this.$element.trigger('shown.bs.collapse');
    };

    if (!$.support.transition) return complete.call(this);
    var scrollSize = $.camelCase(['scroll', dimension].join('-'));
    this.$element.one('bsTransitionEnd', $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize]);
  };

  Collapse.prototype.hide = function () {
    if (this.transitioning || !this.$element.hasClass('in')) return;
    var startEvent = $.Event('hide.bs.collapse');
    this.$element.trigger(startEvent);
    if (startEvent.isDefaultPrevented()) return;
    var dimension = this.dimension();
    this.$element[dimension](this.$element[dimension]())[0].offsetHeight;
    this.$element.addClass('collapsing').removeClass('collapse in').attr('aria-expanded', false);
    this.$trigger.addClass('collapsed').attr('aria-expanded', false);
    this.transitioning = 1;

    var complete = function () {
      this.transitioning = 0;
      this.$element.removeClass('collapsing').addClass('collapse').trigger('hidden.bs.collapse');
    };

    if (!$.support.transition) return complete.call(this);
    this.$element[dimension](0).one('bsTransitionEnd', $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION);
  };

  Collapse.prototype.toggle = function () {
    this[this.$element.hasClass('in') ? 'hide' : 'show']();
  };

  Collapse.prototype.getParent = function () {
    return $(document).find(this.options.parent).find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]').each($.proxy(function (i, element) {
      var $element = $(element);
      this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element);
    }, this)).end();
  };

  Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {
    var isOpen = $element.hasClass('in');
    $element.attr('aria-expanded', isOpen);
    $trigger.toggleClass('collapsed', !isOpen).attr('aria-expanded', isOpen);
  };

  function getTargetFromTrigger($trigger) {
    var href;
    var target = $trigger.attr('data-target') || (href = $trigger.attr('href')) && href.replace(/.*(?=#[^\s]+$)/, ''); // strip for ie7

    return $(document).find(target);
  } // COLLAPSE PLUGIN DEFINITION
  // ==========================


  function Plugin(option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data('bs.collapse');
      var options = $.extend({}, Collapse.DEFAULTS, $this.data(), _typeof(option) == 'object' && option);
      if (!data && options.toggle && /show|hide/.test(option)) options.toggle = false;
      if (!data) $this.data('bs.collapse', data = new Collapse(this, options));
      if (typeof option == 'string') data[option]();
    });
  }

  var old = $.fn.collapse;
  $.fn.collapse = Plugin;
  $.fn.collapse.Constructor = Collapse; // COLLAPSE NO CONFLICT
  // ====================

  $.fn.collapse.noConflict = function () {
    $.fn.collapse = old;
    return this;
  }; // COLLAPSE DATA-API
  // =================


  $(document).on('click.bs.collapse.data-api', '[data-toggle="collapse"]', function (e) {
    var $this = $(this);
    if (!$this.attr('data-target')) e.preventDefault();
    var $target = getTargetFromTrigger($this);
    var data = $target.data('bs.collapse');
    var option = data ? 'toggle' : $this.data();
    Plugin.call($target, option);
  });
}(jQuery);
},{}],"EkLL":[function(require,module,exports) {
/* ========================================================================
 * Bootstrap: dropdown.js v3.4.1
 * https://getbootstrap.com/docs/3.4/javascript/#dropdowns
 * ========================================================================
 * Copyright 2011-2019 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict'; // DROPDOWN CLASS DEFINITION
  // =========================

  var backdrop = '.dropdown-backdrop';
  var toggle = '[data-toggle="dropdown"]';

  var Dropdown = function (element) {
    $(element).on('click.bs.dropdown', this.toggle);
  };

  Dropdown.VERSION = '3.4.1';

  function getParent($this) {
    var selector = $this.attr('data-target');

    if (!selector) {
      selector = $this.attr('href');
      selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, ''); // strip for ie7
    }

    var $parent = selector !== '#' ? $(document).find(selector) : null;
    return $parent && $parent.length ? $parent : $this.parent();
  }

  function clearMenus(e) {
    if (e && e.which === 3) return;
    $(backdrop).remove();
    $(toggle).each(function () {
      var $this = $(this);
      var $parent = getParent($this);
      var relatedTarget = {
        relatedTarget: this
      };
      if (!$parent.hasClass('open')) return;
      if (e && e.type == 'click' && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target)) return;
      $parent.trigger(e = $.Event('hide.bs.dropdown', relatedTarget));
      if (e.isDefaultPrevented()) return;
      $this.attr('aria-expanded', 'false');
      $parent.removeClass('open').trigger($.Event('hidden.bs.dropdown', relatedTarget));
    });
  }

  Dropdown.prototype.toggle = function (e) {
    var $this = $(this);
    if ($this.is('.disabled, :disabled')) return;
    var $parent = getParent($this);
    var isActive = $parent.hasClass('open');
    clearMenus();

    if (!isActive) {
      if ('ontouchstart' in document.documentElement && !$parent.closest('.navbar-nav').length) {
        // if mobile we use a backdrop because click events don't delegate
        $(document.createElement('div')).addClass('dropdown-backdrop').insertAfter($(this)).on('click', clearMenus);
      }

      var relatedTarget = {
        relatedTarget: this
      };
      $parent.trigger(e = $.Event('show.bs.dropdown', relatedTarget));
      if (e.isDefaultPrevented()) return;
      $this.trigger('focus').attr('aria-expanded', 'true');
      $parent.toggleClass('open').trigger($.Event('shown.bs.dropdown', relatedTarget));
    }

    return false;
  };

  Dropdown.prototype.keydown = function (e) {
    if (!/(38|40|27|32)/.test(e.which) || /input|textarea/i.test(e.target.tagName)) return;
    var $this = $(this);
    e.preventDefault();
    e.stopPropagation();
    if ($this.is('.disabled, :disabled')) return;
    var $parent = getParent($this);
    var isActive = $parent.hasClass('open');

    if (!isActive && e.which != 27 || isActive && e.which == 27) {
      if (e.which == 27) $parent.find(toggle).trigger('focus');
      return $this.trigger('click');
    }

    var desc = ' li:not(.disabled):visible a';
    var $items = $parent.find('.dropdown-menu' + desc);
    if (!$items.length) return;
    var index = $items.index(e.target);
    if (e.which == 38 && index > 0) index--; // up

    if (e.which == 40 && index < $items.length - 1) index++; // down

    if (!~index) index = 0;
    $items.eq(index).trigger('focus');
  }; // DROPDOWN PLUGIN DEFINITION
  // ==========================


  function Plugin(option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data('bs.dropdown');
      if (!data) $this.data('bs.dropdown', data = new Dropdown(this));
      if (typeof option == 'string') data[option].call($this);
    });
  }

  var old = $.fn.dropdown;
  $.fn.dropdown = Plugin;
  $.fn.dropdown.Constructor = Dropdown; // DROPDOWN NO CONFLICT
  // ====================

  $.fn.dropdown.noConflict = function () {
    $.fn.dropdown = old;
    return this;
  }; // APPLY TO STANDARD DROPDOWN ELEMENTS
  // ===================================


  $(document).on('click.bs.dropdown.data-api', clearMenus).on('click.bs.dropdown.data-api', '.dropdown form', function (e) {
    e.stopPropagation();
  }).on('click.bs.dropdown.data-api', toggle, Dropdown.prototype.toggle).on('keydown.bs.dropdown.data-api', toggle, Dropdown.prototype.keydown).on('keydown.bs.dropdown.data-api', '.dropdown-menu', Dropdown.prototype.keydown);
}(jQuery);
},{}],"cKcy":[function(require,module,exports) {
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* ========================================================================
 * Bootstrap: modal.js v3.4.1
 * https://getbootstrap.com/docs/3.4/javascript/#modals
 * ========================================================================
 * Copyright 2011-2019 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict'; // MODAL CLASS DEFINITION
  // ======================

  var Modal = function (element, options) {
    this.options = options;
    this.$body = $(document.body);
    this.$element = $(element);
    this.$dialog = this.$element.find('.modal-dialog');
    this.$backdrop = null;
    this.isShown = null;
    this.originalBodyPad = null;
    this.scrollbarWidth = 0;
    this.ignoreBackdropClick = false;
    this.fixedContent = '.navbar-fixed-top, .navbar-fixed-bottom';

    if (this.options.remote) {
      this.$element.find('.modal-content').load(this.options.remote, $.proxy(function () {
        this.$element.trigger('loaded.bs.modal');
      }, this));
    }
  };

  Modal.VERSION = '3.4.1';
  Modal.TRANSITION_DURATION = 300;
  Modal.BACKDROP_TRANSITION_DURATION = 150;
  Modal.DEFAULTS = {
    backdrop: true,
    keyboard: true,
    show: true
  };

  Modal.prototype.toggle = function (_relatedTarget) {
    return this.isShown ? this.hide() : this.show(_relatedTarget);
  };

  Modal.prototype.show = function (_relatedTarget) {
    var that = this;
    var e = $.Event('show.bs.modal', {
      relatedTarget: _relatedTarget
    });
    this.$element.trigger(e);
    if (this.isShown || e.isDefaultPrevented()) return;
    this.isShown = true;
    this.checkScrollbar();
    this.setScrollbar();
    this.$body.addClass('modal-open');
    this.escape();
    this.resize();
    this.$element.on('click.dismiss.bs.modal', '[data-dismiss="modal"]', $.proxy(this.hide, this));
    this.$dialog.on('mousedown.dismiss.bs.modal', function () {
      that.$element.one('mouseup.dismiss.bs.modal', function (e) {
        if ($(e.target).is(that.$element)) that.ignoreBackdropClick = true;
      });
    });
    this.backdrop(function () {
      var transition = $.support.transition && that.$element.hasClass('fade');

      if (!that.$element.parent().length) {
        that.$element.appendTo(that.$body); // don't move modals dom position
      }

      that.$element.show().scrollTop(0);
      that.adjustDialog();

      if (transition) {
        that.$element[0].offsetWidth; // force reflow
      }

      that.$element.addClass('in');
      that.enforceFocus();
      var e = $.Event('shown.bs.modal', {
        relatedTarget: _relatedTarget
      });
      transition ? that.$dialog // wait for modal to slide in
      .one('bsTransitionEnd', function () {
        that.$element.trigger('focus').trigger(e);
      }).emulateTransitionEnd(Modal.TRANSITION_DURATION) : that.$element.trigger('focus').trigger(e);
    });
  };

  Modal.prototype.hide = function (e) {
    if (e) e.preventDefault();
    e = $.Event('hide.bs.modal');
    this.$element.trigger(e);
    if (!this.isShown || e.isDefaultPrevented()) return;
    this.isShown = false;
    this.escape();
    this.resize();
    $(document).off('focusin.bs.modal');
    this.$element.removeClass('in').off('click.dismiss.bs.modal').off('mouseup.dismiss.bs.modal');
    this.$dialog.off('mousedown.dismiss.bs.modal');
    $.support.transition && this.$element.hasClass('fade') ? this.$element.one('bsTransitionEnd', $.proxy(this.hideModal, this)).emulateTransitionEnd(Modal.TRANSITION_DURATION) : this.hideModal();
  };

  Modal.prototype.enforceFocus = function () {
    $(document).off('focusin.bs.modal') // guard against infinite focus loop
    .on('focusin.bs.modal', $.proxy(function (e) {
      if (document !== e.target && this.$element[0] !== e.target && !this.$element.has(e.target).length) {
        this.$element.trigger('focus');
      }
    }, this));
  };

  Modal.prototype.escape = function () {
    if (this.isShown && this.options.keyboard) {
      this.$element.on('keydown.dismiss.bs.modal', $.proxy(function (e) {
        e.which == 27 && this.hide();
      }, this));
    } else if (!this.isShown) {
      this.$element.off('keydown.dismiss.bs.modal');
    }
  };

  Modal.prototype.resize = function () {
    if (this.isShown) {
      $(window).on('resize.bs.modal', $.proxy(this.handleUpdate, this));
    } else {
      $(window).off('resize.bs.modal');
    }
  };

  Modal.prototype.hideModal = function () {
    var that = this;
    this.$element.hide();
    this.backdrop(function () {
      that.$body.removeClass('modal-open');
      that.resetAdjustments();
      that.resetScrollbar();
      that.$element.trigger('hidden.bs.modal');
    });
  };

  Modal.prototype.removeBackdrop = function () {
    this.$backdrop && this.$backdrop.remove();
    this.$backdrop = null;
  };

  Modal.prototype.backdrop = function (callback) {
    var that = this;
    var animate = this.$element.hasClass('fade') ? 'fade' : '';

    if (this.isShown && this.options.backdrop) {
      var doAnimate = $.support.transition && animate;
      this.$backdrop = $(document.createElement('div')).addClass('modal-backdrop ' + animate).appendTo(this.$body);
      this.$element.on('click.dismiss.bs.modal', $.proxy(function (e) {
        if (this.ignoreBackdropClick) {
          this.ignoreBackdropClick = false;
          return;
        }

        if (e.target !== e.currentTarget) return;
        this.options.backdrop == 'static' ? this.$element[0].focus() : this.hide();
      }, this));
      if (doAnimate) this.$backdrop[0].offsetWidth; // force reflow

      this.$backdrop.addClass('in');
      if (!callback) return;
      doAnimate ? this.$backdrop.one('bsTransitionEnd', callback).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callback();
    } else if (!this.isShown && this.$backdrop) {
      this.$backdrop.removeClass('in');

      var callbackRemove = function () {
        that.removeBackdrop();
        callback && callback();
      };

      $.support.transition && this.$element.hasClass('fade') ? this.$backdrop.one('bsTransitionEnd', callbackRemove).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callbackRemove();
    } else if (callback) {
      callback();
    }
  }; // these following methods are used to handle overflowing modals


  Modal.prototype.handleUpdate = function () {
    this.adjustDialog();
  };

  Modal.prototype.adjustDialog = function () {
    var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight;
    this.$element.css({
      paddingLeft: !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : '',
      paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ''
    });
  };

  Modal.prototype.resetAdjustments = function () {
    this.$element.css({
      paddingLeft: '',
      paddingRight: ''
    });
  };

  Modal.prototype.checkScrollbar = function () {
    var fullWindowWidth = window.innerWidth;

    if (!fullWindowWidth) {
      // workaround for missing window.innerWidth in IE8
      var documentElementRect = document.documentElement.getBoundingClientRect();
      fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left);
    }

    this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth;
    this.scrollbarWidth = this.measureScrollbar();
  };

  Modal.prototype.setScrollbar = function () {
    var bodyPad = parseInt(this.$body.css('padding-right') || 0, 10);
    this.originalBodyPad = document.body.style.paddingRight || '';
    var scrollbarWidth = this.scrollbarWidth;

    if (this.bodyIsOverflowing) {
      this.$body.css('padding-right', bodyPad + scrollbarWidth);
      $(this.fixedContent).each(function (index, element) {
        var actualPadding = element.style.paddingRight;
        var calculatedPadding = $(element).css('padding-right');
        $(element).data('padding-right', actualPadding).css('padding-right', parseFloat(calculatedPadding) + scrollbarWidth + 'px');
      });
    }
  };

  Modal.prototype.resetScrollbar = function () {
    this.$body.css('padding-right', this.originalBodyPad);
    $(this.fixedContent).each(function (index, element) {
      var padding = $(element).data('padding-right');
      $(element).removeData('padding-right');
      element.style.paddingRight = padding ? padding : '';
    });
  };

  Modal.prototype.measureScrollbar = function () {
    // thx walsh
    var scrollDiv = document.createElement('div');
    scrollDiv.className = 'modal-scrollbar-measure';
    this.$body.append(scrollDiv);
    var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
    this.$body[0].removeChild(scrollDiv);
    return scrollbarWidth;
  }; // MODAL PLUGIN DEFINITION
  // =======================


  function Plugin(option, _relatedTarget) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data('bs.modal');
      var options = $.extend({}, Modal.DEFAULTS, $this.data(), _typeof(option) == 'object' && option);
      if (!data) $this.data('bs.modal', data = new Modal(this, options));
      if (typeof option == 'string') data[option](_relatedTarget);else if (options.show) data.show(_relatedTarget);
    });
  }

  var old = $.fn.modal;
  $.fn.modal = Plugin;
  $.fn.modal.Constructor = Modal; // MODAL NO CONFLICT
  // =================

  $.fn.modal.noConflict = function () {
    $.fn.modal = old;
    return this;
  }; // MODAL DATA-API
  // ==============


  $(document).on('click.bs.modal.data-api', '[data-toggle="modal"]', function (e) {
    var $this = $(this);
    var href = $this.attr('href');
    var target = $this.attr('data-target') || href && href.replace(/.*(?=#[^\s]+$)/, ''); // strip for ie7

    var $target = $(document).find(target);
    var option = $target.data('bs.modal') ? 'toggle' : $.extend({
      remote: !/#/.test(href) && href
    }, $target.data(), $this.data());
    if ($this.is('a')) e.preventDefault();
    $target.one('show.bs.modal', function (showEvent) {
      if (showEvent.isDefaultPrevented()) return; // only register focus restorer if modal will actually get shown

      $target.one('hidden.bs.modal', function () {
        $this.is(':visible') && $this.trigger('focus');
      });
    });
    Plugin.call($target, option, this);
  });
}(jQuery);
},{}],"dtvv":[function(require,module,exports) {
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* ========================================================================
 * Bootstrap: tooltip.js v3.4.1
 * https://getbootstrap.com/docs/3.4/javascript/#tooltip
 * Inspired by the original jQuery.tipsy by Jason Frame
 * ========================================================================
 * Copyright 2011-2019 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict';

  var DISALLOWED_ATTRIBUTES = ['sanitize', 'whiteList', 'sanitizeFn'];
  var uriAttrs = ['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href'];
  var ARIA_ATTRIBUTE_PATTERN = /^aria-[\w-]*$/i;
  var DefaultWhitelist = {
    // Global attributes allowed on any supplied element below.
    '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],
    a: ['target', 'href', 'title', 'rel'],
    area: [],
    b: [],
    br: [],
    col: [],
    code: [],
    div: [],
    em: [],
    hr: [],
    h1: [],
    h2: [],
    h3: [],
    h4: [],
    h5: [],
    h6: [],
    i: [],
    img: ['src', 'alt', 'title', 'width', 'height'],
    li: [],
    ol: [],
    p: [],
    pre: [],
    s: [],
    small: [],
    span: [],
    sub: [],
    sup: [],
    strong: [],
    u: [],
    ul: []
  };
  /**
   * A pattern that recognizes a commonly useful subset of URLs that are safe.
   *
   * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts
   */

  var SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file):|[^&:/?#]*(?:[/?#]|$))/gi;
  /**
   * A pattern that matches safe data URLs. Only matches image, video and audio types.
   *
   * Shoutout to Angular 7 https://github.com/angular/angular/blob/7.2.4/packages/core/src/sanitization/url_sanitizer.ts
   */

  var DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+/]+=*$/i;

  function allowedAttribute(attr, allowedAttributeList) {
    var attrName = attr.nodeName.toLowerCase();

    if ($.inArray(attrName, allowedAttributeList) !== -1) {
      if ($.inArray(attrName, uriAttrs) !== -1) {
        return Boolean(attr.nodeValue.match(SAFE_URL_PATTERN) || attr.nodeValue.match(DATA_URL_PATTERN));
      }

      return true;
    }

    var regExp = $(allowedAttributeList).filter(function (index, value) {
      return value instanceof RegExp;
    }); // Check if a regular expression validates the attribute.

    for (var i = 0, l = regExp.length; i < l; i++) {
      if (attrName.match(regExp[i])) {
        return true;
      }
    }

    return false;
  }

  function sanitizeHtml(unsafeHtml, whiteList, sanitizeFn) {
    if (unsafeHtml.length === 0) {
      return unsafeHtml;
    }

    if (sanitizeFn && typeof sanitizeFn === 'function') {
      return sanitizeFn(unsafeHtml);
    } // IE 8 and below don't support createHTMLDocument


    if (!document.implementation || !document.implementation.createHTMLDocument) {
      return unsafeHtml;
    }

    var createdDocument = document.implementation.createHTMLDocument('sanitization');
    createdDocument.body.innerHTML = unsafeHtml;
    var whitelistKeys = $.map(whiteList, function (el, i) {
      return i;
    });
    var elements = $(createdDocument.body).find('*');

    for (var i = 0, len = elements.length; i < len; i++) {
      var el = elements[i];
      var elName = el.nodeName.toLowerCase();

      if ($.inArray(elName, whitelistKeys) === -1) {
        el.parentNode.removeChild(el);
        continue;
      }

      var attributeList = $.map(el.attributes, function (el) {
        return el;
      });
      var whitelistedAttributes = [].concat(whiteList['*'] || [], whiteList[elName] || []);

      for (var j = 0, len2 = attributeList.length; j < len2; j++) {
        if (!allowedAttribute(attributeList[j], whitelistedAttributes)) {
          el.removeAttribute(attributeList[j].nodeName);
        }
      }
    }

    return createdDocument.body.innerHTML;
  } // TOOLTIP PUBLIC CLASS DEFINITION
  // ===============================


  var Tooltip = function (element, options) {
    this.type = null;
    this.options = null;
    this.enabled = null;
    this.timeout = null;
    this.hoverState = null;
    this.$element = null;
    this.inState = null;
    this.init('tooltip', element, options);
  };

  Tooltip.VERSION = '3.4.1';
  Tooltip.TRANSITION_DURATION = 150;
  Tooltip.DEFAULTS = {
    animation: true,
    placement: 'top',
    selector: false,
    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
    trigger: 'hover focus',
    title: '',
    delay: 0,
    html: false,
    container: false,
    viewport: {
      selector: 'body',
      padding: 0
    },
    sanitize: true,
    sanitizeFn: null,
    whiteList: DefaultWhitelist
  };

  Tooltip.prototype.init = function (type, element, options) {
    this.enabled = true;
    this.type = type;
    this.$element = $(element);
    this.options = this.getOptions(options);
    this.$viewport = this.options.viewport && $(document).find($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : this.options.viewport.selector || this.options.viewport);
    this.inState = {
      click: false,
      hover: false,
      focus: false
    };

    if (this.$element[0] instanceof document.constructor && !this.options.selector) {
      throw new Error('`selector` option must be specified when initializing ' + this.type + ' on the window.document object!');
    }

    var triggers = this.options.trigger.split(' ');

    for (var i = triggers.length; i--;) {
      var trigger = triggers[i];

      if (trigger == 'click') {
        this.$element.on('click.' + this.type, this.options.selector, $.proxy(this.toggle, this));
      } else if (trigger != 'manual') {
        var eventIn = trigger == 'hover' ? 'mouseenter' : 'focusin';
        var eventOut = trigger == 'hover' ? 'mouseleave' : 'focusout';
        this.$element.on(eventIn + '.' + this.type, this.options.selector, $.proxy(this.enter, this));
        this.$element.on(eventOut + '.' + this.type, this.options.selector, $.proxy(this.leave, this));
      }
    }

    this.options.selector ? this._options = $.extend({}, this.options, {
      trigger: 'manual',
      selector: ''
    }) : this.fixTitle();
  };

  Tooltip.prototype.getDefaults = function () {
    return Tooltip.DEFAULTS;
  };

  Tooltip.prototype.getOptions = function (options) {
    var dataAttributes = this.$element.data();

    for (var dataAttr in dataAttributes) {
      if (dataAttributes.hasOwnProperty(dataAttr) && $.inArray(dataAttr, DISALLOWED_ATTRIBUTES) !== -1) {
        delete dataAttributes[dataAttr];
      }
    }

    options = $.extend({}, this.getDefaults(), dataAttributes, options);

    if (options.delay && typeof options.delay == 'number') {
      options.delay = {
        show: options.delay,
        hide: options.delay
      };
    }

    if (options.sanitize) {
      options.template = sanitizeHtml(options.template, options.whiteList, options.sanitizeFn);
    }

    return options;
  };

  Tooltip.prototype.getDelegateOptions = function () {
    var options = {};
    var defaults = this.getDefaults();
    this._options && $.each(this._options, function (key, value) {
      if (defaults[key] != value) options[key] = value;
    });
    return options;
  };

  Tooltip.prototype.enter = function (obj) {
    var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data('bs.' + this.type);

    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions());
      $(obj.currentTarget).data('bs.' + this.type, self);
    }

    if (obj instanceof $.Event) {
      self.inState[obj.type == 'focusin' ? 'focus' : 'hover'] = true;
    }

    if (self.tip().hasClass('in') || self.hoverState == 'in') {
      self.hoverState = 'in';
      return;
    }

    clearTimeout(self.timeout);
    self.hoverState = 'in';
    if (!self.options.delay || !self.options.delay.show) return self.show();
    self.timeout = setTimeout(function () {
      if (self.hoverState == 'in') self.show();
    }, self.options.delay.show);
  };

  Tooltip.prototype.isInStateTrue = function () {
    for (var key in this.inState) {
      if (this.inState[key]) return true;
    }

    return false;
  };

  Tooltip.prototype.leave = function (obj) {
    var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data('bs.' + this.type);

    if (!self) {
      self = new this.constructor(obj.currentTarget, this.getDelegateOptions());
      $(obj.currentTarget).data('bs.' + this.type, self);
    }

    if (obj instanceof $.Event) {
      self.inState[obj.type == 'focusout' ? 'focus' : 'hover'] = false;
    }

    if (self.isInStateTrue()) return;
    clearTimeout(self.timeout);
    self.hoverState = 'out';
    if (!self.options.delay || !self.options.delay.hide) return self.hide();
    self.timeout = setTimeout(function () {
      if (self.hoverState == 'out') self.hide();
    }, self.options.delay.hide);
  };

  Tooltip.prototype.show = function () {
    var e = $.Event('show.bs.' + this.type);

    if (this.hasContent() && this.enabled) {
      this.$element.trigger(e);
      var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]);
      if (e.isDefaultPrevented() || !inDom) return;
      var that = this;
      var $tip = this.tip();
      var tipId = this.getUID(this.type);
      this.setContent();
      $tip.attr('id', tipId);
      this.$element.attr('aria-describedby', tipId);
      if (this.options.animation) $tip.addClass('fade');
      var placement = typeof this.options.placement == 'function' ? this.options.placement.call(this, $tip[0], this.$element[0]) : this.options.placement;
      var autoToken = /\s?auto?\s?/i;
      var autoPlace = autoToken.test(placement);
      if (autoPlace) placement = placement.replace(autoToken, '') || 'top';
      $tip.detach().css({
        top: 0,
        left: 0,
        display: 'block'
      }).addClass(placement).data('bs.' + this.type, this);
      this.options.container ? $tip.appendTo($(document).find(this.options.container)) : $tip.insertAfter(this.$element);
      this.$element.trigger('inserted.bs.' + this.type);
      var pos = this.getPosition();
      var actualWidth = $tip[0].offsetWidth;
      var actualHeight = $tip[0].offsetHeight;

      if (autoPlace) {
        var orgPlacement = placement;
        var viewportDim = this.getPosition(this.$viewport);
        placement = placement == 'bottom' && pos.bottom + actualHeight > viewportDim.bottom ? 'top' : placement == 'top' && pos.top - actualHeight < viewportDim.top ? 'bottom' : placement == 'right' && pos.right + actualWidth > viewportDim.width ? 'left' : placement == 'left' && pos.left - actualWidth < viewportDim.left ? 'right' : placement;
        $tip.removeClass(orgPlacement).addClass(placement);
      }

      var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight);
      this.applyPlacement(calculatedOffset, placement);

      var complete = function () {
        var prevHoverState = that.hoverState;
        that.$element.trigger('shown.bs.' + that.type);
        that.hoverState = null;
        if (prevHoverState == 'out') that.leave(that);
      };

      $.support.transition && this.$tip.hasClass('fade') ? $tip.one('bsTransitionEnd', complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete();
    }
  };

  Tooltip.prototype.applyPlacement = function (offset, placement) {
    var $tip = this.tip();
    var width = $tip[0].offsetWidth;
    var height = $tip[0].offsetHeight; // manually read margins because getBoundingClientRect includes difference

    var marginTop = parseInt($tip.css('margin-top'), 10);
    var marginLeft = parseInt($tip.css('margin-left'), 10); // we must check for NaN for ie 8/9

    if (isNaN(marginTop)) marginTop = 0;
    if (isNaN(marginLeft)) marginLeft = 0;
    offset.top += marginTop;
    offset.left += marginLeft; // $.fn.offset doesn't round pixel values
    // so we use setOffset directly with our own function B-0

    $.offset.setOffset($tip[0], $.extend({
      using: function (props) {
        $tip.css({
          top: Math.round(props.top),
          left: Math.round(props.left)
        });
      }
    }, offset), 0);
    $tip.addClass('in'); // check to see if placing tip in new offset caused the tip to resize itself

    var actualWidth = $tip[0].offsetWidth;
    var actualHeight = $tip[0].offsetHeight;

    if (placement == 'top' && actualHeight != height) {
      offset.top = offset.top + height - actualHeight;
    }

    var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);
    if (delta.left) offset.left += delta.left;else offset.top += delta.top;
    var isVertical = /top|bottom/.test(placement);
    var arrowDelta = isVertical ? delta.left * 2 - width + actualWidth : delta.top * 2 - height + actualHeight;
    var arrowOffsetPosition = isVertical ? 'offsetWidth' : 'offsetHeight';
    $tip.offset(offset);
    this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical);
  };

  Tooltip.prototype.replaceArrow = function (delta, dimension, isVertical) {
    this.arrow().css(isVertical ? 'left' : 'top', 50 * (1 - delta / dimension) + '%').css(isVertical ? 'top' : 'left', '');
  };

  Tooltip.prototype.setContent = function () {
    var $tip = this.tip();
    var title = this.getTitle();

    if (this.options.html) {
      if (this.options.sanitize) {
        title = sanitizeHtml(title, this.options.whiteList, this.options.sanitizeFn);
      }

      $tip.find('.tooltip-inner').html(title);
    } else {
      $tip.find('.tooltip-inner').text(title);
    }

    $tip.removeClass('fade in top bottom left right');
  };

  Tooltip.prototype.hide = function (callback) {
    var that = this;
    var $tip = $(this.$tip);
    var e = $.Event('hide.bs.' + this.type);

    function complete() {
      if (that.hoverState != 'in') $tip.detach();

      if (that.$element) {
        // TODO: Check whether guarding this code with this `if` is really necessary.
        that.$element.removeAttr('aria-describedby').trigger('hidden.bs.' + that.type);
      }

      callback && callback();
    }

    this.$element.trigger(e);
    if (e.isDefaultPrevented()) return;
    $tip.removeClass('in');
    $.support.transition && $tip.hasClass('fade') ? $tip.one('bsTransitionEnd', complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete();
    this.hoverState = null;
    return this;
  };

  Tooltip.prototype.fixTitle = function () {
    var $e = this.$element;

    if ($e.attr('title') || typeof $e.attr('data-original-title') != 'string') {
      $e.attr('data-original-title', $e.attr('title') || '').attr('title', '');
    }
  };

  Tooltip.prototype.hasContent = function () {
    return this.getTitle();
  };

  Tooltip.prototype.getPosition = function ($element) {
    $element = $element || this.$element;
    var el = $element[0];
    var isBody = el.tagName == 'BODY';
    var elRect = el.getBoundingClientRect();

    if (elRect.width == null) {
      // width and height are missing in IE8, so compute them manually; see https://github.com/twbs/bootstrap/issues/14093
      elRect = $.extend({}, elRect, {
        width: elRect.right - elRect.left,
        height: elRect.bottom - elRect.top
      });
    }

    var isSvg = window.SVGElement && el instanceof window.SVGElement; // Avoid using $.offset() on SVGs since it gives incorrect results in jQuery 3.
    // See https://github.com/twbs/bootstrap/issues/20280

    var elOffset = isBody ? {
      top: 0,
      left: 0
    } : isSvg ? null : $element.offset();
    var scroll = {
      scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop()
    };
    var outerDims = isBody ? {
      width: $(window).width(),
      height: $(window).height()
    } : null;
    return $.extend({}, elRect, scroll, outerDims, elOffset);
  };

  Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
    return placement == 'bottom' ? {
      top: pos.top + pos.height,
      left: pos.left + pos.width / 2 - actualWidth / 2
    } : placement == 'top' ? {
      top: pos.top - actualHeight,
      left: pos.left + pos.width / 2 - actualWidth / 2
    } : placement == 'left' ? {
      top: pos.top + pos.height / 2 - actualHeight / 2,
      left: pos.left - actualWidth
    } :
    /* placement == 'right' */
    {
      top: pos.top + pos.height / 2 - actualHeight / 2,
      left: pos.left + pos.width
    };
  };

  Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {
    var delta = {
      top: 0,
      left: 0
    };
    if (!this.$viewport) return delta;
    var viewportPadding = this.options.viewport && this.options.viewport.padding || 0;
    var viewportDimensions = this.getPosition(this.$viewport);

    if (/right|left/.test(placement)) {
      var topEdgeOffset = pos.top - viewportPadding - viewportDimensions.scroll;
      var bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight;

      if (topEdgeOffset < viewportDimensions.top) {
        // top overflow
        delta.top = viewportDimensions.top - topEdgeOffset;
      } else if (bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height) {
        // bottom overflow
        delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset;
      }
    } else {
      var leftEdgeOffset = pos.left - viewportPadding;
      var rightEdgeOffset = pos.left + viewportPadding + actualWidth;

      if (leftEdgeOffset < viewportDimensions.left) {
        // left overflow
        delta.left = viewportDimensions.left - leftEdgeOffset;
      } else if (rightEdgeOffset > viewportDimensions.right) {
        // right overflow
        delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset;
      }
    }

    return delta;
  };

  Tooltip.prototype.getTitle = function () {
    var title;
    var $e = this.$element;
    var o = this.options;
    title = $e.attr('data-original-title') || (typeof o.title == 'function' ? o.title.call($e[0]) : o.title);
    return title;
  };

  Tooltip.prototype.getUID = function (prefix) {
    do {
      prefix += ~~(Math.random() * 1000000);
    } while (document.getElementById(prefix));

    return prefix;
  };

  Tooltip.prototype.tip = function () {
    if (!this.$tip) {
      this.$tip = $(this.options.template);

      if (this.$tip.length != 1) {
        throw new Error(this.type + ' `template` option must consist of exactly 1 top-level element!');
      }
    }

    return this.$tip;
  };

  Tooltip.prototype.arrow = function () {
    return this.$arrow = this.$arrow || this.tip().find('.tooltip-arrow');
  };

  Tooltip.prototype.enable = function () {
    this.enabled = true;
  };

  Tooltip.prototype.disable = function () {
    this.enabled = false;
  };

  Tooltip.prototype.toggleEnabled = function () {
    this.enabled = !this.enabled;
  };

  Tooltip.prototype.toggle = function (e) {
    var self = this;

    if (e) {
      self = $(e.currentTarget).data('bs.' + this.type);

      if (!self) {
        self = new this.constructor(e.currentTarget, this.getDelegateOptions());
        $(e.currentTarget).data('bs.' + this.type, self);
      }
    }

    if (e) {
      self.inState.click = !self.inState.click;
      if (self.isInStateTrue()) self.enter(self);else self.leave(self);
    } else {
      self.tip().hasClass('in') ? self.leave(self) : self.enter(self);
    }
  };

  Tooltip.prototype.destroy = function () {
    var that = this;
    clearTimeout(this.timeout);
    this.hide(function () {
      that.$element.off('.' + that.type).removeData('bs.' + that.type);

      if (that.$tip) {
        that.$tip.detach();
      }

      that.$tip = null;
      that.$arrow = null;
      that.$viewport = null;
      that.$element = null;
    });
  };

  Tooltip.prototype.sanitizeHtml = function (unsafeHtml) {
    return sanitizeHtml(unsafeHtml, this.options.whiteList, this.options.sanitizeFn);
  }; // TOOLTIP PLUGIN DEFINITION
  // =========================


  function Plugin(option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data('bs.tooltip');
      var options = _typeof(option) == 'object' && option;
      if (!data && /destroy|hide/.test(option)) return;
      if (!data) $this.data('bs.tooltip', data = new Tooltip(this, options));
      if (typeof option == 'string') data[option]();
    });
  }

  var old = $.fn.tooltip;
  $.fn.tooltip = Plugin;
  $.fn.tooltip.Constructor = Tooltip; // TOOLTIP NO CONFLICT
  // ===================

  $.fn.tooltip.noConflict = function () {
    $.fn.tooltip = old;
    return this;
  };
}(jQuery);
},{}],"N8dD":[function(require,module,exports) {
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* ========================================================================
 * Bootstrap: popover.js v3.4.1
 * https://getbootstrap.com/docs/3.4/javascript/#popovers
 * ========================================================================
 * Copyright 2011-2019 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict'; // POPOVER PUBLIC CLASS DEFINITION
  // ===============================

  var Popover = function (element, options) {
    this.init('popover', element, options);
  };

  if (!$.fn.tooltip) throw new Error('Popover requires tooltip.js');
  Popover.VERSION = '3.4.1';
  Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
    placement: 'right',
    trigger: 'click',
    content: '',
    template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
  }); // NOTE: POPOVER EXTENDS tooltip.js
  // ================================

  Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype);
  Popover.prototype.constructor = Popover;

  Popover.prototype.getDefaults = function () {
    return Popover.DEFAULTS;
  };

  Popover.prototype.setContent = function () {
    var $tip = this.tip();
    var title = this.getTitle();
    var content = this.getContent();

    if (this.options.html) {
      var typeContent = _typeof(content);

      if (this.options.sanitize) {
        title = this.sanitizeHtml(title);

        if (typeContent === 'string') {
          content = this.sanitizeHtml(content);
        }
      }

      $tip.find('.popover-title').html(title);
      $tip.find('.popover-content').children().detach().end()[typeContent === 'string' ? 'html' : 'append'](content);
    } else {
      $tip.find('.popover-title').text(title);
      $tip.find('.popover-content').children().detach().end().text(content);
    }

    $tip.removeClass('fade top bottom left right in'); // IE8 doesn't accept hiding via the `:empty` pseudo selector, we have to do
    // this manually by checking the contents.

    if (!$tip.find('.popover-title').html()) $tip.find('.popover-title').hide();
  };

  Popover.prototype.hasContent = function () {
    return this.getTitle() || this.getContent();
  };

  Popover.prototype.getContent = function () {
    var $e = this.$element;
    var o = this.options;
    return $e.attr('data-content') || (typeof o.content == 'function' ? o.content.call($e[0]) : o.content);
  };

  Popover.prototype.arrow = function () {
    return this.$arrow = this.$arrow || this.tip().find('.arrow');
  }; // POPOVER PLUGIN DEFINITION
  // =========================


  function Plugin(option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data('bs.popover');
      var options = _typeof(option) == 'object' && option;
      if (!data && /destroy|hide/.test(option)) return;
      if (!data) $this.data('bs.popover', data = new Popover(this, options));
      if (typeof option == 'string') data[option]();
    });
  }

  var old = $.fn.popover;
  $.fn.popover = Plugin;
  $.fn.popover.Constructor = Popover; // POPOVER NO CONFLICT
  // ===================

  $.fn.popover.noConflict = function () {
    $.fn.popover = old;
    return this;
  };
}(jQuery);
},{}],"F6iO":[function(require,module,exports) {
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* ========================================================================
 * Bootstrap: scrollspy.js v3.4.1
 * https://getbootstrap.com/docs/3.4/javascript/#scrollspy
 * ========================================================================
 * Copyright 2011-2019 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict'; // SCROLLSPY CLASS DEFINITION
  // ==========================

  function ScrollSpy(element, options) {
    this.$body = $(document.body);
    this.$scrollElement = $(element).is(document.body) ? $(window) : $(element);
    this.options = $.extend({}, ScrollSpy.DEFAULTS, options);
    this.selector = (this.options.target || '') + ' .nav li > a';
    this.offsets = [];
    this.targets = [];
    this.activeTarget = null;
    this.scrollHeight = 0;
    this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this));
    this.refresh();
    this.process();
  }

  ScrollSpy.VERSION = '3.4.1';
  ScrollSpy.DEFAULTS = {
    offset: 10
  };

  ScrollSpy.prototype.getScrollHeight = function () {
    return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight);
  };

  ScrollSpy.prototype.refresh = function () {
    var that = this;
    var offsetMethod = 'offset';
    var offsetBase = 0;
    this.offsets = [];
    this.targets = [];
    this.scrollHeight = this.getScrollHeight();

    if (!$.isWindow(this.$scrollElement[0])) {
      offsetMethod = 'position';
      offsetBase = this.$scrollElement.scrollTop();
    }

    this.$body.find(this.selector).map(function () {
      var $el = $(this);
      var href = $el.data('target') || $el.attr('href');
      var $href = /^#./.test(href) && $(href);
      return $href && $href.length && $href.is(':visible') && [[$href[offsetMethod]().top + offsetBase, href]] || null;
    }).sort(function (a, b) {
      return a[0] - b[0];
    }).each(function () {
      that.offsets.push(this[0]);
      that.targets.push(this[1]);
    });
  };

  ScrollSpy.prototype.process = function () {
    var scrollTop = this.$scrollElement.scrollTop() + this.options.offset;
    var scrollHeight = this.getScrollHeight();
    var maxScroll = this.options.offset + scrollHeight - this.$scrollElement.height();
    var offsets = this.offsets;
    var targets = this.targets;
    var activeTarget = this.activeTarget;
    var i;

    if (this.scrollHeight != scrollHeight) {
      this.refresh();
    }

    if (scrollTop >= maxScroll) {
      return activeTarget != (i = targets[targets.length - 1]) && this.activate(i);
    }

    if (activeTarget && scrollTop < offsets[0]) {
      this.activeTarget = null;
      return this.clear();
    }

    for (i = offsets.length; i--;) {
      activeTarget != targets[i] && scrollTop >= offsets[i] && (offsets[i + 1] === undefined || scrollTop < offsets[i + 1]) && this.activate(targets[i]);
    }
  };

  ScrollSpy.prototype.activate = function (target) {
    this.activeTarget = target;
    this.clear();
    var selector = this.selector + '[data-target="' + target + '"],' + this.selector + '[href="' + target + '"]';
    var active = $(selector).parents('li').addClass('active');

    if (active.parent('.dropdown-menu').length) {
      active = active.closest('li.dropdown').addClass('active');
    }

    active.trigger('activate.bs.scrollspy');
  };

  ScrollSpy.prototype.clear = function () {
    $(this.selector).parentsUntil(this.options.target, '.active').removeClass('active');
  }; // SCROLLSPY PLUGIN DEFINITION
  // ===========================


  function Plugin(option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data('bs.scrollspy');
      var options = _typeof(option) == 'object' && option;
      if (!data) $this.data('bs.scrollspy', data = new ScrollSpy(this, options));
      if (typeof option == 'string') data[option]();
    });
  }

  var old = $.fn.scrollspy;
  $.fn.scrollspy = Plugin;
  $.fn.scrollspy.Constructor = ScrollSpy; // SCROLLSPY NO CONFLICT
  // =====================

  $.fn.scrollspy.noConflict = function () {
    $.fn.scrollspy = old;
    return this;
  }; // SCROLLSPY DATA-API
  // ==================


  $(window).on('load.bs.scrollspy.data-api', function () {
    $('[data-spy="scroll"]').each(function () {
      var $spy = $(this);
      Plugin.call($spy, $spy.data());
    });
  });
}(jQuery);
},{}],"ZuDb":[function(require,module,exports) {
/* ========================================================================
 * Bootstrap: tab.js v3.4.1
 * https://getbootstrap.com/docs/3.4/javascript/#tabs
 * ========================================================================
 * Copyright 2011-2019 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict'; // TAB CLASS DEFINITION
  // ====================

  var Tab = function (element) {
    // jscs:disable requireDollarBeforejQueryAssignment
    this.element = $(element); // jscs:enable requireDollarBeforejQueryAssignment
  };

  Tab.VERSION = '3.4.1';
  Tab.TRANSITION_DURATION = 150;

  Tab.prototype.show = function () {
    var $this = this.element;
    var $ul = $this.closest('ul:not(.dropdown-menu)');
    var selector = $this.data('target');

    if (!selector) {
      selector = $this.attr('href');
      selector = selector && selector.replace(/.*(?=#[^\s]*$)/, ''); // strip for ie7
    }

    if ($this.parent('li').hasClass('active')) return;
    var $previous = $ul.find('.active:last a');
    var hideEvent = $.Event('hide.bs.tab', {
      relatedTarget: $this[0]
    });
    var showEvent = $.Event('show.bs.tab', {
      relatedTarget: $previous[0]
    });
    $previous.trigger(hideEvent);
    $this.trigger(showEvent);
    if (showEvent.isDefaultPrevented() || hideEvent.isDefaultPrevented()) return;
    var $target = $(document).find(selector);
    this.activate($this.closest('li'), $ul);
    this.activate($target, $target.parent(), function () {
      $previous.trigger({
        type: 'hidden.bs.tab',
        relatedTarget: $this[0]
      });
      $this.trigger({
        type: 'shown.bs.tab',
        relatedTarget: $previous[0]
      });
    });
  };

  Tab.prototype.activate = function (element, container, callback) {
    var $active = container.find('> .active');
    var transition = callback && $.support.transition && ($active.length && $active.hasClass('fade') || !!container.find('> .fade').length);

    function next() {
      $active.removeClass('active').find('> .dropdown-menu > .active').removeClass('active').end().find('[data-toggle="tab"]').attr('aria-expanded', false);
      element.addClass('active').find('[data-toggle="tab"]').attr('aria-expanded', true);

      if (transition) {
        element[0].offsetWidth; // reflow for transition

        element.addClass('in');
      } else {
        element.removeClass('fade');
      }

      if (element.parent('.dropdown-menu').length) {
        element.closest('li.dropdown').addClass('active').end().find('[data-toggle="tab"]').attr('aria-expanded', true);
      }

      callback && callback();
    }

    $active.length && transition ? $active.one('bsTransitionEnd', next).emulateTransitionEnd(Tab.TRANSITION_DURATION) : next();
    $active.removeClass('in');
  }; // TAB PLUGIN DEFINITION
  // =====================


  function Plugin(option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data('bs.tab');
      if (!data) $this.data('bs.tab', data = new Tab(this));
      if (typeof option == 'string') data[option]();
    });
  }

  var old = $.fn.tab;
  $.fn.tab = Plugin;
  $.fn.tab.Constructor = Tab; // TAB NO CONFLICT
  // ===============

  $.fn.tab.noConflict = function () {
    $.fn.tab = old;
    return this;
  }; // TAB DATA-API
  // ============


  var clickHandler = function (e) {
    e.preventDefault();
    Plugin.call($(this), 'show');
  };

  $(document).on('click.bs.tab.data-api', '[data-toggle="tab"]', clickHandler).on('click.bs.tab.data-api', '[data-toggle="pill"]', clickHandler);
}(jQuery);
},{}],"ZK0v":[function(require,module,exports) {
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function (obj) { return typeof obj; }; } else { _typeof = function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/* ========================================================================
 * Bootstrap: affix.js v3.4.1
 * https://getbootstrap.com/docs/3.4/javascript/#affix
 * ========================================================================
 * Copyright 2011-2019 Twitter, Inc.
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE)
 * ======================================================================== */
+function ($) {
  'use strict'; // AFFIX CLASS DEFINITION
  // ======================

  var Affix = function (element, options) {
    this.options = $.extend({}, Affix.DEFAULTS, options);
    var target = this.options.target === Affix.DEFAULTS.target ? $(this.options.target) : $(document).find(this.options.target);
    this.$target = target.on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this)).on('click.bs.affix.data-api', $.proxy(this.checkPositionWithEventLoop, this));
    this.$element = $(element);
    this.affixed = null;
    this.unpin = null;
    this.pinnedOffset = null;
    this.checkPosition();
  };

  Affix.VERSION = '3.4.1';
  Affix.RESET = 'affix affix-top affix-bottom';
  Affix.DEFAULTS = {
    offset: 0,
    target: window
  };

  Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {
    var scrollTop = this.$target.scrollTop();
    var position = this.$element.offset();
    var targetHeight = this.$target.height();
    if (offsetTop != null && this.affixed == 'top') return scrollTop < offsetTop ? 'top' : false;

    if (this.affixed == 'bottom') {
      if (offsetTop != null) return scrollTop + this.unpin <= position.top ? false : 'bottom';
      return scrollTop + targetHeight <= scrollHeight - offsetBottom ? false : 'bottom';
    }

    var initializing = this.affixed == null;
    var colliderTop = initializing ? scrollTop : position.top;
    var colliderHeight = initializing ? targetHeight : height;
    if (offsetTop != null && scrollTop <= offsetTop) return 'top';
    if (offsetBottom != null && colliderTop + colliderHeight >= scrollHeight - offsetBottom) return 'bottom';
    return false;
  };

  Affix.prototype.getPinnedOffset = function () {
    if (this.pinnedOffset) return this.pinnedOffset;
    this.$element.removeClass(Affix.RESET).addClass('affix');
    var scrollTop = this.$target.scrollTop();
    var position = this.$element.offset();
    return this.pinnedOffset = position.top - scrollTop;
  };

  Affix.prototype.checkPositionWithEventLoop = function () {
    setTimeout($.proxy(this.checkPosition, this), 1);
  };

  Affix.prototype.checkPosition = function () {
    if (!this.$element.is(':visible')) return;
    var height = this.$element.height();
    var offset = this.options.offset;
    var offsetTop = offset.top;
    var offsetBottom = offset.bottom;
    var scrollHeight = Math.max($(document).height(), $(document.body).height());
    if (_typeof(offset) != 'object') offsetBottom = offsetTop = offset;
    if (typeof offsetTop == 'function') offsetTop = offset.top(this.$element);
    if (typeof offsetBottom == 'function') offsetBottom = offset.bottom(this.$element);
    var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom);

    if (this.affixed != affix) {
      if (this.unpin != null) this.$element.css('top', '');
      var affixType = 'affix' + (affix ? '-' + affix : '');
      var e = $.Event(affixType + '.bs.affix');
      this.$element.trigger(e);
      if (e.isDefaultPrevented()) return;
      this.affixed = affix;
      this.unpin = affix == 'bottom' ? this.getPinnedOffset() : null;
      this.$element.removeClass(Affix.RESET).addClass(affixType).trigger(affixType.replace('affix', 'affixed') + '.bs.affix');
    }

    if (affix == 'bottom') {
      this.$element.offset({
        top: scrollHeight - height - offsetBottom
      });
    }
  }; // AFFIX PLUGIN DEFINITION
  // =======================


  function Plugin(option) {
    return this.each(function () {
      var $this = $(this);
      var data = $this.data('bs.affix');
      var options = _typeof(option) == 'object' && option;
      if (!data) $this.data('bs.affix', data = new Affix(this, options));
      if (typeof option == 'string') data[option]();
    });
  }

  var old = $.fn.affix;
  $.fn.affix = Plugin;
  $.fn.affix.Constructor = Affix; // AFFIX NO CONFLICT
  // =================

  $.fn.affix.noConflict = function () {
    $.fn.affix = old;
    return this;
  }; // AFFIX DATA-API
  // ==============


  $(window).on('load', function () {
    $('[data-spy="affix"]').each(function () {
      var $spy = $(this);
      var data = $spy.data();
      data.offset = data.offset || {};
      if (data.offsetBottom != null) data.offset.bottom = data.offsetBottom;
      if (data.offsetTop != null) data.offset.top = data.offsetTop;
      Plugin.call($spy, data);
    });
  });
}(jQuery);
},{}],"jv0N":[function(require,module,exports) {
// This file is autogenerated via the `commonjs` Grunt task. You can require() this file in a CommonJS environment.
require('../../js/transition.js');

require('../../js/alert.js');

require('../../js/button.js');

require('../../js/carousel.js');

require('../../js/collapse.js');

require('../../js/dropdown.js');

require('../../js/modal.js');

require('../../js/tooltip.js');

require('../../js/popover.js');

require('../../js/scrollspy.js');

require('../../js/tab.js');

require('../../js/affix.js');
},{"../../js/transition.js":"kDs4","../../js/alert.js":"UId9","../../js/button.js":"kLSm","../../js/carousel.js":"H0Sg","../../js/collapse.js":"JIxA","../../js/dropdown.js":"EkLL","../../js/modal.js":"cKcy","../../js/tooltip.js":"dtvv","../../js/popover.js":"N8dD","../../js/scrollspy.js":"F6iO","../../js/tab.js":"ZuDb","../../js/affix.js":"ZK0v"}],"gsgA":[function(require,module,exports) {

},{"./../fonts/glyphicons-halflings-regular.eot":[["glyphicons-halflings-regular.e3673d14.eot","HVSd"],"HVSd"],"./../fonts/glyphicons-halflings-regular.woff2":[["glyphicons-halflings-regular.b2fb4677.woff2","WkOq"],"WkOq"],"./../fonts/glyphicons-halflings-regular.woff":[["glyphicons-halflings-regular.0b190d8e.woff","yHVR"],"yHVR"],"./../fonts/glyphicons-halflings-regular.ttf":[["glyphicons-halflings-regular.5db79c4f.ttf","EFEd"],"EFEd"],"./../fonts/glyphicons-halflings-regular.svg":[["glyphicons-halflings-regular.f9ab423a.svg","ryRX"],"ryRX"]}],"Eofe":[function(require,module,exports) {

},{"./../webfonts/fa-brands-400.eot":[["fa-brands-400.e5cf17a2.eot","YH3g"],"YH3g"],"./../webfonts/fa-brands-400.woff2":[["fa-brands-400.fa2b50eb.woff2","qUWF"],"qUWF"],"./../webfonts/fa-brands-400.woff":[["fa-brands-400.76d38564.woff","d16i"],"d16i"],"./../webfonts/fa-brands-400.ttf":[["fa-brands-400.d8d82559.ttf","Lu1x"],"Lu1x"],"./../webfonts/fa-brands-400.svg":[["fa-brands-400.4d16fbfe.svg","GRGc"],"GRGc"],"./../webfonts/fa-regular-400.eot":[["fa-regular-400.b8524921.eot","nv22"],"nv22"],"./../webfonts/fa-regular-400.woff2":[["fa-regular-400.1f18e0a2.woff2","M504"],"M504"],"./../webfonts/fa-regular-400.woff":[["fa-regular-400.d7f209fa.woff","H1q6"],"H1q6"],"./../webfonts/fa-regular-400.ttf":[["fa-regular-400.da848ba3.ttf","Evul"],"Evul"],"./../webfonts/fa-regular-400.svg":[["fa-regular-400.2be1b64f.svg","D7rB"],"D7rB"],"./../webfonts/fa-solid-900.eot":[["fa-solid-900.4fe5d922.eot","ISQp"],"ISQp"],"./../webfonts/fa-solid-900.woff2":[["fa-solid-900.effee26e.woff2","PerI"],"PerI"],"./../webfonts/fa-solid-900.woff":[["fa-solid-900.187d4d4b.woff","nA9q"],"nA9q"],"./../webfonts/fa-solid-900.ttf":[["fa-solid-900.a633dba1.ttf","FJZt"],"FJZt"],"./../webfonts/fa-solid-900.svg":[["fa-solid-900.102f442e.svg","lFqB"],"lFqB"]}],"ju9n":[function(require,module,exports) {

},{}],"KA2S":[function(require,module,exports) {
var define;
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var runtime = (function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.
  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
    return obj[key];
  }
  try {
    // IE 8 has a broken Object.defineProperty that only works on DOM objects.
    define({}, "");
  } catch (err) {
    define = function(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []);

    // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.
    generator._invoke = makeInvokeMethod(innerFn, self, context);

    return generator;
  }
  exports.wrap = wrap;

  // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.
  function tryCatch(fn, obj, arg) {
    try {
      return { type: "normal", arg: fn.call(obj, arg) };
    } catch (err) {
      return { type: "throw", arg: err };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed";

  // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.
  var ContinueSentinel = {};

  // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.
  function Generator() {}
  function GeneratorFunction() {}
  function GeneratorFunctionPrototype() {}

  // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.
  var IteratorPrototype = {};
  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  if (NativeIteratorPrototype &&
      NativeIteratorPrototype !== Op &&
      hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype =
    Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunction.displayName = define(
    GeneratorFunctionPrototype,
    toStringTagSymbol,
    "GeneratorFunction"
  );

  // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.
  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function(method) {
      define(prototype, method, function(arg) {
        return this._invoke(method, arg);
      });
    });
  }

  exports.isGeneratorFunction = function(genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor
      ? ctor === GeneratorFunction ||
        // For the native GeneratorFunction constructor, the best we can
        // do is to check its .name property.
        (ctor.displayName || ctor.name) === "GeneratorFunction"
      : false;
  };

  exports.mark = function(genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;
      define(genFun, toStringTagSymbol, "GeneratorFunction");
    }
    genFun.prototype = Object.create(Gp);
    return genFun;
  };

  // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.
  exports.awrap = function(arg) {
    return { __await: arg };
  };

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);
      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;
        if (value &&
            typeof value === "object" &&
            hasOwn.call(value, "__await")) {
          return PromiseImpl.resolve(value.__await).then(function(value) {
            invoke("next", value, resolve, reject);
          }, function(err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return PromiseImpl.resolve(value).then(function(unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function(error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function(resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise =
        // If enqueue has been called before, then we want to wait until
        // all previous Promises have been resolved before calling invoke,
        // so that results are always delivered in the correct order. If
        // enqueue has not been called before, then it is important to
        // call invoke immediately, without waiting on a callback to fire,
        // so that the async generator function has the opportunity to do
        // any necessary setup in a predictable way. This predictability
        // is why the Promise constructor synchronously invokes its
        // executor callback, and why async functions synchronously
        // execute code before the first await. Since we implement simple
        // async functions in terms of async generators, it is especially
        // important to get this right, even though it requires care.
        previousPromise ? previousPromise.then(
          callInvokeWithMethodAndArg,
          // Avoid propagating failures to Promises returned by later
          // invocations of the iterator.
          callInvokeWithMethodAndArg
        ) : callInvokeWithMethodAndArg();
    }

    // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).
    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);
  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };
  exports.AsyncIterator = AsyncIterator;

  // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.
  exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    if (PromiseImpl === void 0) PromiseImpl = Promise;

    var iter = new AsyncIterator(
      wrap(innerFn, outerFn, self, tryLocsList),
      PromiseImpl
    );

    return exports.isGeneratorFunction(outerFn)
      ? iter // If outerFn is a generator, return the full iterator.
      : iter.next().then(function(result) {
          return result.done ? result.value : iter.next();
        });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;

    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        }

        // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;
        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);
          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;

        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);

        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;

        var record = tryCatch(innerFn, self, context);
        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done
            ? GenStateCompleted
            : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };

        } else if (record.type === "throw") {
          state = GenStateCompleted;
          // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.
          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  }

  // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.
  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];
    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError(
          "The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (! info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value;

      // Resume execution at the desired location (see delegateYield).
      context.next = delegate.nextLoc;

      // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.
      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }

    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    }

    // The delegate iterator is finished, so forget it and continue with
    // the outer generator.
    context.delegate = null;
    return ContinueSentinel;
  }

  // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.
  defineIteratorMethods(Gp);

  define(Gp, toStringTagSymbol, "Generator");

  // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.
  Gp[iteratorSymbol] = function() {
    return this;
  };

  Gp.toString = function() {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = { tryLoc: locs[0] };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{ tryLoc: "root" }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function(object) {
    var keys = [];
    for (var key in object) {
      keys.push(key);
    }
    keys.reverse();

    // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.
    return function next() {
      while (keys.length) {
        var key = keys.pop();
        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      }

      // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.
      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1, next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;

          return next;
        };

        return next.next = next;
      }
    }

    // Return an iterator with no values.
    return { next: doneResult };
  }
  exports.values = values;

  function doneResult() {
    return { value: undefined, done: true };
  }

  Context.prototype = {
    constructor: Context,

    reset: function(skipTempReset) {
      this.prev = 0;
      this.next = 0;
      // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.
      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;

      this.method = "next";
      this.arg = undefined;

      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" &&
              hasOwn.call(this, name) &&
              !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },

    stop: function() {
      this.done = true;

      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;
      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },

    dispatchException: function(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;
      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !! caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }

          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }

          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },

    abrupt: function(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc <= this.prev &&
            hasOwn.call(entry, "finallyLoc") &&
            this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry &&
          (type === "break" ||
           type === "continue") &&
          finallyEntry.tryLoc <= arg &&
          arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },

    complete: function(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" ||
          record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },

    finish: function(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },

    "catch": function(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;
          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }
          return thrown;
        }
      }

      // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.
      throw new Error("illegal catch attempt");
    },

    delegateYield: function(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  };

  // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.
  return exports;

}(
  // If this script is executing as a CommonJS module, use module.exports
  // as the regeneratorRuntime namespace. Otherwise create a new empty
  // object. Either way, the resulting object will be used to initialize
  // the regeneratorRuntime variable at the top of this file.
  typeof module === "object" ? module.exports : {}
));

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}

},{}],"Q2ym":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dependencies = exports.devDependencies = exports.scripts = exports.repository = exports.module = exports.jsdelivr = exports.unpkg = exports.main = exports.author = exports.license = exports.homepage = exports.keywords = exports.description = exports.version = exports.name = void 0;
var name = "d3";
exports.name = name;
var version = "4.13.0";
exports.version = version;
var description = "Data-Driven Documents";
exports.description = description;
var keywords = ["dom", "visualization", "svg", "animation", "canvas"];
exports.keywords = keywords;
var homepage = "https://d3js.org";
exports.homepage = homepage;
var license = "BSD-3-Clause";
exports.license = license;
var author = {
  "name": "Mike Bostock",
  "url": "https://bost.ocks.org/mike"
};
exports.author = author;
var main = "build/d3.node.js";
exports.main = main;
var unpkg = "build/d3.min.js";
exports.unpkg = unpkg;
var jsdelivr = "build/d3.min.js";
exports.jsdelivr = jsdelivr;
var _module = "index";
exports.module = _module;
var repository = {
  "type": "git",
  "url": "https://github.com/d3/d3.git"
};
exports.repository = repository;
var scripts = {
  "pretest": "rimraf build && mkdir build && json2module package.json > build/package.js && node rollup.node",
  "test": "tape 'test/**/*-test.js'",
  "prepublishOnly": "npm run test && rollup -c --banner \"$(preamble)\" && uglifyjs -b beautify=false,preamble=\"'$(preamble)'\" build/d3.js -c negate_iife=false -m -o build/d3.min.js",
  "postpublish": "git push && git push --tags && cd ../d3.github.com && git pull && cp ../d3/build/d3.js d3.v4.js && cp ../d3/build/d3.min.js d3.v4.min.js && git add d3.v4.js d3.v4.min.js && git commit -m \"d3 ${npm_package_version}\" && git push && cd - && cd ../d3-bower && git pull && cp ../d3/LICENSE ../d3/README.md ../d3/build/d3.js ../d3/build/d3.min.js . && git add -- LICENSE README.md d3.js d3.min.js && git commit -m \"${npm_package_version}\" && git tag -am \"${npm_package_version}\" v${npm_package_version} && git push && git push --tags && cd - && zip -j build/d3.zip -- LICENSE README.md API.md CHANGES.md build/d3.js build/d3.min.js"
};
exports.scripts = scripts;
var devDependencies = {
  "json2module": "0.0",
  "package-preamble": "0.1",
  "rimraf": "2",
  "rollup": "0.53",
  "rollup-plugin-ascii": "0.0",
  "rollup-plugin-node-resolve": "3",
  "tape": "4",
  "uglify-js": "3.2"
};
exports.devDependencies = devDependencies;
var dependencies = {
  "d3-array": "1.2.1",
  "d3-axis": "1.0.8",
  "d3-brush": "1.0.4",
  "d3-chord": "1.0.4",
  "d3-collection": "1.0.4",
  "d3-color": "1.0.3",
  "d3-dispatch": "1.0.3",
  "d3-drag": "1.2.1",
  "d3-dsv": "1.0.8",
  "d3-ease": "1.0.3",
  "d3-force": "1.1.0",
  "d3-format": "1.2.2",
  "d3-geo": "1.9.1",
  "d3-hierarchy": "1.1.5",
  "d3-interpolate": "1.1.6",
  "d3-path": "1.0.5",
  "d3-polygon": "1.0.3",
  "d3-quadtree": "1.0.3",
  "d3-queue": "3.0.7",
  "d3-random": "1.1.0",
  "d3-request": "1.0.6",
  "d3-scale": "1.0.7",
  "d3-selection": "1.3.0",
  "d3-shape": "1.2.0",
  "d3-time": "1.0.8",
  "d3-time-format": "2.1.1",
  "d3-timer": "1.0.7",
  "d3-transition": "1.1.1",
  "d3-voronoi": "1.1.2",
  "d3-zoom": "1.7.1"
};
exports.dependencies = dependencies;
},{}],"A6FA":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}
},{}],"raOJ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _ascending = _interopRequireDefault(require("./ascending"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(compare) {
  if (compare.length === 1) compare = ascendingComparator(compare);
  return {
    left: function (a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;

      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) < 0) lo = mid + 1;else hi = mid;
      }

      return lo;
    },
    right: function (a, x, lo, hi) {
      if (lo == null) lo = 0;
      if (hi == null) hi = a.length;

      while (lo < hi) {
        var mid = lo + hi >>> 1;
        if (compare(a[mid], x) > 0) hi = mid;else lo = mid + 1;
      }

      return lo;
    }
  };
}

function ascendingComparator(f) {
  return function (d, x) {
    return (0, _ascending.default)(f(d), x);
  };
}
},{"./ascending":"A6FA"}],"VXHZ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.bisectLeft = exports.bisectRight = void 0;

var _ascending = _interopRequireDefault(require("./ascending"));

var _bisector = _interopRequireDefault(require("./bisector"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var ascendingBisect = (0, _bisector.default)(_ascending.default);
var bisectRight = ascendingBisect.right;
exports.bisectRight = bisectRight;
var bisectLeft = ascendingBisect.left;
exports.bisectLeft = bisectLeft;
var _default = bisectRight;
exports.default = _default;
},{"./ascending":"A6FA","./bisector":"raOJ"}],"aKlf":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.pair = pair;

function _default(array, f) {
  if (f == null) f = pair;
  var i = 0,
      n = array.length - 1,
      p = array[0],
      pairs = new Array(n < 0 ? 0 : n);

  while (i < n) pairs[i] = f(p, p = array[++i]);

  return pairs;
}

function pair(a, b) {
  return [a, b];
}
},{}],"JGhM":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _pairs = require("./pairs");

function _default(values0, values1, reduce) {
  var n0 = values0.length,
      n1 = values1.length,
      values = new Array(n0 * n1),
      i0,
      i1,
      i,
      value0;
  if (reduce == null) reduce = _pairs.pair;

  for (i0 = i = 0; i0 < n0; ++i0) {
    for (value0 = values0[i0], i1 = 0; i1 < n1; ++i1, ++i) {
      values[i] = reduce(value0, values1[i1]);
    }
  }

  return values;
}
},{"./pairs":"aKlf"}],"wjXp":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(a, b) {
  return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;
}
},{}],"fzXe":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(x) {
  return x === null ? NaN : +x;
}
},{}],"IBjk":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _number = _interopRequireDefault(require("./number"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(values, valueof) {
  var n = values.length,
      m = 0,
      i = -1,
      mean = 0,
      value,
      delta,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = (0, _number.default)(values[i]))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  } else {
    while (++i < n) {
      if (!isNaN(value = (0, _number.default)(valueof(values[i], i, values)))) {
        delta = value - mean;
        mean += delta / ++m;
        sum += delta * (value - mean);
      }
    }
  }

  if (m > 1) return sum / (m - 1);
}
},{"./number":"fzXe"}],"JPBu":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _variance = _interopRequireDefault(require("./variance"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(array, f) {
  var v = (0, _variance.default)(array, f);
  return v ? Math.sqrt(v) : v;
}
},{"./variance":"IBjk"}],"tlMU":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min,
      max;

  if (valueof == null) {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = max = value;

        while (++i < n) {
          // Compare the remaining values.
          if ((value = values[i]) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  } else {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = max = value;

        while (++i < n) {
          // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null) {
            if (min > value) min = value;
            if (max < value) max = value;
          }
        }
      }
    }
  }

  return [min, max];
}
},{}],"OA0j":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.map = exports.slice = void 0;
var array = Array.prototype;
var slice = array.slice;
exports.slice = slice;
var map = array.map;
exports.map = map;
},{}],"OY6d":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(x) {
  return function () {
    return x;
  };
}
},{}],"nPOL":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(x) {
  return x;
}
},{}],"M46h":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(start, stop, step) {
  start = +start, stop = +stop, step = (n = arguments.length) < 2 ? (stop = start, start = 0, 1) : n < 3 ? 1 : +step;
  var i = -1,
      n = Math.max(0, Math.ceil((stop - start) / step)) | 0,
      range = new Array(n);

  while (++i < n) {
    range[i] = start + i * step;
  }

  return range;
}
},{}],"nJNY":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.tickIncrement = tickIncrement;
exports.tickStep = tickStep;
var e10 = Math.sqrt(50),
    e5 = Math.sqrt(10),
    e2 = Math.sqrt(2);

function _default(start, stop, count) {
  var reverse,
      i = -1,
      n,
      ticks,
      step;
  stop = +stop, start = +start, count = +count;
  if (start === stop && count > 0) return [start];
  if (reverse = stop < start) n = start, start = stop, stop = n;
  if ((step = tickIncrement(start, stop, count)) === 0 || !isFinite(step)) return [];

  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));

    while (++i < n) ticks[i] = (start + i) * step;
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(start - stop + 1));

    while (++i < n) ticks[i] = (start - i) / step;
  }

  if (reverse) ticks.reverse();
  return ticks;
}

function tickIncrement(start, stop, count) {
  var step = (stop - start) / Math.max(0, count),
      power = Math.floor(Math.log(step) / Math.LN10),
      error = step / Math.pow(10, power);
  return power >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power) : -Math.pow(10, -power) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}

function tickStep(start, stop, count) {
  var step0 = Math.abs(stop - start) / Math.max(0, count),
      step1 = Math.pow(10, Math.floor(Math.log(step0) / Math.LN10)),
      error = step0 / step1;
  if (error >= e10) step1 *= 10;else if (error >= e5) step1 *= 5;else if (error >= e2) step1 *= 2;
  return stop < start ? -step1 : step1;
}
},{}],"PgUT":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(values) {
  return Math.ceil(Math.log(values.length) / Math.LN2) + 1;
}
},{}],"eRk3":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _array = require("./array");

var _bisect = _interopRequireDefault(require("./bisect"));

var _constant = _interopRequireDefault(require("./constant"));

var _extent = _interopRequireDefault(require("./extent"));

var _identity = _interopRequireDefault(require("./identity"));

var _range = _interopRequireDefault(require("./range"));

var _ticks = require("./ticks");

var _sturges = _interopRequireDefault(require("./threshold/sturges"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default() {
  var value = _identity.default,
      domain = _extent.default,
      threshold = _sturges.default;

  function histogram(data) {
    var i,
        n = data.length,
        x,
        values = new Array(n);

    for (i = 0; i < n; ++i) {
      values[i] = value(data[i], i, data);
    }

    var xz = domain(values),
        x0 = xz[0],
        x1 = xz[1],
        tz = threshold(values, x0, x1); // Convert number of thresholds into uniform thresholds.

    if (!Array.isArray(tz)) {
      tz = (0, _ticks.tickStep)(x0, x1, tz);
      tz = (0, _range.default)(Math.ceil(x0 / tz) * tz, Math.floor(x1 / tz) * tz, tz); // exclusive
    } // Remove any thresholds outside the domain.


    var m = tz.length;

    while (tz[0] <= x0) tz.shift(), --m;

    while (tz[m - 1] > x1) tz.pop(), --m;

    var bins = new Array(m + 1),
        bin; // Initialize bins.

    for (i = 0; i <= m; ++i) {
      bin = bins[i] = [];
      bin.x0 = i > 0 ? tz[i - 1] : x0;
      bin.x1 = i < m ? tz[i] : x1;
    } // Assign data to bins by value, ignoring any outside the domain.


    for (i = 0; i < n; ++i) {
      x = values[i];

      if (x0 <= x && x <= x1) {
        bins[(0, _bisect.default)(tz, x, 0, m)].push(data[i]);
      }
    }

    return bins;
  }

  histogram.value = function (_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : (0, _constant.default)(_), histogram) : value;
  };

  histogram.domain = function (_) {
    return arguments.length ? (domain = typeof _ === "function" ? _ : (0, _constant.default)([_[0], _[1]]), histogram) : domain;
  };

  histogram.thresholds = function (_) {
    return arguments.length ? (threshold = typeof _ === "function" ? _ : Array.isArray(_) ? (0, _constant.default)(_array.slice.call(_)) : (0, _constant.default)(_), histogram) : threshold;
  };

  return histogram;
}
},{"./array":"OA0j","./bisect":"VXHZ","./constant":"OY6d","./extent":"tlMU","./identity":"nPOL","./range":"M46h","./ticks":"nJNY","./threshold/sturges":"PgUT"}],"qoxw":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _number = _interopRequireDefault(require("./number"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(values, p, valueof) {
  if (valueof == null) valueof = _number.default;
  if (!(n = values.length)) return;
  if ((p = +p) <= 0 || n < 2) return +valueof(values[0], 0, values);
  if (p >= 1) return +valueof(values[n - 1], n - 1, values);
  var n,
      i = (n - 1) * p,
      i0 = Math.floor(i),
      value0 = +valueof(values[i0], i0, values),
      value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
}
},{"./number":"fzXe"}],"a8Ry":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _array = require("../array");

var _ascending = _interopRequireDefault(require("../ascending"));

var _number = _interopRequireDefault(require("../number"));

var _quantile = _interopRequireDefault(require("../quantile"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(values, min, max) {
  values = _array.map.call(values, _number.default).sort(_ascending.default);
  return Math.ceil((max - min) / (2 * ((0, _quantile.default)(values, 0.75) - (0, _quantile.default)(values, 0.25)) * Math.pow(values.length, -1 / 3)));
}
},{"../array":"OA0j","../ascending":"A6FA","../number":"fzXe","../quantile":"qoxw"}],"VlA4":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _deviation = _interopRequireDefault(require("../deviation"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(values, min, max) {
  return Math.ceil((max - min) / (3.5 * (0, _deviation.default)(values) * Math.pow(values.length, -1 / 3)));
}
},{"../deviation":"JPBu"}],"Raoi":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      max;

  if (valueof == null) {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        max = value;

        while (++i < n) {
          // Compare the remaining values.
          if ((value = values[i]) != null && value > max) {
            max = value;
          }
        }
      }
    }
  } else {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        max = value;

        while (++i < n) {
          // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && value > max) {
            max = value;
          }
        }
      }
    }
  }

  return max;
}
},{}],"hoEE":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _number = _interopRequireDefault(require("./number"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(values, valueof) {
  var n = values.length,
      m = n,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = (0, _number.default)(values[i]))) sum += value;else --m;
    }
  } else {
    while (++i < n) {
      if (!isNaN(value = (0, _number.default)(valueof(values[i], i, values)))) sum += value;else --m;
    }
  }

  if (m) return sum / m;
}
},{"./number":"fzXe"}],"FMd1":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _ascending = _interopRequireDefault(require("./ascending"));

var _number = _interopRequireDefault(require("./number"));

var _quantile = _interopRequireDefault(require("./quantile"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      numbers = [];

  if (valueof == null) {
    while (++i < n) {
      if (!isNaN(value = (0, _number.default)(values[i]))) {
        numbers.push(value);
      }
    }
  } else {
    while (++i < n) {
      if (!isNaN(value = (0, _number.default)(valueof(values[i], i, values)))) {
        numbers.push(value);
      }
    }
  }

  return (0, _quantile.default)(numbers.sort(_ascending.default), 0.5);
}
},{"./ascending":"A6FA","./number":"fzXe","./quantile":"qoxw"}],"SAjT":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(arrays) {
  var n = arrays.length,
      m,
      i = -1,
      j = 0,
      merged,
      array;

  while (++i < n) j += arrays[i].length;

  merged = new Array(j);

  while (--n >= 0) {
    array = arrays[n];
    m = array.length;

    while (--m >= 0) {
      merged[--j] = array[m];
    }
  }

  return merged;
}
},{}],"WLfU":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      min;

  if (valueof == null) {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = values[i]) != null && value >= value) {
        min = value;

        while (++i < n) {
          // Compare the remaining values.
          if ((value = values[i]) != null && min > value) {
            min = value;
          }
        }
      }
    }
  } else {
    while (++i < n) {
      // Find the first comparable value.
      if ((value = valueof(values[i], i, values)) != null && value >= value) {
        min = value;

        while (++i < n) {
          // Compare the remaining values.
          if ((value = valueof(values[i], i, values)) != null && min > value) {
            min = value;
          }
        }
      }
    }
  }

  return min;
}
},{}],"V5Z5":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(array, indexes) {
  var i = indexes.length,
      permutes = new Array(i);

  while (i--) permutes[i] = array[indexes[i]];

  return permutes;
}
},{}],"c8hi":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _ascending = _interopRequireDefault(require("./ascending"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(values, compare) {
  if (!(n = values.length)) return;
  var n,
      i = 0,
      j = 0,
      xi,
      xj = values[j];
  if (compare == null) compare = _ascending.default;

  while (++i < n) {
    if (compare(xi = values[i], xj) < 0 || compare(xj, xj) !== 0) {
      xj = xi, j = i;
    }
  }

  if (compare(xj, xj) === 0) return j;
}
},{"./ascending":"A6FA"}],"Z0Nc":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(array, i0, i1) {
  var m = (i1 == null ? array.length : i1) - (i0 = i0 == null ? 0 : +i0),
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m + i0];
    array[m + i0] = array[i + i0];
    array[i + i0] = t;
  }

  return array;
}
},{}],"O7Vy":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(values, valueof) {
  var n = values.length,
      i = -1,
      value,
      sum = 0;

  if (valueof == null) {
    while (++i < n) {
      if (value = +values[i]) sum += value; // Note: zero and null are equivalent.
    }
  } else {
    while (++i < n) {
      if (value = +valueof(values[i], i, values)) sum += value;
    }
  }

  return sum;
}
},{}],"pk0a":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _min = _interopRequireDefault(require("./min"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(matrix) {
  if (!(n = matrix.length)) return [];

  for (var i = -1, m = (0, _min.default)(matrix, length), transpose = new Array(m); ++i < m;) {
    for (var j = -1, n, row = transpose[i] = new Array(n); ++j < n;) {
      row[j] = matrix[j][i];
    }
  }

  return transpose;
}

function length(d) {
  return d.length;
}
},{"./min":"WLfU"}],"oAxq":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _transpose = _interopRequireDefault(require("./transpose"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default() {
  return (0, _transpose.default)(arguments);
}
},{"./transpose":"pk0a"}],"ybfZ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "bisect", {
  enumerable: true,
  get: function () {
    return _bisect.default;
  }
});
Object.defineProperty(exports, "bisectRight", {
  enumerable: true,
  get: function () {
    return _bisect.bisectRight;
  }
});
Object.defineProperty(exports, "bisectLeft", {
  enumerable: true,
  get: function () {
    return _bisect.bisectLeft;
  }
});
Object.defineProperty(exports, "ascending", {
  enumerable: true,
  get: function () {
    return _ascending.default;
  }
});
Object.defineProperty(exports, "bisector", {
  enumerable: true,
  get: function () {
    return _bisector.default;
  }
});
Object.defineProperty(exports, "cross", {
  enumerable: true,
  get: function () {
    return _cross.default;
  }
});
Object.defineProperty(exports, "descending", {
  enumerable: true,
  get: function () {
    return _descending.default;
  }
});
Object.defineProperty(exports, "deviation", {
  enumerable: true,
  get: function () {
    return _deviation.default;
  }
});
Object.defineProperty(exports, "extent", {
  enumerable: true,
  get: function () {
    return _extent.default;
  }
});
Object.defineProperty(exports, "histogram", {
  enumerable: true,
  get: function () {
    return _histogram.default;
  }
});
Object.defineProperty(exports, "thresholdFreedmanDiaconis", {
  enumerable: true,
  get: function () {
    return _freedmanDiaconis.default;
  }
});
Object.defineProperty(exports, "thresholdScott", {
  enumerable: true,
  get: function () {
    return _scott.default;
  }
});
Object.defineProperty(exports, "thresholdSturges", {
  enumerable: true,
  get: function () {
    return _sturges.default;
  }
});
Object.defineProperty(exports, "max", {
  enumerable: true,
  get: function () {
    return _max.default;
  }
});
Object.defineProperty(exports, "mean", {
  enumerable: true,
  get: function () {
    return _mean.default;
  }
});
Object.defineProperty(exports, "median", {
  enumerable: true,
  get: function () {
    return _median.default;
  }
});
Object.defineProperty(exports, "merge", {
  enumerable: true,
  get: function () {
    return _merge.default;
  }
});
Object.defineProperty(exports, "min", {
  enumerable: true,
  get: function () {
    return _min.default;
  }
});
Object.defineProperty(exports, "pairs", {
  enumerable: true,
  get: function () {
    return _pairs.default;
  }
});
Object.defineProperty(exports, "permute", {
  enumerable: true,
  get: function () {
    return _permute.default;
  }
});
Object.defineProperty(exports, "quantile", {
  enumerable: true,
  get: function () {
    return _quantile.default;
  }
});
Object.defineProperty(exports, "range", {
  enumerable: true,
  get: function () {
    return _range.default;
  }
});
Object.defineProperty(exports, "scan", {
  enumerable: true,
  get: function () {
    return _scan.default;
  }
});
Object.defineProperty(exports, "shuffle", {
  enumerable: true,
  get: function () {
    return _shuffle.default;
  }
});
Object.defineProperty(exports, "sum", {
  enumerable: true,
  get: function () {
    return _sum.default;
  }
});
Object.defineProperty(exports, "ticks", {
  enumerable: true,
  get: function () {
    return _ticks.default;
  }
});
Object.defineProperty(exports, "tickIncrement", {
  enumerable: true,
  get: function () {
    return _ticks.tickIncrement;
  }
});
Object.defineProperty(exports, "tickStep", {
  enumerable: true,
  get: function () {
    return _ticks.tickStep;
  }
});
Object.defineProperty(exports, "transpose", {
  enumerable: true,
  get: function () {
    return _transpose.default;
  }
});
Object.defineProperty(exports, "variance", {
  enumerable: true,
  get: function () {
    return _variance.default;
  }
});
Object.defineProperty(exports, "zip", {
  enumerable: true,
  get: function () {
    return _zip.default;
  }
});

var _bisect = _interopRequireWildcard(require("./src/bisect"));

var _ascending = _interopRequireDefault(require("./src/ascending"));

var _bisector = _interopRequireDefault(require("./src/bisector"));

var _cross = _interopRequireDefault(require("./src/cross"));

var _descending = _interopRequireDefault(require("./src/descending"));

var _deviation = _interopRequireDefault(require("./src/deviation"));

var _extent = _interopRequireDefault(require("./src/extent"));

var _histogram = _interopRequireDefault(require("./src/histogram"));

var _freedmanDiaconis = _interopRequireDefault(require("./src/threshold/freedmanDiaconis"));

var _scott = _interopRequireDefault(require("./src/threshold/scott"));

var _sturges = _interopRequireDefault(require("./src/threshold/sturges"));

var _max = _interopRequireDefault(require("./src/max"));

var _mean = _interopRequireDefault(require("./src/mean"));

var _median = _interopRequireDefault(require("./src/median"));

var _merge = _interopRequireDefault(require("./src/merge"));

var _min = _interopRequireDefault(require("./src/min"));

var _pairs = _interopRequireDefault(require("./src/pairs"));

var _permute = _interopRequireDefault(require("./src/permute"));

var _quantile = _interopRequireDefault(require("./src/quantile"));

var _range = _interopRequireDefault(require("./src/range"));

var _scan = _interopRequireDefault(require("./src/scan"));

var _shuffle = _interopRequireDefault(require("./src/shuffle"));

var _sum = _interopRequireDefault(require("./src/sum"));

var _ticks = _interopRequireWildcard(require("./src/ticks"));

var _transpose = _interopRequireDefault(require("./src/transpose"));

var _variance = _interopRequireDefault(require("./src/variance"));

var _zip = _interopRequireDefault(require("./src/zip"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
},{"./src/bisect":"VXHZ","./src/ascending":"A6FA","./src/bisector":"raOJ","./src/cross":"JGhM","./src/descending":"wjXp","./src/deviation":"JPBu","./src/extent":"tlMU","./src/histogram":"eRk3","./src/threshold/freedmanDiaconis":"a8Ry","./src/threshold/scott":"VlA4","./src/threshold/sturges":"PgUT","./src/max":"Raoi","./src/mean":"hoEE","./src/median":"FMd1","./src/merge":"SAjT","./src/min":"WLfU","./src/pairs":"aKlf","./src/permute":"V5Z5","./src/quantile":"qoxw","./src/range":"M46h","./src/scan":"c8hi","./src/shuffle":"Z0Nc","./src/sum":"O7Vy","./src/ticks":"nJNY","./src/transpose":"pk0a","./src/variance":"IBjk","./src/zip":"oAxq"}],"rv5q":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.slice = void 0;
var slice = Array.prototype.slice;
exports.slice = slice;
},{}],"Qz6O":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.axisTop = axisTop;
exports.axisRight = axisRight;
exports.axisBottom = axisBottom;
exports.axisLeft = axisLeft;

var _array = require("./array");

var _identity = _interopRequireDefault(require("./identity"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var top = 1,
    right = 2,
    bottom = 3,
    left = 4,
    epsilon = 1e-6;

function translateX(x) {
  return "translate(" + (x + 0.5) + ",0)";
}

function translateY(y) {
  return "translate(0," + (y + 0.5) + ")";
}

function number(scale) {
  return function (d) {
    return +scale(d);
  };
}

function center(scale) {
  var offset = Math.max(0, scale.bandwidth() - 1) / 2; // Adjust for 0.5px offset.

  if (scale.round()) offset = Math.round(offset);
  return function (d) {
    return +scale(d) + offset;
  };
}

function entering() {
  return !this.__axis;
}

function axis(orient, scale) {
  var tickArguments = [],
      tickValues = null,
      tickFormat = null,
      tickSizeInner = 6,
      tickSizeOuter = 6,
      tickPadding = 3,
      k = orient === top || orient === left ? -1 : 1,
      x = orient === left || orient === right ? "x" : "y",
      transform = orient === top || orient === bottom ? translateX : translateY;

  function axis(context) {
    var values = tickValues == null ? scale.ticks ? scale.ticks.apply(scale, tickArguments) : scale.domain() : tickValues,
        format = tickFormat == null ? scale.tickFormat ? scale.tickFormat.apply(scale, tickArguments) : _identity.default : tickFormat,
        spacing = Math.max(tickSizeInner, 0) + tickPadding,
        range = scale.range(),
        range0 = +range[0] + 0.5,
        range1 = +range[range.length - 1] + 0.5,
        position = (scale.bandwidth ? center : number)(scale.copy()),
        selection = context.selection ? context.selection() : context,
        path = selection.selectAll(".domain").data([null]),
        tick = selection.selectAll(".tick").data(values, scale).order(),
        tickExit = tick.exit(),
        tickEnter = tick.enter().append("g").attr("class", "tick"),
        line = tick.select("line"),
        text = tick.select("text");
    path = path.merge(path.enter().insert("path", ".tick").attr("class", "domain").attr("stroke", "#000"));
    tick = tick.merge(tickEnter);
    line = line.merge(tickEnter.append("line").attr("stroke", "#000").attr(x + "2", k * tickSizeInner));
    text = text.merge(tickEnter.append("text").attr("fill", "#000").attr(x, k * spacing).attr("dy", orient === top ? "0em" : orient === bottom ? "0.71em" : "0.32em"));

    if (context !== selection) {
      path = path.transition(context);
      tick = tick.transition(context);
      line = line.transition(context);
      text = text.transition(context);
      tickExit = tickExit.transition(context).attr("opacity", epsilon).attr("transform", function (d) {
        return isFinite(d = position(d)) ? transform(d) : this.getAttribute("transform");
      });
      tickEnter.attr("opacity", epsilon).attr("transform", function (d) {
        var p = this.parentNode.__axis;
        return transform(p && isFinite(p = p(d)) ? p : position(d));
      });
    }

    tickExit.remove();
    path.attr("d", orient === left || orient == right ? "M" + k * tickSizeOuter + "," + range0 + "H0.5V" + range1 + "H" + k * tickSizeOuter : "M" + range0 + "," + k * tickSizeOuter + "V0.5H" + range1 + "V" + k * tickSizeOuter);
    tick.attr("opacity", 1).attr("transform", function (d) {
      return transform(position(d));
    });
    line.attr(x + "2", k * tickSizeInner);
    text.attr(x, k * spacing).text(format);
    selection.filter(entering).attr("fill", "none").attr("font-size", 10).attr("font-family", "sans-serif").attr("text-anchor", orient === right ? "start" : orient === left ? "end" : "middle");
    selection.each(function () {
      this.__axis = position;
    });
  }

  axis.scale = function (_) {
    return arguments.length ? (scale = _, axis) : scale;
  };

  axis.ticks = function () {
    return tickArguments = _array.slice.call(arguments), axis;
  };

  axis.tickArguments = function (_) {
    return arguments.length ? (tickArguments = _ == null ? [] : _array.slice.call(_), axis) : tickArguments.slice();
  };

  axis.tickValues = function (_) {
    return arguments.length ? (tickValues = _ == null ? null : _array.slice.call(_), axis) : tickValues && tickValues.slice();
  };

  axis.tickFormat = function (_) {
    return arguments.length ? (tickFormat = _, axis) : tickFormat;
  };

  axis.tickSize = function (_) {
    return arguments.length ? (tickSizeInner = tickSizeOuter = +_, axis) : tickSizeInner;
  };

  axis.tickSizeInner = function (_) {
    return arguments.length ? (tickSizeInner = +_, axis) : tickSizeInner;
  };

  axis.tickSizeOuter = function (_) {
    return arguments.length ? (tickSizeOuter = +_, axis) : tickSizeOuter;
  };

  axis.tickPadding = function (_) {
    return arguments.length ? (tickPadding = +_, axis) : tickPadding;
  };

  return axis;
}

function axisTop(scale) {
  return axis(top, scale);
}

function axisRight(scale) {
  return axis(right, scale);
}

function axisBottom(scale) {
  return axis(bottom, scale);
}

function axisLeft(scale) {
  return axis(left, scale);
}
},{"./array":"rv5q","./identity":"nPOL"}],"cGCd":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "axisTop", {
  enumerable: true,
  get: function () {
    return _axis.axisTop;
  }
});
Object.defineProperty(exports, "axisRight", {
  enumerable: true,
  get: function () {
    return _axis.axisRight;
  }
});
Object.defineProperty(exports, "axisBottom", {
  enumerable: true,
  get: function () {
    return _axis.axisBottom;
  }
});
Object.defineProperty(exports, "axisLeft", {
  enumerable: true,
  get: function () {
    return _axis.axisLeft;
  }
});

var _axis = require("./src/axis");
},{"./src/axis":"Qz6O"}],"CLHd":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var noop = {
  value: function () {}
};

function dispatch() {
  for (var i = 0, n = arguments.length, _ = {}, t; i < n; ++i) {
    if (!(t = arguments[i] + "") || t in _) throw new Error("illegal type: " + t);
    _[t] = [];
  }

  return new Dispatch(_);
}

function Dispatch(_) {
  this._ = _;
}

function parseTypenames(typenames, types) {
  return typenames.trim().split(/^|\s+/).map(function (t) {
    var name = "",
        i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    if (t && !types.hasOwnProperty(t)) throw new Error("unknown type: " + t);
    return {
      type: t,
      name: name
    };
  });
}

Dispatch.prototype = dispatch.prototype = {
  constructor: Dispatch,
  on: function (typename, callback) {
    var _ = this._,
        T = parseTypenames(typename + "", _),
        t,
        i = -1,
        n = T.length; // If no callback was specified, return the callback of the given type and name.

    if (arguments.length < 2) {
      while (++i < n) if ((t = (typename = T[i]).type) && (t = get(_[t], typename.name))) return t;

      return;
    } // If a type was specified, set the callback for the given type and name.
    // Otherwise, if a null callback was specified, remove callbacks of the given name.


    if (callback != null && typeof callback !== "function") throw new Error("invalid callback: " + callback);

    while (++i < n) {
      if (t = (typename = T[i]).type) _[t] = set(_[t], typename.name, callback);else if (callback == null) for (t in _) _[t] = set(_[t], typename.name, null);
    }

    return this;
  },
  copy: function () {
    var copy = {},
        _ = this._;

    for (var t in _) copy[t] = _[t].slice();

    return new Dispatch(copy);
  },
  call: function (type, that) {
    if ((n = arguments.length - 2) > 0) for (var args = new Array(n), i = 0, n, t; i < n; ++i) args[i] = arguments[i + 2];
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);

    for (t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  },
  apply: function (type, that, args) {
    if (!this._.hasOwnProperty(type)) throw new Error("unknown type: " + type);

    for (var t = this._[type], i = 0, n = t.length; i < n; ++i) t[i].value.apply(that, args);
  }
};

function get(type, name) {
  for (var i = 0, n = type.length, c; i < n; ++i) {
    if ((c = type[i]).name === name) {
      return c.value;
    }
  }
}

function set(type, name, callback) {
  for (var i = 0, n = type.length; i < n; ++i) {
    if (type[i].name === name) {
      type[i] = noop, type = type.slice(0, i).concat(type.slice(i + 1));
      break;
    }
  }

  if (callback != null) type.push({
    name: name,
    value: callback
  });
  return type;
}

var _default = dispatch;
exports.default = _default;
},{}],"FHGa":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "dispatch", {
  enumerable: true,
  get: function () {
    return _dispatch.default;
  }
});

var _dispatch = _interopRequireDefault(require("./src/dispatch"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./src/dispatch":"CLHd"}],"UzOB":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.xhtml = void 0;
var xhtml = "http://www.w3.org/1999/xhtml";
exports.xhtml = xhtml;
var _default = {
  svg: "http://www.w3.org/2000/svg",
  xhtml: xhtml,
  xlink: "http://www.w3.org/1999/xlink",
  xml: "http://www.w3.org/XML/1998/namespace",
  xmlns: "http://www.w3.org/2000/xmlns/"
};
exports.default = _default;
},{}],"OLJ5":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _namespaces = _interopRequireDefault(require("./namespaces"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(name) {
  var prefix = name += "",
      i = prefix.indexOf(":");
  if (i >= 0 && (prefix = name.slice(0, i)) !== "xmlns") name = name.slice(i + 1);
  return _namespaces.default.hasOwnProperty(prefix) ? {
    space: _namespaces.default[prefix],
    local: name
  } : name;
}
},{"./namespaces":"UzOB"}],"EIjt":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _namespace = _interopRequireDefault(require("./namespace"));

var _namespaces = require("./namespaces");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function creatorInherit(name) {
  return function () {
    var document = this.ownerDocument,
        uri = this.namespaceURI;
    return uri === _namespaces.xhtml && document.documentElement.namespaceURI === _namespaces.xhtml ? document.createElement(name) : document.createElementNS(uri, name);
  };
}

function creatorFixed(fullname) {
  return function () {
    return this.ownerDocument.createElementNS(fullname.space, fullname.local);
  };
}

function _default(name) {
  var fullname = (0, _namespace.default)(name);
  return (fullname.local ? creatorFixed : creatorInherit)(fullname);
}
},{"./namespace":"OLJ5","./namespaces":"UzOB"}],"xs2I":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function none() {}

function _default(selector) {
  return selector == null ? none : function () {
    return this.querySelector(selector);
  };
}
},{}],"LRy5":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = require("./index");

var _selector = _interopRequireDefault(require("../selector"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(select) {
  if (typeof select !== "function") select = (0, _selector.default)(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
      }
    }
  }

  return new _index.Selection(subgroups, this._parents);
}
},{"./index":"jpDG","../selector":"xs2I"}],"mHY5":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function empty() {
  return [];
}

function _default(selector) {
  return selector == null ? empty : function () {
    return this.querySelectorAll(selector);
  };
}
},{}],"ijGs":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = require("./index");

var _selectorAll = _interopRequireDefault(require("../selectorAll"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(select) {
  if (typeof select !== "function") select = (0, _selectorAll.default)(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        subgroups.push(select.call(node, node.__data__, i, group));
        parents.push(node);
      }
    }
  }

  return new _index.Selection(subgroups, parents);
}
},{"./index":"jpDG","../selectorAll":"mHY5"}],"PkZe":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var matcher = function (selector) {
  return function () {
    return this.matches(selector);
  };
};

if (typeof document !== "undefined") {
  var element = document.documentElement;

  if (!element.matches) {
    var vendorMatches = element.webkitMatchesSelector || element.msMatchesSelector || element.mozMatchesSelector || element.oMatchesSelector;

    matcher = function (selector) {
      return function () {
        return vendorMatches.call(this, selector);
      };
    };
  }
}

var _default = matcher;
exports.default = _default;
},{}],"hrVj":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = require("./index");

var _matcher = _interopRequireDefault(require("../matcher"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(match) {
  if (typeof match !== "function") match = (0, _matcher.default)(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index.Selection(subgroups, this._parents);
}
},{"./index":"jpDG","../matcher":"PkZe"}],"NmjR":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(update) {
  return new Array(update.length);
}
},{}],"wXei":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.EnterNode = EnterNode;

var _sparse = _interopRequireDefault(require("./sparse"));

var _index = require("./index");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default() {
  return new _index.Selection(this._enter || this._groups.map(_sparse.default), this._parents);
}

function EnterNode(parent, datum) {
  this.ownerDocument = parent.ownerDocument;
  this.namespaceURI = parent.namespaceURI;
  this._next = null;
  this._parent = parent;
  this.__data__ = datum;
}

EnterNode.prototype = {
  constructor: EnterNode,
  appendChild: function (child) {
    return this._parent.insertBefore(child, this._next);
  },
  insertBefore: function (child, next) {
    return this._parent.insertBefore(child, next);
  },
  querySelector: function (selector) {
    return this._parent.querySelector(selector);
  },
  querySelectorAll: function (selector) {
    return this._parent.querySelectorAll(selector);
  }
};
},{"./sparse":"NmjR","./index":"jpDG"}],"QmPF":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = require("./index");

var _enter = require("./enter");

var _constant = _interopRequireDefault(require("../constant"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var keyPrefix = "$"; // Protect against keys like “__proto__”.

function bindIndex(parent, group, enter, update, exit, data) {
  var i = 0,
      node,
      groupLength = group.length,
      dataLength = data.length; // Put any non-null nodes that fit into update.
  // Put any null nodes into enter.
  // Put any remaining data into enter.

  for (; i < dataLength; ++i) {
    if (node = group[i]) {
      node.__data__ = data[i];
      update[i] = node;
    } else {
      enter[i] = new _enter.EnterNode(parent, data[i]);
    }
  } // Put any non-null nodes that don’t fit into exit.


  for (; i < groupLength; ++i) {
    if (node = group[i]) {
      exit[i] = node;
    }
  }
}

function bindKey(parent, group, enter, update, exit, data, key) {
  var i,
      node,
      nodeByKeyValue = {},
      groupLength = group.length,
      dataLength = data.length,
      keyValues = new Array(groupLength),
      keyValue; // Compute the key for each node.
  // If multiple nodes have the same key, the duplicates are added to exit.

  for (i = 0; i < groupLength; ++i) {
    if (node = group[i]) {
      keyValues[i] = keyValue = keyPrefix + key.call(node, node.__data__, i, group);

      if (keyValue in nodeByKeyValue) {
        exit[i] = node;
      } else {
        nodeByKeyValue[keyValue] = node;
      }
    }
  } // Compute the key for each datum.
  // If there a node associated with this key, join and add it to update.
  // If there is not (or the key is a duplicate), add it to enter.


  for (i = 0; i < dataLength; ++i) {
    keyValue = keyPrefix + key.call(parent, data[i], i, data);

    if (node = nodeByKeyValue[keyValue]) {
      update[i] = node;
      node.__data__ = data[i];
      nodeByKeyValue[keyValue] = null;
    } else {
      enter[i] = new _enter.EnterNode(parent, data[i]);
    }
  } // Add any remaining nodes that were not bound to data to exit.


  for (i = 0; i < groupLength; ++i) {
    if ((node = group[i]) && nodeByKeyValue[keyValues[i]] === node) {
      exit[i] = node;
    }
  }
}

function _default(value, key) {
  if (!value) {
    data = new Array(this.size()), j = -1;
    this.each(function (d) {
      data[++j] = d;
    });
    return data;
  }

  var bind = key ? bindKey : bindIndex,
      parents = this._parents,
      groups = this._groups;
  if (typeof value !== "function") value = (0, _constant.default)(value);

  for (var m = groups.length, update = new Array(m), enter = new Array(m), exit = new Array(m), j = 0; j < m; ++j) {
    var parent = parents[j],
        group = groups[j],
        groupLength = group.length,
        data = value.call(parent, parent && parent.__data__, j, parents),
        dataLength = data.length,
        enterGroup = enter[j] = new Array(dataLength),
        updateGroup = update[j] = new Array(dataLength),
        exitGroup = exit[j] = new Array(groupLength);
    bind(parent, group, enterGroup, updateGroup, exitGroup, data, key); // Now connect the enter nodes to their following update node, such that
    // appendChild can insert the materialized enter node before this node,
    // rather than at the end of the parent node.

    for (var i0 = 0, i1 = 0, previous, next; i0 < dataLength; ++i0) {
      if (previous = enterGroup[i0]) {
        if (i0 >= i1) i1 = i0 + 1;

        while (!(next = updateGroup[i1]) && ++i1 < dataLength);

        previous._next = next || null;
      }
    }
  }

  update = new _index.Selection(update, parents);
  update._enter = enter;
  update._exit = exit;
  return update;
}
},{"./index":"jpDG","./enter":"wXei","../constant":"OY6d"}],"tchs":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _sparse = _interopRequireDefault(require("./sparse"));

var _index = require("./index");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default() {
  return new _index.Selection(this._exit || this._groups.map(_sparse.default), this._parents);
}
},{"./sparse":"NmjR","./index":"jpDG"}],"i5nV":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = require("./index");

function _default(selection) {
  for (var groups0 = this._groups, groups1 = selection._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index.Selection(merges, this._parents);
}
},{"./index":"jpDG"}],"RepQ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default() {
  for (var groups = this._groups, j = -1, m = groups.length; ++j < m;) {
    for (var group = groups[j], i = group.length - 1, next = group[i], node; --i >= 0;) {
      if (node = group[i]) {
        if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);
        next = node;
      }
    }
  }

  return this;
}
},{}],"D8yW":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = require("./index");

function _default(compare) {
  if (!compare) compare = ascending;

  function compareNode(a, b) {
    return a && b ? compare(a.__data__, b.__data__) : !a - !b;
  }

  for (var groups = this._groups, m = groups.length, sortgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, sortgroup = sortgroups[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        sortgroup[i] = node;
      }
    }

    sortgroup.sort(compareNode);
  }

  return new _index.Selection(sortgroups, this._parents).order();
}

function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;
}
},{"./index":"jpDG"}],"pbQ4":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default() {
  var callback = arguments[0];
  arguments[0] = this;
  callback.apply(null, arguments);
  return this;
}
},{}],"kO0T":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default() {
  var nodes = new Array(this.size()),
      i = -1;
  this.each(function () {
    nodes[++i] = this;
  });
  return nodes;
}
},{}],"xFUP":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default() {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length; i < n; ++i) {
      var node = group[i];
      if (node) return node;
    }
  }

  return null;
}
},{}],"w9fp":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default() {
  var size = 0;
  this.each(function () {
    ++size;
  });
  return size;
}
},{}],"UFOA":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default() {
  return !this.node();
}
},{}],"q4XW":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(callback) {
  for (var groups = this._groups, j = 0, m = groups.length; j < m; ++j) {
    for (var group = groups[j], i = 0, n = group.length, node; i < n; ++i) {
      if (node = group[i]) callback.call(node, node.__data__, i, group);
    }
  }

  return this;
}
},{}],"Tdf9":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _namespace = _interopRequireDefault(require("../namespace"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function attrRemove(name) {
  return function () {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function () {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, value) {
  return function () {
    this.setAttribute(name, value);
  };
}

function attrConstantNS(fullname, value) {
  return function () {
    this.setAttributeNS(fullname.space, fullname.local, value);
  };
}

function attrFunction(name, value) {
  return function () {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttribute(name);else this.setAttribute(name, v);
  };
}

function attrFunctionNS(fullname, value) {
  return function () {
    var v = value.apply(this, arguments);
    if (v == null) this.removeAttributeNS(fullname.space, fullname.local);else this.setAttributeNS(fullname.space, fullname.local, v);
  };
}

function _default(name, value) {
  var fullname = (0, _namespace.default)(name);

  if (arguments.length < 2) {
    var node = this.node();
    return fullname.local ? node.getAttributeNS(fullname.space, fullname.local) : node.getAttribute(fullname);
  }

  return this.each((value == null ? fullname.local ? attrRemoveNS : attrRemove : typeof value === "function" ? fullname.local ? attrFunctionNS : attrFunction : fullname.local ? attrConstantNS : attrConstant)(fullname, value));
}
},{"../namespace":"OLJ5"}],"D1dR":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(node) {
  return node.ownerDocument && node.ownerDocument.defaultView || // node is a Node
  node.document && node // node is a Window
  || node.defaultView; // node is a Document
}
},{}],"VXjm":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.styleValue = styleValue;

var _window = _interopRequireDefault(require("../window"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function styleRemove(name) {
  return function () {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, value, priority) {
  return function () {
    this.style.setProperty(name, value, priority);
  };
}

function styleFunction(name, value, priority) {
  return function () {
    var v = value.apply(this, arguments);
    if (v == null) this.style.removeProperty(name);else this.style.setProperty(name, v, priority);
  };
}

function _default(name, value, priority) {
  return arguments.length > 1 ? this.each((value == null ? styleRemove : typeof value === "function" ? styleFunction : styleConstant)(name, value, priority == null ? "" : priority)) : styleValue(this.node(), name);
}

function styleValue(node, name) {
  return node.style.getPropertyValue(name) || (0, _window.default)(node).getComputedStyle(node, null).getPropertyValue(name);
}
},{"../window":"D1dR"}],"QOWh":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function propertyRemove(name) {
  return function () {
    delete this[name];
  };
}

function propertyConstant(name, value) {
  return function () {
    this[name] = value;
  };
}

function propertyFunction(name, value) {
  return function () {
    var v = value.apply(this, arguments);
    if (v == null) delete this[name];else this[name] = v;
  };
}

function _default(name, value) {
  return arguments.length > 1 ? this.each((value == null ? propertyRemove : typeof value === "function" ? propertyFunction : propertyConstant)(name, value)) : this.node()[name];
}
},{}],"rtNW":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function classArray(string) {
  return string.trim().split(/^|\s+/);
}

function classList(node) {
  return node.classList || new ClassList(node);
}

function ClassList(node) {
  this._node = node;
  this._names = classArray(node.getAttribute("class") || "");
}

ClassList.prototype = {
  add: function (name) {
    var i = this._names.indexOf(name);

    if (i < 0) {
      this._names.push(name);

      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  remove: function (name) {
    var i = this._names.indexOf(name);

    if (i >= 0) {
      this._names.splice(i, 1);

      this._node.setAttribute("class", this._names.join(" "));
    }
  },
  contains: function (name) {
    return this._names.indexOf(name) >= 0;
  }
};

function classedAdd(node, names) {
  var list = classList(node),
      i = -1,
      n = names.length;

  while (++i < n) list.add(names[i]);
}

function classedRemove(node, names) {
  var list = classList(node),
      i = -1,
      n = names.length;

  while (++i < n) list.remove(names[i]);
}

function classedTrue(names) {
  return function () {
    classedAdd(this, names);
  };
}

function classedFalse(names) {
  return function () {
    classedRemove(this, names);
  };
}

function classedFunction(names, value) {
  return function () {
    (value.apply(this, arguments) ? classedAdd : classedRemove)(this, names);
  };
}

function _default(name, value) {
  var names = classArray(name + "");

  if (arguments.length < 2) {
    var list = classList(this.node()),
        i = -1,
        n = names.length;

    while (++i < n) if (!list.contains(names[i])) return false;

    return true;
  }

  return this.each((typeof value === "function" ? classedFunction : value ? classedTrue : classedFalse)(names, value));
}
},{}],"hAJ3":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function textRemove() {
  this.textContent = "";
}

function textConstant(value) {
  return function () {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function () {
    var v = value.apply(this, arguments);
    this.textContent = v == null ? "" : v;
  };
}

function _default(value) {
  return arguments.length ? this.each(value == null ? textRemove : (typeof value === "function" ? textFunction : textConstant)(value)) : this.node().textContent;
}
},{}],"FiSM":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function htmlRemove() {
  this.innerHTML = "";
}

function htmlConstant(value) {
  return function () {
    this.innerHTML = value;
  };
}

function htmlFunction(value) {
  return function () {
    var v = value.apply(this, arguments);
    this.innerHTML = v == null ? "" : v;
  };
}

function _default(value) {
  return arguments.length ? this.each(value == null ? htmlRemove : (typeof value === "function" ? htmlFunction : htmlConstant)(value)) : this.node().innerHTML;
}
},{}],"gvi7":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function raise() {
  if (this.nextSibling) this.parentNode.appendChild(this);
}

function _default() {
  return this.each(raise);
}
},{}],"gv51":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function lower() {
  if (this.previousSibling) this.parentNode.insertBefore(this, this.parentNode.firstChild);
}

function _default() {
  return this.each(lower);
}
},{}],"efv1":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _creator = _interopRequireDefault(require("../creator"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(name) {
  var create = typeof name === "function" ? name : (0, _creator.default)(name);
  return this.select(function () {
    return this.appendChild(create.apply(this, arguments));
  });
}
},{"../creator":"EIjt"}],"ILQF":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _creator = _interopRequireDefault(require("../creator"));

var _selector = _interopRequireDefault(require("../selector"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function constantNull() {
  return null;
}

function _default(name, before) {
  var create = typeof name === "function" ? name : (0, _creator.default)(name),
      select = before == null ? constantNull : typeof before === "function" ? before : (0, _selector.default)(before);
  return this.select(function () {
    return this.insertBefore(create.apply(this, arguments), select.apply(this, arguments) || null);
  });
}
},{"../creator":"EIjt","../selector":"xs2I"}],"quBB":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function remove() {
  var parent = this.parentNode;
  if (parent) parent.removeChild(this);
}

function _default() {
  return this.each(remove);
}
},{}],"UpcG":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function selection_cloneShallow() {
  return this.parentNode.insertBefore(this.cloneNode(false), this.nextSibling);
}

function selection_cloneDeep() {
  return this.parentNode.insertBefore(this.cloneNode(true), this.nextSibling);
}

function _default(deep) {
  return this.select(deep ? selection_cloneDeep : selection_cloneShallow);
}
},{}],"fuQ8":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(value) {
  return arguments.length ? this.property("__data__", value) : this.node().__data__;
}
},{}],"j4rF":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.customEvent = customEvent;
exports.event = void 0;
var filterEvents = {};
var event = null;
exports.event = event;

if (typeof document !== "undefined") {
  var element = document.documentElement;

  if (!("onmouseenter" in element)) {
    filterEvents = {
      mouseenter: "mouseover",
      mouseleave: "mouseout"
    };
  }
}

function filterContextListener(listener, index, group) {
  listener = contextListener(listener, index, group);
  return function (event) {
    var related = event.relatedTarget;

    if (!related || related !== this && !(related.compareDocumentPosition(this) & 8)) {
      listener.call(this, event);
    }
  };
}

function contextListener(listener, index, group) {
  return function (event1) {
    var event0 = event; // Events can be reentrant (e.g., focus).

    exports.event = event = event1;

    try {
      listener.call(this, this.__data__, index, group);
    } finally {
      exports.event = event = event0;
    }
  };
}

function parseTypenames(typenames) {
  return typenames.trim().split(/^|\s+/).map(function (t) {
    var name = "",
        i = t.indexOf(".");
    if (i >= 0) name = t.slice(i + 1), t = t.slice(0, i);
    return {
      type: t,
      name: name
    };
  });
}

function onRemove(typename) {
  return function () {
    var on = this.__on;
    if (!on) return;

    for (var j = 0, i = -1, m = on.length, o; j < m; ++j) {
      if (o = on[j], (!typename.type || o.type === typename.type) && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
      } else {
        on[++i] = o;
      }
    }

    if (++i) on.length = i;else delete this.__on;
  };
}

function onAdd(typename, value, capture) {
  var wrap = filterEvents.hasOwnProperty(typename.type) ? filterContextListener : contextListener;
  return function (d, i, group) {
    var on = this.__on,
        o,
        listener = wrap(value, i, group);
    if (on) for (var j = 0, m = on.length; j < m; ++j) {
      if ((o = on[j]).type === typename.type && o.name === typename.name) {
        this.removeEventListener(o.type, o.listener, o.capture);
        this.addEventListener(o.type, o.listener = listener, o.capture = capture);
        o.value = value;
        return;
      }
    }
    this.addEventListener(typename.type, listener, capture);
    o = {
      type: typename.type,
      name: typename.name,
      value: value,
      listener: listener,
      capture: capture
    };
    if (!on) this.__on = [o];else on.push(o);
  };
}

function _default(typename, value, capture) {
  var typenames = parseTypenames(typename + ""),
      i,
      n = typenames.length,
      t;

  if (arguments.length < 2) {
    var on = this.node().__on;

    if (on) for (var j = 0, m = on.length, o; j < m; ++j) {
      for (i = 0, o = on[j]; i < n; ++i) {
        if ((t = typenames[i]).type === o.type && t.name === o.name) {
          return o.value;
        }
      }
    }
    return;
  }

  on = value ? onAdd : onRemove;
  if (capture == null) capture = false;

  for (i = 0; i < n; ++i) this.each(on(typenames[i], value, capture));

  return this;
}

function customEvent(event1, listener, that, args) {
  var event0 = event;
  event1.sourceEvent = event;
  exports.event = event = event1;

  try {
    return listener.apply(that, args);
  } finally {
    exports.event = event = event0;
  }
}
},{}],"enVu":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _window = _interopRequireDefault(require("../window"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function dispatchEvent(node, type, params) {
  var window = (0, _window.default)(node),
      event = window.CustomEvent;

  if (typeof event === "function") {
    event = new event(type, params);
  } else {
    event = window.document.createEvent("Event");
    if (params) event.initEvent(type, params.bubbles, params.cancelable), event.detail = params.detail;else event.initEvent(type, false, false);
  }

  node.dispatchEvent(event);
}

function dispatchConstant(type, params) {
  return function () {
    return dispatchEvent(this, type, params);
  };
}

function dispatchFunction(type, params) {
  return function () {
    return dispatchEvent(this, type, params.apply(this, arguments));
  };
}

function _default(type, params) {
  return this.each((typeof params === "function" ? dispatchFunction : dispatchConstant)(type, params));
}
},{"../window":"D1dR"}],"jpDG":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Selection = Selection;
exports.default = exports.root = void 0;

var _select = _interopRequireDefault(require("./select"));

var _selectAll = _interopRequireDefault(require("./selectAll"));

var _filter = _interopRequireDefault(require("./filter"));

var _data = _interopRequireDefault(require("./data"));

var _enter = _interopRequireDefault(require("./enter"));

var _exit = _interopRequireDefault(require("./exit"));

var _merge = _interopRequireDefault(require("./merge"));

var _order = _interopRequireDefault(require("./order"));

var _sort = _interopRequireDefault(require("./sort"));

var _call = _interopRequireDefault(require("./call"));

var _nodes = _interopRequireDefault(require("./nodes"));

var _node = _interopRequireDefault(require("./node"));

var _size = _interopRequireDefault(require("./size"));

var _empty = _interopRequireDefault(require("./empty"));

var _each = _interopRequireDefault(require("./each"));

var _attr = _interopRequireDefault(require("./attr"));

var _style = _interopRequireDefault(require("./style"));

var _property = _interopRequireDefault(require("./property"));

var _classed = _interopRequireDefault(require("./classed"));

var _text = _interopRequireDefault(require("./text"));

var _html = _interopRequireDefault(require("./html"));

var _raise = _interopRequireDefault(require("./raise"));

var _lower = _interopRequireDefault(require("./lower"));

var _append = _interopRequireDefault(require("./append"));

var _insert = _interopRequireDefault(require("./insert"));

var _remove = _interopRequireDefault(require("./remove"));

var _clone = _interopRequireDefault(require("./clone"));

var _datum = _interopRequireDefault(require("./datum"));

var _on = _interopRequireDefault(require("./on"));

var _dispatch = _interopRequireDefault(require("./dispatch"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var root = [null];
exports.root = root;

function Selection(groups, parents) {
  this._groups = groups;
  this._parents = parents;
}

function selection() {
  return new Selection([[document.documentElement]], root);
}

Selection.prototype = selection.prototype = {
  constructor: Selection,
  select: _select.default,
  selectAll: _selectAll.default,
  filter: _filter.default,
  data: _data.default,
  enter: _enter.default,
  exit: _exit.default,
  merge: _merge.default,
  order: _order.default,
  sort: _sort.default,
  call: _call.default,
  nodes: _nodes.default,
  node: _node.default,
  size: _size.default,
  empty: _empty.default,
  each: _each.default,
  attr: _attr.default,
  style: _style.default,
  property: _property.default,
  classed: _classed.default,
  text: _text.default,
  html: _html.default,
  raise: _raise.default,
  lower: _lower.default,
  append: _append.default,
  insert: _insert.default,
  remove: _remove.default,
  clone: _clone.default,
  datum: _datum.default,
  on: _on.default,
  dispatch: _dispatch.default
};
var _default = selection;
exports.default = _default;
},{"./select":"LRy5","./selectAll":"ijGs","./filter":"hrVj","./data":"QmPF","./enter":"wXei","./exit":"tchs","./merge":"i5nV","./order":"RepQ","./sort":"D8yW","./call":"pbQ4","./nodes":"kO0T","./node":"xFUP","./size":"w9fp","./empty":"UFOA","./each":"q4XW","./attr":"Tdf9","./style":"VXjm","./property":"QOWh","./classed":"rtNW","./text":"hAJ3","./html":"FiSM","./raise":"gvi7","./lower":"gv51","./append":"efv1","./insert":"ILQF","./remove":"quBB","./clone":"UpcG","./datum":"fuQ8","./on":"j4rF","./dispatch":"enVu"}],"iTOx":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = require("./selection/index");

function _default(selector) {
  return typeof selector === "string" ? new _index.Selection([[document.querySelector(selector)]], [document.documentElement]) : new _index.Selection([[selector]], _index.root);
}
},{"./selection/index":"jpDG"}],"tmZM":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _creator = _interopRequireDefault(require("./creator"));

var _select = _interopRequireDefault(require("./select"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(name) {
  return (0, _select.default)((0, _creator.default)(name).call(document.documentElement));
}
},{"./creator":"EIjt","./select":"iTOx"}],"JuPP":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = local;
var nextId = 0;

function local() {
  return new Local();
}

function Local() {
  this._ = "@" + (++nextId).toString(36);
}

Local.prototype = local.prototype = {
  constructor: Local,
  get: function (node) {
    var id = this._;

    while (!(id in node)) if (!(node = node.parentNode)) return;

    return node[id];
  },
  set: function (node, value) {
    return node[this._] = value;
  },
  remove: function (node) {
    return this._ in node && delete node[this._];
  },
  toString: function () {
    return this._;
  }
};
},{}],"mu9P":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _on = require("./selection/on");

function _default() {
  var current = _on.event,
      source;

  while (source = current.sourceEvent) current = source;

  return current;
}
},{"./selection/on":"j4rF"}],"ZIl1":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(node, event) {
  var svg = node.ownerSVGElement || node;

  if (svg.createSVGPoint) {
    var point = svg.createSVGPoint();
    point.x = event.clientX, point.y = event.clientY;
    point = point.matrixTransform(node.getScreenCTM().inverse());
    return [point.x, point.y];
  }

  var rect = node.getBoundingClientRect();
  return [event.clientX - rect.left - node.clientLeft, event.clientY - rect.top - node.clientTop];
}
},{}],"lbxf":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _sourceEvent = _interopRequireDefault(require("./sourceEvent"));

var _point = _interopRequireDefault(require("./point"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(node) {
  var event = (0, _sourceEvent.default)();
  if (event.changedTouches) event = event.changedTouches[0];
  return (0, _point.default)(node, event);
}
},{"./sourceEvent":"mu9P","./point":"ZIl1"}],"toE0":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = require("./selection/index");

function _default(selector) {
  return typeof selector === "string" ? new _index.Selection([document.querySelectorAll(selector)], [document.documentElement]) : new _index.Selection([selector == null ? [] : selector], _index.root);
}
},{"./selection/index":"jpDG"}],"Mh7G":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _sourceEvent = _interopRequireDefault(require("./sourceEvent"));

var _point = _interopRequireDefault(require("./point"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(node, touches, identifier) {
  if (arguments.length < 3) identifier = touches, touches = (0, _sourceEvent.default)().changedTouches;

  for (var i = 0, n = touches ? touches.length : 0, touch; i < n; ++i) {
    if ((touch = touches[i]).identifier === identifier) {
      return (0, _point.default)(node, touch);
    }
  }

  return null;
}
},{"./sourceEvent":"mu9P","./point":"ZIl1"}],"RG1U":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _sourceEvent = _interopRequireDefault(require("./sourceEvent"));

var _point = _interopRequireDefault(require("./point"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(node, touches) {
  if (touches == null) touches = (0, _sourceEvent.default)().touches;

  for (var i = 0, n = touches ? touches.length : 0, points = new Array(n); i < n; ++i) {
    points[i] = (0, _point.default)(node, touches[i]);
  }

  return points;
}
},{"./sourceEvent":"mu9P","./point":"ZIl1"}],"ObH6":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "create", {
  enumerable: true,
  get: function () {
    return _create.default;
  }
});
Object.defineProperty(exports, "creator", {
  enumerable: true,
  get: function () {
    return _creator.default;
  }
});
Object.defineProperty(exports, "local", {
  enumerable: true,
  get: function () {
    return _local.default;
  }
});
Object.defineProperty(exports, "matcher", {
  enumerable: true,
  get: function () {
    return _matcher.default;
  }
});
Object.defineProperty(exports, "mouse", {
  enumerable: true,
  get: function () {
    return _mouse.default;
  }
});
Object.defineProperty(exports, "namespace", {
  enumerable: true,
  get: function () {
    return _namespace.default;
  }
});
Object.defineProperty(exports, "namespaces", {
  enumerable: true,
  get: function () {
    return _namespaces.default;
  }
});
Object.defineProperty(exports, "clientPoint", {
  enumerable: true,
  get: function () {
    return _point.default;
  }
});
Object.defineProperty(exports, "select", {
  enumerable: true,
  get: function () {
    return _select.default;
  }
});
Object.defineProperty(exports, "selectAll", {
  enumerable: true,
  get: function () {
    return _selectAll.default;
  }
});
Object.defineProperty(exports, "selection", {
  enumerable: true,
  get: function () {
    return _index.default;
  }
});
Object.defineProperty(exports, "selector", {
  enumerable: true,
  get: function () {
    return _selector.default;
  }
});
Object.defineProperty(exports, "selectorAll", {
  enumerable: true,
  get: function () {
    return _selectorAll.default;
  }
});
Object.defineProperty(exports, "style", {
  enumerable: true,
  get: function () {
    return _style.styleValue;
  }
});
Object.defineProperty(exports, "touch", {
  enumerable: true,
  get: function () {
    return _touch.default;
  }
});
Object.defineProperty(exports, "touches", {
  enumerable: true,
  get: function () {
    return _touches.default;
  }
});
Object.defineProperty(exports, "window", {
  enumerable: true,
  get: function () {
    return _window.default;
  }
});
Object.defineProperty(exports, "event", {
  enumerable: true,
  get: function () {
    return _on.event;
  }
});
Object.defineProperty(exports, "customEvent", {
  enumerable: true,
  get: function () {
    return _on.customEvent;
  }
});

var _create = _interopRequireDefault(require("./src/create"));

var _creator = _interopRequireDefault(require("./src/creator"));

var _local = _interopRequireDefault(require("./src/local"));

var _matcher = _interopRequireDefault(require("./src/matcher"));

var _mouse = _interopRequireDefault(require("./src/mouse"));

var _namespace = _interopRequireDefault(require("./src/namespace"));

var _namespaces = _interopRequireDefault(require("./src/namespaces"));

var _point = _interopRequireDefault(require("./src/point"));

var _select = _interopRequireDefault(require("./src/select"));

var _selectAll = _interopRequireDefault(require("./src/selectAll"));

var _index = _interopRequireDefault(require("./src/selection/index"));

var _selector = _interopRequireDefault(require("./src/selector"));

var _selectorAll = _interopRequireDefault(require("./src/selectorAll"));

var _style = require("./src/selection/style");

var _touch = _interopRequireDefault(require("./src/touch"));

var _touches = _interopRequireDefault(require("./src/touches"));

var _window = _interopRequireDefault(require("./src/window"));

var _on = require("./src/selection/on");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./src/create":"tmZM","./src/creator":"EIjt","./src/local":"JuPP","./src/matcher":"PkZe","./src/mouse":"lbxf","./src/namespace":"OLJ5","./src/namespaces":"UzOB","./src/point":"ZIl1","./src/select":"iTOx","./src/selectAll":"toE0","./src/selection/index":"jpDG","./src/selector":"xs2I","./src/selectorAll":"mHY5","./src/selection/style":"VXjm","./src/touch":"Mh7G","./src/touches":"RG1U","./src/window":"D1dR","./src/selection/on":"j4rF"}],"DCEg":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.nopropagation = nopropagation;
exports.default = _default;

var _d3Selection = require("d3-selection");

function nopropagation() {
  _d3Selection.event.stopImmediatePropagation();
}

function _default() {
  _d3Selection.event.preventDefault();

  _d3Selection.event.stopImmediatePropagation();
}
},{"d3-selection":"ObH6"}],"rD9l":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.yesdrag = yesdrag;

var _d3Selection = require("d3-selection");

var _noevent = _interopRequireDefault(require("./noevent"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(view) {
  var root = view.document.documentElement,
      selection = (0, _d3Selection.select)(view).on("dragstart.drag", _noevent.default, true);

  if ("onselectstart" in root) {
    selection.on("selectstart.drag", _noevent.default, true);
  } else {
    root.__noselect = root.style.MozUserSelect;
    root.style.MozUserSelect = "none";
  }
}

function yesdrag(view, noclick) {
  var root = view.document.documentElement,
      selection = (0, _d3Selection.select)(view).on("dragstart.drag", null);

  if (noclick) {
    selection.on("click.drag", _noevent.default, true);
    setTimeout(function () {
      selection.on("click.drag", null);
    }, 0);
  }

  if ("onselectstart" in root) {
    selection.on("selectstart.drag", null);
  } else {
    root.style.MozUserSelect = root.__noselect;
    delete root.__noselect;
  }
}
},{"d3-selection":"ObH6","./noevent":"DCEg"}],"IkUE":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = DragEvent;

function DragEvent(target, type, subject, id, active, x, y, dx, dy, dispatch) {
  this.target = target;
  this.type = type;
  this.subject = subject;
  this.identifier = id;
  this.active = active;
  this.x = x;
  this.y = y;
  this.dx = dx;
  this.dy = dy;
  this._ = dispatch;
}

DragEvent.prototype.on = function () {
  var value = this._.on.apply(this._, arguments);

  return value === this._ ? this : value;
};
},{}],"fG09":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _d3Dispatch = require("d3-dispatch");

var _d3Selection = require("d3-selection");

var _nodrag = _interopRequireWildcard(require("./nodrag"));

var _noevent = _interopRequireWildcard(require("./noevent"));

var _constant = _interopRequireDefault(require("./constant"));

var _event = _interopRequireDefault(require("./event"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !_d3Selection.event.button;
}

function defaultContainer() {
  return this.parentNode;
}

function defaultSubject(d) {
  return d == null ? {
    x: _d3Selection.event.x,
    y: _d3Selection.event.y
  } : d;
}

function defaultTouchable() {
  return "ontouchstart" in this;
}

function _default() {
  var filter = defaultFilter,
      container = defaultContainer,
      subject = defaultSubject,
      touchable = defaultTouchable,
      gestures = {},
      listeners = (0, _d3Dispatch.dispatch)("start", "drag", "end"),
      active = 0,
      mousedownx,
      mousedowny,
      mousemoving,
      touchending,
      clickDistance2 = 0;

  function drag(selection) {
    selection.on("mousedown.drag", mousedowned).filter(touchable).on("touchstart.drag", touchstarted).on("touchmove.drag", touchmoved).on("touchend.drag touchcancel.drag", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var gesture = beforestart("mouse", container.apply(this, arguments), _d3Selection.mouse, this, arguments);
    if (!gesture) return;
    (0, _d3Selection.select)(_d3Selection.event.view).on("mousemove.drag", mousemoved, true).on("mouseup.drag", mouseupped, true);
    (0, _nodrag.default)(_d3Selection.event.view);
    (0, _noevent.nopropagation)();
    mousemoving = false;
    mousedownx = _d3Selection.event.clientX;
    mousedowny = _d3Selection.event.clientY;
    gesture("start");
  }

  function mousemoved() {
    (0, _noevent.default)();

    if (!mousemoving) {
      var dx = _d3Selection.event.clientX - mousedownx,
          dy = _d3Selection.event.clientY - mousedowny;
      mousemoving = dx * dx + dy * dy > clickDistance2;
    }

    gestures.mouse("drag");
  }

  function mouseupped() {
    (0, _d3Selection.select)(_d3Selection.event.view).on("mousemove.drag mouseup.drag", null);
    (0, _nodrag.yesdrag)(_d3Selection.event.view, mousemoving);
    (0, _noevent.default)();
    gestures.mouse("end");
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var touches = _d3Selection.event.changedTouches,
        c = container.apply(this, arguments),
        n = touches.length,
        i,
        gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = beforestart(touches[i].identifier, c, _d3Selection.touch, this, arguments)) {
        (0, _noevent.nopropagation)();
        gesture("start");
      }
    }
  }

  function touchmoved() {
    var touches = _d3Selection.event.changedTouches,
        n = touches.length,
        i,
        gesture;

    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        (0, _noevent.default)();
        gesture("drag");
      }
    }
  }

  function touchended() {
    var touches = _d3Selection.event.changedTouches,
        n = touches.length,
        i,
        gesture;
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function () {
      touchending = null;
    }, 500); // Ghost clicks are delayed!

    for (i = 0; i < n; ++i) {
      if (gesture = gestures[touches[i].identifier]) {
        (0, _noevent.nopropagation)();
        gesture("end");
      }
    }
  }

  function beforestart(id, container, point, that, args) {
    var p = point(container, id),
        s,
        dx,
        dy,
        sublisteners = listeners.copy();
    if (!(0, _d3Selection.customEvent)(new _event.default(drag, "beforestart", s, id, active, p[0], p[1], 0, 0, sublisteners), function () {
      if ((_d3Selection.event.subject = s = subject.apply(that, args)) == null) return false;
      dx = s.x - p[0] || 0;
      dy = s.y - p[1] || 0;
      return true;
    })) return;
    return function gesture(type) {
      var p0 = p,
          n;

      switch (type) {
        case "start":
          gestures[id] = gesture, n = active++;
          break;

        case "end":
          delete gestures[id], --active;
        // nobreak

        case "drag":
          p = point(container, id), n = active;
          break;
      }

      (0, _d3Selection.customEvent)(new _event.default(drag, type, s, id, n, p[0] + dx, p[1] + dy, p[0] - p0[0], p[1] - p0[1], sublisteners), sublisteners.apply, sublisteners, [type, that, args]);
    };
  }

  drag.filter = function (_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : (0, _constant.default)(!!_), drag) : filter;
  };

  drag.container = function (_) {
    return arguments.length ? (container = typeof _ === "function" ? _ : (0, _constant.default)(_), drag) : container;
  };

  drag.subject = function (_) {
    return arguments.length ? (subject = typeof _ === "function" ? _ : (0, _constant.default)(_), drag) : subject;
  };

  drag.touchable = function (_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : (0, _constant.default)(!!_), drag) : touchable;
  };

  drag.on = function () {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? drag : value;
  };

  drag.clickDistance = function (_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, drag) : Math.sqrt(clickDistance2);
  };

  return drag;
}
},{"d3-dispatch":"FHGa","d3-selection":"ObH6","./nodrag":"rD9l","./noevent":"DCEg","./constant":"OY6d","./event":"IkUE"}],"IqNk":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "drag", {
  enumerable: true,
  get: function () {
    return _drag.default;
  }
});
Object.defineProperty(exports, "dragDisable", {
  enumerable: true,
  get: function () {
    return _nodrag.default;
  }
});
Object.defineProperty(exports, "dragEnable", {
  enumerable: true,
  get: function () {
    return _nodrag.yesdrag;
  }
});

var _drag = _interopRequireDefault(require("./src/drag"));

var _nodrag = _interopRequireWildcard(require("./src/nodrag"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./src/drag":"fG09","./src/nodrag":"rD9l"}],"CSb3":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.extend = extend;

function _default(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}

function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);

  for (var key in definition) prototype[key] = definition[key];

  return prototype;
}
},{}],"UAf0":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Color = Color;
exports.default = color;
exports.rgbConvert = rgbConvert;
exports.rgb = rgb;
exports.Rgb = Rgb;
exports.hslConvert = hslConvert;
exports.hsl = hsl;
exports.brighter = exports.darker = void 0;

var _define = _interopRequireWildcard(require("./define"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function Color() {}

var darker = 0.7;
exports.darker = darker;
var brighter = 1 / darker;
exports.brighter = brighter;
var reI = "\\s*([+-]?\\d+)\\s*",
    reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*",
    reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*",
    reHex3 = /^#([0-9a-f]{3})$/,
    reHex6 = /^#([0-9a-f]{6})$/,
    reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"),
    reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"),
    reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"),
    reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"),
    reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"),
    reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
var named = {
  aliceblue: 0xf0f8ff,
  antiquewhite: 0xfaebd7,
  aqua: 0x00ffff,
  aquamarine: 0x7fffd4,
  azure: 0xf0ffff,
  beige: 0xf5f5dc,
  bisque: 0xffe4c4,
  black: 0x000000,
  blanchedalmond: 0xffebcd,
  blue: 0x0000ff,
  blueviolet: 0x8a2be2,
  brown: 0xa52a2a,
  burlywood: 0xdeb887,
  cadetblue: 0x5f9ea0,
  chartreuse: 0x7fff00,
  chocolate: 0xd2691e,
  coral: 0xff7f50,
  cornflowerblue: 0x6495ed,
  cornsilk: 0xfff8dc,
  crimson: 0xdc143c,
  cyan: 0x00ffff,
  darkblue: 0x00008b,
  darkcyan: 0x008b8b,
  darkgoldenrod: 0xb8860b,
  darkgray: 0xa9a9a9,
  darkgreen: 0x006400,
  darkgrey: 0xa9a9a9,
  darkkhaki: 0xbdb76b,
  darkmagenta: 0x8b008b,
  darkolivegreen: 0x556b2f,
  darkorange: 0xff8c00,
  darkorchid: 0x9932cc,
  darkred: 0x8b0000,
  darksalmon: 0xe9967a,
  darkseagreen: 0x8fbc8f,
  darkslateblue: 0x483d8b,
  darkslategray: 0x2f4f4f,
  darkslategrey: 0x2f4f4f,
  darkturquoise: 0x00ced1,
  darkviolet: 0x9400d3,
  deeppink: 0xff1493,
  deepskyblue: 0x00bfff,
  dimgray: 0x696969,
  dimgrey: 0x696969,
  dodgerblue: 0x1e90ff,
  firebrick: 0xb22222,
  floralwhite: 0xfffaf0,
  forestgreen: 0x228b22,
  fuchsia: 0xff00ff,
  gainsboro: 0xdcdcdc,
  ghostwhite: 0xf8f8ff,
  gold: 0xffd700,
  goldenrod: 0xdaa520,
  gray: 0x808080,
  green: 0x008000,
  greenyellow: 0xadff2f,
  grey: 0x808080,
  honeydew: 0xf0fff0,
  hotpink: 0xff69b4,
  indianred: 0xcd5c5c,
  indigo: 0x4b0082,
  ivory: 0xfffff0,
  khaki: 0xf0e68c,
  lavender: 0xe6e6fa,
  lavenderblush: 0xfff0f5,
  lawngreen: 0x7cfc00,
  lemonchiffon: 0xfffacd,
  lightblue: 0xadd8e6,
  lightcoral: 0xf08080,
  lightcyan: 0xe0ffff,
  lightgoldenrodyellow: 0xfafad2,
  lightgray: 0xd3d3d3,
  lightgreen: 0x90ee90,
  lightgrey: 0xd3d3d3,
  lightpink: 0xffb6c1,
  lightsalmon: 0xffa07a,
  lightseagreen: 0x20b2aa,
  lightskyblue: 0x87cefa,
  lightslategray: 0x778899,
  lightslategrey: 0x778899,
  lightsteelblue: 0xb0c4de,
  lightyellow: 0xffffe0,
  lime: 0x00ff00,
  limegreen: 0x32cd32,
  linen: 0xfaf0e6,
  magenta: 0xff00ff,
  maroon: 0x800000,
  mediumaquamarine: 0x66cdaa,
  mediumblue: 0x0000cd,
  mediumorchid: 0xba55d3,
  mediumpurple: 0x9370db,
  mediumseagreen: 0x3cb371,
  mediumslateblue: 0x7b68ee,
  mediumspringgreen: 0x00fa9a,
  mediumturquoise: 0x48d1cc,
  mediumvioletred: 0xc71585,
  midnightblue: 0x191970,
  mintcream: 0xf5fffa,
  mistyrose: 0xffe4e1,
  moccasin: 0xffe4b5,
  navajowhite: 0xffdead,
  navy: 0x000080,
  oldlace: 0xfdf5e6,
  olive: 0x808000,
  olivedrab: 0x6b8e23,
  orange: 0xffa500,
  orangered: 0xff4500,
  orchid: 0xda70d6,
  palegoldenrod: 0xeee8aa,
  palegreen: 0x98fb98,
  paleturquoise: 0xafeeee,
  palevioletred: 0xdb7093,
  papayawhip: 0xffefd5,
  peachpuff: 0xffdab9,
  peru: 0xcd853f,
  pink: 0xffc0cb,
  plum: 0xdda0dd,
  powderblue: 0xb0e0e6,
  purple: 0x800080,
  rebeccapurple: 0x663399,
  red: 0xff0000,
  rosybrown: 0xbc8f8f,
  royalblue: 0x4169e1,
  saddlebrown: 0x8b4513,
  salmon: 0xfa8072,
  sandybrown: 0xf4a460,
  seagreen: 0x2e8b57,
  seashell: 0xfff5ee,
  sienna: 0xa0522d,
  silver: 0xc0c0c0,
  skyblue: 0x87ceeb,
  slateblue: 0x6a5acd,
  slategray: 0x708090,
  slategrey: 0x708090,
  snow: 0xfffafa,
  springgreen: 0x00ff7f,
  steelblue: 0x4682b4,
  tan: 0xd2b48c,
  teal: 0x008080,
  thistle: 0xd8bfd8,
  tomato: 0xff6347,
  turquoise: 0x40e0d0,
  violet: 0xee82ee,
  wheat: 0xf5deb3,
  white: 0xffffff,
  whitesmoke: 0xf5f5f5,
  yellow: 0xffff00,
  yellowgreen: 0x9acd32
};
(0, _define.default)(Color, color, {
  displayable: function () {
    return this.rgb().displayable();
  },
  toString: function () {
    return this.rgb() + "";
  }
});

function color(format) {
  var m;
  format = (format + "").trim().toLowerCase();
  return (m = reHex3.exec(format)) ? (m = parseInt(m[1], 16), new Rgb(m >> 8 & 0xf | m >> 4 & 0x0f0, m >> 4 & 0xf | m & 0xf0, (m & 0xf) << 4 | m & 0xf, 1) // #f00
  ) : (m = reHex6.exec(format)) ? rgbn(parseInt(m[1], 16)) // #ff0000
  : (m = reRgbInteger.exec(format)) ? new Rgb(m[1], m[2], m[3], 1) // rgb(255, 0, 0)
  : (m = reRgbPercent.exec(format)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) // rgb(100%, 0%, 0%)
  : (m = reRgbaInteger.exec(format)) ? rgba(m[1], m[2], m[3], m[4]) // rgba(255, 0, 0, 1)
  : (m = reRgbaPercent.exec(format)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) // rgb(100%, 0%, 0%, 1)
  : (m = reHslPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) // hsl(120, 50%, 50%)
  : (m = reHslaPercent.exec(format)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) // hsla(120, 50%, 50%, 1)
  : named.hasOwnProperty(format) ? rgbn(named[format]) : format === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}

function rgbn(n) {
  return new Rgb(n >> 16 & 0xff, n >> 8 & 0xff, n & 0xff, 1);
}

function rgba(r, g, b, a) {
  if (a <= 0) r = g = b = NaN;
  return new Rgb(r, g, b, a);
}

function rgbConvert(o) {
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}

function rgb(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}

function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}

(0, _define.default)(Rgb, rgb, (0, _define.extend)(Color, {
  brighter: function (k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function (k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function () {
    return this;
  },
  displayable: function () {
    return 0 <= this.r && this.r <= 255 && 0 <= this.g && this.g <= 255 && 0 <= this.b && this.b <= 255 && 0 <= this.opacity && this.opacity <= 1;
  },
  toString: function () {
    var a = this.opacity;
    a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a === 1 ? ")" : ", " + a + ")");
  }
}));

function hsla(h, s, l, a) {
  if (a <= 0) h = s = l = NaN;else if (l <= 0 || l >= 1) h = s = NaN;else if (s <= 0) h = NaN;
  return new Hsl(h, s, l, a);
}

function hslConvert(o) {
  if (o instanceof Hsl) return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color)) o = color(o);
  if (!o) return new Hsl();
  if (o instanceof Hsl) return o;
  o = o.rgb();
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      min = Math.min(r, g, b),
      max = Math.max(r, g, b),
      h = NaN,
      s = max - min,
      l = (max + min) / 2;

  if (s) {
    if (r === max) h = (g - b) / s + (g < b) * 6;else if (g === max) h = (b - r) / s + 2;else h = (r - g) / s + 4;
    s /= l < 0.5 ? max + min : 2 - max - min;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }

  return new Hsl(h, s, l, o.opacity);
}

function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}

function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

(0, _define.default)(Hsl, hsl, (0, _define.extend)(Color, {
  brighter: function (k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function (k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function () {
    var h = this.h % 360 + (this.h < 0) * 360,
        s = isNaN(h) || isNaN(this.s) ? 0 : this.s,
        l = this.l,
        m2 = l + (l < 0.5 ? l : 1 - l) * s,
        m1 = 2 * l - m2;
    return new Rgb(hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2), hsl2rgb(h, m1, m2), hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2), this.opacity);
  },
  displayable: function () {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && 0 <= this.l && this.l <= 1 && 0 <= this.opacity && this.opacity <= 1;
  }
}));
/* From FvD 13.37, CSS Color Module Level 3 */

function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}
},{"./define":"CSb3"}],"ykIB":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.rad2deg = exports.deg2rad = void 0;
var deg2rad = Math.PI / 180;
exports.deg2rad = deg2rad;
var rad2deg = 180 / Math.PI;
exports.rad2deg = rad2deg;
},{}],"n21X":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = lab;
exports.Lab = Lab;
exports.hcl = hcl;
exports.Hcl = Hcl;

var _define = _interopRequireWildcard(require("./define"));

var _color = require("./color");

var _math = require("./math");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var Kn = 18,
    Xn = 0.950470,
    // D65 standard referent
Yn = 1,
    Zn = 1.088830,
    t0 = 4 / 29,
    t1 = 6 / 29,
    t2 = 3 * t1 * t1,
    t3 = t1 * t1 * t1;

function labConvert(o) {
  if (o instanceof Lab) return new Lab(o.l, o.a, o.b, o.opacity);

  if (o instanceof Hcl) {
    var h = o.h * _math.deg2rad;
    return new Lab(o.l, Math.cos(h) * o.c, Math.sin(h) * o.c, o.opacity);
  }

  if (!(o instanceof _color.Rgb)) o = (0, _color.rgbConvert)(o);
  var b = rgb2xyz(o.r),
      a = rgb2xyz(o.g),
      l = rgb2xyz(o.b),
      x = xyz2lab((0.4124564 * b + 0.3575761 * a + 0.1804375 * l) / Xn),
      y = xyz2lab((0.2126729 * b + 0.7151522 * a + 0.0721750 * l) / Yn),
      z = xyz2lab((0.0193339 * b + 0.1191920 * a + 0.9503041 * l) / Zn);
  return new Lab(116 * y - 16, 500 * (x - y), 200 * (y - z), o.opacity);
}

function lab(l, a, b, opacity) {
  return arguments.length === 1 ? labConvert(l) : new Lab(l, a, b, opacity == null ? 1 : opacity);
}

function Lab(l, a, b, opacity) {
  this.l = +l;
  this.a = +a;
  this.b = +b;
  this.opacity = +opacity;
}

(0, _define.default)(Lab, lab, (0, _define.extend)(_color.Color, {
  brighter: function (k) {
    return new Lab(this.l + Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  darker: function (k) {
    return new Lab(this.l - Kn * (k == null ? 1 : k), this.a, this.b, this.opacity);
  },
  rgb: function () {
    var y = (this.l + 16) / 116,
        x = isNaN(this.a) ? y : y + this.a / 500,
        z = isNaN(this.b) ? y : y - this.b / 200;
    y = Yn * lab2xyz(y);
    x = Xn * lab2xyz(x);
    z = Zn * lab2xyz(z);
    return new _color.Rgb(xyz2rgb(3.2404542 * x - 1.5371385 * y - 0.4985314 * z), // D65 -> sRGB
    xyz2rgb(-0.9692660 * x + 1.8760108 * y + 0.0415560 * z), xyz2rgb(0.0556434 * x - 0.2040259 * y + 1.0572252 * z), this.opacity);
  }
}));

function xyz2lab(t) {
  return t > t3 ? Math.pow(t, 1 / 3) : t / t2 + t0;
}

function lab2xyz(t) {
  return t > t1 ? t * t * t : t2 * (t - t0);
}

function xyz2rgb(x) {
  return 255 * (x <= 0.0031308 ? 12.92 * x : 1.055 * Math.pow(x, 1 / 2.4) - 0.055);
}

function rgb2xyz(x) {
  return (x /= 255) <= 0.04045 ? x / 12.92 : Math.pow((x + 0.055) / 1.055, 2.4);
}

function hclConvert(o) {
  if (o instanceof Hcl) return new Hcl(o.h, o.c, o.l, o.opacity);
  if (!(o instanceof Lab)) o = labConvert(o);

  var h = Math.atan2(o.b, o.a) * _math.rad2deg;

  return new Hcl(h < 0 ? h + 360 : h, Math.sqrt(o.a * o.a + o.b * o.b), o.l, o.opacity);
}

function hcl(h, c, l, opacity) {
  return arguments.length === 1 ? hclConvert(h) : new Hcl(h, c, l, opacity == null ? 1 : opacity);
}

function Hcl(h, c, l, opacity) {
  this.h = +h;
  this.c = +c;
  this.l = +l;
  this.opacity = +opacity;
}

(0, _define.default)(Hcl, hcl, (0, _define.extend)(_color.Color, {
  brighter: function (k) {
    return new Hcl(this.h, this.c, this.l + Kn * (k == null ? 1 : k), this.opacity);
  },
  darker: function (k) {
    return new Hcl(this.h, this.c, this.l - Kn * (k == null ? 1 : k), this.opacity);
  },
  rgb: function () {
    return labConvert(this).rgb();
  }
}));
},{"./define":"CSb3","./color":"UAf0","./math":"ykIB"}],"aDX2":[function(require,module,exports) {

"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = cubehelix;
exports.Cubehelix = Cubehelix;

var _define = _interopRequireWildcard(require("./define"));

var _color = require("./color");

var _math = require("./math");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var A = -0.14861,
    B = +1.78277,
    C = -0.29227,
    D = -0.90649,
    E = +1.97294,
    ED = E * D,
    EB = E * B,
    BC_DA = B * C - D * A;

function cubehelixConvert(o) {
  if (o instanceof Cubehelix) return new Cubehelix(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof _color.Rgb)) o = (0, _color.rgbConvert)(o);
  var r = o.r / 255,
      g = o.g / 255,
      b = o.b / 255,
      l = (BC_DA * b + ED * r - EB * g) / (BC_DA + ED - EB),
      bl = b - l,
      k = (E * (g - l) - C * bl) / D,
      s = Math.sqrt(k * k + bl * bl) / (E * l * (1 - l)),
      // NaN if l=0 or l=1
  h = s ? Math.atan2(k, bl) * _math.rad2deg - 120 : NaN;
  return new Cubehelix(h < 0 ? h + 360 : h, s, l, o.opacity);
}

function cubehelix(h, s, l, opacity) {
  return arguments.length === 1 ? cubehelixConvert(h) : new Cubehelix(h, s, l, opacity == null ? 1 : opacity);
}

function Cubehelix(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}

(0, _define.default)(Cubehelix, cubehelix, (0, _define.extend)(_color.Color, {
  brighter: function (k) {
    k = k == null ? _color.brighter : Math.pow(_color.brighter, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function (k) {
    k = k == null ? _color.darker : Math.pow(_color.darker, k);
    return new Cubehelix(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function () {
    var h = isNaN(this.h) ? 0 : (this.h + 120) * _math.deg2rad,
        l = +this.l,
        a = isNaN(this.s) ? 0 : this.s * l * (1 - l),
        cosh = Math.cos(h),
        sinh = Math.sin(h);
    return new _color.Rgb(255 * (l + a * (A * cosh + B * sinh)), 255 * (l + a * (C * cosh + D * sinh)), 255 * (l + a * (E * cosh)), this.opacity);
  }
}));
},{"./define":"CSb3","./color":"UAf0","./math":"ykIB"}],"RuBy":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "color", {
  enumerable: true,
  get: function () {
    return _color.default;
  }
});
Object.defineProperty(exports, "rgb", {
  enumerable: true,
  get: function () {
    return _color.rgb;
  }
});
Object.defineProperty(exports, "hsl", {
  enumerable: true,
  get: function () {
    return _color.hsl;
  }
});
Object.defineProperty(exports, "lab", {
  enumerable: true,
  get: function () {
    return _lab.default;
  }
});
Object.defineProperty(exports, "hcl", {
  enumerable: true,
  get: function () {
    return _lab.hcl;
  }
});
Object.defineProperty(exports, "cubehelix", {
  enumerable: true,
  get: function () {
    return _cubehelix.default;
  }
});

var _color = _interopRequireWildcard(require("./src/color"));

var _lab = _interopRequireWildcard(require("./src/lab"));

var _cubehelix = _interopRequireDefault(require("./src/cubehelix"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
},{"./src/color":"UAf0","./src/lab":"n21X","./src/cubehelix":"aDX2"}],"mIuw":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.basis = basis;
exports.default = _default;

function basis(t1, v0, v1, v2, v3) {
  var t2 = t1 * t1,
      t3 = t2 * t1;
  return ((1 - 3 * t1 + 3 * t2 - t3) * v0 + (4 - 6 * t2 + 3 * t3) * v1 + (1 + 3 * t1 + 3 * t2 - 3 * t3) * v2 + t3 * v3) / 6;
}

function _default(values) {
  var n = values.length - 1;
  return function (t) {
    var i = t <= 0 ? t = 0 : t >= 1 ? (t = 1, n - 1) : Math.floor(t * n),
        v1 = values[i],
        v2 = values[i + 1],
        v0 = i > 0 ? values[i - 1] : 2 * v1 - v2,
        v3 = i < n - 1 ? values[i + 2] : 2 * v2 - v1;
    return basis((t - i / n) * n, v0, v1, v2, v3);
  };
}
},{}],"t9MF":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _basis = require("./basis");

function _default(values) {
  var n = values.length;
  return function (t) {
    var i = Math.floor(((t %= 1) < 0 ? ++t : t) * n),
        v0 = values[(i + n - 1) % n],
        v1 = values[i % n],
        v2 = values[(i + 1) % n],
        v3 = values[(i + 2) % n];
    return (0, _basis.basis)((t - i / n) * n, v0, v1, v2, v3);
  };
}
},{"./basis":"mIuw"}],"OW9X":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hue = hue;
exports.gamma = gamma;
exports.default = nogamma;

var _constant = _interopRequireDefault(require("./constant"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function linear(a, d) {
  return function (t) {
    return a + t * d;
  };
}

function exponential(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function (t) {
    return Math.pow(a + t * b, y);
  };
}

function hue(a, b) {
  var d = b - a;
  return d ? linear(a, d > 180 || d < -180 ? d - 360 * Math.round(d / 360) : d) : (0, _constant.default)(isNaN(a) ? b : a);
}

function gamma(y) {
  return (y = +y) === 1 ? nogamma : function (a, b) {
    return b - a ? exponential(a, b, y) : (0, _constant.default)(isNaN(a) ? b : a);
  };
}

function nogamma(a, b) {
  var d = b - a;
  return d ? linear(a, d) : (0, _constant.default)(isNaN(a) ? b : a);
}
},{"./constant":"OY6d"}],"hw5o":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.rgbBasisClosed = exports.rgbBasis = exports.default = void 0;

var _d3Color = require("d3-color");

var _basis = _interopRequireDefault(require("./basis"));

var _basisClosed = _interopRequireDefault(require("./basisClosed"));

var _color = _interopRequireWildcard(require("./color"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = function rgbGamma(y) {
  var color = (0, _color.gamma)(y);

  function rgb(start, end) {
    var r = color((start = (0, _d3Color.rgb)(start)).r, (end = (0, _d3Color.rgb)(end)).r),
        g = color(start.g, end.g),
        b = color(start.b, end.b),
        opacity = (0, _color.default)(start.opacity, end.opacity);
    return function (t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }

  rgb.gamma = rgbGamma;
  return rgb;
}(1);

exports.default = _default;

function rgbSpline(spline) {
  return function (colors) {
    var n = colors.length,
        r = new Array(n),
        g = new Array(n),
        b = new Array(n),
        i,
        color;

    for (i = 0; i < n; ++i) {
      color = (0, _d3Color.rgb)(colors[i]);
      r[i] = color.r || 0;
      g[i] = color.g || 0;
      b[i] = color.b || 0;
    }

    r = spline(r);
    g = spline(g);
    b = spline(b);
    color.opacity = 1;
    return function (t) {
      color.r = r(t);
      color.g = g(t);
      color.b = b(t);
      return color + "";
    };
  };
}

var rgbBasis = rgbSpline(_basis.default);
exports.rgbBasis = rgbBasis;
var rgbBasisClosed = rgbSpline(_basisClosed.default);
exports.rgbBasisClosed = rgbBasisClosed;
},{"d3-color":"RuBy","./basis":"mIuw","./basisClosed":"t9MF","./color":"OW9X"}],"j6Kl":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _value = _interopRequireDefault(require("./value"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(a, b) {
  var nb = b ? b.length : 0,
      na = a ? Math.min(nb, a.length) : 0,
      x = new Array(na),
      c = new Array(nb),
      i;

  for (i = 0; i < na; ++i) x[i] = (0, _value.default)(a[i], b[i]);

  for (; i < nb; ++i) c[i] = b[i];

  return function (t) {
    for (i = 0; i < na; ++i) c[i] = x[i](t);

    return c;
  };
}
},{"./value":"ONGM"}],"npIv":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(a, b) {
  var d = new Date();
  return a = +a, b -= a, function (t) {
    return d.setTime(a + b * t), d;
  };
}
},{}],"eUtU":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(a, b) {
  return a = +a, b -= a, function (t) {
    return a + b * t;
  };
}
},{}],"Ci2u":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _value = _interopRequireDefault(require("./value"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(a, b) {
  var i = {},
      c = {},
      k;
  if (a === null || typeof a !== "object") a = {};
  if (b === null || typeof b !== "object") b = {};

  for (k in b) {
    if (k in a) {
      i[k] = (0, _value.default)(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }

  return function (t) {
    for (k in i) c[k] = i[k](t);

    return c;
  };
}
},{"./value":"ONGM"}],"WNxQ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _number = _interopRequireDefault(require("./number"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,
    reB = new RegExp(reA.source, "g");

function zero(b) {
  return function () {
    return b;
  };
}

function one(b) {
  return function (t) {
    return b(t) + "";
  };
}

function _default(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0,
      // scan index for next number in b
  am,
      // current match in a
  bm,
      // current match in b
  bs,
      // string preceding current number in b, if any
  i = -1,
      // index in s
  s = [],
      // string constants and placeholders
  q = []; // number interpolators
  // Coerce inputs to strings.

  a = a + "", b = b + ""; // Interpolate pairs of numbers in a & b.

  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      // a string precedes the next number in b
      bs = b.slice(bi, bs);
      if (s[i]) s[i] += bs; // coalesce with previous string
      else s[++i] = bs;
    }

    if ((am = am[0]) === (bm = bm[0])) {
      // numbers in a & b match
      if (s[i]) s[i] += bm; // coalesce with previous string
      else s[++i] = bm;
    } else {
      // interpolate non-matching numbers
      s[++i] = null;
      q.push({
        i: i,
        x: (0, _number.default)(am, bm)
      });
    }

    bi = reB.lastIndex;
  } // Add remains of b.


  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i]) s[i] += bs; // coalesce with previous string
    else s[++i] = bs;
  } // Special optimization for only a single match.
  // Otherwise, interpolate each of the numbers and rejoin the string.


  return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function (t) {
    for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);

    return s.join("");
  });
}
},{"./number":"eUtU"}],"ONGM":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _d3Color = require("d3-color");

var _rgb = _interopRequireDefault(require("./rgb"));

var _array = _interopRequireDefault(require("./array"));

var _date = _interopRequireDefault(require("./date"));

var _number = _interopRequireDefault(require("./number"));

var _object = _interopRequireDefault(require("./object"));

var _string = _interopRequireDefault(require("./string"));

var _constant = _interopRequireDefault(require("./constant"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(a, b) {
  var t = typeof b,
      c;
  return b == null || t === "boolean" ? (0, _constant.default)(b) : (t === "number" ? _number.default : t === "string" ? (c = (0, _d3Color.color)(b)) ? (b = c, _rgb.default) : _string.default : b instanceof _d3Color.color ? _rgb.default : b instanceof Date ? _date.default : Array.isArray(b) ? _array.default : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? _object.default : _number.default)(a, b);
}
},{"d3-color":"RuBy","./rgb":"hw5o","./array":"j6Kl","./date":"npIv","./number":"eUtU","./object":"Ci2u","./string":"WNxQ","./constant":"OY6d"}],"Ehv8":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(a, b) {
  return a = +a, b -= a, function (t) {
    return Math.round(a + b * t);
  };
}
},{}],"sFbg":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.identity = void 0;
var degrees = 180 / Math.PI;
var identity = {
  translateX: 0,
  translateY: 0,
  rotate: 0,
  skewX: 0,
  scaleX: 1,
  scaleY: 1
};
exports.identity = identity;

function _default(a, b, c, d, e, f) {
  var scaleX, scaleY, skewX;
  if (scaleX = Math.sqrt(a * a + b * b)) a /= scaleX, b /= scaleX;
  if (skewX = a * c + b * d) c -= a * skewX, d -= b * skewX;
  if (scaleY = Math.sqrt(c * c + d * d)) c /= scaleY, d /= scaleY, skewX /= scaleY;
  if (a * d < b * c) a = -a, b = -b, skewX = -skewX, scaleX = -scaleX;
  return {
    translateX: e,
    translateY: f,
    rotate: Math.atan2(b, a) * degrees,
    skewX: Math.atan(skewX) * degrees,
    scaleX: scaleX,
    scaleY: scaleY
  };
}
},{}],"igaz":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.parseCss = parseCss;
exports.parseSvg = parseSvg;

var _decompose = _interopRequireWildcard(require("./decompose"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var cssNode, cssRoot, cssView, svgNode;

function parseCss(value) {
  if (value === "none") return _decompose.identity;
  if (!cssNode) cssNode = document.createElement("DIV"), cssRoot = document.documentElement, cssView = document.defaultView;
  cssNode.style.transform = value;
  value = cssView.getComputedStyle(cssRoot.appendChild(cssNode), null).getPropertyValue("transform");
  cssRoot.removeChild(cssNode);
  value = value.slice(7, -1).split(",");
  return (0, _decompose.default)(+value[0], +value[1], +value[2], +value[3], +value[4], +value[5]);
}

function parseSvg(value) {
  if (value == null) return _decompose.identity;
  if (!svgNode) svgNode = document.createElementNS("http://www.w3.org/2000/svg", "g");
  svgNode.setAttribute("transform", value);
  if (!(value = svgNode.transform.baseVal.consolidate())) return _decompose.identity;
  value = value.matrix;
  return (0, _decompose.default)(value.a, value.b, value.c, value.d, value.e, value.f);
}
},{"./decompose":"sFbg"}],"tUKx":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.interpolateTransformSvg = exports.interpolateTransformCss = void 0;

var _number = _interopRequireDefault(require("../number"));

var _parse = require("./parse");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function interpolateTransform(parse, pxComma, pxParen, degParen) {
  function pop(s) {
    return s.length ? s.pop() + " " : "";
  }

  function translate(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push("translate(", null, pxComma, null, pxParen);
      q.push({
        i: i - 4,
        x: (0, _number.default)(xa, xb)
      }, {
        i: i - 2,
        x: (0, _number.default)(ya, yb)
      });
    } else if (xb || yb) {
      s.push("translate(" + xb + pxComma + yb + pxParen);
    }
  }

  function rotate(a, b, s, q) {
    if (a !== b) {
      if (a - b > 180) b += 360;else if (b - a > 180) a += 360; // shortest path

      q.push({
        i: s.push(pop(s) + "rotate(", null, degParen) - 2,
        x: (0, _number.default)(a, b)
      });
    } else if (b) {
      s.push(pop(s) + "rotate(" + b + degParen);
    }
  }

  function skewX(a, b, s, q) {
    if (a !== b) {
      q.push({
        i: s.push(pop(s) + "skewX(", null, degParen) - 2,
        x: (0, _number.default)(a, b)
      });
    } else if (b) {
      s.push(pop(s) + "skewX(" + b + degParen);
    }
  }

  function scale(xa, ya, xb, yb, s, q) {
    if (xa !== xb || ya !== yb) {
      var i = s.push(pop(s) + "scale(", null, ",", null, ")");
      q.push({
        i: i - 4,
        x: (0, _number.default)(xa, xb)
      }, {
        i: i - 2,
        x: (0, _number.default)(ya, yb)
      });
    } else if (xb !== 1 || yb !== 1) {
      s.push(pop(s) + "scale(" + xb + "," + yb + ")");
    }
  }

  return function (a, b) {
    var s = [],
        // string constants and placeholders
    q = []; // number interpolators

    a = parse(a), b = parse(b);
    translate(a.translateX, a.translateY, b.translateX, b.translateY, s, q);
    rotate(a.rotate, b.rotate, s, q);
    skewX(a.skewX, b.skewX, s, q);
    scale(a.scaleX, a.scaleY, b.scaleX, b.scaleY, s, q);
    a = b = null; // gc

    return function (t) {
      var i = -1,
          n = q.length,
          o;

      while (++i < n) s[(o = q[i]).i] = o.x(t);

      return s.join("");
    };
  };
}

var interpolateTransformCss = interpolateTransform(_parse.parseCss, "px, ", "px)", "deg)");
exports.interpolateTransformCss = interpolateTransformCss;
var interpolateTransformSvg = interpolateTransform(_parse.parseSvg, ", ", ")", ")");
exports.interpolateTransformSvg = interpolateTransformSvg;
},{"../number":"eUtU","./parse":"igaz"}],"MbcF":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var rho = Math.SQRT2,
    rho2 = 2,
    rho4 = 4,
    epsilon2 = 1e-12;

function cosh(x) {
  return ((x = Math.exp(x)) + 1 / x) / 2;
}

function sinh(x) {
  return ((x = Math.exp(x)) - 1 / x) / 2;
}

function tanh(x) {
  return ((x = Math.exp(2 * x)) - 1) / (x + 1);
} // p0 = [ux0, uy0, w0]
// p1 = [ux1, uy1, w1]


function _default(p0, p1) {
  var ux0 = p0[0],
      uy0 = p0[1],
      w0 = p0[2],
      ux1 = p1[0],
      uy1 = p1[1],
      w1 = p1[2],
      dx = ux1 - ux0,
      dy = uy1 - uy0,
      d2 = dx * dx + dy * dy,
      i,
      S; // Special case for u0 ≅ u1.

  if (d2 < epsilon2) {
    S = Math.log(w1 / w0) / rho;

    i = function (t) {
      return [ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(rho * t * S)];
    };
  } // General case.
  else {
      var d1 = Math.sqrt(d2),
          b0 = (w1 * w1 - w0 * w0 + rho4 * d2) / (2 * w0 * rho2 * d1),
          b1 = (w1 * w1 - w0 * w0 - rho4 * d2) / (2 * w1 * rho2 * d1),
          r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0),
          r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);
      S = (r1 - r0) / rho;

      i = function (t) {
        var s = t * S,
            coshr0 = cosh(r0),
            u = w0 / (rho2 * d1) * (coshr0 * tanh(rho * s + r0) - sinh(r0));
        return [ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / cosh(rho * s + r0)];
      };
    }

  i.duration = S * 1000;
  return i;
}
},{}],"BrWg":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hslLong = exports.default = void 0;

var _d3Color = require("d3-color");

var _color = _interopRequireWildcard(require("./color"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function hsl(hue) {
  return function (start, end) {
    var h = hue((start = (0, _d3Color.hsl)(start)).h, (end = (0, _d3Color.hsl)(end)).h),
        s = (0, _color.default)(start.s, end.s),
        l = (0, _color.default)(start.l, end.l),
        opacity = (0, _color.default)(start.opacity, end.opacity);
    return function (t) {
      start.h = h(t);
      start.s = s(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}

var _default = hsl(_color.hue);

exports.default = _default;
var hslLong = hsl(_color.default);
exports.hslLong = hslLong;
},{"d3-color":"RuBy","./color":"OW9X"}],"HCNS":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = lab;

var _d3Color = require("d3-color");

var _color = _interopRequireDefault(require("./color"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function lab(start, end) {
  var l = (0, _color.default)((start = (0, _d3Color.lab)(start)).l, (end = (0, _d3Color.lab)(end)).l),
      a = (0, _color.default)(start.a, end.a),
      b = (0, _color.default)(start.b, end.b),
      opacity = (0, _color.default)(start.opacity, end.opacity);
  return function (t) {
    start.l = l(t);
    start.a = a(t);
    start.b = b(t);
    start.opacity = opacity(t);
    return start + "";
  };
}
},{"d3-color":"RuBy","./color":"OW9X"}],"VIlX":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hclLong = exports.default = void 0;

var _d3Color = require("d3-color");

var _color = _interopRequireWildcard(require("./color"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function hcl(hue) {
  return function (start, end) {
    var h = hue((start = (0, _d3Color.hcl)(start)).h, (end = (0, _d3Color.hcl)(end)).h),
        c = (0, _color.default)(start.c, end.c),
        l = (0, _color.default)(start.l, end.l),
        opacity = (0, _color.default)(start.opacity, end.opacity);
    return function (t) {
      start.h = h(t);
      start.c = c(t);
      start.l = l(t);
      start.opacity = opacity(t);
      return start + "";
    };
  };
}

var _default = hcl(_color.hue);

exports.default = _default;
var hclLong = hcl(_color.default);
exports.hclLong = hclLong;
},{"d3-color":"RuBy","./color":"OW9X"}],"NOHm":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cubehelixLong = exports.default = void 0;

var _d3Color = require("d3-color");

var _color = _interopRequireWildcard(require("./color"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function cubehelix(hue) {
  return function cubehelixGamma(y) {
    y = +y;

    function cubehelix(start, end) {
      var h = hue((start = (0, _d3Color.cubehelix)(start)).h, (end = (0, _d3Color.cubehelix)(end)).h),
          s = (0, _color.default)(start.s, end.s),
          l = (0, _color.default)(start.l, end.l),
          opacity = (0, _color.default)(start.opacity, end.opacity);
      return function (t) {
        start.h = h(t);
        start.s = s(t);
        start.l = l(Math.pow(t, y));
        start.opacity = opacity(t);
        return start + "";
      };
    }

    cubehelix.gamma = cubehelixGamma;
    return cubehelix;
  }(1);
}

var _default = cubehelix(_color.hue);

exports.default = _default;
var cubehelixLong = cubehelix(_color.default);
exports.cubehelixLong = cubehelixLong;
},{"d3-color":"RuBy","./color":"OW9X"}],"g3ua":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(interpolator, n) {
  var samples = new Array(n);

  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));

  return samples;
}
},{}],"nuBz":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "interpolate", {
  enumerable: true,
  get: function () {
    return _value.default;
  }
});
Object.defineProperty(exports, "interpolateArray", {
  enumerable: true,
  get: function () {
    return _array.default;
  }
});
Object.defineProperty(exports, "interpolateBasis", {
  enumerable: true,
  get: function () {
    return _basis.default;
  }
});
Object.defineProperty(exports, "interpolateBasisClosed", {
  enumerable: true,
  get: function () {
    return _basisClosed.default;
  }
});
Object.defineProperty(exports, "interpolateDate", {
  enumerable: true,
  get: function () {
    return _date.default;
  }
});
Object.defineProperty(exports, "interpolateNumber", {
  enumerable: true,
  get: function () {
    return _number.default;
  }
});
Object.defineProperty(exports, "interpolateObject", {
  enumerable: true,
  get: function () {
    return _object.default;
  }
});
Object.defineProperty(exports, "interpolateRound", {
  enumerable: true,
  get: function () {
    return _round.default;
  }
});
Object.defineProperty(exports, "interpolateString", {
  enumerable: true,
  get: function () {
    return _string.default;
  }
});
Object.defineProperty(exports, "interpolateTransformCss", {
  enumerable: true,
  get: function () {
    return _index.interpolateTransformCss;
  }
});
Object.defineProperty(exports, "interpolateTransformSvg", {
  enumerable: true,
  get: function () {
    return _index.interpolateTransformSvg;
  }
});
Object.defineProperty(exports, "interpolateZoom", {
  enumerable: true,
  get: function () {
    return _zoom.default;
  }
});
Object.defineProperty(exports, "interpolateRgb", {
  enumerable: true,
  get: function () {
    return _rgb.default;
  }
});
Object.defineProperty(exports, "interpolateRgbBasis", {
  enumerable: true,
  get: function () {
    return _rgb.rgbBasis;
  }
});
Object.defineProperty(exports, "interpolateRgbBasisClosed", {
  enumerable: true,
  get: function () {
    return _rgb.rgbBasisClosed;
  }
});
Object.defineProperty(exports, "interpolateHsl", {
  enumerable: true,
  get: function () {
    return _hsl.default;
  }
});
Object.defineProperty(exports, "interpolateHslLong", {
  enumerable: true,
  get: function () {
    return _hsl.hslLong;
  }
});
Object.defineProperty(exports, "interpolateLab", {
  enumerable: true,
  get: function () {
    return _lab.default;
  }
});
Object.defineProperty(exports, "interpolateHcl", {
  enumerable: true,
  get: function () {
    return _hcl.default;
  }
});
Object.defineProperty(exports, "interpolateHclLong", {
  enumerable: true,
  get: function () {
    return _hcl.hclLong;
  }
});
Object.defineProperty(exports, "interpolateCubehelix", {
  enumerable: true,
  get: function () {
    return _cubehelix.default;
  }
});
Object.defineProperty(exports, "interpolateCubehelixLong", {
  enumerable: true,
  get: function () {
    return _cubehelix.cubehelixLong;
  }
});
Object.defineProperty(exports, "quantize", {
  enumerable: true,
  get: function () {
    return _quantize.default;
  }
});

var _value = _interopRequireDefault(require("./src/value"));

var _array = _interopRequireDefault(require("./src/array"));

var _basis = _interopRequireDefault(require("./src/basis"));

var _basisClosed = _interopRequireDefault(require("./src/basisClosed"));

var _date = _interopRequireDefault(require("./src/date"));

var _number = _interopRequireDefault(require("./src/number"));

var _object = _interopRequireDefault(require("./src/object"));

var _round = _interopRequireDefault(require("./src/round"));

var _string = _interopRequireDefault(require("./src/string"));

var _index = require("./src/transform/index");

var _zoom = _interopRequireDefault(require("./src/zoom"));

var _rgb = _interopRequireWildcard(require("./src/rgb"));

var _hsl = _interopRequireWildcard(require("./src/hsl"));

var _lab = _interopRequireDefault(require("./src/lab"));

var _hcl = _interopRequireWildcard(require("./src/hcl"));

var _cubehelix = _interopRequireWildcard(require("./src/cubehelix"));

var _quantize = _interopRequireDefault(require("./src/quantize"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./src/value":"ONGM","./src/array":"j6Kl","./src/basis":"mIuw","./src/basisClosed":"t9MF","./src/date":"npIv","./src/number":"eUtU","./src/object":"Ci2u","./src/round":"Ehv8","./src/string":"WNxQ","./src/transform/index":"tUKx","./src/zoom":"MbcF","./src/rgb":"hw5o","./src/hsl":"BrWg","./src/lab":"HCNS","./src/hcl":"VIlX","./src/cubehelix":"NOHm","./src/quantize":"g3ua"}],"v2Ya":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.now = now;
exports.Timer = Timer;
exports.timer = timer;
exports.timerFlush = timerFlush;
var frame = 0,
    // is an animation frame pending?
timeout = 0,
    // is a timeout pending?
interval = 0,
    // are any timers active?
pokeDelay = 1000,
    // how frequently we check for clock skew
taskHead,
    taskTail,
    clockLast = 0,
    clockNow = 0,
    clockSkew = 0,
    clock = typeof performance === "object" && performance.now ? performance : Date,
    setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function (f) {
  setTimeout(f, 17);
};

function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}

function clearNow() {
  clockNow = 0;
}

function Timer() {
  this._call = this._time = this._next = null;
}

Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function (callback, delay, time) {
    if (typeof callback !== "function") throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);

    if (!this._next && taskTail !== this) {
      if (taskTail) taskTail._next = this;else taskHead = this;
      taskTail = this;
    }

    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function () {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};

function timer(callback, delay, time) {
  var t = new Timer();
  t.restart(callback, delay, time);
  return t;
}

function timerFlush() {
  now(); // Get the current time, if not already set.

  ++frame; // Pretend we’ve set an alarm, if we haven’t already.

  var t = taskHead,
      e;

  while (t) {
    if ((e = clockNow - t._time) >= 0) t._call.call(null, e);
    t = t._next;
  }

  --frame;
}

function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;

  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}

function poke() {
  var now = clock.now(),
      delay = now - clockLast;
  if (delay > pokeDelay) clockSkew -= delay, clockLast = now;
}

function nap() {
  var t0,
      t1 = taskHead,
      t2,
      time = Infinity;

  while (t1) {
    if (t1._call) {
      if (time > t1._time) time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }

  taskTail = t0;
  sleep(time);
}

function sleep(time) {
  if (frame) return; // Soonest alarm already set, or will be.

  if (timeout) timeout = clearTimeout(timeout);
  var delay = time - clockNow; // Strictly less than if we recomputed clockNow.

  if (delay > 24) {
    if (time < Infinity) timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval) interval = clearInterval(interval);
  } else {
    if (!interval) clockLast = clock.now(), interval = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}
},{}],"iEU7":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _timer = require("./timer");

function _default(callback, delay, time) {
  var t = new _timer.Timer();
  delay = delay == null ? 0 : +delay;
  t.restart(function (elapsed) {
    t.stop();
    callback(elapsed + delay);
  }, delay, time);
  return t;
}
},{"./timer":"v2Ya"}],"B8zX":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _timer = require("./timer");

function _default(callback, delay, time) {
  var t = new _timer.Timer(),
      total = delay;
  if (delay == null) return t.restart(callback, delay, time), t;
  delay = +delay, time = time == null ? (0, _timer.now)() : +time;
  t.restart(function tick(elapsed) {
    elapsed += total;
    t.restart(tick, total += delay, time);
    callback(elapsed);
  }, delay, time);
  return t;
}
},{"./timer":"v2Ya"}],"Gc7n":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "now", {
  enumerable: true,
  get: function () {
    return _timer.now;
  }
});
Object.defineProperty(exports, "timer", {
  enumerable: true,
  get: function () {
    return _timer.timer;
  }
});
Object.defineProperty(exports, "timerFlush", {
  enumerable: true,
  get: function () {
    return _timer.timerFlush;
  }
});
Object.defineProperty(exports, "timeout", {
  enumerable: true,
  get: function () {
    return _timeout.default;
  }
});
Object.defineProperty(exports, "interval", {
  enumerable: true,
  get: function () {
    return _interval.default;
  }
});

var _timer = require("./src/timer");

var _timeout = _interopRequireDefault(require("./src/timeout"));

var _interval = _interopRequireDefault(require("./src/interval"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./src/timer":"v2Ya","./src/timeout":"iEU7","./src/interval":"B8zX"}],"GDzO":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.init = init;
exports.set = set;
exports.get = get;
exports.ENDED = exports.ENDING = exports.RUNNING = exports.STARTED = exports.STARTING = exports.SCHEDULED = exports.CREATED = void 0;

var _d3Dispatch = require("d3-dispatch");

var _d3Timer = require("d3-timer");

var emptyOn = (0, _d3Dispatch.dispatch)("start", "end", "interrupt");
var emptyTween = [];
var CREATED = 0;
exports.CREATED = CREATED;
var SCHEDULED = 1;
exports.SCHEDULED = SCHEDULED;
var STARTING = 2;
exports.STARTING = STARTING;
var STARTED = 3;
exports.STARTED = STARTED;
var RUNNING = 4;
exports.RUNNING = RUNNING;
var ENDING = 5;
exports.ENDING = ENDING;
var ENDED = 6;
exports.ENDED = ENDED;

function _default(node, name, id, index, group, timing) {
  var schedules = node.__transition;
  if (!schedules) node.__transition = {};else if (id in schedules) return;
  create(node, id, {
    name: name,
    index: index,
    // For context during callback.
    group: group,
    // For context during callback.
    on: emptyOn,
    tween: emptyTween,
    time: timing.time,
    delay: timing.delay,
    duration: timing.duration,
    ease: timing.ease,
    timer: null,
    state: CREATED
  });
}

function init(node, id) {
  var schedule = get(node, id);
  if (schedule.state > CREATED) throw new Error("too late; already scheduled");
  return schedule;
}

function set(node, id) {
  var schedule = get(node, id);
  if (schedule.state > STARTING) throw new Error("too late; already started");
  return schedule;
}

function get(node, id) {
  var schedule = node.__transition;
  if (!schedule || !(schedule = schedule[id])) throw new Error("transition not found");
  return schedule;
}

function create(node, id, self) {
  var schedules = node.__transition,
      tween; // Initialize the self timer when the transition is created.
  // Note the actual delay is not known until the first callback!

  schedules[id] = self;
  self.timer = (0, _d3Timer.timer)(schedule, 0, self.time);

  function schedule(elapsed) {
    self.state = SCHEDULED;
    self.timer.restart(start, self.delay, self.time); // If the elapsed delay is less than our first sleep, start immediately.

    if (self.delay <= elapsed) start(elapsed - self.delay);
  }

  function start(elapsed) {
    var i, j, n, o; // If the state is not SCHEDULED, then we previously errored on start.

    if (self.state !== SCHEDULED) return stop();

    for (i in schedules) {
      o = schedules[i];
      if (o.name !== self.name) continue; // While this element already has a starting transition during this frame,
      // defer starting an interrupting transition until that transition has a
      // chance to tick (and possibly end); see d3/d3-transition#54!

      if (o.state === STARTED) return (0, _d3Timer.timeout)(start); // Interrupt the active transition, if any.
      // Dispatch the interrupt event.

      if (o.state === RUNNING) {
        o.state = ENDED;
        o.timer.stop();
        o.on.call("interrupt", node, node.__data__, o.index, o.group);
        delete schedules[i];
      } // Cancel any pre-empted transitions. No interrupt event is dispatched
      // because the cancelled transitions never started. Note that this also
      // removes this transition from the pending list!
      else if (+i < id) {
          o.state = ENDED;
          o.timer.stop();
          delete schedules[i];
        }
    } // Defer the first tick to end of the current frame; see d3/d3#1576.
    // Note the transition may be canceled after start and before the first tick!
    // Note this must be scheduled before the start event; see d3/d3-transition#16!
    // Assuming this is successful, subsequent callbacks go straight to tick.


    (0, _d3Timer.timeout)(function () {
      if (self.state === STARTED) {
        self.state = RUNNING;
        self.timer.restart(tick, self.delay, self.time);
        tick(elapsed);
      }
    }); // Dispatch the start event.
    // Note this must be done before the tween are initialized.

    self.state = STARTING;
    self.on.call("start", node, node.__data__, self.index, self.group);
    if (self.state !== STARTING) return; // interrupted

    self.state = STARTED; // Initialize the tween, deleting null tween.

    tween = new Array(n = self.tween.length);

    for (i = 0, j = -1; i < n; ++i) {
      if (o = self.tween[i].value.call(node, node.__data__, self.index, self.group)) {
        tween[++j] = o;
      }
    }

    tween.length = j + 1;
  }

  function tick(elapsed) {
    var t = elapsed < self.duration ? self.ease.call(null, elapsed / self.duration) : (self.timer.restart(stop), self.state = ENDING, 1),
        i = -1,
        n = tween.length;

    while (++i < n) {
      tween[i].call(null, t);
    } // Dispatch the end event.


    if (self.state === ENDING) {
      self.on.call("end", node, node.__data__, self.index, self.group);
      stop();
    }
  }

  function stop() {
    self.state = ENDED;
    self.timer.stop();
    delete schedules[id];

    for (var i in schedules) return; // eslint-disable-line no-unused-vars


    delete node.__transition;
  }
}
},{"d3-dispatch":"FHGa","d3-timer":"Gc7n"}],"xAnP":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _schedule = require("./transition/schedule");

function _default(node, name) {
  var schedules = node.__transition,
      schedule,
      active,
      empty = true,
      i;
  if (!schedules) return;
  name = name == null ? null : name + "";

  for (i in schedules) {
    if ((schedule = schedules[i]).name !== name) {
      empty = false;
      continue;
    }

    active = schedule.state > _schedule.STARTING && schedule.state < _schedule.ENDING;
    schedule.state = _schedule.ENDED;
    schedule.timer.stop();
    if (active) schedule.on.call("interrupt", node, node.__data__, schedule.index, schedule.group);
    delete schedules[i];
  }

  if (empty) delete node.__transition;
}
},{"./transition/schedule":"GDzO"}],"JwzZ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _interrupt = _interopRequireDefault(require("../interrupt"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(name) {
  return this.each(function () {
    (0, _interrupt.default)(this, name);
  });
}
},{"../interrupt":"xAnP"}],"CgJV":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.tweenValue = tweenValue;

var _schedule = require("./schedule");

function tweenRemove(id, name) {
  var tween0, tween1;
  return function () {
    var schedule = (0, _schedule.set)(this, id),
        tween = schedule.tween; // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.

    if (tween !== tween0) {
      tween1 = tween0 = tween;

      for (var i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1 = tween1.slice();
          tween1.splice(i, 1);
          break;
        }
      }
    }

    schedule.tween = tween1;
  };
}

function tweenFunction(id, name, value) {
  var tween0, tween1;
  if (typeof value !== "function") throw new Error();
  return function () {
    var schedule = (0, _schedule.set)(this, id),
        tween = schedule.tween; // If this node shared tween with the previous node,
    // just assign the updated shared tween and we’re done!
    // Otherwise, copy-on-write.

    if (tween !== tween0) {
      tween1 = (tween0 = tween).slice();

      for (var t = {
        name: name,
        value: value
      }, i = 0, n = tween1.length; i < n; ++i) {
        if (tween1[i].name === name) {
          tween1[i] = t;
          break;
        }
      }

      if (i === n) tween1.push(t);
    }

    schedule.tween = tween1;
  };
}

function _default(name, value) {
  var id = this._id;
  name += "";

  if (arguments.length < 2) {
    var tween = (0, _schedule.get)(this.node(), id).tween;

    for (var i = 0, n = tween.length, t; i < n; ++i) {
      if ((t = tween[i]).name === name) {
        return t.value;
      }
    }

    return null;
  }

  return this.each((value == null ? tweenRemove : tweenFunction)(id, name, value));
}

function tweenValue(transition, name, value) {
  var id = transition._id;
  transition.each(function () {
    var schedule = (0, _schedule.set)(this, id);
    (schedule.value || (schedule.value = {}))[name] = value.apply(this, arguments);
  });
  return function (node) {
    return (0, _schedule.get)(node, id).value[name];
  };
}
},{"./schedule":"GDzO"}],"KSuB":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _d3Color = require("d3-color");

var _d3Interpolate = require("d3-interpolate");

function _default(a, b) {
  var c;
  return (typeof b === "number" ? _d3Interpolate.interpolateNumber : b instanceof _d3Color.color ? _d3Interpolate.interpolateRgb : (c = (0, _d3Color.color)(b)) ? (b = c, _d3Interpolate.interpolateRgb) : _d3Interpolate.interpolateString)(a, b);
}
},{"d3-color":"RuBy","d3-interpolate":"nuBz"}],"e4SM":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _d3Interpolate = require("d3-interpolate");

var _d3Selection = require("d3-selection");

var _tween = require("./tween");

var _interpolate = _interopRequireDefault(require("./interpolate"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function attrRemove(name) {
  return function () {
    this.removeAttribute(name);
  };
}

function attrRemoveNS(fullname) {
  return function () {
    this.removeAttributeNS(fullname.space, fullname.local);
  };
}

function attrConstant(name, interpolate, value1) {
  var value00, interpolate0;
  return function () {
    var value0 = this.getAttribute(name);
    return value0 === value1 ? null : value0 === value00 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value1);
  };
}

function attrConstantNS(fullname, interpolate, value1) {
  var value00, interpolate0;
  return function () {
    var value0 = this.getAttributeNS(fullname.space, fullname.local);
    return value0 === value1 ? null : value0 === value00 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value1);
  };
}

function attrFunction(name, interpolate, value) {
  var value00, value10, interpolate0;
  return function () {
    var value0,
        value1 = value(this);
    if (value1 == null) return void this.removeAttribute(name);
    value0 = this.getAttribute(name);
    return value0 === value1 ? null : value0 === value00 && value1 === value10 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value10 = value1);
  };
}

function attrFunctionNS(fullname, interpolate, value) {
  var value00, value10, interpolate0;
  return function () {
    var value0,
        value1 = value(this);
    if (value1 == null) return void this.removeAttributeNS(fullname.space, fullname.local);
    value0 = this.getAttributeNS(fullname.space, fullname.local);
    return value0 === value1 ? null : value0 === value00 && value1 === value10 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value10 = value1);
  };
}

function _default(name, value) {
  var fullname = (0, _d3Selection.namespace)(name),
      i = fullname === "transform" ? _d3Interpolate.interpolateTransformSvg : _interpolate.default;
  return this.attrTween(name, typeof value === "function" ? (fullname.local ? attrFunctionNS : attrFunction)(fullname, i, (0, _tween.tweenValue)(this, "attr." + name, value)) : value == null ? (fullname.local ? attrRemoveNS : attrRemove)(fullname) : (fullname.local ? attrConstantNS : attrConstant)(fullname, i, value + ""));
}
},{"d3-interpolate":"nuBz","d3-selection":"ObH6","./tween":"CgJV","./interpolate":"KSuB"}],"L4WC":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _d3Selection = require("d3-selection");

function attrTweenNS(fullname, value) {
  function tween() {
    var node = this,
        i = value.apply(node, arguments);
    return i && function (t) {
      node.setAttributeNS(fullname.space, fullname.local, i(t));
    };
  }

  tween._value = value;
  return tween;
}

function attrTween(name, value) {
  function tween() {
    var node = this,
        i = value.apply(node, arguments);
    return i && function (t) {
      node.setAttribute(name, i(t));
    };
  }

  tween._value = value;
  return tween;
}

function _default(name, value) {
  var key = "attr." + name;
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error();
  var fullname = (0, _d3Selection.namespace)(name);
  return this.tween(key, (fullname.local ? attrTweenNS : attrTween)(fullname, value));
}
},{"d3-selection":"ObH6"}],"K26P":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _schedule = require("./schedule");

function delayFunction(id, value) {
  return function () {
    (0, _schedule.init)(this, id).delay = +value.apply(this, arguments);
  };
}

function delayConstant(id, value) {
  return value = +value, function () {
    (0, _schedule.init)(this, id).delay = value;
  };
}

function _default(value) {
  var id = this._id;
  return arguments.length ? this.each((typeof value === "function" ? delayFunction : delayConstant)(id, value)) : (0, _schedule.get)(this.node(), id).delay;
}
},{"./schedule":"GDzO"}],"ZZtL":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _schedule = require("./schedule");

function durationFunction(id, value) {
  return function () {
    (0, _schedule.set)(this, id).duration = +value.apply(this, arguments);
  };
}

function durationConstant(id, value) {
  return value = +value, function () {
    (0, _schedule.set)(this, id).duration = value;
  };
}

function _default(value) {
  var id = this._id;
  return arguments.length ? this.each((typeof value === "function" ? durationFunction : durationConstant)(id, value)) : (0, _schedule.get)(this.node(), id).duration;
}
},{"./schedule":"GDzO"}],"pgS5":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _schedule = require("./schedule");

function easeConstant(id, value) {
  if (typeof value !== "function") throw new Error();
  return function () {
    (0, _schedule.set)(this, id).ease = value;
  };
}

function _default(value) {
  var id = this._id;
  return arguments.length ? this.each(easeConstant(id, value)) : (0, _schedule.get)(this.node(), id).ease;
}
},{"./schedule":"GDzO"}],"QDlU":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _d3Selection = require("d3-selection");

var _index = require("./index");

function _default(match) {
  if (typeof match !== "function") match = (0, _d3Selection.matcher)(match);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = [], node, i = 0; i < n; ++i) {
      if ((node = group[i]) && match.call(node, node.__data__, i, group)) {
        subgroup.push(node);
      }
    }
  }

  return new _index.Transition(subgroups, this._parents, this._name, this._id);
}
},{"d3-selection":"ObH6","./index":"J3C7"}],"Z2Q2":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = require("./index");

function _default(transition) {
  if (transition._id !== this._id) throw new Error();

  for (var groups0 = this._groups, groups1 = transition._groups, m0 = groups0.length, m1 = groups1.length, m = Math.min(m0, m1), merges = new Array(m0), j = 0; j < m; ++j) {
    for (var group0 = groups0[j], group1 = groups1[j], n = group0.length, merge = merges[j] = new Array(n), node, i = 0; i < n; ++i) {
      if (node = group0[i] || group1[i]) {
        merge[i] = node;
      }
    }
  }

  for (; j < m0; ++j) {
    merges[j] = groups0[j];
  }

  return new _index.Transition(merges, this._parents, this._name, this._id);
}
},{"./index":"J3C7"}],"VZes":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _schedule = require("./schedule");

function start(name) {
  return (name + "").trim().split(/^|\s+/).every(function (t) {
    var i = t.indexOf(".");
    if (i >= 0) t = t.slice(0, i);
    return !t || t === "start";
  });
}

function onFunction(id, name, listener) {
  var on0,
      on1,
      sit = start(name) ? _schedule.init : _schedule.set;
  return function () {
    var schedule = sit(this, id),
        on = schedule.on; // If this node shared a dispatch with the previous node,
    // just assign the updated shared dispatch and we’re done!
    // Otherwise, copy-on-write.

    if (on !== on0) (on1 = (on0 = on).copy()).on(name, listener);
    schedule.on = on1;
  };
}

function _default(name, listener) {
  var id = this._id;
  return arguments.length < 2 ? (0, _schedule.get)(this.node(), id).on.on(name) : this.each(onFunction(id, name, listener));
}
},{"./schedule":"GDzO"}],"FS2t":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function removeFunction(id) {
  return function () {
    var parent = this.parentNode;

    for (var i in this.__transition) if (+i !== id) return;

    if (parent) parent.removeChild(this);
  };
}

function _default() {
  return this.on("end.remove", removeFunction(this._id));
}
},{}],"Xvwr":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _d3Selection = require("d3-selection");

var _index = require("./index");

var _schedule = _interopRequireWildcard(require("./schedule"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _default(select) {
  var name = this._name,
      id = this._id;
  if (typeof select !== "function") select = (0, _d3Selection.selector)(select);

  for (var groups = this._groups, m = groups.length, subgroups = new Array(m), j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, subgroup = subgroups[j] = new Array(n), node, subnode, i = 0; i < n; ++i) {
      if ((node = group[i]) && (subnode = select.call(node, node.__data__, i, group))) {
        if ("__data__" in node) subnode.__data__ = node.__data__;
        subgroup[i] = subnode;
        (0, _schedule.default)(subgroup[i], name, id, i, subgroup, (0, _schedule.get)(node, id));
      }
    }
  }

  return new _index.Transition(subgroups, this._parents, name, id);
}
},{"d3-selection":"ObH6","./index":"J3C7","./schedule":"GDzO"}],"DOdJ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _d3Selection = require("d3-selection");

var _index = require("./index");

var _schedule = _interopRequireWildcard(require("./schedule"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _default(select) {
  var name = this._name,
      id = this._id;
  if (typeof select !== "function") select = (0, _d3Selection.selectorAll)(select);

  for (var groups = this._groups, m = groups.length, subgroups = [], parents = [], j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        for (var children = select.call(node, node.__data__, i, group), child, inherit = (0, _schedule.get)(node, id), k = 0, l = children.length; k < l; ++k) {
          if (child = children[k]) {
            (0, _schedule.default)(child, name, id, k, children, inherit);
          }
        }

        subgroups.push(children);
        parents.push(node);
      }
    }
  }

  return new _index.Transition(subgroups, parents, name, id);
}
},{"d3-selection":"ObH6","./index":"J3C7","./schedule":"GDzO"}],"bQR7":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _d3Selection = require("d3-selection");

var Selection = _d3Selection.selection.prototype.constructor;

function _default() {
  return new Selection(this._groups, this._parents);
}
},{"d3-selection":"ObH6"}],"gXfd":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _d3Interpolate = require("d3-interpolate");

var _d3Selection = require("d3-selection");

var _tween = require("./tween");

var _interpolate = _interopRequireDefault(require("./interpolate"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function styleRemove(name, interpolate) {
  var value00, value10, interpolate0;
  return function () {
    var value0 = (0, _d3Selection.style)(this, name),
        value1 = (this.style.removeProperty(name), (0, _d3Selection.style)(this, name));
    return value0 === value1 ? null : value0 === value00 && value1 === value10 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value10 = value1);
  };
}

function styleRemoveEnd(name) {
  return function () {
    this.style.removeProperty(name);
  };
}

function styleConstant(name, interpolate, value1) {
  var value00, interpolate0;
  return function () {
    var value0 = (0, _d3Selection.style)(this, name);
    return value0 === value1 ? null : value0 === value00 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value1);
  };
}

function styleFunction(name, interpolate, value) {
  var value00, value10, interpolate0;
  return function () {
    var value0 = (0, _d3Selection.style)(this, name),
        value1 = value(this);
    if (value1 == null) value1 = (this.style.removeProperty(name), (0, _d3Selection.style)(this, name));
    return value0 === value1 ? null : value0 === value00 && value1 === value10 ? interpolate0 : interpolate0 = interpolate(value00 = value0, value10 = value1);
  };
}

function _default(name, value, priority) {
  var i = (name += "") === "transform" ? _d3Interpolate.interpolateTransformCss : _interpolate.default;
  return value == null ? this.styleTween(name, styleRemove(name, i)).on("end.style." + name, styleRemoveEnd(name)) : this.styleTween(name, typeof value === "function" ? styleFunction(name, i, (0, _tween.tweenValue)(this, "style." + name, value)) : styleConstant(name, i, value + ""), priority);
}
},{"d3-interpolate":"nuBz","d3-selection":"ObH6","./tween":"CgJV","./interpolate":"KSuB"}],"SCZW":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function styleTween(name, value, priority) {
  function tween() {
    var node = this,
        i = value.apply(node, arguments);
    return i && function (t) {
      node.style.setProperty(name, i(t), priority);
    };
  }

  tween._value = value;
  return tween;
}

function _default(name, value, priority) {
  var key = "style." + (name += "");
  if (arguments.length < 2) return (key = this.tween(key)) && key._value;
  if (value == null) return this.tween(key, null);
  if (typeof value !== "function") throw new Error();
  return this.tween(key, styleTween(name, value, priority == null ? "" : priority));
}
},{}],"HTlb":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _tween = require("./tween");

function textConstant(value) {
  return function () {
    this.textContent = value;
  };
}

function textFunction(value) {
  return function () {
    var value1 = value(this);
    this.textContent = value1 == null ? "" : value1;
  };
}

function _default(value) {
  return this.tween("text", typeof value === "function" ? textFunction((0, _tween.tweenValue)(this, "text", value)) : textConstant(value == null ? "" : value + ""));
}
},{"./tween":"CgJV"}],"rWxz":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = require("./index");

var _schedule = _interopRequireWildcard(require("./schedule"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _default() {
  var name = this._name,
      id0 = this._id,
      id1 = (0, _index.newId)();

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        var inherit = (0, _schedule.get)(node, id0);
        (0, _schedule.default)(node, name, id1, i, group, {
          time: inherit.time + inherit.delay + inherit.duration,
          delay: 0,
          duration: inherit.duration,
          ease: inherit.ease
        });
      }
    }
  }

  return new _index.Transition(groups, this._parents, name, id1);
}
},{"./index":"J3C7","./schedule":"GDzO"}],"J3C7":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Transition = Transition;
exports.default = transition;
exports.newId = newId;

var _d3Selection = require("d3-selection");

var _attr = _interopRequireDefault(require("./attr"));

var _attrTween = _interopRequireDefault(require("./attrTween"));

var _delay = _interopRequireDefault(require("./delay"));

var _duration = _interopRequireDefault(require("./duration"));

var _ease = _interopRequireDefault(require("./ease"));

var _filter = _interopRequireDefault(require("./filter"));

var _merge = _interopRequireDefault(require("./merge"));

var _on = _interopRequireDefault(require("./on"));

var _remove = _interopRequireDefault(require("./remove"));

var _select = _interopRequireDefault(require("./select"));

var _selectAll = _interopRequireDefault(require("./selectAll"));

var _selection = _interopRequireDefault(require("./selection"));

var _style = _interopRequireDefault(require("./style"));

var _styleTween = _interopRequireDefault(require("./styleTween"));

var _text = _interopRequireDefault(require("./text"));

var _transition = _interopRequireDefault(require("./transition"));

var _tween = _interopRequireDefault(require("./tween"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var id = 0;

function Transition(groups, parents, name, id) {
  this._groups = groups;
  this._parents = parents;
  this._name = name;
  this._id = id;
}

function transition(name) {
  return (0, _d3Selection.selection)().transition(name);
}

function newId() {
  return ++id;
}

var selection_prototype = _d3Selection.selection.prototype;
Transition.prototype = transition.prototype = {
  constructor: Transition,
  select: _select.default,
  selectAll: _selectAll.default,
  filter: _filter.default,
  merge: _merge.default,
  selection: _selection.default,
  transition: _transition.default,
  call: selection_prototype.call,
  nodes: selection_prototype.nodes,
  node: selection_prototype.node,
  size: selection_prototype.size,
  empty: selection_prototype.empty,
  each: selection_prototype.each,
  on: _on.default,
  attr: _attr.default,
  attrTween: _attrTween.default,
  style: _style.default,
  styleTween: _styleTween.default,
  text: _text.default,
  remove: _remove.default,
  tween: _tween.default,
  delay: _delay.default,
  duration: _duration.default,
  ease: _ease.default
};
},{"d3-selection":"ObH6","./attr":"e4SM","./attrTween":"L4WC","./delay":"K26P","./duration":"ZZtL","./ease":"pgS5","./filter":"QDlU","./merge":"Z2Q2","./on":"VZes","./remove":"FS2t","./select":"Xvwr","./selectAll":"DOdJ","./selection":"bQR7","./style":"gXfd","./styleTween":"SCZW","./text":"HTlb","./transition":"rWxz","./tween":"CgJV"}],"fXiu":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.linear = linear;

function linear(t) {
  return +t;
}
},{}],"GaS5":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.quadIn = quadIn;
exports.quadOut = quadOut;
exports.quadInOut = quadInOut;

function quadIn(t) {
  return t * t;
}

function quadOut(t) {
  return t * (2 - t);
}

function quadInOut(t) {
  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
}
},{}],"PA7e":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cubicIn = cubicIn;
exports.cubicOut = cubicOut;
exports.cubicInOut = cubicInOut;

function cubicIn(t) {
  return t * t * t;
}

function cubicOut(t) {
  return --t * t * t + 1;
}

function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}
},{}],"ECJi":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.polyInOut = exports.polyOut = exports.polyIn = void 0;
var exponent = 3;

var polyIn = function custom(e) {
  e = +e;

  function polyIn(t) {
    return Math.pow(t, e);
  }

  polyIn.exponent = custom;
  return polyIn;
}(exponent);

exports.polyIn = polyIn;

var polyOut = function custom(e) {
  e = +e;

  function polyOut(t) {
    return 1 - Math.pow(1 - t, e);
  }

  polyOut.exponent = custom;
  return polyOut;
}(exponent);

exports.polyOut = polyOut;

var polyInOut = function custom(e) {
  e = +e;

  function polyInOut(t) {
    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
  }

  polyInOut.exponent = custom;
  return polyInOut;
}(exponent);

exports.polyInOut = polyInOut;
},{}],"sZZb":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sinIn = sinIn;
exports.sinOut = sinOut;
exports.sinInOut = sinInOut;
var pi = Math.PI,
    halfPi = pi / 2;

function sinIn(t) {
  return 1 - Math.cos(t * halfPi);
}

function sinOut(t) {
  return Math.sin(t * halfPi);
}

function sinInOut(t) {
  return (1 - Math.cos(pi * t)) / 2;
}
},{}],"rYq8":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.expIn = expIn;
exports.expOut = expOut;
exports.expInOut = expInOut;

function expIn(t) {
  return Math.pow(2, 10 * t - 10);
}

function expOut(t) {
  return 1 - Math.pow(2, -10 * t);
}

function expInOut(t) {
  return ((t *= 2) <= 1 ? Math.pow(2, 10 * t - 10) : 2 - Math.pow(2, 10 - 10 * t)) / 2;
}
},{}],"hED8":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.circleIn = circleIn;
exports.circleOut = circleOut;
exports.circleInOut = circleInOut;

function circleIn(t) {
  return 1 - Math.sqrt(1 - t * t);
}

function circleOut(t) {
  return Math.sqrt(1 - --t * t);
}

function circleInOut(t) {
  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
}
},{}],"MKsh":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bounceIn = bounceIn;
exports.bounceOut = bounceOut;
exports.bounceInOut = bounceInOut;
var b1 = 4 / 11,
    b2 = 6 / 11,
    b3 = 8 / 11,
    b4 = 3 / 4,
    b5 = 9 / 11,
    b6 = 10 / 11,
    b7 = 15 / 16,
    b8 = 21 / 22,
    b9 = 63 / 64,
    b0 = 1 / b1 / b1;

function bounceIn(t) {
  return 1 - bounceOut(1 - t);
}

function bounceOut(t) {
  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
}

function bounceInOut(t) {
  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
}
},{}],"fCsL":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.backInOut = exports.backOut = exports.backIn = void 0;
var overshoot = 1.70158;

var backIn = function custom(s) {
  s = +s;

  function backIn(t) {
    return t * t * ((s + 1) * t - s);
  }

  backIn.overshoot = custom;
  return backIn;
}(overshoot);

exports.backIn = backIn;

var backOut = function custom(s) {
  s = +s;

  function backOut(t) {
    return --t * t * ((s + 1) * t + s) + 1;
  }

  backOut.overshoot = custom;
  return backOut;
}(overshoot);

exports.backOut = backOut;

var backInOut = function custom(s) {
  s = +s;

  function backInOut(t) {
    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
  }

  backInOut.overshoot = custom;
  return backInOut;
}(overshoot);

exports.backInOut = backInOut;
},{}],"xolo":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.elasticInOut = exports.elasticOut = exports.elasticIn = void 0;
var tau = 2 * Math.PI,
    amplitude = 1,
    period = 0.3;

var elasticIn = function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticIn(t) {
    return a * Math.pow(2, 10 * --t) * Math.sin((s - t) / p);
  }

  elasticIn.amplitude = function (a) {
    return custom(a, p * tau);
  };

  elasticIn.period = function (p) {
    return custom(a, p);
  };

  return elasticIn;
}(amplitude, period);

exports.elasticIn = elasticIn;

var elasticOut = function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticOut(t) {
    return 1 - a * Math.pow(2, -10 * (t = +t)) * Math.sin((t + s) / p);
  }

  elasticOut.amplitude = function (a) {
    return custom(a, p * tau);
  };

  elasticOut.period = function (p) {
    return custom(a, p);
  };

  return elasticOut;
}(amplitude, period);

exports.elasticOut = elasticOut;

var elasticInOut = function custom(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);

  function elasticInOut(t) {
    return ((t = t * 2 - 1) < 0 ? a * Math.pow(2, 10 * t) * Math.sin((s - t) / p) : 2 - a * Math.pow(2, -10 * t) * Math.sin((s + t) / p)) / 2;
  }

  elasticInOut.amplitude = function (a) {
    return custom(a, p * tau);
  };

  elasticInOut.period = function (p) {
    return custom(a, p);
  };

  return elasticInOut;
}(amplitude, period);

exports.elasticInOut = elasticInOut;
},{}],"Ufrd":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "easeLinear", {
  enumerable: true,
  get: function () {
    return _linear.linear;
  }
});
Object.defineProperty(exports, "easeQuad", {
  enumerable: true,
  get: function () {
    return _quad.quadInOut;
  }
});
Object.defineProperty(exports, "easeQuadIn", {
  enumerable: true,
  get: function () {
    return _quad.quadIn;
  }
});
Object.defineProperty(exports, "easeQuadOut", {
  enumerable: true,
  get: function () {
    return _quad.quadOut;
  }
});
Object.defineProperty(exports, "easeQuadInOut", {
  enumerable: true,
  get: function () {
    return _quad.quadInOut;
  }
});
Object.defineProperty(exports, "easeCubic", {
  enumerable: true,
  get: function () {
    return _cubic.cubicInOut;
  }
});
Object.defineProperty(exports, "easeCubicIn", {
  enumerable: true,
  get: function () {
    return _cubic.cubicIn;
  }
});
Object.defineProperty(exports, "easeCubicOut", {
  enumerable: true,
  get: function () {
    return _cubic.cubicOut;
  }
});
Object.defineProperty(exports, "easeCubicInOut", {
  enumerable: true,
  get: function () {
    return _cubic.cubicInOut;
  }
});
Object.defineProperty(exports, "easePoly", {
  enumerable: true,
  get: function () {
    return _poly.polyInOut;
  }
});
Object.defineProperty(exports, "easePolyIn", {
  enumerable: true,
  get: function () {
    return _poly.polyIn;
  }
});
Object.defineProperty(exports, "easePolyOut", {
  enumerable: true,
  get: function () {
    return _poly.polyOut;
  }
});
Object.defineProperty(exports, "easePolyInOut", {
  enumerable: true,
  get: function () {
    return _poly.polyInOut;
  }
});
Object.defineProperty(exports, "easeSin", {
  enumerable: true,
  get: function () {
    return _sin.sinInOut;
  }
});
Object.defineProperty(exports, "easeSinIn", {
  enumerable: true,
  get: function () {
    return _sin.sinIn;
  }
});
Object.defineProperty(exports, "easeSinOut", {
  enumerable: true,
  get: function () {
    return _sin.sinOut;
  }
});
Object.defineProperty(exports, "easeSinInOut", {
  enumerable: true,
  get: function () {
    return _sin.sinInOut;
  }
});
Object.defineProperty(exports, "easeExp", {
  enumerable: true,
  get: function () {
    return _exp.expInOut;
  }
});
Object.defineProperty(exports, "easeExpIn", {
  enumerable: true,
  get: function () {
    return _exp.expIn;
  }
});
Object.defineProperty(exports, "easeExpOut", {
  enumerable: true,
  get: function () {
    return _exp.expOut;
  }
});
Object.defineProperty(exports, "easeExpInOut", {
  enumerable: true,
  get: function () {
    return _exp.expInOut;
  }
});
Object.defineProperty(exports, "easeCircle", {
  enumerable: true,
  get: function () {
    return _circle.circleInOut;
  }
});
Object.defineProperty(exports, "easeCircleIn", {
  enumerable: true,
  get: function () {
    return _circle.circleIn;
  }
});
Object.defineProperty(exports, "easeCircleOut", {
  enumerable: true,
  get: function () {
    return _circle.circleOut;
  }
});
Object.defineProperty(exports, "easeCircleInOut", {
  enumerable: true,
  get: function () {
    return _circle.circleInOut;
  }
});
Object.defineProperty(exports, "easeBounce", {
  enumerable: true,
  get: function () {
    return _bounce.bounceOut;
  }
});
Object.defineProperty(exports, "easeBounceIn", {
  enumerable: true,
  get: function () {
    return _bounce.bounceIn;
  }
});
Object.defineProperty(exports, "easeBounceOut", {
  enumerable: true,
  get: function () {
    return _bounce.bounceOut;
  }
});
Object.defineProperty(exports, "easeBounceInOut", {
  enumerable: true,
  get: function () {
    return _bounce.bounceInOut;
  }
});
Object.defineProperty(exports, "easeBack", {
  enumerable: true,
  get: function () {
    return _back.backInOut;
  }
});
Object.defineProperty(exports, "easeBackIn", {
  enumerable: true,
  get: function () {
    return _back.backIn;
  }
});
Object.defineProperty(exports, "easeBackOut", {
  enumerable: true,
  get: function () {
    return _back.backOut;
  }
});
Object.defineProperty(exports, "easeBackInOut", {
  enumerable: true,
  get: function () {
    return _back.backInOut;
  }
});
Object.defineProperty(exports, "easeElastic", {
  enumerable: true,
  get: function () {
    return _elastic.elasticOut;
  }
});
Object.defineProperty(exports, "easeElasticIn", {
  enumerable: true,
  get: function () {
    return _elastic.elasticIn;
  }
});
Object.defineProperty(exports, "easeElasticOut", {
  enumerable: true,
  get: function () {
    return _elastic.elasticOut;
  }
});
Object.defineProperty(exports, "easeElasticInOut", {
  enumerable: true,
  get: function () {
    return _elastic.elasticInOut;
  }
});

var _linear = require("./src/linear");

var _quad = require("./src/quad");

var _cubic = require("./src/cubic");

var _poly = require("./src/poly");

var _sin = require("./src/sin");

var _exp = require("./src/exp");

var _circle = require("./src/circle");

var _bounce = require("./src/bounce");

var _back = require("./src/back");

var _elastic = require("./src/elastic");
},{"./src/linear":"fXiu","./src/quad":"GaS5","./src/cubic":"PA7e","./src/poly":"ECJi","./src/sin":"sZZb","./src/exp":"rYq8","./src/circle":"hED8","./src/bounce":"MKsh","./src/back":"fCsL","./src/elastic":"xolo"}],"CNir":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = require("../transition/index");

var _schedule = _interopRequireDefault(require("../transition/schedule"));

var _d3Ease = require("d3-ease");

var _d3Timer = require("d3-timer");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var defaultTiming = {
  time: null,
  // Set on use.
  delay: 0,
  duration: 250,
  ease: _d3Ease.easeCubicInOut
};

function inherit(node, id) {
  var timing;

  while (!(timing = node.__transition) || !(timing = timing[id])) {
    if (!(node = node.parentNode)) {
      return defaultTiming.time = (0, _d3Timer.now)(), defaultTiming;
    }
  }

  return timing;
}

function _default(name) {
  var id, timing;

  if (name instanceof _index.Transition) {
    id = name._id, name = name._name;
  } else {
    id = (0, _index.newId)(), (timing = defaultTiming).time = (0, _d3Timer.now)(), name = name == null ? null : name + "";
  }

  for (var groups = this._groups, m = groups.length, j = 0; j < m; ++j) {
    for (var group = groups[j], n = group.length, node, i = 0; i < n; ++i) {
      if (node = group[i]) {
        (0, _schedule.default)(node, name, id, i, group, timing || inherit(node, id));
      }
    }
  }

  return new _index.Transition(groups, this._parents, name, id);
}
},{"../transition/index":"J3C7","../transition/schedule":"GDzO","d3-ease":"Ufrd","d3-timer":"Gc7n"}],"uhVG":[function(require,module,exports) {
"use strict";

var _d3Selection = require("d3-selection");

var _interrupt = _interopRequireDefault(require("./interrupt"));

var _transition = _interopRequireDefault(require("./transition"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_d3Selection.selection.prototype.interrupt = _interrupt.default;
_d3Selection.selection.prototype.transition = _transition.default;
},{"d3-selection":"ObH6","./interrupt":"JwzZ","./transition":"CNir"}],"zz7H":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = require("./transition/index");

var _schedule = require("./transition/schedule");

var root = [null];

function _default(node, name) {
  var schedules = node.__transition,
      schedule,
      i;

  if (schedules) {
    name = name == null ? null : name + "";

    for (i in schedules) {
      if ((schedule = schedules[i]).state > _schedule.SCHEDULED && schedule.name === name) {
        return new _index.Transition([[node]], root, name, +i);
      }
    }
  }

  return null;
}
},{"./transition/index":"J3C7","./transition/schedule":"GDzO"}],"RVDI":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "transition", {
  enumerable: true,
  get: function () {
    return _index2.default;
  }
});
Object.defineProperty(exports, "active", {
  enumerable: true,
  get: function () {
    return _active.default;
  }
});
Object.defineProperty(exports, "interrupt", {
  enumerable: true,
  get: function () {
    return _interrupt.default;
  }
});

require("./src/selection/index");

var _index2 = _interopRequireDefault(require("./src/transition/index"));

var _active = _interopRequireDefault(require("./src/active"));

var _interrupt = _interopRequireDefault(require("./src/interrupt"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./src/selection/index":"uhVG","./src/transition/index":"J3C7","./src/active":"zz7H","./src/interrupt":"xAnP"}],"iX60":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(target, type, selection) {
  this.target = target;
  this.type = type;
  this.selection = selection;
}
},{}],"HwJw":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.brushSelection = brushSelection;
exports.brushX = brushX;
exports.brushY = brushY;
exports.default = _default;

var _d3Dispatch = require("d3-dispatch");

var _d3Drag = require("d3-drag");

var _d3Interpolate = require("d3-interpolate");

var _d3Selection = require("d3-selection");

var _d3Transition = require("d3-transition");

var _constant = _interopRequireDefault(require("./constant"));

var _event = _interopRequireDefault(require("./event"));

var _noevent = _interopRequireWildcard(require("./noevent"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MODE_DRAG = {
  name: "drag"
},
    MODE_SPACE = {
  name: "space"
},
    MODE_HANDLE = {
  name: "handle"
},
    MODE_CENTER = {
  name: "center"
};
var X = {
  name: "x",
  handles: ["e", "w"].map(type),
  input: function (x, e) {
    return x && [[x[0], e[0][1]], [x[1], e[1][1]]];
  },
  output: function (xy) {
    return xy && [xy[0][0], xy[1][0]];
  }
};
var Y = {
  name: "y",
  handles: ["n", "s"].map(type),
  input: function (y, e) {
    return y && [[e[0][0], y[0]], [e[1][0], y[1]]];
  },
  output: function (xy) {
    return xy && [xy[0][1], xy[1][1]];
  }
};
var XY = {
  name: "xy",
  handles: ["n", "e", "s", "w", "nw", "ne", "se", "sw"].map(type),
  input: function (xy) {
    return xy;
  },
  output: function (xy) {
    return xy;
  }
};
var cursors = {
  overlay: "crosshair",
  selection: "move",
  n: "ns-resize",
  e: "ew-resize",
  s: "ns-resize",
  w: "ew-resize",
  nw: "nwse-resize",
  ne: "nesw-resize",
  se: "nwse-resize",
  sw: "nesw-resize"
};
var flipX = {
  e: "w",
  w: "e",
  nw: "ne",
  ne: "nw",
  se: "sw",
  sw: "se"
};
var flipY = {
  n: "s",
  s: "n",
  nw: "sw",
  ne: "se",
  se: "ne",
  sw: "nw"
};
var signsX = {
  overlay: +1,
  selection: +1,
  n: null,
  e: +1,
  s: null,
  w: -1,
  nw: -1,
  ne: +1,
  se: +1,
  sw: -1
};
var signsY = {
  overlay: +1,
  selection: +1,
  n: -1,
  e: null,
  s: +1,
  w: null,
  nw: -1,
  ne: -1,
  se: +1,
  sw: +1
};

function type(t) {
  return {
    type: t
  };
} // Ignore right-click, since that should open the context menu.


function defaultFilter() {
  return !_d3Selection.event.button;
}

function defaultExtent() {
  var svg = this.ownerSVGElement || this;
  return [[0, 0], [svg.width.baseVal.value, svg.height.baseVal.value]];
} // Like d3.local, but with the name “__brush” rather than auto-generated.


function local(node) {
  while (!node.__brush) if (!(node = node.parentNode)) return;

  return node.__brush;
}

function empty(extent) {
  return extent[0][0] === extent[1][0] || extent[0][1] === extent[1][1];
}

function brushSelection(node) {
  var state = node.__brush;
  return state ? state.dim.output(state.selection) : null;
}

function brushX() {
  return brush(X);
}

function brushY() {
  return brush(Y);
}

function _default() {
  return brush(XY);
}

function brush(dim) {
  var extent = defaultExtent,
      filter = defaultFilter,
      listeners = (0, _d3Dispatch.dispatch)(brush, "start", "brush", "end"),
      handleSize = 6,
      touchending;

  function brush(group) {
    var overlay = group.property("__brush", initialize).selectAll(".overlay").data([type("overlay")]);
    overlay.enter().append("rect").attr("class", "overlay").attr("pointer-events", "all").attr("cursor", cursors.overlay).merge(overlay).each(function () {
      var extent = local(this).extent;
      (0, _d3Selection.select)(this).attr("x", extent[0][0]).attr("y", extent[0][1]).attr("width", extent[1][0] - extent[0][0]).attr("height", extent[1][1] - extent[0][1]);
    });
    group.selectAll(".selection").data([type("selection")]).enter().append("rect").attr("class", "selection").attr("cursor", cursors.selection).attr("fill", "#777").attr("fill-opacity", 0.3).attr("stroke", "#fff").attr("shape-rendering", "crispEdges");
    var handle = group.selectAll(".handle").data(dim.handles, function (d) {
      return d.type;
    });
    handle.exit().remove();
    handle.enter().append("rect").attr("class", function (d) {
      return "handle handle--" + d.type;
    }).attr("cursor", function (d) {
      return cursors[d.type];
    });
    group.each(redraw).attr("fill", "none").attr("pointer-events", "all").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)").on("mousedown.brush touchstart.brush", started);
  }

  brush.move = function (group, selection) {
    if (group.selection) {
      group.on("start.brush", function () {
        emitter(this, arguments).beforestart().start();
      }).on("interrupt.brush end.brush", function () {
        emitter(this, arguments).end();
      }).tween("brush", function () {
        var that = this,
            state = that.__brush,
            emit = emitter(that, arguments),
            selection0 = state.selection,
            selection1 = dim.input(typeof selection === "function" ? selection.apply(this, arguments) : selection, state.extent),
            i = (0, _d3Interpolate.interpolate)(selection0, selection1);

        function tween(t) {
          state.selection = t === 1 && empty(selection1) ? null : i(t);
          redraw.call(that);
          emit.brush();
        }

        return selection0 && selection1 ? tween : tween(1);
      });
    } else {
      group.each(function () {
        var that = this,
            args = arguments,
            state = that.__brush,
            selection1 = dim.input(typeof selection === "function" ? selection.apply(that, args) : selection, state.extent),
            emit = emitter(that, args).beforestart();
        (0, _d3Transition.interrupt)(that);
        state.selection = selection1 == null || empty(selection1) ? null : selection1;
        redraw.call(that);
        emit.start().brush().end();
      });
    }
  };

  function redraw() {
    var group = (0, _d3Selection.select)(this),
        selection = local(this).selection;

    if (selection) {
      group.selectAll(".selection").style("display", null).attr("x", selection[0][0]).attr("y", selection[0][1]).attr("width", selection[1][0] - selection[0][0]).attr("height", selection[1][1] - selection[0][1]);
      group.selectAll(".handle").style("display", null).attr("x", function (d) {
        return d.type[d.type.length - 1] === "e" ? selection[1][0] - handleSize / 2 : selection[0][0] - handleSize / 2;
      }).attr("y", function (d) {
        return d.type[0] === "s" ? selection[1][1] - handleSize / 2 : selection[0][1] - handleSize / 2;
      }).attr("width", function (d) {
        return d.type === "n" || d.type === "s" ? selection[1][0] - selection[0][0] + handleSize : handleSize;
      }).attr("height", function (d) {
        return d.type === "e" || d.type === "w" ? selection[1][1] - selection[0][1] + handleSize : handleSize;
      });
    } else {
      group.selectAll(".selection,.handle").style("display", "none").attr("x", null).attr("y", null).attr("width", null).attr("height", null);
    }
  }

  function emitter(that, args) {
    return that.__brush.emitter || new Emitter(that, args);
  }

  function Emitter(that, args) {
    this.that = that;
    this.args = args;
    this.state = that.__brush;
    this.active = 0;
  }

  Emitter.prototype = {
    beforestart: function () {
      if (++this.active === 1) this.state.emitter = this, this.starting = true;
      return this;
    },
    start: function () {
      if (this.starting) this.starting = false, this.emit("start");
      return this;
    },
    brush: function () {
      this.emit("brush");
      return this;
    },
    end: function () {
      if (--this.active === 0) delete this.state.emitter, this.emit("end");
      return this;
    },
    emit: function (type) {
      (0, _d3Selection.customEvent)(new _event.default(brush, type, dim.output(this.state.selection)), listeners.apply, listeners, [type, this.that, this.args]);
    }
  };

  function started() {
    if (_d3Selection.event.touches) {
      if (_d3Selection.event.changedTouches.length < _d3Selection.event.touches.length) return (0, _noevent.default)();
    } else if (touchending) return;

    if (!filter.apply(this, arguments)) return;
    var that = this,
        type = _d3Selection.event.target.__data__.type,
        mode = (_d3Selection.event.metaKey ? type = "overlay" : type) === "selection" ? MODE_DRAG : _d3Selection.event.altKey ? MODE_CENTER : MODE_HANDLE,
        signX = dim === Y ? null : signsX[type],
        signY = dim === X ? null : signsY[type],
        state = local(that),
        extent = state.extent,
        selection = state.selection,
        W = extent[0][0],
        w0,
        w1,
        N = extent[0][1],
        n0,
        n1,
        E = extent[1][0],
        e0,
        e1,
        S = extent[1][1],
        s0,
        s1,
        dx,
        dy,
        moving,
        shifting = signX && signY && _d3Selection.event.shiftKey,
        lockX,
        lockY,
        point0 = (0, _d3Selection.mouse)(that),
        point = point0,
        emit = emitter(that, arguments).beforestart();

    if (type === "overlay") {
      state.selection = selection = [[w0 = dim === Y ? W : point0[0], n0 = dim === X ? N : point0[1]], [e0 = dim === Y ? E : w0, s0 = dim === X ? S : n0]];
    } else {
      w0 = selection[0][0];
      n0 = selection[0][1];
      e0 = selection[1][0];
      s0 = selection[1][1];
    }

    w1 = w0;
    n1 = n0;
    e1 = e0;
    s1 = s0;
    var group = (0, _d3Selection.select)(that).attr("pointer-events", "none");
    var overlay = group.selectAll(".overlay").attr("cursor", cursors[type]);

    if (_d3Selection.event.touches) {
      group.on("touchmove.brush", moved, true).on("touchend.brush touchcancel.brush", ended, true);
    } else {
      var view = (0, _d3Selection.select)(_d3Selection.event.view).on("keydown.brush", keydowned, true).on("keyup.brush", keyupped, true).on("mousemove.brush", moved, true).on("mouseup.brush", ended, true);
      (0, _d3Drag.dragDisable)(_d3Selection.event.view);
    }

    (0, _noevent.nopropagation)();
    (0, _d3Transition.interrupt)(that);
    redraw.call(that);
    emit.start();

    function moved() {
      var point1 = (0, _d3Selection.mouse)(that);

      if (shifting && !lockX && !lockY) {
        if (Math.abs(point1[0] - point[0]) > Math.abs(point1[1] - point[1])) lockY = true;else lockX = true;
      }

      point = point1;
      moving = true;
      (0, _noevent.default)();
      move();
    }

    function move() {
      var t;
      dx = point[0] - point0[0];
      dy = point[1] - point0[1];

      switch (mode) {
        case MODE_SPACE:
        case MODE_DRAG:
          {
            if (signX) dx = Math.max(W - w0, Math.min(E - e0, dx)), w1 = w0 + dx, e1 = e0 + dx;
            if (signY) dy = Math.max(N - n0, Math.min(S - s0, dy)), n1 = n0 + dy, s1 = s0 + dy;
            break;
          }

        case MODE_HANDLE:
          {
            if (signX < 0) dx = Math.max(W - w0, Math.min(E - w0, dx)), w1 = w0 + dx, e1 = e0;else if (signX > 0) dx = Math.max(W - e0, Math.min(E - e0, dx)), w1 = w0, e1 = e0 + dx;
            if (signY < 0) dy = Math.max(N - n0, Math.min(S - n0, dy)), n1 = n0 + dy, s1 = s0;else if (signY > 0) dy = Math.max(N - s0, Math.min(S - s0, dy)), n1 = n0, s1 = s0 + dy;
            break;
          }

        case MODE_CENTER:
          {
            if (signX) w1 = Math.max(W, Math.min(E, w0 - dx * signX)), e1 = Math.max(W, Math.min(E, e0 + dx * signX));
            if (signY) n1 = Math.max(N, Math.min(S, n0 - dy * signY)), s1 = Math.max(N, Math.min(S, s0 + dy * signY));
            break;
          }
      }

      if (e1 < w1) {
        signX *= -1;
        t = w0, w0 = e0, e0 = t;
        t = w1, w1 = e1, e1 = t;
        if (type in flipX) overlay.attr("cursor", cursors[type = flipX[type]]);
      }

      if (s1 < n1) {
        signY *= -1;
        t = n0, n0 = s0, s0 = t;
        t = n1, n1 = s1, s1 = t;
        if (type in flipY) overlay.attr("cursor", cursors[type = flipY[type]]);
      }

      if (state.selection) selection = state.selection; // May be set by brush.move!

      if (lockX) w1 = selection[0][0], e1 = selection[1][0];
      if (lockY) n1 = selection[0][1], s1 = selection[1][1];

      if (selection[0][0] !== w1 || selection[0][1] !== n1 || selection[1][0] !== e1 || selection[1][1] !== s1) {
        state.selection = [[w1, n1], [e1, s1]];
        redraw.call(that);
        emit.brush();
      }
    }

    function ended() {
      (0, _noevent.nopropagation)();

      if (_d3Selection.event.touches) {
        if (_d3Selection.event.touches.length) return;
        if (touchending) clearTimeout(touchending);
        touchending = setTimeout(function () {
          touchending = null;
        }, 500); // Ghost clicks are delayed!

        group.on("touchmove.brush touchend.brush touchcancel.brush", null);
      } else {
        (0, _d3Drag.dragEnable)(_d3Selection.event.view, moving);
        view.on("keydown.brush keyup.brush mousemove.brush mouseup.brush", null);
      }

      group.attr("pointer-events", "all");
      overlay.attr("cursor", cursors.overlay);
      if (state.selection) selection = state.selection; // May be set by brush.move (on start)!

      if (empty(selection)) state.selection = null, redraw.call(that);
      emit.end();
    }

    function keydowned() {
      switch (_d3Selection.event.keyCode) {
        case 16:
          {
            // SHIFT
            shifting = signX && signY;
            break;
          }

        case 18:
          {
            // ALT
            if (mode === MODE_HANDLE) {
              if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
              if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
              mode = MODE_CENTER;
              move();
            }

            break;
          }

        case 32:
          {
            // SPACE; takes priority over ALT
            if (mode === MODE_HANDLE || mode === MODE_CENTER) {
              if (signX < 0) e0 = e1 - dx;else if (signX > 0) w0 = w1 - dx;
              if (signY < 0) s0 = s1 - dy;else if (signY > 0) n0 = n1 - dy;
              mode = MODE_SPACE;
              overlay.attr("cursor", cursors.selection);
              move();
            }

            break;
          }

        default:
          return;
      }

      (0, _noevent.default)();
    }

    function keyupped() {
      switch (_d3Selection.event.keyCode) {
        case 16:
          {
            // SHIFT
            if (shifting) {
              lockX = lockY = shifting = false;
              move();
            }

            break;
          }

        case 18:
          {
            // ALT
            if (mode === MODE_CENTER) {
              if (signX < 0) e0 = e1;else if (signX > 0) w0 = w1;
              if (signY < 0) s0 = s1;else if (signY > 0) n0 = n1;
              mode = MODE_HANDLE;
              move();
            }

            break;
          }

        case 32:
          {
            // SPACE
            if (mode === MODE_SPACE) {
              if (_d3Selection.event.altKey) {
                if (signX) e0 = e1 - dx * signX, w0 = w1 + dx * signX;
                if (signY) s0 = s1 - dy * signY, n0 = n1 + dy * signY;
                mode = MODE_CENTER;
              } else {
                if (signX < 0) e0 = e1;else if (signX > 0) w0 = w1;
                if (signY < 0) s0 = s1;else if (signY > 0) n0 = n1;
                mode = MODE_HANDLE;
              }

              overlay.attr("cursor", cursors[type]);
              move();
            }

            break;
          }

        default:
          return;
      }

      (0, _noevent.default)();
    }
  }

  function initialize() {
    var state = this.__brush || {
      selection: null
    };
    state.extent = extent.apply(this, arguments);
    state.dim = dim;
    return state;
  }

  brush.extent = function (_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : (0, _constant.default)([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), brush) : extent;
  };

  brush.filter = function (_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : (0, _constant.default)(!!_), brush) : filter;
  };

  brush.handleSize = function (_) {
    return arguments.length ? (handleSize = +_, brush) : handleSize;
  };

  brush.on = function () {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? brush : value;
  };

  return brush;
}
},{"d3-dispatch":"FHGa","d3-drag":"IqNk","d3-interpolate":"nuBz","d3-selection":"ObH6","d3-transition":"RVDI","./constant":"OY6d","./event":"iX60","./noevent":"DCEg"}],"mXZn":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "brush", {
  enumerable: true,
  get: function () {
    return _brush.default;
  }
});
Object.defineProperty(exports, "brushX", {
  enumerable: true,
  get: function () {
    return _brush.brushX;
  }
});
Object.defineProperty(exports, "brushY", {
  enumerable: true,
  get: function () {
    return _brush.brushY;
  }
});
Object.defineProperty(exports, "brushSelection", {
  enumerable: true,
  get: function () {
    return _brush.brushSelection;
  }
});

var _brush = _interopRequireWildcard(require("./src/brush"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
},{"./src/brush":"HwJw"}],"zRdk":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.max = exports.tau = exports.halfPi = exports.pi = exports.sin = exports.cos = void 0;
var cos = Math.cos;
exports.cos = cos;
var sin = Math.sin;
exports.sin = sin;
var pi = Math.PI;
exports.pi = pi;
var halfPi = pi / 2;
exports.halfPi = halfPi;
var tau = pi * 2;
exports.tau = tau;
var max = Math.max;
exports.max = max;
},{}],"YLYV":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _d3Array = require("d3-array");

var _math = require("./math");

function compareValue(compare) {
  return function (a, b) {
    return compare(a.source.value + a.target.value, b.source.value + b.target.value);
  };
}

function _default() {
  var padAngle = 0,
      sortGroups = null,
      sortSubgroups = null,
      sortChords = null;

  function chord(matrix) {
    var n = matrix.length,
        groupSums = [],
        groupIndex = (0, _d3Array.range)(n),
        subgroupIndex = [],
        chords = [],
        groups = chords.groups = new Array(n),
        subgroups = new Array(n * n),
        k,
        x,
        x0,
        dx,
        i,
        j; // Compute the sum.

    k = 0, i = -1;

    while (++i < n) {
      x = 0, j = -1;

      while (++j < n) {
        x += matrix[i][j];
      }

      groupSums.push(x);
      subgroupIndex.push((0, _d3Array.range)(n));
      k += x;
    } // Sort groups…


    if (sortGroups) groupIndex.sort(function (a, b) {
      return sortGroups(groupSums[a], groupSums[b]);
    }); // Sort subgroups…

    if (sortSubgroups) subgroupIndex.forEach(function (d, i) {
      d.sort(function (a, b) {
        return sortSubgroups(matrix[i][a], matrix[i][b]);
      });
    }); // Convert the sum to scaling factor for [0, 2pi].
    // TODO Allow start and end angle to be specified?
    // TODO Allow padding to be specified as percentage?

    k = (0, _math.max)(0, _math.tau - padAngle * n) / k;
    dx = k ? padAngle : _math.tau / n; // Compute the start and end angle for each group and subgroup.
    // Note: Opera has a bug reordering object literal properties!

    x = 0, i = -1;

    while (++i < n) {
      x0 = x, j = -1;

      while (++j < n) {
        var di = groupIndex[i],
            dj = subgroupIndex[di][j],
            v = matrix[di][dj],
            a0 = x,
            a1 = x += v * k;
        subgroups[dj * n + di] = {
          index: di,
          subindex: dj,
          startAngle: a0,
          endAngle: a1,
          value: v
        };
      }

      groups[di] = {
        index: di,
        startAngle: x0,
        endAngle: x,
        value: groupSums[di]
      };
      x += dx;
    } // Generate chords for each (non-empty) subgroup-subgroup link.


    i = -1;

    while (++i < n) {
      j = i - 1;

      while (++j < n) {
        var source = subgroups[j * n + i],
            target = subgroups[i * n + j];

        if (source.value || target.value) {
          chords.push(source.value < target.value ? {
            source: target,
            target: source
          } : {
            source: source,
            target: target
          });
        }
      }
    }

    return sortChords ? chords.sort(sortChords) : chords;
  }

  chord.padAngle = function (_) {
    return arguments.length ? (padAngle = (0, _math.max)(0, _), chord) : padAngle;
  };

  chord.sortGroups = function (_) {
    return arguments.length ? (sortGroups = _, chord) : sortGroups;
  };

  chord.sortSubgroups = function (_) {
    return arguments.length ? (sortSubgroups = _, chord) : sortSubgroups;
  };

  chord.sortChords = function (_) {
    return arguments.length ? (_ == null ? sortChords = null : (sortChords = compareValue(_))._ = _, chord) : sortChords && sortChords._;
  };

  return chord;
}
},{"d3-array":"ybfZ","./math":"zRdk"}],"E5FC":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var pi = Math.PI,
    tau = 2 * pi,
    epsilon = 1e-6,
    tauEpsilon = tau - epsilon;

function Path() {
  this._x0 = this._y0 = // start of current subpath
  this._x1 = this._y1 = null; // end of current subpath

  this._ = "";
}

function path() {
  return new Path();
}

Path.prototype = path.prototype = {
  constructor: Path,
  moveTo: function (x, y) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y);
  },
  closePath: function () {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._ += "Z";
    }
  },
  lineTo: function (x, y) {
    this._ += "L" + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  quadraticCurveTo: function (x1, y1, x, y) {
    this._ += "Q" + +x1 + "," + +y1 + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  bezierCurveTo: function (x1, y1, x2, y2, x, y) {
    this._ += "C" + +x1 + "," + +y1 + "," + +x2 + "," + +y2 + "," + (this._x1 = +x) + "," + (this._y1 = +y);
  },
  arcTo: function (x1, y1, x2, y2, r) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r = +r;
    var x0 = this._x1,
        y0 = this._y1,
        x21 = x2 - x1,
        y21 = y2 - y1,
        x01 = x0 - x1,
        y01 = y0 - y1,
        l01_2 = x01 * x01 + y01 * y01; // Is the radius negative? Error.

    if (r < 0) throw new Error("negative radius: " + r); // Is this path empty? Move to (x1,y1).

    if (this._x1 === null) {
      this._ += "M" + (this._x1 = x1) + "," + (this._y1 = y1);
    } // Or, is (x1,y1) coincident with (x0,y0)? Do nothing.
    else if (!(l01_2 > epsilon)) {} // Or, are (x0,y0), (x1,y1) and (x2,y2) collinear?
      // Equivalently, is (x1,y1) coincident with (x2,y2)?
      // Or, is the radius zero? Line to (x1,y1).
      else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r) {
          this._ += "L" + (this._x1 = x1) + "," + (this._y1 = y1);
        } // Otherwise, draw an arc!
        else {
            var x20 = x2 - x0,
                y20 = y2 - y0,
                l21_2 = x21 * x21 + y21 * y21,
                l20_2 = x20 * x20 + y20 * y20,
                l21 = Math.sqrt(l21_2),
                l01 = Math.sqrt(l01_2),
                l = r * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2),
                t01 = l / l01,
                t21 = l / l21; // If the start tangent is not coincident with (x0,y0), line to.

            if (Math.abs(t01 - 1) > epsilon) {
              this._ += "L" + (x1 + t01 * x01) + "," + (y1 + t01 * y01);
            }

            this._ += "A" + r + "," + r + ",0,0," + +(y01 * x20 > x01 * y20) + "," + (this._x1 = x1 + t21 * x21) + "," + (this._y1 = y1 + t21 * y21);
          }
  },
  arc: function (x, y, r, a0, a1, ccw) {
    x = +x, y = +y, r = +r;
    var dx = r * Math.cos(a0),
        dy = r * Math.sin(a0),
        x0 = x + dx,
        y0 = y + dy,
        cw = 1 ^ ccw,
        da = ccw ? a0 - a1 : a1 - a0; // Is the radius negative? Error.

    if (r < 0) throw new Error("negative radius: " + r); // Is this path empty? Move to (x0,y0).

    if (this._x1 === null) {
      this._ += "M" + x0 + "," + y0;
    } // Or, is (x0,y0) not coincident with the previous point? Line to (x0,y0).
    else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
        this._ += "L" + x0 + "," + y0;
      } // Is this arc empty? We’re done.


    if (!r) return; // Does the angle go the wrong way? Flip the direction.

    if (da < 0) da = da % tau + tau; // Is this a complete circle? Draw two arcs to complete the circle.

    if (da > tauEpsilon) {
      this._ += "A" + r + "," + r + ",0,1," + cw + "," + (x - dx) + "," + (y - dy) + "A" + r + "," + r + ",0,1," + cw + "," + (this._x1 = x0) + "," + (this._y1 = y0);
    } // Is this arc non-empty? Draw an arc!
    else if (da > epsilon) {
        this._ += "A" + r + "," + r + ",0," + +(da >= pi) + "," + cw + "," + (this._x1 = x + r * Math.cos(a1)) + "," + (this._y1 = y + r * Math.sin(a1));
      }
  },
  rect: function (x, y, w, h) {
    this._ += "M" + (this._x0 = this._x1 = +x) + "," + (this._y0 = this._y1 = +y) + "h" + +w + "v" + +h + "h" + -w + "Z";
  },
  toString: function () {
    return this._;
  }
};
var _default = path;
exports.default = _default;
},{}],"ZiSL":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "path", {
  enumerable: true,
  get: function () {
    return _path.default;
  }
});

var _path = _interopRequireDefault(require("./src/path"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./src/path":"E5FC"}],"ootM":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _array = require("./array");

var _constant = _interopRequireDefault(require("./constant"));

var _math = require("./math");

var _d3Path = require("d3-path");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function defaultSource(d) {
  return d.source;
}

function defaultTarget(d) {
  return d.target;
}

function defaultRadius(d) {
  return d.radius;
}

function defaultStartAngle(d) {
  return d.startAngle;
}

function defaultEndAngle(d) {
  return d.endAngle;
}

function _default() {
  var source = defaultSource,
      target = defaultTarget,
      radius = defaultRadius,
      startAngle = defaultStartAngle,
      endAngle = defaultEndAngle,
      context = null;

  function ribbon() {
    var buffer,
        argv = _array.slice.call(arguments),
        s = source.apply(this, argv),
        t = target.apply(this, argv),
        sr = +radius.apply(this, (argv[0] = s, argv)),
        sa0 = startAngle.apply(this, argv) - _math.halfPi,
        sa1 = endAngle.apply(this, argv) - _math.halfPi,
        sx0 = sr * (0, _math.cos)(sa0),
        sy0 = sr * (0, _math.sin)(sa0),
        tr = +radius.apply(this, (argv[0] = t, argv)),
        ta0 = startAngle.apply(this, argv) - _math.halfPi,
        ta1 = endAngle.apply(this, argv) - _math.halfPi;

    if (!context) context = buffer = (0, _d3Path.path)();
    context.moveTo(sx0, sy0);
    context.arc(0, 0, sr, sa0, sa1);

    if (sa0 !== ta0 || sa1 !== ta1) {
      // TODO sr !== tr?
      context.quadraticCurveTo(0, 0, tr * (0, _math.cos)(ta0), tr * (0, _math.sin)(ta0));
      context.arc(0, 0, tr, ta0, ta1);
    }

    context.quadraticCurveTo(0, 0, sx0, sy0);
    context.closePath();
    if (buffer) return context = null, buffer + "" || null;
  }

  ribbon.radius = function (_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : (0, _constant.default)(+_), ribbon) : radius;
  };

  ribbon.startAngle = function (_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : (0, _constant.default)(+_), ribbon) : startAngle;
  };

  ribbon.endAngle = function (_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : (0, _constant.default)(+_), ribbon) : endAngle;
  };

  ribbon.source = function (_) {
    return arguments.length ? (source = _, ribbon) : source;
  };

  ribbon.target = function (_) {
    return arguments.length ? (target = _, ribbon) : target;
  };

  ribbon.context = function (_) {
    return arguments.length ? (context = _ == null ? null : _, ribbon) : context;
  };

  return ribbon;
}
},{"./array":"rv5q","./constant":"OY6d","./math":"zRdk","d3-path":"ZiSL"}],"HrqC":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "chord", {
  enumerable: true,
  get: function () {
    return _chord.default;
  }
});
Object.defineProperty(exports, "ribbon", {
  enumerable: true,
  get: function () {
    return _ribbon.default;
  }
});

var _chord = _interopRequireDefault(require("./src/chord"));

var _ribbon = _interopRequireDefault(require("./src/ribbon"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./src/chord":"YLYV","./src/ribbon":"ootM"}],"wDCQ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.prefix = void 0;
var prefix = "$";
exports.prefix = prefix;

function Map() {}

Map.prototype = map.prototype = {
  constructor: Map,
  has: function (key) {
    return prefix + key in this;
  },
  get: function (key) {
    return this[prefix + key];
  },
  set: function (key, value) {
    this[prefix + key] = value;
    return this;
  },
  remove: function (key) {
    var property = prefix + key;
    return property in this && delete this[property];
  },
  clear: function () {
    for (var property in this) if (property[0] === prefix) delete this[property];
  },
  keys: function () {
    var keys = [];

    for (var property in this) if (property[0] === prefix) keys.push(property.slice(1));

    return keys;
  },
  values: function () {
    var values = [];

    for (var property in this) if (property[0] === prefix) values.push(this[property]);

    return values;
  },
  entries: function () {
    var entries = [];

    for (var property in this) if (property[0] === prefix) entries.push({
      key: property.slice(1),
      value: this[property]
    });

    return entries;
  },
  size: function () {
    var size = 0;

    for (var property in this) if (property[0] === prefix) ++size;

    return size;
  },
  empty: function () {
    for (var property in this) if (property[0] === prefix) return false;

    return true;
  },
  each: function (f) {
    for (var property in this) if (property[0] === prefix) f(this[property], property.slice(1), this);
  }
};

function map(object, f) {
  var map = new Map(); // Copy constructor.

  if (object instanceof Map) object.each(function (value, key) {
    map.set(key, value);
  }); // Index array by numeric index or specified key function.
  else if (Array.isArray(object)) {
      var i = -1,
          n = object.length,
          o;
      if (f == null) while (++i < n) map.set(i, object[i]);else while (++i < n) map.set(f(o = object[i], i, object), o);
    } // Convert object to map.
    else if (object) for (var key in object) map.set(key, object[key]);
  return map;
}

var _default = map;
exports.default = _default;
},{}],"TaNJ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _map = _interopRequireDefault(require("./map"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default() {
  var keys = [],
      sortKeys = [],
      sortValues,
      rollup,
      nest;

  function apply(array, depth, createResult, setResult) {
    if (depth >= keys.length) {
      if (sortValues != null) array.sort(sortValues);
      return rollup != null ? rollup(array) : array;
    }

    var i = -1,
        n = array.length,
        key = keys[depth++],
        keyValue,
        value,
        valuesByKey = (0, _map.default)(),
        values,
        result = createResult();

    while (++i < n) {
      if (values = valuesByKey.get(keyValue = key(value = array[i]) + "")) {
        values.push(value);
      } else {
        valuesByKey.set(keyValue, [value]);
      }
    }

    valuesByKey.each(function (values, key) {
      setResult(result, key, apply(values, depth, createResult, setResult));
    });
    return result;
  }

  function entries(map, depth) {
    if (++depth > keys.length) return map;
    var array,
        sortKey = sortKeys[depth - 1];
    if (rollup != null && depth >= keys.length) array = map.entries();else array = [], map.each(function (v, k) {
      array.push({
        key: k,
        values: entries(v, depth)
      });
    });
    return sortKey != null ? array.sort(function (a, b) {
      return sortKey(a.key, b.key);
    }) : array;
  }

  return nest = {
    object: function (array) {
      return apply(array, 0, createObject, setObject);
    },
    map: function (array) {
      return apply(array, 0, createMap, setMap);
    },
    entries: function (array) {
      return entries(apply(array, 0, createMap, setMap), 0);
    },
    key: function (d) {
      keys.push(d);
      return nest;
    },
    sortKeys: function (order) {
      sortKeys[keys.length - 1] = order;
      return nest;
    },
    sortValues: function (order) {
      sortValues = order;
      return nest;
    },
    rollup: function (f) {
      rollup = f;
      return nest;
    }
  };
}

function createObject() {
  return {};
}

function setObject(object, key, value) {
  object[key] = value;
}

function createMap() {
  return (0, _map.default)();
}

function setMap(map, key, value) {
  map.set(key, value);
}
},{"./map":"wDCQ"}],"fgw3":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _map = _interopRequireWildcard(require("./map"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function Set() {}

var proto = _map.default.prototype;
Set.prototype = set.prototype = {
  constructor: Set,
  has: proto.has,
  add: function (value) {
    value += "";
    this[_map.prefix + value] = value;
    return this;
  },
  remove: proto.remove,
  clear: proto.clear,
  values: proto.keys,
  size: proto.size,
  empty: proto.empty,
  each: proto.each
};

function set(object, f) {
  var set = new Set(); // Copy constructor.

  if (object instanceof Set) object.each(function (value) {
    set.add(value);
  }); // Otherwise, assume it’s an array.
  else if (object) {
      var i = -1,
          n = object.length;
      if (f == null) while (++i < n) set.add(object[i]);else while (++i < n) set.add(f(object[i], i, object));
    }
  return set;
}

var _default = set;
exports.default = _default;
},{"./map":"wDCQ"}],"STSP":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(map) {
  var keys = [];

  for (var key in map) keys.push(key);

  return keys;
}
},{}],"wANB":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(map) {
  var values = [];

  for (var key in map) values.push(map[key]);

  return values;
}
},{}],"u9ZW":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(map) {
  var entries = [];

  for (var key in map) entries.push({
    key: key,
    value: map[key]
  });

  return entries;
}
},{}],"GTGQ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "nest", {
  enumerable: true,
  get: function () {
    return _nest.default;
  }
});
Object.defineProperty(exports, "set", {
  enumerable: true,
  get: function () {
    return _set.default;
  }
});
Object.defineProperty(exports, "map", {
  enumerable: true,
  get: function () {
    return _map.default;
  }
});
Object.defineProperty(exports, "keys", {
  enumerable: true,
  get: function () {
    return _keys.default;
  }
});
Object.defineProperty(exports, "values", {
  enumerable: true,
  get: function () {
    return _values.default;
  }
});
Object.defineProperty(exports, "entries", {
  enumerable: true,
  get: function () {
    return _entries.default;
  }
});

var _nest = _interopRequireDefault(require("./src/nest"));

var _set = _interopRequireDefault(require("./src/set"));

var _map = _interopRequireDefault(require("./src/map"));

var _keys = _interopRequireDefault(require("./src/keys"));

var _values = _interopRequireDefault(require("./src/values"));

var _entries = _interopRequireDefault(require("./src/entries"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./src/nest":"TaNJ","./src/set":"fgw3","./src/map":"wDCQ","./src/keys":"STSP","./src/values":"wANB","./src/entries":"u9ZW"}],"SCWu":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
var EOL = {},
    EOF = {},
    QUOTE = 34,
    NEWLINE = 10,
    RETURN = 13;

function objectConverter(columns) {
  return new Function("d", "return {" + columns.map(function (name, i) {
    return JSON.stringify(name) + ": d[" + i + "]";
  }).join(",") + "}");
}

function customConverter(columns, f) {
  var object = objectConverter(columns);
  return function (row, i) {
    return f(object(row), i, columns);
  };
} // Compute unique columns in order of discovery.


function inferColumns(rows) {
  var columnSet = Object.create(null),
      columns = [];
  rows.forEach(function (row) {
    for (var column in row) {
      if (!(column in columnSet)) {
        columns.push(columnSet[column] = column);
      }
    }
  });
  return columns;
}

function _default(delimiter) {
  var reFormat = new RegExp("[\"" + delimiter + "\n\r]"),
      DELIMITER = delimiter.charCodeAt(0);

  function parse(text, f) {
    var convert,
        columns,
        rows = parseRows(text, function (row, i) {
      if (convert) return convert(row, i - 1);
      columns = row, convert = f ? customConverter(row, f) : objectConverter(row);
    });
    rows.columns = columns || [];
    return rows;
  }

  function parseRows(text, f) {
    var rows = [],
        // output rows
    N = text.length,
        I = 0,
        // current character index
    n = 0,
        // current line number
    t,
        // current token
    eof = N <= 0,
        // current token followed by EOF?
    eol = false; // current token followed by EOL?
    // Strip the trailing newline.

    if (text.charCodeAt(N - 1) === NEWLINE) --N;
    if (text.charCodeAt(N - 1) === RETURN) --N;

    function token() {
      if (eof) return EOF;
      if (eol) return eol = false, EOL; // Unescape quotes.

      var i,
          j = I,
          c;

      if (text.charCodeAt(j) === QUOTE) {
        while (I++ < N && text.charCodeAt(I) !== QUOTE || text.charCodeAt(++I) === QUOTE);

        if ((i = I) >= N) eof = true;else if ((c = text.charCodeAt(I++)) === NEWLINE) eol = true;else if (c === RETURN) {
          eol = true;
          if (text.charCodeAt(I) === NEWLINE) ++I;
        }
        return text.slice(j + 1, i - 1).replace(/""/g, "\"");
      } // Find next delimiter or newline.


      while (I < N) {
        if ((c = text.charCodeAt(i = I++)) === NEWLINE) eol = true;else if (c === RETURN) {
          eol = true;
          if (text.charCodeAt(I) === NEWLINE) ++I;
        } else if (c !== DELIMITER) continue;
        return text.slice(j, i);
      } // Return last token before EOF.


      return eof = true, text.slice(j, N);
    }

    while ((t = token()) !== EOF) {
      var row = [];

      while (t !== EOL && t !== EOF) row.push(t), t = token();

      if (f && (row = f(row, n++)) == null) continue;
      rows.push(row);
    }

    return rows;
  }

  function format(rows, columns) {
    if (columns == null) columns = inferColumns(rows);
    return [columns.map(formatValue).join(delimiter)].concat(rows.map(function (row) {
      return columns.map(function (column) {
        return formatValue(row[column]);
      }).join(delimiter);
    })).join("\n");
  }

  function formatRows(rows) {
    return rows.map(formatRow).join("\n");
  }

  function formatRow(row) {
    return row.map(formatValue).join(delimiter);
  }

  function formatValue(text) {
    return text == null ? "" : reFormat.test(text += "") ? "\"" + text.replace(/"/g, "\"\"") + "\"" : text;
  }

  return {
    parse: parse,
    parseRows: parseRows,
    format: format,
    formatRows: formatRows
  };
}
},{}],"mU2J":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.csvFormatRows = exports.csvFormat = exports.csvParseRows = exports.csvParse = void 0;

var _dsv = _interopRequireDefault(require("./dsv"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var csv = (0, _dsv.default)(",");
var csvParse = csv.parse;
exports.csvParse = csvParse;
var csvParseRows = csv.parseRows;
exports.csvParseRows = csvParseRows;
var csvFormat = csv.format;
exports.csvFormat = csvFormat;
var csvFormatRows = csv.formatRows;
exports.csvFormatRows = csvFormatRows;
},{"./dsv":"SCWu"}],"zpVZ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tsvFormatRows = exports.tsvFormat = exports.tsvParseRows = exports.tsvParse = void 0;

var _dsv = _interopRequireDefault(require("./dsv"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var tsv = (0, _dsv.default)("\t");
var tsvParse = tsv.parse;
exports.tsvParse = tsvParse;
var tsvParseRows = tsv.parseRows;
exports.tsvParseRows = tsvParseRows;
var tsvFormat = tsv.format;
exports.tsvFormat = tsvFormat;
var tsvFormatRows = tsv.formatRows;
exports.tsvFormatRows = tsvFormatRows;
},{"./dsv":"SCWu"}],"NYIA":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "dsvFormat", {
  enumerable: true,
  get: function () {
    return _dsv.default;
  }
});
Object.defineProperty(exports, "csvParse", {
  enumerable: true,
  get: function () {
    return _csv.csvParse;
  }
});
Object.defineProperty(exports, "csvParseRows", {
  enumerable: true,
  get: function () {
    return _csv.csvParseRows;
  }
});
Object.defineProperty(exports, "csvFormat", {
  enumerable: true,
  get: function () {
    return _csv.csvFormat;
  }
});
Object.defineProperty(exports, "csvFormatRows", {
  enumerable: true,
  get: function () {
    return _csv.csvFormatRows;
  }
});
Object.defineProperty(exports, "tsvParse", {
  enumerable: true,
  get: function () {
    return _tsv.tsvParse;
  }
});
Object.defineProperty(exports, "tsvParseRows", {
  enumerable: true,
  get: function () {
    return _tsv.tsvParseRows;
  }
});
Object.defineProperty(exports, "tsvFormat", {
  enumerable: true,
  get: function () {
    return _tsv.tsvFormat;
  }
});
Object.defineProperty(exports, "tsvFormatRows", {
  enumerable: true,
  get: function () {
    return _tsv.tsvFormatRows;
  }
});

var _dsv = _interopRequireDefault(require("./src/dsv"));

var _csv = require("./src/csv");

var _tsv = require("./src/tsv");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./src/dsv":"SCWu","./src/csv":"mU2J","./src/tsv":"zpVZ"}],"yF4t":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(x, y) {
  var nodes;
  if (x == null) x = 0;
  if (y == null) y = 0;

  function force() {
    var i,
        n = nodes.length,
        node,
        sx = 0,
        sy = 0;

    for (i = 0; i < n; ++i) {
      node = nodes[i], sx += node.x, sy += node.y;
    }

    for (sx = sx / n - x, sy = sy / n - y, i = 0; i < n; ++i) {
      node = nodes[i], node.x -= sx, node.y -= sy;
    }
  }

  force.initialize = function (_) {
    nodes = _;
  };

  force.x = function (_) {
    return arguments.length ? (x = +_, force) : x;
  };

  force.y = function (_) {
    return arguments.length ? (y = +_, force) : y;
  };

  return force;
}
},{}],"jmDl":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default() {
  return (Math.random() - 0.5) * 1e-6;
}
},{}],"c4hk":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.addAll = addAll;

function _default(d) {
  var x = +this._x.call(null, d),
      y = +this._y.call(null, d);
  return add(this.cover(x, y), x, y, d);
}

function add(tree, x, y, d) {
  if (isNaN(x) || isNaN(y)) return tree; // ignore invalid points

  var parent,
      node = tree._root,
      leaf = {
    data: d
  },
      x0 = tree._x0,
      y0 = tree._y0,
      x1 = tree._x1,
      y1 = tree._y1,
      xm,
      ym,
      xp,
      yp,
      right,
      bottom,
      i,
      j; // If the tree is empty, initialize the root as a leaf.

  if (!node) return tree._root = leaf, tree; // Find the existing leaf for the new point, or add it.

  while (node.length) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm;else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym;else y1 = ym;
    if (parent = node, !(node = node[i = bottom << 1 | right])) return parent[i] = leaf, tree;
  } // Is the new point is exactly coincident with the existing point?


  xp = +tree._x.call(null, node.data);
  yp = +tree._y.call(null, node.data);
  if (x === xp && y === yp) return leaf.next = node, parent ? parent[i] = leaf : tree._root = leaf, tree; // Otherwise, split the leaf node until the old and new point are separated.

  do {
    parent = parent ? parent[i] = new Array(4) : tree._root = new Array(4);
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm;else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym;else y1 = ym;
  } while ((i = bottom << 1 | right) === (j = (yp >= ym) << 1 | xp >= xm));

  return parent[j] = node, parent[i] = leaf, tree;
}

function addAll(data) {
  var d,
      i,
      n = data.length,
      x,
      y,
      xz = new Array(n),
      yz = new Array(n),
      x0 = Infinity,
      y0 = Infinity,
      x1 = -Infinity,
      y1 = -Infinity; // Compute the points and their extent.

  for (i = 0; i < n; ++i) {
    if (isNaN(x = +this._x.call(null, d = data[i])) || isNaN(y = +this._y.call(null, d))) continue;
    xz[i] = x;
    yz[i] = y;
    if (x < x0) x0 = x;
    if (x > x1) x1 = x;
    if (y < y0) y0 = y;
    if (y > y1) y1 = y;
  } // If there were no (valid) points, inherit the existing extent.


  if (x1 < x0) x0 = this._x0, x1 = this._x1;
  if (y1 < y0) y0 = this._y0, y1 = this._y1; // Expand the tree to cover the new points.

  this.cover(x0, y0).cover(x1, y1); // Add the new points.

  for (i = 0; i < n; ++i) {
    add(this, xz[i], yz[i], data[i]);
  }

  return this;
}
},{}],"DeJI":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(x, y) {
  if (isNaN(x = +x) || isNaN(y = +y)) return this; // ignore invalid points

  var x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1; // If the quadtree has no extent, initialize them.
  // Integer extent are necessary so that if we later double the extent,
  // the existing quadrant boundaries don’t change due to floating point error!

  if (isNaN(x0)) {
    x1 = (x0 = Math.floor(x)) + 1;
    y1 = (y0 = Math.floor(y)) + 1;
  } // Otherwise, double repeatedly to cover.
  else if (x0 > x || x > x1 || y0 > y || y > y1) {
      var z = x1 - x0,
          node = this._root,
          parent,
          i;

      switch (i = (y < (y0 + y1) / 2) << 1 | x < (x0 + x1) / 2) {
        case 0:
          {
            do parent = new Array(4), parent[i] = node, node = parent; while ((z *= 2, x1 = x0 + z, y1 = y0 + z, x > x1 || y > y1));

            break;
          }

        case 1:
          {
            do parent = new Array(4), parent[i] = node, node = parent; while ((z *= 2, x0 = x1 - z, y1 = y0 + z, x0 > x || y > y1));

            break;
          }

        case 2:
          {
            do parent = new Array(4), parent[i] = node, node = parent; while ((z *= 2, x1 = x0 + z, y0 = y1 - z, x > x1 || y0 > y));

            break;
          }

        case 3:
          {
            do parent = new Array(4), parent[i] = node, node = parent; while ((z *= 2, x0 = x1 - z, y0 = y1 - z, x0 > x || y0 > y));

            break;
          }
      }

      if (this._root && this._root.length) this._root = node;
    } // If the quadtree covers the point already, just return.
    else return this;

  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  return this;
}
},{}],"HTBh":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default() {
  var data = [];
  this.visit(function (node) {
    if (!node.length) do data.push(node.data); while (node = node.next);
  });
  return data;
}
},{}],"JRL4":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(_) {
  return arguments.length ? this.cover(+_[0][0], +_[0][1]).cover(+_[1][0], +_[1][1]) : isNaN(this._x0) ? undefined : [[this._x0, this._y0], [this._x1, this._y1]];
}
},{}],"BPLw":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(node, x0, y0, x1, y1) {
  this.node = node;
  this.x0 = x0;
  this.y0 = y0;
  this.x1 = x1;
  this.y1 = y1;
}
},{}],"t1gW":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _quad = _interopRequireDefault(require("./quad"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(x, y, radius) {
  var data,
      x0 = this._x0,
      y0 = this._y0,
      x1,
      y1,
      x2,
      y2,
      x3 = this._x1,
      y3 = this._y1,
      quads = [],
      node = this._root,
      q,
      i;
  if (node) quads.push(new _quad.default(node, x0, y0, x3, y3));
  if (radius == null) radius = Infinity;else {
    x0 = x - radius, y0 = y - radius;
    x3 = x + radius, y3 = y + radius;
    radius *= radius;
  }

  while (q = quads.pop()) {
    // Stop searching if this quadrant can’t contain a closer node.
    if (!(node = q.node) || (x1 = q.x0) > x3 || (y1 = q.y0) > y3 || (x2 = q.x1) < x0 || (y2 = q.y1) < y0) continue; // Bisect the current quadrant.

    if (node.length) {
      var xm = (x1 + x2) / 2,
          ym = (y1 + y2) / 2;
      quads.push(new _quad.default(node[3], xm, ym, x2, y2), new _quad.default(node[2], x1, ym, xm, y2), new _quad.default(node[1], xm, y1, x2, ym), new _quad.default(node[0], x1, y1, xm, ym)); // Visit the closest quadrant first.

      if (i = (y >= ym) << 1 | x >= xm) {
        q = quads[quads.length - 1];
        quads[quads.length - 1] = quads[quads.length - 1 - i];
        quads[quads.length - 1 - i] = q;
      }
    } // Visit this point. (Visiting coincident points isn’t necessary!)
    else {
        var dx = x - +this._x.call(null, node.data),
            dy = y - +this._y.call(null, node.data),
            d2 = dx * dx + dy * dy;

        if (d2 < radius) {
          var d = Math.sqrt(radius = d2);
          x0 = x - d, y0 = y - d;
          x3 = x + d, y3 = y + d;
          data = node.data;
        }
      }
  }

  return data;
}
},{"./quad":"BPLw"}],"wnjT":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.removeAll = removeAll;

function _default(d) {
  if (isNaN(x = +this._x.call(null, d)) || isNaN(y = +this._y.call(null, d))) return this; // ignore invalid points

  var parent,
      node = this._root,
      retainer,
      previous,
      next,
      x0 = this._x0,
      y0 = this._y0,
      x1 = this._x1,
      y1 = this._y1,
      x,
      y,
      xm,
      ym,
      right,
      bottom,
      i,
      j; // If the tree is empty, initialize the root as a leaf.

  if (!node) return this; // Find the leaf node for the point.
  // While descending, also retain the deepest parent with a non-removed sibling.

  if (node.length) while (true) {
    if (right = x >= (xm = (x0 + x1) / 2)) x0 = xm;else x1 = xm;
    if (bottom = y >= (ym = (y0 + y1) / 2)) y0 = ym;else y1 = ym;
    if (!(parent = node, node = node[i = bottom << 1 | right])) return this;
    if (!node.length) break;
    if (parent[i + 1 & 3] || parent[i + 2 & 3] || parent[i + 3 & 3]) retainer = parent, j = i;
  } // Find the point to remove.

  while (node.data !== d) if (!(previous = node, node = node.next)) return this;

  if (next = node.next) delete node.next; // If there are multiple coincident points, remove just the point.

  if (previous) return next ? previous.next = next : delete previous.next, this; // If this is the root point, remove it.

  if (!parent) return this._root = next, this; // Remove this leaf.

  next ? parent[i] = next : delete parent[i]; // If the parent now contains exactly one leaf, collapse superfluous parents.

  if ((node = parent[0] || parent[1] || parent[2] || parent[3]) && node === (parent[3] || parent[2] || parent[1] || parent[0]) && !node.length) {
    if (retainer) retainer[j] = node;else this._root = node;
  }

  return this;
}

function removeAll(data) {
  for (var i = 0, n = data.length; i < n; ++i) this.remove(data[i]);

  return this;
}
},{}],"aU2q":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default() {
  return this._root;
}
},{}],"PC8q":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default() {
  var size = 0;
  this.visit(function (node) {
    if (!node.length) do ++size; while (node = node.next);
  });
  return size;
}
},{}],"MOvE":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _quad = _interopRequireDefault(require("./quad"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(callback) {
  var quads = [],
      q,
      node = this._root,
      child,
      x0,
      y0,
      x1,
      y1;
  if (node) quads.push(new _quad.default(node, this._x0, this._y0, this._x1, this._y1));

  while (q = quads.pop()) {
    if (!callback(node = q.node, x0 = q.x0, y0 = q.y0, x1 = q.x1, y1 = q.y1) && node.length) {
      var xm = (x0 + x1) / 2,
          ym = (y0 + y1) / 2;
      if (child = node[3]) quads.push(new _quad.default(child, xm, ym, x1, y1));
      if (child = node[2]) quads.push(new _quad.default(child, x0, ym, xm, y1));
      if (child = node[1]) quads.push(new _quad.default(child, xm, y0, x1, ym));
      if (child = node[0]) quads.push(new _quad.default(child, x0, y0, xm, ym));
    }
  }

  return this;
}
},{"./quad":"BPLw"}],"EdvS":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _quad = _interopRequireDefault(require("./quad"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(callback) {
  var quads = [],
      next = [],
      q;
  if (this._root) quads.push(new _quad.default(this._root, this._x0, this._y0, this._x1, this._y1));

  while (q = quads.pop()) {
    var node = q.node;

    if (node.length) {
      var child,
          x0 = q.x0,
          y0 = q.y0,
          x1 = q.x1,
          y1 = q.y1,
          xm = (x0 + x1) / 2,
          ym = (y0 + y1) / 2;
      if (child = node[0]) quads.push(new _quad.default(child, x0, y0, xm, ym));
      if (child = node[1]) quads.push(new _quad.default(child, xm, y0, x1, ym));
      if (child = node[2]) quads.push(new _quad.default(child, x0, ym, xm, y1));
      if (child = node[3]) quads.push(new _quad.default(child, xm, ym, x1, y1));
    }

    next.push(q);
  }

  while (q = next.pop()) {
    callback(q.node, q.x0, q.y0, q.x1, q.y1);
  }

  return this;
}
},{"./quad":"BPLw"}],"yqgF":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultX = defaultX;
exports.default = _default;

function defaultX(d) {
  return d[0];
}

function _default(_) {
  return arguments.length ? (this._x = _, this) : this._x;
}
},{}],"FeNP":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.defaultY = defaultY;
exports.default = _default;

function defaultY(d) {
  return d[1];
}

function _default(_) {
  return arguments.length ? (this._y = _, this) : this._y;
}
},{}],"HCic":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = quadtree;

var _add = _interopRequireWildcard(require("./add"));

var _cover = _interopRequireDefault(require("./cover"));

var _data = _interopRequireDefault(require("./data"));

var _extent = _interopRequireDefault(require("./extent"));

var _find = _interopRequireDefault(require("./find"));

var _remove = _interopRequireWildcard(require("./remove"));

var _root = _interopRequireDefault(require("./root"));

var _size = _interopRequireDefault(require("./size"));

var _visit = _interopRequireDefault(require("./visit"));

var _visitAfter = _interopRequireDefault(require("./visitAfter"));

var _x = _interopRequireWildcard(require("./x"));

var _y = _interopRequireWildcard(require("./y"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function quadtree(nodes, x, y) {
  var tree = new Quadtree(x == null ? _x.defaultX : x, y == null ? _y.defaultY : y, NaN, NaN, NaN, NaN);
  return nodes == null ? tree : tree.addAll(nodes);
}

function Quadtree(x, y, x0, y0, x1, y1) {
  this._x = x;
  this._y = y;
  this._x0 = x0;
  this._y0 = y0;
  this._x1 = x1;
  this._y1 = y1;
  this._root = undefined;
}

function leaf_copy(leaf) {
  var copy = {
    data: leaf.data
  },
      next = copy;

  while (leaf = leaf.next) next = next.next = {
    data: leaf.data
  };

  return copy;
}

var treeProto = quadtree.prototype = Quadtree.prototype;

treeProto.copy = function () {
  var copy = new Quadtree(this._x, this._y, this._x0, this._y0, this._x1, this._y1),
      node = this._root,
      nodes,
      child;
  if (!node) return copy;
  if (!node.length) return copy._root = leaf_copy(node), copy;
  nodes = [{
    source: node,
    target: copy._root = new Array(4)
  }];

  while (node = nodes.pop()) {
    for (var i = 0; i < 4; ++i) {
      if (child = node.source[i]) {
        if (child.length) nodes.push({
          source: child,
          target: node.target[i] = new Array(4)
        });else node.target[i] = leaf_copy(child);
      }
    }
  }

  return copy;
};

treeProto.add = _add.default;
treeProto.addAll = _add.addAll;
treeProto.cover = _cover.default;
treeProto.data = _data.default;
treeProto.extent = _extent.default;
treeProto.find = _find.default;
treeProto.remove = _remove.default;
treeProto.removeAll = _remove.removeAll;
treeProto.root = _root.default;
treeProto.size = _size.default;
treeProto.visit = _visit.default;
treeProto.visitAfter = _visitAfter.default;
treeProto.x = _x.default;
treeProto.y = _y.default;
},{"./add":"c4hk","./cover":"DeJI","./data":"HTBh","./extent":"JRL4","./find":"t1gW","./remove":"wnjT","./root":"aU2q","./size":"PC8q","./visit":"MOvE","./visitAfter":"EdvS","./x":"yqgF","./y":"FeNP"}],"LBnY":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "quadtree", {
  enumerable: true,
  get: function () {
    return _quadtree.default;
  }
});

var _quadtree = _interopRequireDefault(require("./src/quadtree"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./src/quadtree":"HCic"}],"ZCSV":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _constant = _interopRequireDefault(require("./constant"));

var _jiggle = _interopRequireDefault(require("./jiggle"));

var _d3Quadtree = require("d3-quadtree");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function x(d) {
  return d.x + d.vx;
}

function y(d) {
  return d.y + d.vy;
}

function _default(radius) {
  var nodes,
      radii,
      strength = 1,
      iterations = 1;
  if (typeof radius !== "function") radius = (0, _constant.default)(radius == null ? 1 : +radius);

  function force() {
    var i,
        n = nodes.length,
        tree,
        node,
        xi,
        yi,
        ri,
        ri2;

    for (var k = 0; k < iterations; ++k) {
      tree = (0, _d3Quadtree.quadtree)(nodes, x, y).visitAfter(prepare);

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        ri = radii[node.index], ri2 = ri * ri;
        xi = node.x + node.vx;
        yi = node.y + node.vy;
        tree.visit(apply);
      }
    }

    function apply(quad, x0, y0, x1, y1) {
      var data = quad.data,
          rj = quad.r,
          r = ri + rj;

      if (data) {
        if (data.index > node.index) {
          var x = xi - data.x - data.vx,
              y = yi - data.y - data.vy,
              l = x * x + y * y;

          if (l < r * r) {
            if (x === 0) x = (0, _jiggle.default)(), l += x * x;
            if (y === 0) y = (0, _jiggle.default)(), l += y * y;
            l = (r - (l = Math.sqrt(l))) / l * strength;
            node.vx += (x *= l) * (r = (rj *= rj) / (ri2 + rj));
            node.vy += (y *= l) * r;
            data.vx -= x * (r = 1 - r);
            data.vy -= y * r;
          }
        }

        return;
      }

      return x0 > xi + r || x1 < xi - r || y0 > yi + r || y1 < yi - r;
    }
  }

  function prepare(quad) {
    if (quad.data) return quad.r = radii[quad.data.index];

    for (var i = quad.r = 0; i < 4; ++i) {
      if (quad[i] && quad[i].r > quad.r) {
        quad.r = quad[i].r;
      }
    }
  }

  function initialize() {
    if (!nodes) return;
    var i,
        n = nodes.length,
        node;
    radii = new Array(n);

    for (i = 0; i < n; ++i) node = nodes[i], radii[node.index] = +radius(node, i, nodes);
  }

  force.initialize = function (_) {
    nodes = _;
    initialize();
  };

  force.iterations = function (_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function (_) {
    return arguments.length ? (strength = +_, force) : strength;
  };

  force.radius = function (_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : (0, _constant.default)(+_), initialize(), force) : radius;
  };

  return force;
}
},{"./constant":"OY6d","./jiggle":"jmDl","d3-quadtree":"LBnY"}],"M788":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _constant = _interopRequireDefault(require("./constant"));

var _jiggle = _interopRequireDefault(require("./jiggle"));

var _d3Collection = require("d3-collection");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function index(d) {
  return d.index;
}

function find(nodeById, nodeId) {
  var node = nodeById.get(nodeId);
  if (!node) throw new Error("missing: " + nodeId);
  return node;
}

function _default(links) {
  var id = index,
      strength = defaultStrength,
      strengths,
      distance = (0, _constant.default)(30),
      distances,
      nodes,
      count,
      bias,
      iterations = 1;
  if (links == null) links = [];

  function defaultStrength(link) {
    return 1 / Math.min(count[link.source.index], count[link.target.index]);
  }

  function force(alpha) {
    for (var k = 0, n = links.length; k < iterations; ++k) {
      for (var i = 0, link, source, target, x, y, l, b; i < n; ++i) {
        link = links[i], source = link.source, target = link.target;
        x = target.x + target.vx - source.x - source.vx || (0, _jiggle.default)();
        y = target.y + target.vy - source.y - source.vy || (0, _jiggle.default)();
        l = Math.sqrt(x * x + y * y);
        l = (l - distances[i]) / l * alpha * strengths[i];
        x *= l, y *= l;
        target.vx -= x * (b = bias[i]);
        target.vy -= y * b;
        source.vx += x * (b = 1 - b);
        source.vy += y * b;
      }
    }
  }

  function initialize() {
    if (!nodes) return;
    var i,
        n = nodes.length,
        m = links.length,
        nodeById = (0, _d3Collection.map)(nodes, id),
        link;

    for (i = 0, count = new Array(n); i < m; ++i) {
      link = links[i], link.index = i;
      if (typeof link.source !== "object") link.source = find(nodeById, link.source);
      if (typeof link.target !== "object") link.target = find(nodeById, link.target);
      count[link.source.index] = (count[link.source.index] || 0) + 1;
      count[link.target.index] = (count[link.target.index] || 0) + 1;
    }

    for (i = 0, bias = new Array(m); i < m; ++i) {
      link = links[i], bias[i] = count[link.source.index] / (count[link.source.index] + count[link.target.index]);
    }

    strengths = new Array(m), initializeStrength();
    distances = new Array(m), initializeDistance();
  }

  function initializeStrength() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      strengths[i] = +strength(links[i], i, links);
    }
  }

  function initializeDistance() {
    if (!nodes) return;

    for (var i = 0, n = links.length; i < n; ++i) {
      distances[i] = +distance(links[i], i, links);
    }
  }

  force.initialize = function (_) {
    nodes = _;
    initialize();
  };

  force.links = function (_) {
    return arguments.length ? (links = _, initialize(), force) : links;
  };

  force.id = function (_) {
    return arguments.length ? (id = _, force) : id;
  };

  force.iterations = function (_) {
    return arguments.length ? (iterations = +_, force) : iterations;
  };

  force.strength = function (_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0, _constant.default)(+_), initializeStrength(), force) : strength;
  };

  force.distance = function (_) {
    return arguments.length ? (distance = typeof _ === "function" ? _ : (0, _constant.default)(+_), initializeDistance(), force) : distance;
  };

  return force;
}
},{"./constant":"OY6d","./jiggle":"jmDl","d3-collection":"GTGQ"}],"lwF8":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.x = x;
exports.y = y;
exports.default = _default;

var _d3Dispatch = require("d3-dispatch");

var _d3Collection = require("d3-collection");

var _d3Timer = require("d3-timer");

function x(d) {
  return d.x;
}

function y(d) {
  return d.y;
}

var initialRadius = 10,
    initialAngle = Math.PI * (3 - Math.sqrt(5));

function _default(nodes) {
  var simulation,
      alpha = 1,
      alphaMin = 0.001,
      alphaDecay = 1 - Math.pow(alphaMin, 1 / 300),
      alphaTarget = 0,
      velocityDecay = 0.6,
      forces = (0, _d3Collection.map)(),
      stepper = (0, _d3Timer.timer)(step),
      event = (0, _d3Dispatch.dispatch)("tick", "end");
  if (nodes == null) nodes = [];

  function step() {
    tick();
    event.call("tick", simulation);

    if (alpha < alphaMin) {
      stepper.stop();
      event.call("end", simulation);
    }
  }

  function tick() {
    var i,
        n = nodes.length,
        node;
    alpha += (alphaTarget - alpha) * alphaDecay;
    forces.each(function (force) {
      force(alpha);
    });

    for (i = 0; i < n; ++i) {
      node = nodes[i];
      if (node.fx == null) node.x += node.vx *= velocityDecay;else node.x = node.fx, node.vx = 0;
      if (node.fy == null) node.y += node.vy *= velocityDecay;else node.y = node.fy, node.vy = 0;
    }
  }

  function initializeNodes() {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.index = i;

      if (isNaN(node.x) || isNaN(node.y)) {
        var radius = initialRadius * Math.sqrt(i),
            angle = i * initialAngle;
        node.x = radius * Math.cos(angle);
        node.y = radius * Math.sin(angle);
      }

      if (isNaN(node.vx) || isNaN(node.vy)) {
        node.vx = node.vy = 0;
      }
    }
  }

  function initializeForce(force) {
    if (force.initialize) force.initialize(nodes);
    return force;
  }

  initializeNodes();
  return simulation = {
    tick: tick,
    restart: function () {
      return stepper.restart(step), simulation;
    },
    stop: function () {
      return stepper.stop(), simulation;
    },
    nodes: function (_) {
      return arguments.length ? (nodes = _, initializeNodes(), forces.each(initializeForce), simulation) : nodes;
    },
    alpha: function (_) {
      return arguments.length ? (alpha = +_, simulation) : alpha;
    },
    alphaMin: function (_) {
      return arguments.length ? (alphaMin = +_, simulation) : alphaMin;
    },
    alphaDecay: function (_) {
      return arguments.length ? (alphaDecay = +_, simulation) : +alphaDecay;
    },
    alphaTarget: function (_) {
      return arguments.length ? (alphaTarget = +_, simulation) : alphaTarget;
    },
    velocityDecay: function (_) {
      return arguments.length ? (velocityDecay = 1 - _, simulation) : 1 - velocityDecay;
    },
    force: function (name, _) {
      return arguments.length > 1 ? (_ == null ? forces.remove(name) : forces.set(name, initializeForce(_)), simulation) : forces.get(name);
    },
    find: function (x, y, radius) {
      var i = 0,
          n = nodes.length,
          dx,
          dy,
          d2,
          node,
          closest;
      if (radius == null) radius = Infinity;else radius *= radius;

      for (i = 0; i < n; ++i) {
        node = nodes[i];
        dx = x - node.x;
        dy = y - node.y;
        d2 = dx * dx + dy * dy;
        if (d2 < radius) closest = node, radius = d2;
      }

      return closest;
    },
    on: function (name, _) {
      return arguments.length > 1 ? (event.on(name, _), simulation) : event.on(name);
    }
  };
}
},{"d3-dispatch":"FHGa","d3-collection":"GTGQ","d3-timer":"Gc7n"}],"cead":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _constant = _interopRequireDefault(require("./constant"));

var _jiggle = _interopRequireDefault(require("./jiggle"));

var _d3Quadtree = require("d3-quadtree");

var _simulation = require("./simulation");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default() {
  var nodes,
      node,
      alpha,
      strength = (0, _constant.default)(-30),
      strengths,
      distanceMin2 = 1,
      distanceMax2 = Infinity,
      theta2 = 0.81;

  function force(_) {
    var i,
        n = nodes.length,
        tree = (0, _d3Quadtree.quadtree)(nodes, _simulation.x, _simulation.y).visitAfter(accumulate);

    for (alpha = _, i = 0; i < n; ++i) node = nodes[i], tree.visit(apply);
  }

  function initialize() {
    if (!nodes) return;
    var i,
        n = nodes.length,
        node;
    strengths = new Array(n);

    for (i = 0; i < n; ++i) node = nodes[i], strengths[node.index] = +strength(node, i, nodes);
  }

  function accumulate(quad) {
    var strength = 0,
        q,
        c,
        weight = 0,
        x,
        y,
        i; // For internal nodes, accumulate forces from child quadrants.

    if (quad.length) {
      for (x = y = i = 0; i < 4; ++i) {
        if ((q = quad[i]) && (c = Math.abs(q.value))) {
          strength += q.value, weight += c, x += c * q.x, y += c * q.y;
        }
      }

      quad.x = x / weight;
      quad.y = y / weight;
    } // For leaf nodes, accumulate forces from coincident quadrants.
    else {
        q = quad;
        q.x = q.data.x;
        q.y = q.data.y;

        do strength += strengths[q.data.index]; while (q = q.next);
      }

    quad.value = strength;
  }

  function apply(quad, x1, _, x2) {
    if (!quad.value) return true;
    var x = quad.x - node.x,
        y = quad.y - node.y,
        w = x2 - x1,
        l = x * x + y * y; // Apply the Barnes-Hut approximation if possible.
    // Limit forces for very close nodes; randomize direction if coincident.

    if (w * w / theta2 < l) {
      if (l < distanceMax2) {
        if (x === 0) x = (0, _jiggle.default)(), l += x * x;
        if (y === 0) y = (0, _jiggle.default)(), l += y * y;
        if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
        node.vx += x * quad.value * alpha / l;
        node.vy += y * quad.value * alpha / l;
      }

      return true;
    } // Otherwise, process points directly.
    else if (quad.length || l >= distanceMax2) return; // Limit forces for very close nodes; randomize direction if coincident.


    if (quad.data !== node || quad.next) {
      if (x === 0) x = (0, _jiggle.default)(), l += x * x;
      if (y === 0) y = (0, _jiggle.default)(), l += y * y;
      if (l < distanceMin2) l = Math.sqrt(distanceMin2 * l);
    }

    do if (quad.data !== node) {
      w = strengths[quad.data.index] * alpha / l;
      node.vx += x * w;
      node.vy += y * w;
    } while (quad = quad.next);
  }

  force.initialize = function (_) {
    nodes = _;
    initialize();
  };

  force.strength = function (_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0, _constant.default)(+_), initialize(), force) : strength;
  };

  force.distanceMin = function (_) {
    return arguments.length ? (distanceMin2 = _ * _, force) : Math.sqrt(distanceMin2);
  };

  force.distanceMax = function (_) {
    return arguments.length ? (distanceMax2 = _ * _, force) : Math.sqrt(distanceMax2);
  };

  force.theta = function (_) {
    return arguments.length ? (theta2 = _ * _, force) : Math.sqrt(theta2);
  };

  return force;
}
},{"./constant":"OY6d","./jiggle":"jmDl","d3-quadtree":"LBnY","./simulation":"lwF8"}],"qX1S":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _constant = _interopRequireDefault(require("./constant"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(radius, x, y) {
  var nodes,
      strength = (0, _constant.default)(0.1),
      strengths,
      radiuses;
  if (typeof radius !== "function") radius = (0, _constant.default)(+radius);
  if (x == null) x = 0;
  if (y == null) y = 0;

  function force(alpha) {
    for (var i = 0, n = nodes.length; i < n; ++i) {
      var node = nodes[i],
          dx = node.x - x || 1e-6,
          dy = node.y - y || 1e-6,
          r = Math.sqrt(dx * dx + dy * dy),
          k = (radiuses[i] - r) * strengths[i] * alpha / r;
      node.vx += dx * k;
      node.vy += dy * k;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i,
        n = nodes.length;
    strengths = new Array(n);
    radiuses = new Array(n);

    for (i = 0; i < n; ++i) {
      radiuses[i] = +radius(nodes[i], i, nodes);
      strengths[i] = isNaN(radiuses[i]) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function (_) {
    nodes = _, initialize();
  };

  force.strength = function (_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0, _constant.default)(+_), initialize(), force) : strength;
  };

  force.radius = function (_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : (0, _constant.default)(+_), initialize(), force) : radius;
  };

  force.x = function (_) {
    return arguments.length ? (x = +_, force) : x;
  };

  force.y = function (_) {
    return arguments.length ? (y = +_, force) : y;
  };

  return force;
}
},{"./constant":"OY6d"}],"AO2h":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _constant = _interopRequireDefault(require("./constant"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(x) {
  var strength = (0, _constant.default)(0.1),
      nodes,
      strengths,
      xz;
  if (typeof x !== "function") x = (0, _constant.default)(x == null ? 0 : +x);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vx += (xz[i] - node.x) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i,
        n = nodes.length;
    strengths = new Array(n);
    xz = new Array(n);

    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(xz[i] = +x(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function (_) {
    nodes = _;
    initialize();
  };

  force.strength = function (_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0, _constant.default)(+_), initialize(), force) : strength;
  };

  force.x = function (_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : (0, _constant.default)(+_), initialize(), force) : x;
  };

  return force;
}
},{"./constant":"OY6d"}],"SUZ3":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _constant = _interopRequireDefault(require("./constant"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(y) {
  var strength = (0, _constant.default)(0.1),
      nodes,
      strengths,
      yz;
  if (typeof y !== "function") y = (0, _constant.default)(y == null ? 0 : +y);

  function force(alpha) {
    for (var i = 0, n = nodes.length, node; i < n; ++i) {
      node = nodes[i], node.vy += (yz[i] - node.y) * strengths[i] * alpha;
    }
  }

  function initialize() {
    if (!nodes) return;
    var i,
        n = nodes.length;
    strengths = new Array(n);
    yz = new Array(n);

    for (i = 0; i < n; ++i) {
      strengths[i] = isNaN(yz[i] = +y(nodes[i], i, nodes)) ? 0 : +strength(nodes[i], i, nodes);
    }
  }

  force.initialize = function (_) {
    nodes = _;
    initialize();
  };

  force.strength = function (_) {
    return arguments.length ? (strength = typeof _ === "function" ? _ : (0, _constant.default)(+_), initialize(), force) : strength;
  };

  force.y = function (_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : (0, _constant.default)(+_), initialize(), force) : y;
  };

  return force;
}
},{"./constant":"OY6d"}],"Cxwz":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "forceCenter", {
  enumerable: true,
  get: function () {
    return _center.default;
  }
});
Object.defineProperty(exports, "forceCollide", {
  enumerable: true,
  get: function () {
    return _collide.default;
  }
});
Object.defineProperty(exports, "forceLink", {
  enumerable: true,
  get: function () {
    return _link.default;
  }
});
Object.defineProperty(exports, "forceManyBody", {
  enumerable: true,
  get: function () {
    return _manyBody.default;
  }
});
Object.defineProperty(exports, "forceRadial", {
  enumerable: true,
  get: function () {
    return _radial.default;
  }
});
Object.defineProperty(exports, "forceSimulation", {
  enumerable: true,
  get: function () {
    return _simulation.default;
  }
});
Object.defineProperty(exports, "forceX", {
  enumerable: true,
  get: function () {
    return _x.default;
  }
});
Object.defineProperty(exports, "forceY", {
  enumerable: true,
  get: function () {
    return _y.default;
  }
});

var _center = _interopRequireDefault(require("./src/center"));

var _collide = _interopRequireDefault(require("./src/collide"));

var _link = _interopRequireDefault(require("./src/link"));

var _manyBody = _interopRequireDefault(require("./src/manyBody"));

var _radial = _interopRequireDefault(require("./src/radial"));

var _simulation = _interopRequireDefault(require("./src/simulation"));

var _x = _interopRequireDefault(require("./src/x"));

var _y = _interopRequireDefault(require("./src/y"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./src/center":"yF4t","./src/collide":"ZCSV","./src/link":"M788","./src/manyBody":"cead","./src/radial":"qX1S","./src/simulation":"lwF8","./src/x":"AO2h","./src/y":"SUZ3"}],"cJhM":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

// Computes the decimal coefficient and exponent of the specified number x with
// significant digits p, where x is positive and p is in [1, 21] or undefined.
// For example, formatDecimal(1.23) returns ["123", 0].
function _default(x, p) {
  if ((i = (x = p ? x.toExponential(p - 1) : x.toExponential()).indexOf("e")) < 0) return null; // NaN, ±Infinity

  var i,
      coefficient = x.slice(0, i); // The string returned by toExponential either has the form \d\.\d+e[-+]\d+
  // (e.g., 1.2e+3) or the form \de[-+]\d+ (e.g., 1e+3).

  return [coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient, +x.slice(i + 1)];
}
},{}],"m3FQ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _formatDecimal = _interopRequireDefault(require("./formatDecimal"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(x) {
  return x = (0, _formatDecimal.default)(Math.abs(x)), x ? x[1] : NaN;
}
},{"./formatDecimal":"cJhM"}],"e1cc":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(grouping, thousands) {
  return function (value, width) {
    var i = value.length,
        t = [],
        j = 0,
        g = grouping[0],
        length = 0;

    while (i > 0 && g > 0) {
      if (length + g + 1 > width) g = Math.max(1, width - length);
      t.push(value.substring(i -= g, i + g));
      if ((length += g + 1) > width) break;
      g = grouping[j = (j + 1) % grouping.length];
    }

    return t.reverse().join(thousands);
  };
}
},{}],"Wswx":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(numerals) {
  return function (value) {
    return value.replace(/[0-9]/g, function (i) {
      return numerals[+i];
    });
  };
}
},{}],"ONKv":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(x, p) {
  x = x.toPrecision(p);

  out: for (var n = x.length, i = 1, i0 = -1, i1; i < n; ++i) {
    switch (x[i]) {
      case ".":
        i0 = i1 = i;
        break;

      case "0":
        if (i0 === 0) i0 = i;
        i1 = i;
        break;

      case "e":
        break out;

      default:
        if (i0 > 0) i0 = 0;
        break;
    }
  }

  return i0 > 0 ? x.slice(0, i0) + x.slice(i1 + 1) : x;
}
},{}],"KTGF":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.prefixExponent = void 0;

var _formatDecimal = _interopRequireDefault(require("./formatDecimal"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var prefixExponent;
exports.prefixExponent = prefixExponent;

function _default(x, p) {
  var d = (0, _formatDecimal.default)(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1],
      i = exponent - (exports.prefixExponent = prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent / 3))) * 3) + 1,
      n = coefficient.length;
  return i === n ? coefficient : i > n ? coefficient + new Array(i - n + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + (0, _formatDecimal.default)(x, Math.max(0, p + i - 1))[0]; // less than 1y!
}
},{"./formatDecimal":"cJhM"}],"e8gU":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _formatDecimal = _interopRequireDefault(require("./formatDecimal"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(x, p) {
  var d = (0, _formatDecimal.default)(x, p);
  if (!d) return x + "";
  var coefficient = d[0],
      exponent = d[1];
  return exponent < 0 ? "0." + new Array(-exponent).join("0") + coefficient : coefficient.length > exponent + 1 ? coefficient.slice(0, exponent + 1) + "." + coefficient.slice(exponent + 1) : coefficient + new Array(exponent - coefficient.length + 2).join("0");
}
},{"./formatDecimal":"cJhM"}],"uFUO":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _formatDefault = _interopRequireDefault(require("./formatDefault"));

var _formatPrefixAuto = _interopRequireDefault(require("./formatPrefixAuto"));

var _formatRounded = _interopRequireDefault(require("./formatRounded"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = {
  "": _formatDefault.default,
  "%": function (x, p) {
    return (x * 100).toFixed(p);
  },
  "b": function (x) {
    return Math.round(x).toString(2);
  },
  "c": function (x) {
    return x + "";
  },
  "d": function (x) {
    return Math.round(x).toString(10);
  },
  "e": function (x, p) {
    return x.toExponential(p);
  },
  "f": function (x, p) {
    return x.toFixed(p);
  },
  "g": function (x, p) {
    return x.toPrecision(p);
  },
  "o": function (x) {
    return Math.round(x).toString(8);
  },
  "p": function (x, p) {
    return (0, _formatRounded.default)(x * 100, p);
  },
  "r": _formatRounded.default,
  "s": _formatPrefixAuto.default,
  "X": function (x) {
    return Math.round(x).toString(16).toUpperCase();
  },
  "x": function (x) {
    return Math.round(x).toString(16);
  }
};
exports.default = _default;
},{"./formatDefault":"ONKv","./formatPrefixAuto":"KTGF","./formatRounded":"e8gU"}],"gePe":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = formatSpecifier;

var _formatTypes = _interopRequireDefault(require("./formatTypes"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// [[fill]align][sign][symbol][0][width][,][.precision][type]
var re = /^(?:(.)?([<>=^]))?([+\-\( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?([a-z%])?$/i;

function formatSpecifier(specifier) {
  return new FormatSpecifier(specifier);
}

formatSpecifier.prototype = FormatSpecifier.prototype; // instanceof

function FormatSpecifier(specifier) {
  if (!(match = re.exec(specifier))) throw new Error("invalid format: " + specifier);
  var match,
      fill = match[1] || " ",
      align = match[2] || ">",
      sign = match[3] || "-",
      symbol = match[4] || "",
      zero = !!match[5],
      width = match[6] && +match[6],
      comma = !!match[7],
      precision = match[8] && +match[8].slice(1),
      type = match[9] || ""; // The "n" type is an alias for ",g".

  if (type === "n") comma = true, type = "g"; // Map invalid types to the default format.
  else if (!_formatTypes.default[type]) type = ""; // If zero fill is specified, padding goes after sign and before digits.

  if (zero || fill === "0" && align === "=") zero = true, fill = "0", align = "=";
  this.fill = fill;
  this.align = align;
  this.sign = sign;
  this.symbol = symbol;
  this.zero = zero;
  this.width = width;
  this.comma = comma;
  this.precision = precision;
  this.type = type;
}

FormatSpecifier.prototype.toString = function () {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width == null ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision == null ? "" : "." + Math.max(0, this.precision | 0)) + this.type;
};
},{"./formatTypes":"uFUO"}],"QWQX":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _exponent = _interopRequireDefault(require("./exponent"));

var _formatGroup = _interopRequireDefault(require("./formatGroup"));

var _formatNumerals = _interopRequireDefault(require("./formatNumerals"));

var _formatSpecifier = _interopRequireDefault(require("./formatSpecifier"));

var _formatTypes = _interopRequireDefault(require("./formatTypes"));

var _formatPrefixAuto = require("./formatPrefixAuto");

var _identity = _interopRequireDefault(require("./identity"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var prefixes = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];

function _default(locale) {
  var group = locale.grouping && locale.thousands ? (0, _formatGroup.default)(locale.grouping, locale.thousands) : _identity.default,
      currency = locale.currency,
      decimal = locale.decimal,
      numerals = locale.numerals ? (0, _formatNumerals.default)(locale.numerals) : _identity.default,
      percent = locale.percent || "%";

  function newFormat(specifier) {
    specifier = (0, _formatSpecifier.default)(specifier);
    var fill = specifier.fill,
        align = specifier.align,
        sign = specifier.sign,
        symbol = specifier.symbol,
        zero = specifier.zero,
        width = specifier.width,
        comma = specifier.comma,
        precision = specifier.precision,
        type = specifier.type; // Compute the prefix and suffix.
    // For SI-prefix, the suffix is lazily computed.

    var prefix = symbol === "$" ? currency[0] : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "",
        suffix = symbol === "$" ? currency[1] : /[%p]/.test(type) ? percent : ""; // What format function should we use?
    // Is this an integer type?
    // Can this type generate exponential notation?

    var formatType = _formatTypes.default[type],
        maybeSuffix = !type || /[defgprs%]/.test(type); // Set the default precision if not specified,
    // or clamp the specified precision to the supported range.
    // For significant precision, it must be in [1, 21].
    // For fixed precision, it must be in [0, 20].

    precision = precision == null ? type ? 6 : 12 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));

    function format(value) {
      var valuePrefix = prefix,
          valueSuffix = suffix,
          i,
          n,
          c;

      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value; // Perform the initial formatting.

        var valueNegative = value < 0;
        value = formatType(Math.abs(value), precision); // If a negative value rounds to zero during formatting, treat as positive.

        if (valueNegative && +value === 0) valueNegative = false; // Compute the prefix and suffix.

        valuePrefix = (valueNegative ? sign === "(" ? sign : "-" : sign === "-" || sign === "(" ? "" : sign) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + _formatPrefixAuto.prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign === "(" ? ")" : ""); // Break the formatted value into the integer “value” part that can be
        // grouped, and fractional or exponential “suffix” part that is not.

        if (maybeSuffix) {
          i = -1, n = value.length;

          while (++i < n) {
            if (c = value.charCodeAt(i), 48 > c || c > 57) {
              valueSuffix = (c === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      } // If the fill character is not "0", grouping is applied before padding.


      if (comma && !zero) value = group(value, Infinity); // Compute the padding.

      var length = valuePrefix.length + value.length + valueSuffix.length,
          padding = length < width ? new Array(width - length + 1).join(fill) : ""; // If the fill character is "0", grouping is applied after padding.

      if (comma && zero) value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = ""; // Reconstruct the final output based on the desired alignment.

      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;
          break;

        case "=":
          value = valuePrefix + padding + value + valueSuffix;
          break;

        case "^":
          value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
          break;

        default:
          value = padding + valuePrefix + value + valueSuffix;
          break;
      }

      return numerals(value);
    }

    format.toString = function () {
      return specifier + "";
    };

    return format;
  }

  function formatPrefix(specifier, value) {
    var f = newFormat((specifier = (0, _formatSpecifier.default)(specifier), specifier.type = "f", specifier)),
        e = Math.max(-8, Math.min(8, Math.floor((0, _exponent.default)(value) / 3))) * 3,
        k = Math.pow(10, -e),
        prefix = prefixes[8 + e / 3];
    return function (value) {
      return f(k * value) + prefix;
    };
  }

  return {
    format: newFormat,
    formatPrefix: formatPrefix
  };
}
},{"./exponent":"m3FQ","./formatGroup":"e1cc","./formatNumerals":"Wswx","./formatSpecifier":"gePe","./formatTypes":"uFUO","./formatPrefixAuto":"KTGF","./identity":"nPOL"}],"yM0X":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = defaultLocale;
exports.formatPrefix = exports.format = void 0;

var _locale = _interopRequireDefault(require("./locale"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var locale;
var format;
exports.format = format;
var formatPrefix;
exports.formatPrefix = formatPrefix;
defaultLocale({
  decimal: ".",
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});

function defaultLocale(definition) {
  locale = (0, _locale.default)(definition);
  exports.format = format = locale.format;
  exports.formatPrefix = formatPrefix = locale.formatPrefix;
  return locale;
}
},{"./locale":"QWQX"}],"QL8u":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _exponent = _interopRequireDefault(require("./exponent"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(step) {
  return Math.max(0, -(0, _exponent.default)(Math.abs(step)));
}
},{"./exponent":"m3FQ"}],"DzQJ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _exponent = _interopRequireDefault(require("./exponent"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor((0, _exponent.default)(value) / 3))) * 3 - (0, _exponent.default)(Math.abs(step)));
}
},{"./exponent":"m3FQ"}],"afbh":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _exponent = _interopRequireDefault(require("./exponent"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(step, max) {
  step = Math.abs(step), max = Math.abs(max) - step;
  return Math.max(0, (0, _exponent.default)(max) - (0, _exponent.default)(step)) + 1;
}
},{"./exponent":"m3FQ"}],"ftuj":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "formatDefaultLocale", {
  enumerable: true,
  get: function () {
    return _defaultLocale.default;
  }
});
Object.defineProperty(exports, "format", {
  enumerable: true,
  get: function () {
    return _defaultLocale.format;
  }
});
Object.defineProperty(exports, "formatPrefix", {
  enumerable: true,
  get: function () {
    return _defaultLocale.formatPrefix;
  }
});
Object.defineProperty(exports, "formatLocale", {
  enumerable: true,
  get: function () {
    return _locale.default;
  }
});
Object.defineProperty(exports, "formatSpecifier", {
  enumerable: true,
  get: function () {
    return _formatSpecifier.default;
  }
});
Object.defineProperty(exports, "precisionFixed", {
  enumerable: true,
  get: function () {
    return _precisionFixed.default;
  }
});
Object.defineProperty(exports, "precisionPrefix", {
  enumerable: true,
  get: function () {
    return _precisionPrefix.default;
  }
});
Object.defineProperty(exports, "precisionRound", {
  enumerable: true,
  get: function () {
    return _precisionRound.default;
  }
});

var _defaultLocale = _interopRequireWildcard(require("./src/defaultLocale"));

var _locale = _interopRequireDefault(require("./src/locale"));

var _formatSpecifier = _interopRequireDefault(require("./src/formatSpecifier"));

var _precisionFixed = _interopRequireDefault(require("./src/precisionFixed"));

var _precisionPrefix = _interopRequireDefault(require("./src/precisionPrefix"));

var _precisionRound = _interopRequireDefault(require("./src/precisionRound"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
},{"./src/defaultLocale":"yM0X","./src/locale":"QWQX","./src/formatSpecifier":"gePe","./src/precisionFixed":"QL8u","./src/precisionPrefix":"DzQJ","./src/precisionRound":"afbh"}],"GlqK":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

// Adds floating point numbers with twice the normal precision.
// Reference: J. R. Shewchuk, Adaptive Precision Floating-Point Arithmetic and
// Fast Robust Geometric Predicates, Discrete & Computational Geometry 18(3)
// 305–363 (1997).
// Code adapted from GeographicLib by Charles F. F. Karney,
// http://geographiclib.sourceforge.net/
function _default() {
  return new Adder();
}

function Adder() {
  this.reset();
}

Adder.prototype = {
  constructor: Adder,
  reset: function () {
    this.s = // rounded value
    this.t = 0; // exact error
  },
  add: function (y) {
    add(temp, y, this.t);
    add(this, temp.s, this.s);
    if (this.s) this.t += temp.t;else this.s = temp.t;
  },
  valueOf: function () {
    return this.s;
  }
};
var temp = new Adder();

function add(adder, a, b) {
  var x = adder.s = a + b,
      bv = x - a,
      av = x - bv;
  adder.t = a - av + (b - bv);
}
},{}],"sEgP":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.acos = acos;
exports.asin = asin;
exports.haversin = haversin;
exports.tan = exports.sqrt = exports.sign = exports.sin = exports.pow = exports.log = exports.floor = exports.exp = exports.ceil = exports.cos = exports.atan2 = exports.atan = exports.abs = exports.radians = exports.degrees = exports.tau = exports.quarterPi = exports.halfPi = exports.pi = exports.epsilon2 = exports.epsilon = void 0;
var epsilon = 1e-6;
exports.epsilon = epsilon;
var epsilon2 = 1e-12;
exports.epsilon2 = epsilon2;
var pi = Math.PI;
exports.pi = pi;
var halfPi = pi / 2;
exports.halfPi = halfPi;
var quarterPi = pi / 4;
exports.quarterPi = quarterPi;
var tau = pi * 2;
exports.tau = tau;
var degrees = 180 / pi;
exports.degrees = degrees;
var radians = pi / 180;
exports.radians = radians;
var abs = Math.abs;
exports.abs = abs;
var atan = Math.atan;
exports.atan = atan;
var atan2 = Math.atan2;
exports.atan2 = atan2;
var cos = Math.cos;
exports.cos = cos;
var ceil = Math.ceil;
exports.ceil = ceil;
var exp = Math.exp;
exports.exp = exp;
var floor = Math.floor;
exports.floor = floor;
var log = Math.log;
exports.log = log;
var pow = Math.pow;
exports.pow = pow;
var sin = Math.sin;
exports.sin = sin;

var sign = Math.sign || function (x) {
  return x > 0 ? 1 : x < 0 ? -1 : 0;
};

exports.sign = sign;
var sqrt = Math.sqrt;
exports.sqrt = sqrt;
var tan = Math.tan;
exports.tan = tan;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x > 1 ? halfPi : x < -1 ? -halfPi : Math.asin(x);
}

function haversin(x) {
  return (x = sin(x / 2)) * x;
}
},{}],"UPwg":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = noop;

function noop() {}
},{}],"XBFK":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function streamGeometry(geometry, stream) {
  if (geometry && streamGeometryType.hasOwnProperty(geometry.type)) {
    streamGeometryType[geometry.type](geometry, stream);
  }
}

var streamObjectType = {
  Feature: function (object, stream) {
    streamGeometry(object.geometry, stream);
  },
  FeatureCollection: function (object, stream) {
    var features = object.features,
        i = -1,
        n = features.length;

    while (++i < n) streamGeometry(features[i].geometry, stream);
  }
};
var streamGeometryType = {
  Sphere: function (object, stream) {
    stream.sphere();
  },
  Point: function (object, stream) {
    object = object.coordinates;
    stream.point(object[0], object[1], object[2]);
  },
  MultiPoint: function (object, stream) {
    var coordinates = object.coordinates,
        i = -1,
        n = coordinates.length;

    while (++i < n) object = coordinates[i], stream.point(object[0], object[1], object[2]);
  },
  LineString: function (object, stream) {
    streamLine(object.coordinates, stream, 0);
  },
  MultiLineString: function (object, stream) {
    var coordinates = object.coordinates,
        i = -1,
        n = coordinates.length;

    while (++i < n) streamLine(coordinates[i], stream, 0);
  },
  Polygon: function (object, stream) {
    streamPolygon(object.coordinates, stream);
  },
  MultiPolygon: function (object, stream) {
    var coordinates = object.coordinates,
        i = -1,
        n = coordinates.length;

    while (++i < n) streamPolygon(coordinates[i], stream);
  },
  GeometryCollection: function (object, stream) {
    var geometries = object.geometries,
        i = -1,
        n = geometries.length;

    while (++i < n) streamGeometry(geometries[i], stream);
  }
};

function streamLine(coordinates, stream, closed) {
  var i = -1,
      n = coordinates.length - closed,
      coordinate;
  stream.lineStart();

  while (++i < n) coordinate = coordinates[i], stream.point(coordinate[0], coordinate[1], coordinate[2]);

  stream.lineEnd();
}

function streamPolygon(coordinates, stream) {
  var i = -1,
      n = coordinates.length;
  stream.polygonStart();

  while (++i < n) streamLine(coordinates[i], stream, 1);

  stream.polygonEnd();
}

function _default(object, stream) {
  if (object && streamObjectType.hasOwnProperty(object.type)) {
    streamObjectType[object.type](object, stream);
  } else {
    streamGeometry(object, stream);
  }
}
},{}],"dpXv":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.areaStream = exports.areaRingSum = void 0;

var _adder = _interopRequireDefault(require("./adder"));

var _math = require("./math");

var _noop = _interopRequireDefault(require("./noop"));

var _stream = _interopRequireDefault(require("./stream"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var areaRingSum = (0, _adder.default)();
exports.areaRingSum = areaRingSum;
var areaSum = (0, _adder.default)(),
    lambda00,
    phi00,
    lambda0,
    cosPhi0,
    sinPhi0;
var areaStream = {
  point: _noop.default,
  lineStart: _noop.default,
  lineEnd: _noop.default,
  polygonStart: function () {
    areaRingSum.reset();
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function () {
    var areaRing = +areaRingSum;
    areaSum.add(areaRing < 0 ? _math.tau + areaRing : areaRing);
    this.lineStart = this.lineEnd = this.point = _noop.default;
  },
  sphere: function () {
    areaSum.add(_math.tau);
  }
};
exports.areaStream = areaStream;

function areaRingStart() {
  areaStream.point = areaPointFirst;
}

function areaRingEnd() {
  areaPoint(lambda00, phi00);
}

function areaPointFirst(lambda, phi) {
  areaStream.point = areaPoint;
  lambda00 = lambda, phi00 = phi;
  lambda *= _math.radians, phi *= _math.radians;
  lambda0 = lambda, cosPhi0 = (0, _math.cos)(phi = phi / 2 + _math.quarterPi), sinPhi0 = (0, _math.sin)(phi);
}

function areaPoint(lambda, phi) {
  lambda *= _math.radians, phi *= _math.radians;
  phi = phi / 2 + _math.quarterPi; // half the angular distance from south pole
  // Spherical excess E for a spherical triangle with vertices: south pole,
  // previous point, current point.  Uses a formula derived from Cagnoli’s
  // theorem.  See Todhunter, Spherical Trig. (1871), Sec. 103, Eq. (2).

  var dLambda = lambda - lambda0,
      sdLambda = dLambda >= 0 ? 1 : -1,
      adLambda = sdLambda * dLambda,
      cosPhi = (0, _math.cos)(phi),
      sinPhi = (0, _math.sin)(phi),
      k = sinPhi0 * sinPhi,
      u = cosPhi0 * cosPhi + k * (0, _math.cos)(adLambda),
      v = k * sdLambda * (0, _math.sin)(adLambda);
  areaRingSum.add((0, _math.atan2)(v, u)); // Advance the previous points.

  lambda0 = lambda, cosPhi0 = cosPhi, sinPhi0 = sinPhi;
}

function _default(object) {
  areaSum.reset();
  (0, _stream.default)(object, areaStream);
  return areaSum * 2;
}
},{"./adder":"GlqK","./math":"sEgP","./noop":"UPwg","./stream":"XBFK"}],"rFMq":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.spherical = spherical;
exports.cartesian = cartesian;
exports.cartesianDot = cartesianDot;
exports.cartesianCross = cartesianCross;
exports.cartesianAddInPlace = cartesianAddInPlace;
exports.cartesianScale = cartesianScale;
exports.cartesianNormalizeInPlace = cartesianNormalizeInPlace;

var _math = require("./math");

function spherical(cartesian) {
  return [(0, _math.atan2)(cartesian[1], cartesian[0]), (0, _math.asin)(cartesian[2])];
}

function cartesian(spherical) {
  var lambda = spherical[0],
      phi = spherical[1],
      cosPhi = (0, _math.cos)(phi);
  return [cosPhi * (0, _math.cos)(lambda), cosPhi * (0, _math.sin)(lambda), (0, _math.sin)(phi)];
}

function cartesianDot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

function cartesianCross(a, b) {
  return [a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0]];
} // TODO return a


function cartesianAddInPlace(a, b) {
  a[0] += b[0], a[1] += b[1], a[2] += b[2];
}

function cartesianScale(vector, k) {
  return [vector[0] * k, vector[1] * k, vector[2] * k];
} // TODO return d


function cartesianNormalizeInPlace(d) {
  var l = (0, _math.sqrt)(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);
  d[0] /= l, d[1] /= l, d[2] /= l;
}
},{"./math":"sEgP"}],"wXR4":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _adder = _interopRequireDefault(require("./adder"));

var _area = require("./area");

var _cartesian = require("./cartesian");

var _math = require("./math");

var _stream = _interopRequireDefault(require("./stream"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var lambda0,
    phi0,
    lambda1,
    phi1,
    // bounds
lambda2,
    // previous lambda-coordinate
lambda00,
    phi00,
    // first point
p0,
    // previous 3D point
deltaSum = (0, _adder.default)(),
    ranges,
    range;
var boundsStream = {
  point: boundsPoint,
  lineStart: boundsLineStart,
  lineEnd: boundsLineEnd,
  polygonStart: function () {
    boundsStream.point = boundsRingPoint;
    boundsStream.lineStart = boundsRingStart;
    boundsStream.lineEnd = boundsRingEnd;
    deltaSum.reset();

    _area.areaStream.polygonStart();
  },
  polygonEnd: function () {
    _area.areaStream.polygonEnd();

    boundsStream.point = boundsPoint;
    boundsStream.lineStart = boundsLineStart;
    boundsStream.lineEnd = boundsLineEnd;
    if (_area.areaRingSum < 0) lambda0 = -(lambda1 = 180), phi0 = -(phi1 = 90);else if (deltaSum > _math.epsilon) phi1 = 90;else if (deltaSum < -_math.epsilon) phi0 = -90;
    range[0] = lambda0, range[1] = lambda1;
  }
};

function boundsPoint(lambda, phi) {
  ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);
  if (phi < phi0) phi0 = phi;
  if (phi > phi1) phi1 = phi;
}

function linePoint(lambda, phi) {
  var p = (0, _cartesian.cartesian)([lambda * _math.radians, phi * _math.radians]);

  if (p0) {
    var normal = (0, _cartesian.cartesianCross)(p0, p),
        equatorial = [normal[1], -normal[0], 0],
        inflection = (0, _cartesian.cartesianCross)(equatorial, normal);
    (0, _cartesian.cartesianNormalizeInPlace)(inflection);
    inflection = (0, _cartesian.spherical)(inflection);
    var delta = lambda - lambda2,
        sign = delta > 0 ? 1 : -1,
        lambdai = inflection[0] * _math.degrees * sign,
        phii,
        antimeridian = (0, _math.abs)(delta) > 180;

    if (antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
      phii = inflection[1] * _math.degrees;
      if (phii > phi1) phi1 = phii;
    } else if (lambdai = (lambdai + 360) % 360 - 180, antimeridian ^ (sign * lambda2 < lambdai && lambdai < sign * lambda)) {
      phii = -inflection[1] * _math.degrees;
      if (phii < phi0) phi0 = phii;
    } else {
      if (phi < phi0) phi0 = phi;
      if (phi > phi1) phi1 = phi;
    }

    if (antimeridian) {
      if (lambda < lambda2) {
        if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;
      } else {
        if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;
      }
    } else {
      if (lambda1 >= lambda0) {
        if (lambda < lambda0) lambda0 = lambda;
        if (lambda > lambda1) lambda1 = lambda;
      } else {
        if (lambda > lambda2) {
          if (angle(lambda0, lambda) > angle(lambda0, lambda1)) lambda1 = lambda;
        } else {
          if (angle(lambda, lambda1) > angle(lambda0, lambda1)) lambda0 = lambda;
        }
      }
    }
  } else {
    ranges.push(range = [lambda0 = lambda, lambda1 = lambda]);
  }

  if (phi < phi0) phi0 = phi;
  if (phi > phi1) phi1 = phi;
  p0 = p, lambda2 = lambda;
}

function boundsLineStart() {
  boundsStream.point = linePoint;
}

function boundsLineEnd() {
  range[0] = lambda0, range[1] = lambda1;
  boundsStream.point = boundsPoint;
  p0 = null;
}

function boundsRingPoint(lambda, phi) {
  if (p0) {
    var delta = lambda - lambda2;
    deltaSum.add((0, _math.abs)(delta) > 180 ? delta + (delta > 0 ? 360 : -360) : delta);
  } else {
    lambda00 = lambda, phi00 = phi;
  }

  _area.areaStream.point(lambda, phi);

  linePoint(lambda, phi);
}

function boundsRingStart() {
  _area.areaStream.lineStart();
}

function boundsRingEnd() {
  boundsRingPoint(lambda00, phi00);

  _area.areaStream.lineEnd();

  if ((0, _math.abs)(deltaSum) > _math.epsilon) lambda0 = -(lambda1 = 180);
  range[0] = lambda0, range[1] = lambda1;
  p0 = null;
} // Finds the left-right distance between two longitudes.
// This is almost the same as (lambda1 - lambda0 + 360°) % 360°, except that we want
// the distance between ±180° to be 360°.


function angle(lambda0, lambda1) {
  return (lambda1 -= lambda0) < 0 ? lambda1 + 360 : lambda1;
}

function rangeCompare(a, b) {
  return a[0] - b[0];
}

function rangeContains(range, x) {
  return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;
}

function _default(feature) {
  var i, n, a, b, merged, deltaMax, delta;
  phi1 = lambda1 = -(lambda0 = phi0 = Infinity);
  ranges = [];
  (0, _stream.default)(feature, boundsStream); // First, sort ranges by their minimum longitudes.

  if (n = ranges.length) {
    ranges.sort(rangeCompare); // Then, merge any ranges that overlap.

    for (i = 1, a = ranges[0], merged = [a]; i < n; ++i) {
      b = ranges[i];

      if (rangeContains(a, b[0]) || rangeContains(a, b[1])) {
        if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];
        if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];
      } else {
        merged.push(a = b);
      }
    } // Finally, find the largest gap between the merged ranges.
    // The final bounding box will be the inverse of this gap.


    for (deltaMax = -Infinity, n = merged.length - 1, i = 0, a = merged[n]; i <= n; a = b, ++i) {
      b = merged[i];
      if ((delta = angle(a[1], b[0])) > deltaMax) deltaMax = delta, lambda0 = b[0], lambda1 = a[1];
    }
  }

  ranges = range = null;
  return lambda0 === Infinity || phi0 === Infinity ? [[NaN, NaN], [NaN, NaN]] : [[lambda0, phi0], [lambda1, phi1]];
}
},{"./adder":"GlqK","./area":"dpXv","./cartesian":"rFMq","./math":"sEgP","./stream":"XBFK"}],"pQGp":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _math = require("./math");

var _noop = _interopRequireDefault(require("./noop"));

var _stream = _interopRequireDefault(require("./stream"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var W0, W1, X0, Y0, Z0, X1, Y1, Z1, X2, Y2, Z2, lambda00, phi00, // first point
x0, y0, z0; // previous point

var centroidStream = {
  sphere: _noop.default,
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function () {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function () {
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  }
}; // Arithmetic mean of Cartesian vectors.

function centroidPoint(lambda, phi) {
  lambda *= _math.radians, phi *= _math.radians;
  var cosPhi = (0, _math.cos)(phi);
  centroidPointCartesian(cosPhi * (0, _math.cos)(lambda), cosPhi * (0, _math.sin)(lambda), (0, _math.sin)(phi));
}

function centroidPointCartesian(x, y, z) {
  ++W0;
  X0 += (x - X0) / W0;
  Y0 += (y - Y0) / W0;
  Z0 += (z - Z0) / W0;
}

function centroidLineStart() {
  centroidStream.point = centroidLinePointFirst;
}

function centroidLinePointFirst(lambda, phi) {
  lambda *= _math.radians, phi *= _math.radians;
  var cosPhi = (0, _math.cos)(phi);
  x0 = cosPhi * (0, _math.cos)(lambda);
  y0 = cosPhi * (0, _math.sin)(lambda);
  z0 = (0, _math.sin)(phi);
  centroidStream.point = centroidLinePoint;
  centroidPointCartesian(x0, y0, z0);
}

function centroidLinePoint(lambda, phi) {
  lambda *= _math.radians, phi *= _math.radians;
  var cosPhi = (0, _math.cos)(phi),
      x = cosPhi * (0, _math.cos)(lambda),
      y = cosPhi * (0, _math.sin)(lambda),
      z = (0, _math.sin)(phi),
      w = (0, _math.atan2)((0, _math.sqrt)((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

function centroidLineEnd() {
  centroidStream.point = centroidPoint;
} // See J. E. Brock, The Inertia Tensor for a Spherical Triangle,
// J. Applied Mechanics 42, 239 (1975).


function centroidRingStart() {
  centroidStream.point = centroidRingPointFirst;
}

function centroidRingEnd() {
  centroidRingPoint(lambda00, phi00);
  centroidStream.point = centroidPoint;
}

function centroidRingPointFirst(lambda, phi) {
  lambda00 = lambda, phi00 = phi;
  lambda *= _math.radians, phi *= _math.radians;
  centroidStream.point = centroidRingPoint;
  var cosPhi = (0, _math.cos)(phi);
  x0 = cosPhi * (0, _math.cos)(lambda);
  y0 = cosPhi * (0, _math.sin)(lambda);
  z0 = (0, _math.sin)(phi);
  centroidPointCartesian(x0, y0, z0);
}

function centroidRingPoint(lambda, phi) {
  lambda *= _math.radians, phi *= _math.radians;
  var cosPhi = (0, _math.cos)(phi),
      x = cosPhi * (0, _math.cos)(lambda),
      y = cosPhi * (0, _math.sin)(lambda),
      z = (0, _math.sin)(phi),
      cx = y0 * z - z0 * y,
      cy = z0 * x - x0 * z,
      cz = x0 * y - y0 * x,
      m = (0, _math.sqrt)(cx * cx + cy * cy + cz * cz),
      w = (0, _math.asin)(m),
      // line weight = angle
  v = m && -w / m; // area weight multiplier

  X2 += v * cx;
  Y2 += v * cy;
  Z2 += v * cz;
  W1 += w;
  X1 += w * (x0 + (x0 = x));
  Y1 += w * (y0 + (y0 = y));
  Z1 += w * (z0 + (z0 = z));
  centroidPointCartesian(x0, y0, z0);
}

function _default(object) {
  W0 = W1 = X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
  (0, _stream.default)(object, centroidStream);
  var x = X2,
      y = Y2,
      z = Z2,
      m = x * x + y * y + z * z; // If the area-weighted ccentroid is undefined, fall back to length-weighted ccentroid.

  if (m < _math.epsilon2) {
    x = X1, y = Y1, z = Z1; // If the feature has zero length, fall back to arithmetic mean of point vectors.

    if (W1 < _math.epsilon) x = X0, y = Y0, z = Z0;
    m = x * x + y * y + z * z; // If the feature still has an undefined ccentroid, then return.

    if (m < _math.epsilon2) return [NaN, NaN];
  }

  return [(0, _math.atan2)(y, x) * _math.degrees, (0, _math.asin)(z / (0, _math.sqrt)(m)) * _math.degrees];
}
},{"./math":"sEgP","./noop":"UPwg","./stream":"XBFK"}],"hCea":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(a, b) {
  function compose(x, y) {
    return x = a(x, y), b(x[0], x[1]);
  }

  if (a.invert && b.invert) compose.invert = function (x, y) {
    return x = b.invert(x, y), x && a.invert(x[0], x[1]);
  };
  return compose;
}
},{}],"KwdP":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.rotateRadians = rotateRadians;
exports.default = _default;

var _compose = _interopRequireDefault(require("./compose"));

var _math = require("./math");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function rotationIdentity(lambda, phi) {
  return [lambda > _math.pi ? lambda - _math.tau : lambda < -_math.pi ? lambda + _math.tau : lambda, phi];
}

rotationIdentity.invert = rotationIdentity;

function rotateRadians(deltaLambda, deltaPhi, deltaGamma) {
  return (deltaLambda %= _math.tau) ? deltaPhi || deltaGamma ? (0, _compose.default)(rotationLambda(deltaLambda), rotationPhiGamma(deltaPhi, deltaGamma)) : rotationLambda(deltaLambda) : deltaPhi || deltaGamma ? rotationPhiGamma(deltaPhi, deltaGamma) : rotationIdentity;
}

function forwardRotationLambda(deltaLambda) {
  return function (lambda, phi) {
    return lambda += deltaLambda, [lambda > _math.pi ? lambda - _math.tau : lambda < -_math.pi ? lambda + _math.tau : lambda, phi];
  };
}

function rotationLambda(deltaLambda) {
  var rotation = forwardRotationLambda(deltaLambda);
  rotation.invert = forwardRotationLambda(-deltaLambda);
  return rotation;
}

function rotationPhiGamma(deltaPhi, deltaGamma) {
  var cosDeltaPhi = (0, _math.cos)(deltaPhi),
      sinDeltaPhi = (0, _math.sin)(deltaPhi),
      cosDeltaGamma = (0, _math.cos)(deltaGamma),
      sinDeltaGamma = (0, _math.sin)(deltaGamma);

  function rotation(lambda, phi) {
    var cosPhi = (0, _math.cos)(phi),
        x = (0, _math.cos)(lambda) * cosPhi,
        y = (0, _math.sin)(lambda) * cosPhi,
        z = (0, _math.sin)(phi),
        k = z * cosDeltaPhi + x * sinDeltaPhi;
    return [(0, _math.atan2)(y * cosDeltaGamma - k * sinDeltaGamma, x * cosDeltaPhi - z * sinDeltaPhi), (0, _math.asin)(k * cosDeltaGamma + y * sinDeltaGamma)];
  }

  rotation.invert = function (lambda, phi) {
    var cosPhi = (0, _math.cos)(phi),
        x = (0, _math.cos)(lambda) * cosPhi,
        y = (0, _math.sin)(lambda) * cosPhi,
        z = (0, _math.sin)(phi),
        k = z * cosDeltaGamma - y * sinDeltaGamma;
    return [(0, _math.atan2)(y * cosDeltaGamma + z * sinDeltaGamma, x * cosDeltaPhi + k * sinDeltaPhi), (0, _math.asin)(k * cosDeltaPhi - x * sinDeltaPhi)];
  };

  return rotation;
}

function _default(rotate) {
  rotate = rotateRadians(rotate[0] * _math.radians, rotate[1] * _math.radians, rotate.length > 2 ? rotate[2] * _math.radians : 0);

  function forward(coordinates) {
    coordinates = rotate(coordinates[0] * _math.radians, coordinates[1] * _math.radians);
    return coordinates[0] *= _math.degrees, coordinates[1] *= _math.degrees, coordinates;
  }

  forward.invert = function (coordinates) {
    coordinates = rotate.invert(coordinates[0] * _math.radians, coordinates[1] * _math.radians);
    return coordinates[0] *= _math.degrees, coordinates[1] *= _math.degrees, coordinates;
  };

  return forward;
}
},{"./compose":"hCea","./math":"sEgP"}],"dbGM":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.circleStream = circleStream;
exports.default = _default;

var _cartesian = require("./cartesian");

var _constant = _interopRequireDefault(require("./constant"));

var _math = require("./math");

var _rotation = require("./rotation");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Generates a circle centered at [0°, 0°], with a given radius and precision.
function circleStream(stream, radius, delta, direction, t0, t1) {
  if (!delta) return;
  var cosRadius = (0, _math.cos)(radius),
      sinRadius = (0, _math.sin)(radius),
      step = direction * delta;

  if (t0 == null) {
    t0 = radius + direction * _math.tau;
    t1 = radius - step / 2;
  } else {
    t0 = circleRadius(cosRadius, t0);
    t1 = circleRadius(cosRadius, t1);
    if (direction > 0 ? t0 < t1 : t0 > t1) t0 += direction * _math.tau;
  }

  for (var point, t = t0; direction > 0 ? t > t1 : t < t1; t -= step) {
    point = (0, _cartesian.spherical)([cosRadius, -sinRadius * (0, _math.cos)(t), -sinRadius * (0, _math.sin)(t)]);
    stream.point(point[0], point[1]);
  }
} // Returns the signed angle of a cartesian point relative to [cosRadius, 0, 0].


function circleRadius(cosRadius, point) {
  point = (0, _cartesian.cartesian)(point), point[0] -= cosRadius;
  (0, _cartesian.cartesianNormalizeInPlace)(point);
  var radius = (0, _math.acos)(-point[1]);
  return ((-point[2] < 0 ? -radius : radius) + _math.tau - _math.epsilon) % _math.tau;
}

function _default() {
  var center = (0, _constant.default)([0, 0]),
      radius = (0, _constant.default)(90),
      precision = (0, _constant.default)(6),
      ring,
      rotate,
      stream = {
    point: point
  };

  function point(x, y) {
    ring.push(x = rotate(x, y));
    x[0] *= _math.degrees, x[1] *= _math.degrees;
  }

  function circle() {
    var c = center.apply(this, arguments),
        r = radius.apply(this, arguments) * _math.radians,
        p = precision.apply(this, arguments) * _math.radians;

    ring = [];
    rotate = (0, _rotation.rotateRadians)(-c[0] * _math.radians, -c[1] * _math.radians, 0).invert;
    circleStream(stream, r, p, 1);
    c = {
      type: "Polygon",
      coordinates: [ring]
    };
    ring = rotate = null;
    return c;
  }

  circle.center = function (_) {
    return arguments.length ? (center = typeof _ === "function" ? _ : (0, _constant.default)([+_[0], +_[1]]), circle) : center;
  };

  circle.radius = function (_) {
    return arguments.length ? (radius = typeof _ === "function" ? _ : (0, _constant.default)(+_), circle) : radius;
  };

  circle.precision = function (_) {
    return arguments.length ? (precision = typeof _ === "function" ? _ : (0, _constant.default)(+_), circle) : precision;
  };

  return circle;
}
},{"./cartesian":"rFMq","./constant":"OY6d","./math":"sEgP","./rotation":"KwdP"}],"VrlK":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _noop = _interopRequireDefault(require("../noop"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default() {
  var lines = [],
      line;
  return {
    point: function (x, y) {
      line.push([x, y]);
    },
    lineStart: function () {
      lines.push(line = []);
    },
    lineEnd: _noop.default,
    rejoin: function () {
      if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));
    },
    result: function () {
      var result = lines;
      lines = [];
      line = null;
      return result;
    }
  };
}
},{"../noop":"UPwg"}],"j4Ms":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _math = require("./math");

function _default(a, b) {
  return (0, _math.abs)(a[0] - b[0]) < _math.epsilon && (0, _math.abs)(a[1] - b[1]) < _math.epsilon;
}
},{"./math":"sEgP"}],"nqrN":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _pointEqual = _interopRequireDefault(require("../pointEqual"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function Intersection(point, points, other, entry) {
  this.x = point;
  this.z = points;
  this.o = other; // another intersection

  this.e = entry; // is an entry?

  this.v = false; // visited

  this.n = this.p = null; // next & previous
} // A generalized polygon clipping algorithm: given a polygon that has been cut
// into its visible line segments, and rejoins the segments by interpolating
// along the clip edge.


function _default(segments, compareIntersection, startInside, interpolate, stream) {
  var subject = [],
      clip = [],
      i,
      n;
  segments.forEach(function (segment) {
    if ((n = segment.length - 1) <= 0) return;
    var n,
        p0 = segment[0],
        p1 = segment[n],
        x; // If the first and last points of a segment are coincident, then treat as a
    // closed ring. TODO if all rings are closed, then the winding order of the
    // exterior ring should be checked.

    if ((0, _pointEqual.default)(p0, p1)) {
      stream.lineStart();

      for (i = 0; i < n; ++i) stream.point((p0 = segment[i])[0], p0[1]);

      stream.lineEnd();
      return;
    }

    subject.push(x = new Intersection(p0, segment, null, true));
    clip.push(x.o = new Intersection(p0, null, x, false));
    subject.push(x = new Intersection(p1, segment, null, false));
    clip.push(x.o = new Intersection(p1, null, x, true));
  });
  if (!subject.length) return;
  clip.sort(compareIntersection);
  link(subject);
  link(clip);

  for (i = 0, n = clip.length; i < n; ++i) {
    clip[i].e = startInside = !startInside;
  }

  var start = subject[0],
      points,
      point;

  while (1) {
    // Find first unvisited intersection.
    var current = start,
        isSubject = true;

    while (current.v) if ((current = current.n) === start) return;

    points = current.z;
    stream.lineStart();

    do {
      current.v = current.o.v = true;

      if (current.e) {
        if (isSubject) {
          for (i = 0, n = points.length; i < n; ++i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.n.x, 1, stream);
        }

        current = current.n;
      } else {
        if (isSubject) {
          points = current.p.z;

          for (i = points.length - 1; i >= 0; --i) stream.point((point = points[i])[0], point[1]);
        } else {
          interpolate(current.x, current.p.x, -1, stream);
        }

        current = current.p;
      }

      current = current.o;
      points = current.z;
      isSubject = !isSubject;
    } while (!current.v);

    stream.lineEnd();
  }
}

function link(array) {
  if (!(n = array.length)) return;
  var n,
      i = 0,
      a = array[0],
      b;

  while (++i < n) {
    a.n = b = array[i];
    b.p = a;
    a = b;
  }

  a.n = b = array[0];
  b.p = a;
}
},{"../pointEqual":"j4Ms"}],"Cmis":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _adder = _interopRequireDefault(require("./adder"));

var _cartesian = require("./cartesian");

var _math = require("./math");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var sum = (0, _adder.default)();

function _default(polygon, point) {
  var lambda = point[0],
      phi = point[1],
      normal = [(0, _math.sin)(lambda), -(0, _math.cos)(lambda), 0],
      angle = 0,
      winding = 0;
  sum.reset();

  for (var i = 0, n = polygon.length; i < n; ++i) {
    if (!(m = (ring = polygon[i]).length)) continue;
    var ring,
        m,
        point0 = ring[m - 1],
        lambda0 = point0[0],
        phi0 = point0[1] / 2 + _math.quarterPi,
        sinPhi0 = (0, _math.sin)(phi0),
        cosPhi0 = (0, _math.cos)(phi0);

    for (var j = 0; j < m; ++j, lambda0 = lambda1, sinPhi0 = sinPhi1, cosPhi0 = cosPhi1, point0 = point1) {
      var point1 = ring[j],
          lambda1 = point1[0],
          phi1 = point1[1] / 2 + _math.quarterPi,
          sinPhi1 = (0, _math.sin)(phi1),
          cosPhi1 = (0, _math.cos)(phi1),
          delta = lambda1 - lambda0,
          sign = delta >= 0 ? 1 : -1,
          absDelta = sign * delta,
          antimeridian = absDelta > _math.pi,
          k = sinPhi0 * sinPhi1;
      sum.add((0, _math.atan2)(k * sign * (0, _math.sin)(absDelta), cosPhi0 * cosPhi1 + k * (0, _math.cos)(absDelta)));
      angle += antimeridian ? delta + sign * _math.tau : delta; // Are the longitudes either side of the point’s meridian (lambda),
      // and are the latitudes smaller than the parallel (phi)?

      if (antimeridian ^ lambda0 >= lambda ^ lambda1 >= lambda) {
        var arc = (0, _cartesian.cartesianCross)((0, _cartesian.cartesian)(point0), (0, _cartesian.cartesian)(point1));
        (0, _cartesian.cartesianNormalizeInPlace)(arc);
        var intersection = (0, _cartesian.cartesianCross)(normal, arc);
        (0, _cartesian.cartesianNormalizeInPlace)(intersection);
        var phiArc = (antimeridian ^ delta >= 0 ? -1 : 1) * (0, _math.asin)(intersection[2]);

        if (phi > phiArc || phi === phiArc && (arc[0] || arc[1])) {
          winding += antimeridian ^ delta >= 0 ? 1 : -1;
        }
      }
    }
  } // First, determine whether the South pole is inside or outside:
  //
  // It is inside if:
  // * the polygon winds around it in a clockwise direction.
  // * the polygon does not (cumulatively) wind around it, but has a negative
  //   (counter-clockwise) area.
  //
  // Second, count the (signed) number of times a segment crosses a lambda
  // from the point to the South pole.  If it is zero, then the point is the
  // same side as the South pole.


  return (angle < -_math.epsilon || angle < _math.epsilon && sum < -_math.epsilon) ^ winding & 1;
}
},{"./adder":"GlqK","./cartesian":"rFMq","./math":"sEgP"}],"bbiM":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _buffer = _interopRequireDefault(require("./buffer"));

var _rejoin = _interopRequireDefault(require("./rejoin"));

var _math = require("../math");

var _polygonContains = _interopRequireDefault(require("../polygonContains"));

var _d3Array = require("d3-array");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(pointVisible, clipLine, interpolate, start) {
  return function (sink) {
    var line = clipLine(sink),
        ringBuffer = (0, _buffer.default)(),
        ringSink = clipLine(ringBuffer),
        polygonStarted = false,
        polygon,
        segments,
        ring;
    var clip = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function () {
        clip.point = pointRing;
        clip.lineStart = ringStart;
        clip.lineEnd = ringEnd;
        segments = [];
        polygon = [];
      },
      polygonEnd: function () {
        clip.point = point;
        clip.lineStart = lineStart;
        clip.lineEnd = lineEnd;
        segments = (0, _d3Array.merge)(segments);
        var startInside = (0, _polygonContains.default)(polygon, start);

        if (segments.length) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          (0, _rejoin.default)(segments, compareIntersection, startInside, interpolate, sink);
        } else if (startInside) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();
          interpolate(null, null, 1, sink);
          sink.lineEnd();
        }

        if (polygonStarted) sink.polygonEnd(), polygonStarted = false;
        segments = polygon = null;
      },
      sphere: function () {
        sink.polygonStart();
        sink.lineStart();
        interpolate(null, null, 1, sink);
        sink.lineEnd();
        sink.polygonEnd();
      }
    };

    function point(lambda, phi) {
      if (pointVisible(lambda, phi)) sink.point(lambda, phi);
    }

    function pointLine(lambda, phi) {
      line.point(lambda, phi);
    }

    function lineStart() {
      clip.point = pointLine;
      line.lineStart();
    }

    function lineEnd() {
      clip.point = point;
      line.lineEnd();
    }

    function pointRing(lambda, phi) {
      ring.push([lambda, phi]);
      ringSink.point(lambda, phi);
    }

    function ringStart() {
      ringSink.lineStart();
      ring = [];
    }

    function ringEnd() {
      pointRing(ring[0][0], ring[0][1]);
      ringSink.lineEnd();
      var clean = ringSink.clean(),
          ringSegments = ringBuffer.result(),
          i,
          n = ringSegments.length,
          m,
          segment,
          point;
      ring.pop();
      polygon.push(ring);
      ring = null;
      if (!n) return; // No intersections.

      if (clean & 1) {
        segment = ringSegments[0];

        if ((m = segment.length - 1) > 0) {
          if (!polygonStarted) sink.polygonStart(), polygonStarted = true;
          sink.lineStart();

          for (i = 0; i < m; ++i) sink.point((point = segment[i])[0], point[1]);

          sink.lineEnd();
        }

        return;
      } // Rejoin connected segments.
      // TODO reuse ringBuffer.rejoin()?


      if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));
      segments.push(ringSegments.filter(validSegment));
    }

    return clip;
  };
}

function validSegment(segment) {
  return segment.length > 1;
} // Intersections are sorted along the clip edge. For both antimeridian cutting
// and circle clipping, the same comparison is used.


function compareIntersection(a, b) {
  return ((a = a.x)[0] < 0 ? a[1] - _math.halfPi - _math.epsilon : _math.halfPi - a[1]) - ((b = b.x)[0] < 0 ? b[1] - _math.halfPi - _math.epsilon : _math.halfPi - b[1]);
}
},{"./buffer":"VrlK","./rejoin":"nqrN","../math":"sEgP","../polygonContains":"Cmis","d3-array":"ybfZ"}],"CWnN":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _index = _interopRequireDefault(require("./index"));

var _math = require("../math");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = (0, _index.default)(function () {
  return true;
}, clipAntimeridianLine, clipAntimeridianInterpolate, [-_math.pi, -_math.halfPi]); // Takes a line and cuts into visible segments. Return values: 0 - there were
// intersections or the line was empty; 1 - no intersections; 2 - there were
// intersections, and the first and last segments should be rejoined.


exports.default = _default;

function clipAntimeridianLine(stream) {
  var lambda0 = NaN,
      phi0 = NaN,
      sign0 = NaN,
      clean; // no intersections

  return {
    lineStart: function () {
      stream.lineStart();
      clean = 1;
    },
    point: function (lambda1, phi1) {
      var sign1 = lambda1 > 0 ? _math.pi : -_math.pi,
          delta = (0, _math.abs)(lambda1 - lambda0);

      if ((0, _math.abs)(delta - _math.pi) < _math.epsilon) {
        // line crosses a pole
        stream.point(lambda0, phi0 = (phi0 + phi1) / 2 > 0 ? _math.halfPi : -_math.halfPi);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        stream.point(lambda1, phi0);
        clean = 0;
      } else if (sign0 !== sign1 && delta >= _math.pi) {
        // line crosses antimeridian
        if ((0, _math.abs)(lambda0 - sign0) < _math.epsilon) lambda0 -= sign0 * _math.epsilon; // handle degeneracies

        if ((0, _math.abs)(lambda1 - sign1) < _math.epsilon) lambda1 -= sign1 * _math.epsilon;
        phi0 = clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1);
        stream.point(sign0, phi0);
        stream.lineEnd();
        stream.lineStart();
        stream.point(sign1, phi0);
        clean = 0;
      }

      stream.point(lambda0 = lambda1, phi0 = phi1);
      sign0 = sign1;
    },
    lineEnd: function () {
      stream.lineEnd();
      lambda0 = phi0 = NaN;
    },
    clean: function () {
      return 2 - clean; // if intersections, rejoin first and last segments
    }
  };
}

function clipAntimeridianIntersect(lambda0, phi0, lambda1, phi1) {
  var cosPhi0,
      cosPhi1,
      sinLambda0Lambda1 = (0, _math.sin)(lambda0 - lambda1);
  return (0, _math.abs)(sinLambda0Lambda1) > _math.epsilon ? (0, _math.atan)(((0, _math.sin)(phi0) * (cosPhi1 = (0, _math.cos)(phi1)) * (0, _math.sin)(lambda1) - (0, _math.sin)(phi1) * (cosPhi0 = (0, _math.cos)(phi0)) * (0, _math.sin)(lambda0)) / (cosPhi0 * cosPhi1 * sinLambda0Lambda1)) : (phi0 + phi1) / 2;
}

function clipAntimeridianInterpolate(from, to, direction, stream) {
  var phi;

  if (from == null) {
    phi = direction * _math.halfPi;
    stream.point(-_math.pi, phi);
    stream.point(0, phi);
    stream.point(_math.pi, phi);
    stream.point(_math.pi, 0);
    stream.point(_math.pi, -phi);
    stream.point(0, -phi);
    stream.point(-_math.pi, -phi);
    stream.point(-_math.pi, 0);
    stream.point(-_math.pi, phi);
  } else if ((0, _math.abs)(from[0] - to[0]) > _math.epsilon) {
    var lambda = from[0] < to[0] ? _math.pi : -_math.pi;
    phi = direction * lambda / 2;
    stream.point(-lambda, phi);
    stream.point(0, phi);
    stream.point(lambda, phi);
  } else {
    stream.point(to[0], to[1]);
  }
}
},{"./index":"bbiM","../math":"sEgP"}],"uulM":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _cartesian = require("../cartesian");

var _circle = require("../circle");

var _math = require("../math");

var _pointEqual = _interopRequireDefault(require("../pointEqual"));

var _index = _interopRequireDefault(require("./index"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(radius) {
  var cr = (0, _math.cos)(radius),
      delta = 6 * _math.radians,
      smallRadius = cr > 0,
      notHemisphere = (0, _math.abs)(cr) > _math.epsilon; // TODO optimise for this common case


  function interpolate(from, to, direction, stream) {
    (0, _circle.circleStream)(stream, radius, delta, direction, from, to);
  }

  function visible(lambda, phi) {
    return (0, _math.cos)(lambda) * (0, _math.cos)(phi) > cr;
  } // Takes a line and cuts into visible segments. Return values used for polygon
  // clipping: 0 - there were intersections or the line was empty; 1 - no
  // intersections 2 - there were intersections, and the first and last segments
  // should be rejoined.


  function clipLine(stream) {
    var point0, // previous point
    c0, // code for previous point
    v0, // visibility of previous point
    v00, // visibility of first point
    clean; // no intersections

    return {
      lineStart: function () {
        v00 = v0 = false;
        clean = 1;
      },
      point: function (lambda, phi) {
        var point1 = [lambda, phi],
            point2,
            v = visible(lambda, phi),
            c = smallRadius ? v ? 0 : code(lambda, phi) : v ? code(lambda + (lambda < 0 ? _math.pi : -_math.pi), phi) : 0;
        if (!point0 && (v00 = v0 = v)) stream.lineStart(); // Handle degeneracies.
        // TODO ignore if not clipping polygons.

        if (v !== v0) {
          point2 = intersect(point0, point1);

          if (!point2 || (0, _pointEqual.default)(point0, point2) || (0, _pointEqual.default)(point1, point2)) {
            point1[0] += _math.epsilon;
            point1[1] += _math.epsilon;
            v = visible(point1[0], point1[1]);
          }
        }

        if (v !== v0) {
          clean = 0;

          if (v) {
            // outside going in
            stream.lineStart();
            point2 = intersect(point1, point0);
            stream.point(point2[0], point2[1]);
          } else {
            // inside going out
            point2 = intersect(point0, point1);
            stream.point(point2[0], point2[1]);
            stream.lineEnd();
          }

          point0 = point2;
        } else if (notHemisphere && point0 && smallRadius ^ v) {
          var t; // If the codes for two points are different, or are both zero,
          // and there this segment intersects with the small circle.

          if (!(c & c0) && (t = intersect(point1, point0, true))) {
            clean = 0;

            if (smallRadius) {
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
            } else {
              stream.point(t[1][0], t[1][1]);
              stream.lineEnd();
              stream.lineStart();
              stream.point(t[0][0], t[0][1]);
            }
          }
        }

        if (v && (!point0 || !(0, _pointEqual.default)(point0, point1))) {
          stream.point(point1[0], point1[1]);
        }

        point0 = point1, v0 = v, c0 = c;
      },
      lineEnd: function () {
        if (v0) stream.lineEnd();
        point0 = null;
      },
      // Rejoin first and last segments if there were intersections and the first
      // and last points were visible.
      clean: function () {
        return clean | (v00 && v0) << 1;
      }
    };
  } // Intersects the great circle between a and b with the clip circle.


  function intersect(a, b, two) {
    var pa = (0, _cartesian.cartesian)(a),
        pb = (0, _cartesian.cartesian)(b); // We have two planes, n1.p = d1 and n2.p = d2.
    // Find intersection line p(t) = c1 n1 + c2 n2 + t (n1 ⨯ n2).

    var n1 = [1, 0, 0],
        // normal
    n2 = (0, _cartesian.cartesianCross)(pa, pb),
        n2n2 = (0, _cartesian.cartesianDot)(n2, n2),
        n1n2 = n2[0],
        // cartesianDot(n1, n2),
    determinant = n2n2 - n1n2 * n1n2; // Two polar points.

    if (!determinant) return !two && a;
    var c1 = cr * n2n2 / determinant,
        c2 = -cr * n1n2 / determinant,
        n1xn2 = (0, _cartesian.cartesianCross)(n1, n2),
        A = (0, _cartesian.cartesianScale)(n1, c1),
        B = (0, _cartesian.cartesianScale)(n2, c2);
    (0, _cartesian.cartesianAddInPlace)(A, B); // Solve |p(t)|^2 = 1.

    var u = n1xn2,
        w = (0, _cartesian.cartesianDot)(A, u),
        uu = (0, _cartesian.cartesianDot)(u, u),
        t2 = w * w - uu * ((0, _cartesian.cartesianDot)(A, A) - 1);
    if (t2 < 0) return;
    var t = (0, _math.sqrt)(t2),
        q = (0, _cartesian.cartesianScale)(u, (-w - t) / uu);
    (0, _cartesian.cartesianAddInPlace)(q, A);
    q = (0, _cartesian.spherical)(q);
    if (!two) return q; // Two intersection points.

    var lambda0 = a[0],
        lambda1 = b[0],
        phi0 = a[1],
        phi1 = b[1],
        z;
    if (lambda1 < lambda0) z = lambda0, lambda0 = lambda1, lambda1 = z;

    var delta = lambda1 - lambda0,
        polar = (0, _math.abs)(delta - _math.pi) < _math.epsilon,
        meridian = polar || delta < _math.epsilon;

    if (!polar && phi1 < phi0) z = phi0, phi0 = phi1, phi1 = z; // Check that the first point is between a and b.

    if (meridian ? polar ? phi0 + phi1 > 0 ^ q[1] < ((0, _math.abs)(q[0] - lambda0) < _math.epsilon ? phi0 : phi1) : phi0 <= q[1] && q[1] <= phi1 : delta > _math.pi ^ (lambda0 <= q[0] && q[0] <= lambda1)) {
      var q1 = (0, _cartesian.cartesianScale)(u, (-w + t) / uu);
      (0, _cartesian.cartesianAddInPlace)(q1, A);
      return [q, (0, _cartesian.spherical)(q1)];
    }
  } // Generates a 4-bit vector representing the location of a point relative to
  // the small circle's bounding box.


  function code(lambda, phi) {
    var r = smallRadius ? radius : _math.pi - radius,
        code = 0;
    if (lambda < -r) code |= 1; // left
    else if (lambda > r) code |= 2; // right

    if (phi < -r) code |= 4; // below
    else if (phi > r) code |= 8; // above

    return code;
  }

  return (0, _index.default)(visible, clipLine, interpolate, smallRadius ? [0, -radius] : [-_math.pi, radius - _math.pi]);
}
},{"../cartesian":"rFMq","../circle":"dbGM","../math":"sEgP","../pointEqual":"j4Ms","./index":"bbiM"}],"RhqQ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(a, b, x0, y0, x1, y1) {
  var ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;
  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;

  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;

  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;

  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;

  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (t0 > 0) a[0] = ax + t0 * dx, a[1] = ay + t0 * dy;
  if (t1 < 1) b[0] = ax + t1 * dx, b[1] = ay + t1 * dy;
  return true;
}
},{}],"E6SH":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = clipRectangle;

var _math = require("../math");

var _buffer = _interopRequireDefault(require("./buffer"));

var _line = _interopRequireDefault(require("./line"));

var _rejoin = _interopRequireDefault(require("./rejoin"));

var _d3Array = require("d3-array");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var clipMax = 1e9,
    clipMin = -clipMax; // TODO Use d3-polygon’s polygonContains here for the ring check?
// TODO Eliminate duplicate buffering in clipBuffer and polygon.push?

function clipRectangle(x0, y0, x1, y1) {
  function visible(x, y) {
    return x0 <= x && x <= x1 && y0 <= y && y <= y1;
  }

  function interpolate(from, to, direction, stream) {
    var a = 0,
        a1 = 0;

    if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoint(from, to) < 0 ^ direction > 0) {
      do stream.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0); while ((a = (a + direction + 4) % 4) !== a1);
    } else {
      stream.point(to[0], to[1]);
    }
  }

  function corner(p, direction) {
    return (0, _math.abs)(p[0] - x0) < _math.epsilon ? direction > 0 ? 0 : 3 : (0, _math.abs)(p[0] - x1) < _math.epsilon ? direction > 0 ? 2 : 1 : (0, _math.abs)(p[1] - y0) < _math.epsilon ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2; // abs(p[1] - y1) < epsilon
  }

  function compareIntersection(a, b) {
    return comparePoint(a.x, b.x);
  }

  function comparePoint(a, b) {
    var ca = corner(a, 1),
        cb = corner(b, 1);
    return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];
  }

  return function (stream) {
    var activeStream = stream,
        bufferStream = (0, _buffer.default)(),
        segments,
        polygon,
        ring,
        x__,
        y__,
        v__,
        // first point
    x_,
        y_,
        v_,
        // previous point
    first,
        clean;
    var clipStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: polygonStart,
      polygonEnd: polygonEnd
    };

    function point(x, y) {
      if (visible(x, y)) activeStream.point(x, y);
    }

    function polygonInside() {
      var winding = 0;

      for (var i = 0, n = polygon.length; i < n; ++i) {
        for (var ring = polygon[i], j = 1, m = ring.length, point = ring[0], a0, a1, b0 = point[0], b1 = point[1]; j < m; ++j) {
          a0 = b0, a1 = b1, point = ring[j], b0 = point[0], b1 = point[1];

          if (a1 <= y1) {
            if (b1 > y1 && (b0 - a0) * (y1 - a1) > (b1 - a1) * (x0 - a0)) ++winding;
          } else {
            if (b1 <= y1 && (b0 - a0) * (y1 - a1) < (b1 - a1) * (x0 - a0)) --winding;
          }
        }
      }

      return winding;
    } // Buffer geometry within a polygon and then clip it en masse.


    function polygonStart() {
      activeStream = bufferStream, segments = [], polygon = [], clean = true;
    }

    function polygonEnd() {
      var startInside = polygonInside(),
          cleanInside = clean && startInside,
          visible = (segments = (0, _d3Array.merge)(segments)).length;

      if (cleanInside || visible) {
        stream.polygonStart();

        if (cleanInside) {
          stream.lineStart();
          interpolate(null, null, 1, stream);
          stream.lineEnd();
        }

        if (visible) {
          (0, _rejoin.default)(segments, compareIntersection, startInside, interpolate, stream);
        }

        stream.polygonEnd();
      }

      activeStream = stream, segments = polygon = ring = null;
    }

    function lineStart() {
      clipStream.point = linePoint;
      if (polygon) polygon.push(ring = []);
      first = true;
      v_ = false;
      x_ = y_ = NaN;
    } // TODO rather than special-case polygons, simply handle them separately.
    // Ideally, coincident intersection points should be jittered to avoid
    // clipping issues.


    function lineEnd() {
      if (segments) {
        linePoint(x__, y__);
        if (v__ && v_) bufferStream.rejoin();
        segments.push(bufferStream.result());
      }

      clipStream.point = point;
      if (v_) activeStream.lineEnd();
    }

    function linePoint(x, y) {
      var v = visible(x, y);
      if (polygon) ring.push([x, y]);

      if (first) {
        x__ = x, y__ = y, v__ = v;
        first = false;

        if (v) {
          activeStream.lineStart();
          activeStream.point(x, y);
        }
      } else {
        if (v && v_) activeStream.point(x, y);else {
          var a = [x_ = Math.max(clipMin, Math.min(clipMax, x_)), y_ = Math.max(clipMin, Math.min(clipMax, y_))],
              b = [x = Math.max(clipMin, Math.min(clipMax, x)), y = Math.max(clipMin, Math.min(clipMax, y))];

          if ((0, _line.default)(a, b, x0, y0, x1, y1)) {
            if (!v_) {
              activeStream.lineStart();
              activeStream.point(a[0], a[1]);
            }

            activeStream.point(b[0], b[1]);
            if (!v) activeStream.lineEnd();
            clean = false;
          } else if (v) {
            activeStream.lineStart();
            activeStream.point(x, y);
            clean = false;
          }
        }
      }

      x_ = x, y_ = y, v_ = v;
    }

    return clipStream;
  };
}
},{"../math":"sEgP","./buffer":"VrlK","./line":"RhqQ","./rejoin":"nqrN","d3-array":"ybfZ"}],"Pttt":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _rectangle = _interopRequireDefault(require("./rectangle"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default() {
  var x0 = 0,
      y0 = 0,
      x1 = 960,
      y1 = 500,
      cache,
      cacheStream,
      clip;
  return clip = {
    stream: function (stream) {
      return cache && cacheStream === stream ? cache : cache = (0, _rectangle.default)(x0, y0, x1, y1)(cacheStream = stream);
    },
    extent: function (_) {
      return arguments.length ? (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1], cache = cacheStream = null, clip) : [[x0, y0], [x1, y1]];
    }
  };
}
},{"./rectangle":"E6SH"}],"rgN9":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _adder = _interopRequireDefault(require("./adder"));

var _math = require("./math");

var _noop = _interopRequireDefault(require("./noop"));

var _stream = _interopRequireDefault(require("./stream"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var lengthSum = (0, _adder.default)(),
    lambda0,
    sinPhi0,
    cosPhi0;
var lengthStream = {
  sphere: _noop.default,
  point: _noop.default,
  lineStart: lengthLineStart,
  lineEnd: _noop.default,
  polygonStart: _noop.default,
  polygonEnd: _noop.default
};

function lengthLineStart() {
  lengthStream.point = lengthPointFirst;
  lengthStream.lineEnd = lengthLineEnd;
}

function lengthLineEnd() {
  lengthStream.point = lengthStream.lineEnd = _noop.default;
}

function lengthPointFirst(lambda, phi) {
  lambda *= _math.radians, phi *= _math.radians;
  lambda0 = lambda, sinPhi0 = (0, _math.sin)(phi), cosPhi0 = (0, _math.cos)(phi);
  lengthStream.point = lengthPoint;
}

function lengthPoint(lambda, phi) {
  lambda *= _math.radians, phi *= _math.radians;
  var sinPhi = (0, _math.sin)(phi),
      cosPhi = (0, _math.cos)(phi),
      delta = (0, _math.abs)(lambda - lambda0),
      cosDelta = (0, _math.cos)(delta),
      sinDelta = (0, _math.sin)(delta),
      x = cosPhi * sinDelta,
      y = cosPhi0 * sinPhi - sinPhi0 * cosPhi * cosDelta,
      z = sinPhi0 * sinPhi + cosPhi0 * cosPhi * cosDelta;
  lengthSum.add((0, _math.atan2)((0, _math.sqrt)(x * x + y * y), z));
  lambda0 = lambda, sinPhi0 = sinPhi, cosPhi0 = cosPhi;
}

function _default(object) {
  lengthSum.reset();
  (0, _stream.default)(object, lengthStream);
  return +lengthSum;
}
},{"./adder":"GlqK","./math":"sEgP","./noop":"UPwg","./stream":"XBFK"}],"IoFW":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _length = _interopRequireDefault(require("./length"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var coordinates = [null, null],
    object = {
  type: "LineString",
  coordinates: coordinates
};

function _default(a, b) {
  coordinates[0] = a;
  coordinates[1] = b;
  return (0, _length.default)(object);
}
},{"./length":"rgN9"}],"bl00":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _polygonContains = _interopRequireDefault(require("./polygonContains"));

var _distance = _interopRequireDefault(require("./distance"));

var _math = require("./math");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var containsObjectType = {
  Feature: function (object, point) {
    return containsGeometry(object.geometry, point);
  },
  FeatureCollection: function (object, point) {
    var features = object.features,
        i = -1,
        n = features.length;

    while (++i < n) if (containsGeometry(features[i].geometry, point)) return true;

    return false;
  }
};
var containsGeometryType = {
  Sphere: function () {
    return true;
  },
  Point: function (object, point) {
    return containsPoint(object.coordinates, point);
  },
  MultiPoint: function (object, point) {
    var coordinates = object.coordinates,
        i = -1,
        n = coordinates.length;

    while (++i < n) if (containsPoint(coordinates[i], point)) return true;

    return false;
  },
  LineString: function (object, point) {
    return containsLine(object.coordinates, point);
  },
  MultiLineString: function (object, point) {
    var coordinates = object.coordinates,
        i = -1,
        n = coordinates.length;

    while (++i < n) if (containsLine(coordinates[i], point)) return true;

    return false;
  },
  Polygon: function (object, point) {
    return containsPolygon(object.coordinates, point);
  },
  MultiPolygon: function (object, point) {
    var coordinates = object.coordinates,
        i = -1,
        n = coordinates.length;

    while (++i < n) if (containsPolygon(coordinates[i], point)) return true;

    return false;
  },
  GeometryCollection: function (object, point) {
    var geometries = object.geometries,
        i = -1,
        n = geometries.length;

    while (++i < n) if (containsGeometry(geometries[i], point)) return true;

    return false;
  }
};

function containsGeometry(geometry, point) {
  return geometry && containsGeometryType.hasOwnProperty(geometry.type) ? containsGeometryType[geometry.type](geometry, point) : false;
}

function containsPoint(coordinates, point) {
  return (0, _distance.default)(coordinates, point) === 0;
}

function containsLine(coordinates, point) {
  var ab = (0, _distance.default)(coordinates[0], coordinates[1]),
      ao = (0, _distance.default)(coordinates[0], point),
      ob = (0, _distance.default)(point, coordinates[1]);
  return ao + ob <= ab + _math.epsilon;
}

function containsPolygon(coordinates, point) {
  return !!(0, _polygonContains.default)(coordinates.map(ringRadians), pointRadians(point));
}

function ringRadians(ring) {
  return ring = ring.map(pointRadians), ring.pop(), ring;
}

function pointRadians(point) {
  return [point[0] * _math.radians, point[1] * _math.radians];
}

function _default(object, point) {
  return (object && containsObjectType.hasOwnProperty(object.type) ? containsObjectType[object.type] : containsGeometry)(object, point);
}
},{"./polygonContains":"Cmis","./distance":"IoFW","./math":"sEgP"}],"fWgv":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = graticule;
exports.graticule10 = graticule10;

var _d3Array = require("d3-array");

var _math = require("./math");

function graticuleX(y0, y1, dy) {
  var y = (0, _d3Array.range)(y0, y1 - _math.epsilon, dy).concat(y1);
  return function (x) {
    return y.map(function (y) {
      return [x, y];
    });
  };
}

function graticuleY(x0, x1, dx) {
  var x = (0, _d3Array.range)(x0, x1 - _math.epsilon, dx).concat(x1);
  return function (y) {
    return x.map(function (x) {
      return [x, y];
    });
  };
}

function graticule() {
  var x1,
      x0,
      X1,
      X0,
      y1,
      y0,
      Y1,
      Y0,
      dx = 10,
      dy = dx,
      DX = 90,
      DY = 360,
      x,
      y,
      X,
      Y,
      precision = 2.5;

  function graticule() {
    return {
      type: "MultiLineString",
      coordinates: lines()
    };
  }

  function lines() {
    return (0, _d3Array.range)((0, _math.ceil)(X0 / DX) * DX, X1, DX).map(X).concat((0, _d3Array.range)((0, _math.ceil)(Y0 / DY) * DY, Y1, DY).map(Y)).concat((0, _d3Array.range)((0, _math.ceil)(x0 / dx) * dx, x1, dx).filter(function (x) {
      return (0, _math.abs)(x % DX) > _math.epsilon;
    }).map(x)).concat((0, _d3Array.range)((0, _math.ceil)(y0 / dy) * dy, y1, dy).filter(function (y) {
      return (0, _math.abs)(y % DY) > _math.epsilon;
    }).map(y));
  }

  graticule.lines = function () {
    return lines().map(function (coordinates) {
      return {
        type: "LineString",
        coordinates: coordinates
      };
    });
  };

  graticule.outline = function () {
    return {
      type: "Polygon",
      coordinates: [X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1))]
    };
  };

  graticule.extent = function (_) {
    if (!arguments.length) return graticule.extentMinor();
    return graticule.extentMajor(_).extentMinor(_);
  };

  graticule.extentMajor = function (_) {
    if (!arguments.length) return [[X0, Y0], [X1, Y1]];
    X0 = +_[0][0], X1 = +_[1][0];
    Y0 = +_[0][1], Y1 = +_[1][1];
    if (X0 > X1) _ = X0, X0 = X1, X1 = _;
    if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;
    return graticule.precision(precision);
  };

  graticule.extentMinor = function (_) {
    if (!arguments.length) return [[x0, y0], [x1, y1]];
    x0 = +_[0][0], x1 = +_[1][0];
    y0 = +_[0][1], y1 = +_[1][1];
    if (x0 > x1) _ = x0, x0 = x1, x1 = _;
    if (y0 > y1) _ = y0, y0 = y1, y1 = _;
    return graticule.precision(precision);
  };

  graticule.step = function (_) {
    if (!arguments.length) return graticule.stepMinor();
    return graticule.stepMajor(_).stepMinor(_);
  };

  graticule.stepMajor = function (_) {
    if (!arguments.length) return [DX, DY];
    DX = +_[0], DY = +_[1];
    return graticule;
  };

  graticule.stepMinor = function (_) {
    if (!arguments.length) return [dx, dy];
    dx = +_[0], dy = +_[1];
    return graticule;
  };

  graticule.precision = function (_) {
    if (!arguments.length) return precision;
    precision = +_;
    x = graticuleX(y0, y1, 90);
    y = graticuleY(x0, x1, precision);
    X = graticuleX(Y0, Y1, 90);
    Y = graticuleY(X0, X1, precision);
    return graticule;
  };

  return graticule.extentMajor([[-180, -90 + _math.epsilon], [180, 90 - _math.epsilon]]).extentMinor([[-180, -80 - _math.epsilon], [180, 80 + _math.epsilon]]);
}

function graticule10() {
  return graticule()();
}
},{"d3-array":"ybfZ","./math":"sEgP"}],"PyvU":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _math = require("./math");

function _default(a, b) {
  var x0 = a[0] * _math.radians,
      y0 = a[1] * _math.radians,
      x1 = b[0] * _math.radians,
      y1 = b[1] * _math.radians,
      cy0 = (0, _math.cos)(y0),
      sy0 = (0, _math.sin)(y0),
      cy1 = (0, _math.cos)(y1),
      sy1 = (0, _math.sin)(y1),
      kx0 = cy0 * (0, _math.cos)(x0),
      ky0 = cy0 * (0, _math.sin)(x0),
      kx1 = cy1 * (0, _math.cos)(x1),
      ky1 = cy1 * (0, _math.sin)(x1),
      d = 2 * (0, _math.asin)((0, _math.sqrt)((0, _math.haversin)(y1 - y0) + cy0 * cy1 * (0, _math.haversin)(x1 - x0))),
      k = (0, _math.sin)(d);
  var interpolate = d ? function (t) {
    var B = (0, _math.sin)(t *= d) / k,
        A = (0, _math.sin)(d - t) / k,
        x = A * kx0 + B * kx1,
        y = A * ky0 + B * ky1,
        z = A * sy0 + B * sy1;
    return [(0, _math.atan2)(y, x) * _math.degrees, (0, _math.atan2)(z, (0, _math.sqrt)(x * x + y * y)) * _math.degrees];
  } : function () {
    return [x0 * _math.degrees, y0 * _math.degrees];
  };
  interpolate.distance = d;
  return interpolate;
}
},{"./math":"sEgP"}],"tBtz":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _adder = _interopRequireDefault(require("../adder"));

var _math = require("../math");

var _noop = _interopRequireDefault(require("../noop"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var areaSum = (0, _adder.default)(),
    areaRingSum = (0, _adder.default)(),
    x00,
    y00,
    x0,
    y0;
var areaStream = {
  point: _noop.default,
  lineStart: _noop.default,
  lineEnd: _noop.default,
  polygonStart: function () {
    areaStream.lineStart = areaRingStart;
    areaStream.lineEnd = areaRingEnd;
  },
  polygonEnd: function () {
    areaStream.lineStart = areaStream.lineEnd = areaStream.point = _noop.default;
    areaSum.add((0, _math.abs)(areaRingSum));
    areaRingSum.reset();
  },
  result: function () {
    var area = areaSum / 2;
    areaSum.reset();
    return area;
  }
};

function areaRingStart() {
  areaStream.point = areaPointFirst;
}

function areaPointFirst(x, y) {
  areaStream.point = areaPoint;
  x00 = x0 = x, y00 = y0 = y;
}

function areaPoint(x, y) {
  areaRingSum.add(y0 * x - x0 * y);
  x0 = x, y0 = y;
}

function areaRingEnd() {
  areaPoint(x00, y00);
}

var _default = areaStream;
exports.default = _default;
},{"../adder":"GlqK","../math":"sEgP","../noop":"UPwg"}],"Mzp9":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _noop = _interopRequireDefault(require("../noop"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var x0 = Infinity,
    y0 = x0,
    x1 = -x0,
    y1 = x1;
var boundsStream = {
  point: boundsPoint,
  lineStart: _noop.default,
  lineEnd: _noop.default,
  polygonStart: _noop.default,
  polygonEnd: _noop.default,
  result: function () {
    var bounds = [[x0, y0], [x1, y1]];
    x1 = y1 = -(y0 = x0 = Infinity);
    return bounds;
  }
};

function boundsPoint(x, y) {
  if (x < x0) x0 = x;
  if (x > x1) x1 = x;
  if (y < y0) y0 = y;
  if (y > y1) y1 = y;
}

var _default = boundsStream;
exports.default = _default;
},{"../noop":"UPwg"}],"HLbf":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _math = require("../math");

// TODO Enforce positive area for exterior, negative area for interior?
var X0 = 0,
    Y0 = 0,
    Z0 = 0,
    X1 = 0,
    Y1 = 0,
    Z1 = 0,
    X2 = 0,
    Y2 = 0,
    Z2 = 0,
    x00,
    y00,
    x0,
    y0;
var centroidStream = {
  point: centroidPoint,
  lineStart: centroidLineStart,
  lineEnd: centroidLineEnd,
  polygonStart: function () {
    centroidStream.lineStart = centroidRingStart;
    centroidStream.lineEnd = centroidRingEnd;
  },
  polygonEnd: function () {
    centroidStream.point = centroidPoint;
    centroidStream.lineStart = centroidLineStart;
    centroidStream.lineEnd = centroidLineEnd;
  },
  result: function () {
    var centroid = Z2 ? [X2 / Z2, Y2 / Z2] : Z1 ? [X1 / Z1, Y1 / Z1] : Z0 ? [X0 / Z0, Y0 / Z0] : [NaN, NaN];
    X0 = Y0 = Z0 = X1 = Y1 = Z1 = X2 = Y2 = Z2 = 0;
    return centroid;
  }
};

function centroidPoint(x, y) {
  X0 += x;
  Y0 += y;
  ++Z0;
}

function centroidLineStart() {
  centroidStream.point = centroidPointFirstLine;
}

function centroidPointFirstLine(x, y) {
  centroidStream.point = centroidPointLine;
  centroidPoint(x0 = x, y0 = y);
}

function centroidPointLine(x, y) {
  var dx = x - x0,
      dy = y - y0,
      z = (0, _math.sqrt)(dx * dx + dy * dy);
  X1 += z * (x0 + x) / 2;
  Y1 += z * (y0 + y) / 2;
  Z1 += z;
  centroidPoint(x0 = x, y0 = y);
}

function centroidLineEnd() {
  centroidStream.point = centroidPoint;
}

function centroidRingStart() {
  centroidStream.point = centroidPointFirstRing;
}

function centroidRingEnd() {
  centroidPointRing(x00, y00);
}

function centroidPointFirstRing(x, y) {
  centroidStream.point = centroidPointRing;
  centroidPoint(x00 = x0 = x, y00 = y0 = y);
}

function centroidPointRing(x, y) {
  var dx = x - x0,
      dy = y - y0,
      z = (0, _math.sqrt)(dx * dx + dy * dy);
  X1 += z * (x0 + x) / 2;
  Y1 += z * (y0 + y) / 2;
  Z1 += z;
  z = y0 * x - x0 * y;
  X2 += z * (x0 + x);
  Y2 += z * (y0 + y);
  Z2 += z * 3;
  centroidPoint(x0 = x, y0 = y);
}

var _default = centroidStream;
exports.default = _default;
},{"../math":"sEgP"}],"ndK6":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = PathContext;

var _math = require("../math");

var _noop = _interopRequireDefault(require("../noop"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function PathContext(context) {
  this._context = context;
}

PathContext.prototype = {
  _radius: 4.5,
  pointRadius: function (_) {
    return this._radius = _, this;
  },
  polygonStart: function () {
    this._line = 0;
  },
  polygonEnd: function () {
    this._line = NaN;
  },
  lineStart: function () {
    this._point = 0;
  },
  lineEnd: function () {
    if (this._line === 0) this._context.closePath();
    this._point = NaN;
  },
  point: function (x, y) {
    switch (this._point) {
      case 0:
        {
          this._context.moveTo(x, y);

          this._point = 1;
          break;
        }

      case 1:
        {
          this._context.lineTo(x, y);

          break;
        }

      default:
        {
          this._context.moveTo(x + this._radius, y);

          this._context.arc(x, y, this._radius, 0, _math.tau);

          break;
        }
    }
  },
  result: _noop.default
};
},{"../math":"sEgP","../noop":"UPwg"}],"CqmG":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _adder = _interopRequireDefault(require("../adder"));

var _math = require("../math");

var _noop = _interopRequireDefault(require("../noop"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var lengthSum = (0, _adder.default)(),
    lengthRing,
    x00,
    y00,
    x0,
    y0;
var lengthStream = {
  point: _noop.default,
  lineStart: function () {
    lengthStream.point = lengthPointFirst;
  },
  lineEnd: function () {
    if (lengthRing) lengthPoint(x00, y00);
    lengthStream.point = _noop.default;
  },
  polygonStart: function () {
    lengthRing = true;
  },
  polygonEnd: function () {
    lengthRing = null;
  },
  result: function () {
    var length = +lengthSum;
    lengthSum.reset();
    return length;
  }
};

function lengthPointFirst(x, y) {
  lengthStream.point = lengthPoint;
  x00 = x0 = x, y00 = y0 = y;
}

function lengthPoint(x, y) {
  x0 -= x, y0 -= y;
  lengthSum.add((0, _math.sqrt)(x0 * x0 + y0 * y0));
  x0 = x, y0 = y;
}

var _default = lengthStream;
exports.default = _default;
},{"../adder":"GlqK","../math":"sEgP","../noop":"UPwg"}],"mB17":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = PathString;

function PathString() {
  this._string = [];
}

PathString.prototype = {
  _radius: 4.5,
  _circle: circle(4.5),
  pointRadius: function (_) {
    if ((_ = +_) !== this._radius) this._radius = _, this._circle = null;
    return this;
  },
  polygonStart: function () {
    this._line = 0;
  },
  polygonEnd: function () {
    this._line = NaN;
  },
  lineStart: function () {
    this._point = 0;
  },
  lineEnd: function () {
    if (this._line === 0) this._string.push("Z");
    this._point = NaN;
  },
  point: function (x, y) {
    switch (this._point) {
      case 0:
        {
          this._string.push("M", x, ",", y);

          this._point = 1;
          break;
        }

      case 1:
        {
          this._string.push("L", x, ",", y);

          break;
        }

      default:
        {
          if (this._circle == null) this._circle = circle(this._radius);

          this._string.push("M", x, ",", y, this._circle);

          break;
        }
    }
  },
  result: function () {
    if (this._string.length) {
      var result = this._string.join("");

      this._string = [];
      return result;
    } else {
      return null;
    }
  }
};

function circle(radius) {
  return "m0," + radius + "a" + radius + "," + radius + " 0 1,1 0," + -2 * radius + "a" + radius + "," + radius + " 0 1,1 0," + 2 * radius + "z";
}
},{}],"A7VF":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _identity = _interopRequireDefault(require("../identity"));

var _stream = _interopRequireDefault(require("../stream"));

var _area = _interopRequireDefault(require("./area"));

var _bounds = _interopRequireDefault(require("./bounds"));

var _centroid = _interopRequireDefault(require("./centroid"));

var _context = _interopRequireDefault(require("./context"));

var _measure = _interopRequireDefault(require("./measure"));

var _string = _interopRequireDefault(require("./string"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(projection, context) {
  var pointRadius = 4.5,
      projectionStream,
      contextStream;

  function path(object) {
    if (object) {
      if (typeof pointRadius === "function") contextStream.pointRadius(+pointRadius.apply(this, arguments));
      (0, _stream.default)(object, projectionStream(contextStream));
    }

    return contextStream.result();
  }

  path.area = function (object) {
    (0, _stream.default)(object, projectionStream(_area.default));
    return _area.default.result();
  };

  path.measure = function (object) {
    (0, _stream.default)(object, projectionStream(_measure.default));
    return _measure.default.result();
  };

  path.bounds = function (object) {
    (0, _stream.default)(object, projectionStream(_bounds.default));
    return _bounds.default.result();
  };

  path.centroid = function (object) {
    (0, _stream.default)(object, projectionStream(_centroid.default));
    return _centroid.default.result();
  };

  path.projection = function (_) {
    return arguments.length ? (projectionStream = _ == null ? (projection = null, _identity.default) : (projection = _).stream, path) : projection;
  };

  path.context = function (_) {
    if (!arguments.length) return context;
    contextStream = _ == null ? (context = null, new _string.default()) : new _context.default(context = _);
    if (typeof pointRadius !== "function") contextStream.pointRadius(pointRadius);
    return path;
  };

  path.pointRadius = function (_) {
    if (!arguments.length) return pointRadius;
    pointRadius = typeof _ === "function" ? _ : (contextStream.pointRadius(+_), +_);
    return path;
  };

  return path.projection(projection).context(context);
}
},{"../identity":"nPOL","../stream":"XBFK","./area":"tBtz","./bounds":"Mzp9","./centroid":"HLbf","./context":"ndK6","./measure":"CqmG","./string":"mB17"}],"ubFV":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.transformer = transformer;

function _default(methods) {
  return {
    stream: transformer(methods)
  };
}

function transformer(methods) {
  return function (stream) {
    var s = new TransformStream();

    for (var key in methods) s[key] = methods[key];

    s.stream = stream;
    return s;
  };
}

function TransformStream() {}

TransformStream.prototype = {
  constructor: TransformStream,
  point: function (x, y) {
    this.stream.point(x, y);
  },
  sphere: function () {
    this.stream.sphere();
  },
  lineStart: function () {
    this.stream.lineStart();
  },
  lineEnd: function () {
    this.stream.lineEnd();
  },
  polygonStart: function () {
    this.stream.polygonStart();
  },
  polygonEnd: function () {
    this.stream.polygonEnd();
  }
};
},{}],"Ty3O":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fitExtent = fitExtent;
exports.fitSize = fitSize;
exports.fitWidth = fitWidth;
exports.fitHeight = fitHeight;

var _stream = _interopRequireDefault(require("../stream"));

var _bounds = _interopRequireDefault(require("../path/bounds"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function fit(projection, fitBounds, object) {
  var clip = projection.clipExtent && projection.clipExtent();
  projection.scale(150).translate([0, 0]);
  if (clip != null) projection.clipExtent(null);
  (0, _stream.default)(object, projection.stream(_bounds.default));
  fitBounds(_bounds.default.result());
  if (clip != null) projection.clipExtent(clip);
  return projection;
}

function fitExtent(projection, extent, object) {
  return fit(projection, function (b) {
    var w = extent[1][0] - extent[0][0],
        h = extent[1][1] - extent[0][1],
        k = Math.min(w / (b[1][0] - b[0][0]), h / (b[1][1] - b[0][1])),
        x = +extent[0][0] + (w - k * (b[1][0] + b[0][0])) / 2,
        y = +extent[0][1] + (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

function fitSize(projection, size, object) {
  return fitExtent(projection, [[0, 0], size], object);
}

function fitWidth(projection, width, object) {
  return fit(projection, function (b) {
    var w = +width,
        k = w / (b[1][0] - b[0][0]),
        x = (w - k * (b[1][0] + b[0][0])) / 2,
        y = -k * b[0][1];
    projection.scale(150 * k).translate([x, y]);
  }, object);
}

function fitHeight(projection, height, object) {
  return fit(projection, function (b) {
    var h = +height,
        k = h / (b[1][1] - b[0][1]),
        x = -k * b[0][0],
        y = (h - k * (b[1][1] + b[0][1])) / 2;
    projection.scale(150 * k).translate([x, y]);
  }, object);
}
},{"../stream":"XBFK","../path/bounds":"Mzp9"}],"vIaz":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _cartesian = require("../cartesian");

var _math = require("../math");

var _transform = require("../transform");

var maxDepth = 16,
    // maximum depth of subdivision
cosMinDistance = (0, _math.cos)(30 * _math.radians); // cos(minimum angular distance)

function _default(project, delta2) {
  return +delta2 ? resample(project, delta2) : resampleNone(project);
}

function resampleNone(project) {
  return (0, _transform.transformer)({
    point: function (x, y) {
      x = project(x, y);
      this.stream.point(x[0], x[1]);
    }
  });
}

function resample(project, delta2) {
  function resampleLineTo(x0, y0, lambda0, a0, b0, c0, x1, y1, lambda1, a1, b1, c1, depth, stream) {
    var dx = x1 - x0,
        dy = y1 - y0,
        d2 = dx * dx + dy * dy;

    if (d2 > 4 * delta2 && depth--) {
      var a = a0 + a1,
          b = b0 + b1,
          c = c0 + c1,
          m = (0, _math.sqrt)(a * a + b * b + c * c),
          phi2 = (0, _math.asin)(c /= m),
          lambda2 = (0, _math.abs)((0, _math.abs)(c) - 1) < _math.epsilon || (0, _math.abs)(lambda0 - lambda1) < _math.epsilon ? (lambda0 + lambda1) / 2 : (0, _math.atan2)(b, a),
          p = project(lambda2, phi2),
          x2 = p[0],
          y2 = p[1],
          dx2 = x2 - x0,
          dy2 = y2 - y0,
          dz = dy * dx2 - dx * dy2;

      if (dz * dz / d2 > delta2 // perpendicular projected distance
      || (0, _math.abs)((dx * dx2 + dy * dy2) / d2 - 0.5) > 0.3 // midpoint close to an end
      || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {
        // angular distance
        resampleLineTo(x0, y0, lambda0, a0, b0, c0, x2, y2, lambda2, a /= m, b /= m, c, depth, stream);
        stream.point(x2, y2);
        resampleLineTo(x2, y2, lambda2, a, b, c, x1, y1, lambda1, a1, b1, c1, depth, stream);
      }
    }
  }

  return function (stream) {
    var lambda00, x00, y00, a00, b00, c00, // first point
    lambda0, x0, y0, a0, b0, c0; // previous point

    var resampleStream = {
      point: point,
      lineStart: lineStart,
      lineEnd: lineEnd,
      polygonStart: function () {
        stream.polygonStart();
        resampleStream.lineStart = ringStart;
      },
      polygonEnd: function () {
        stream.polygonEnd();
        resampleStream.lineStart = lineStart;
      }
    };

    function point(x, y) {
      x = project(x, y);
      stream.point(x[0], x[1]);
    }

    function lineStart() {
      x0 = NaN;
      resampleStream.point = linePoint;
      stream.lineStart();
    }

    function linePoint(lambda, phi) {
      var c = (0, _cartesian.cartesian)([lambda, phi]),
          p = project(lambda, phi);
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x0 = p[0], y0 = p[1], lambda0 = lambda, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);
      stream.point(x0, y0);
    }

    function lineEnd() {
      resampleStream.point = point;
      stream.lineEnd();
    }

    function ringStart() {
      lineStart();
      resampleStream.point = ringPoint;
      resampleStream.lineEnd = ringEnd;
    }

    function ringPoint(lambda, phi) {
      linePoint(lambda00 = lambda, phi), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;
      resampleStream.point = linePoint;
    }

    function ringEnd() {
      resampleLineTo(x0, y0, lambda0, a0, b0, c0, x00, y00, lambda00, a00, b00, c00, maxDepth, stream);
      resampleStream.lineEnd = lineEnd;
      lineEnd();
    }

    return resampleStream;
  };
}
},{"../cartesian":"rFMq","../math":"sEgP","../transform":"ubFV"}],"t1yD":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = projection;
exports.projectionMutator = projectionMutator;

var _antimeridian = _interopRequireDefault(require("../clip/antimeridian"));

var _circle = _interopRequireDefault(require("../clip/circle"));

var _rectangle = _interopRequireDefault(require("../clip/rectangle"));

var _compose = _interopRequireDefault(require("../compose"));

var _identity = _interopRequireDefault(require("../identity"));

var _math = require("../math");

var _rotation = require("../rotation");

var _transform = require("../transform");

var _fit = require("./fit");

var _resample = _interopRequireDefault(require("./resample"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var transformRadians = (0, _transform.transformer)({
  point: function (x, y) {
    this.stream.point(x * _math.radians, y * _math.radians);
  }
});

function transformRotate(rotate) {
  return (0, _transform.transformer)({
    point: function (x, y) {
      var r = rotate(x, y);
      return this.stream.point(r[0], r[1]);
    }
  });
}

function projection(project) {
  return projectionMutator(function () {
    return project;
  })();
}

function projectionMutator(projectAt) {
  var project,
      k = 150,
      // scale
  x = 480,
      y = 250,
      // translate
  dx,
      dy,
      lambda = 0,
      phi = 0,
      // center
  deltaLambda = 0,
      deltaPhi = 0,
      deltaGamma = 0,
      rotate,
      projectRotate,
      // rotate
  theta = null,
      preclip = _antimeridian.default,
      // clip angle
  x0 = null,
      y0,
      x1,
      y1,
      postclip = _identity.default,
      // clip extent
  delta2 = 0.5,
      projectResample = (0, _resample.default)(projectTransform, delta2),
      // precision
  cache,
      cacheStream;

  function projection(point) {
    point = projectRotate(point[0] * _math.radians, point[1] * _math.radians);
    return [point[0] * k + dx, dy - point[1] * k];
  }

  function invert(point) {
    point = projectRotate.invert((point[0] - dx) / k, (dy - point[1]) / k);
    return point && [point[0] * _math.degrees, point[1] * _math.degrees];
  }

  function projectTransform(x, y) {
    return x = project(x, y), [x[0] * k + dx, dy - x[1] * k];
  }

  projection.stream = function (stream) {
    return cache && cacheStream === stream ? cache : cache = transformRadians(transformRotate(rotate)(preclip(projectResample(postclip(cacheStream = stream)))));
  };

  projection.preclip = function (_) {
    return arguments.length ? (preclip = _, theta = undefined, reset()) : preclip;
  };

  projection.postclip = function (_) {
    return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
  };

  projection.clipAngle = function (_) {
    return arguments.length ? (preclip = +_ ? (0, _circle.default)(theta = _ * _math.radians) : (theta = null, _antimeridian.default), reset()) : theta * _math.degrees;
  };

  projection.clipExtent = function (_) {
    return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, _identity.default) : (0, _rectangle.default)(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  projection.scale = function (_) {
    return arguments.length ? (k = +_, recenter()) : k;
  };

  projection.translate = function (_) {
    return arguments.length ? (x = +_[0], y = +_[1], recenter()) : [x, y];
  };

  projection.center = function (_) {
    return arguments.length ? (lambda = _[0] % 360 * _math.radians, phi = _[1] % 360 * _math.radians, recenter()) : [lambda * _math.degrees, phi * _math.degrees];
  };

  projection.rotate = function (_) {
    return arguments.length ? (deltaLambda = _[0] % 360 * _math.radians, deltaPhi = _[1] % 360 * _math.radians, deltaGamma = _.length > 2 ? _[2] % 360 * _math.radians : 0, recenter()) : [deltaLambda * _math.degrees, deltaPhi * _math.degrees, deltaGamma * _math.degrees];
  };

  projection.precision = function (_) {
    return arguments.length ? (projectResample = (0, _resample.default)(projectTransform, delta2 = _ * _), reset()) : (0, _math.sqrt)(delta2);
  };

  projection.fitExtent = function (extent, object) {
    return (0, _fit.fitExtent)(projection, extent, object);
  };

  projection.fitSize = function (size, object) {
    return (0, _fit.fitSize)(projection, size, object);
  };

  projection.fitWidth = function (width, object) {
    return (0, _fit.fitWidth)(projection, width, object);
  };

  projection.fitHeight = function (height, object) {
    return (0, _fit.fitHeight)(projection, height, object);
  };

  function recenter() {
    projectRotate = (0, _compose.default)(rotate = (0, _rotation.rotateRadians)(deltaLambda, deltaPhi, deltaGamma), project);
    var center = project(lambda, phi);
    dx = x - center[0] * k;
    dy = y + center[1] * k;
    return reset();
  }

  function reset() {
    cache = cacheStream = null;
    return projection;
  }

  return function () {
    project = projectAt.apply(this, arguments);
    projection.invert = project.invert && invert;
    return recenter();
  };
}
},{"../clip/antimeridian":"CWnN","../clip/circle":"uulM","../clip/rectangle":"E6SH","../compose":"hCea","../identity":"nPOL","../math":"sEgP","../rotation":"KwdP","../transform":"ubFV","./fit":"Ty3O","./resample":"vIaz"}],"FzMl":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.conicProjection = conicProjection;

var _math = require("../math");

var _index = require("./index");

function conicProjection(projectAt) {
  var phi0 = 0,
      phi1 = _math.pi / 3,
      m = (0, _index.projectionMutator)(projectAt),
      p = m(phi0, phi1);

  p.parallels = function (_) {
    return arguments.length ? m(phi0 = _[0] * _math.radians, phi1 = _[1] * _math.radians) : [phi0 * _math.degrees, phi1 * _math.degrees];
  };

  return p;
}
},{"../math":"sEgP","./index":"t1yD"}],"xg50":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.cylindricalEqualAreaRaw = cylindricalEqualAreaRaw;

var _math = require("../math");

function cylindricalEqualAreaRaw(phi0) {
  var cosPhi0 = (0, _math.cos)(phi0);

  function forward(lambda, phi) {
    return [lambda * cosPhi0, (0, _math.sin)(phi) / cosPhi0];
  }

  forward.invert = function (x, y) {
    return [x / cosPhi0, (0, _math.asin)(y * cosPhi0)];
  };

  return forward;
}
},{"../math":"sEgP"}],"uvEu":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.conicEqualAreaRaw = conicEqualAreaRaw;
exports.default = _default;

var _math = require("../math");

var _conic = require("./conic");

var _cylindricalEqualArea = require("./cylindricalEqualArea");

function conicEqualAreaRaw(y0, y1) {
  var sy0 = (0, _math.sin)(y0),
      n = (sy0 + (0, _math.sin)(y1)) / 2; // Are the parallels symmetrical around the Equator?

  if ((0, _math.abs)(n) < _math.epsilon) return (0, _cylindricalEqualArea.cylindricalEqualAreaRaw)(y0);
  var c = 1 + sy0 * (2 * n - sy0),
      r0 = (0, _math.sqrt)(c) / n;

  function project(x, y) {
    var r = (0, _math.sqrt)(c - 2 * n * (0, _math.sin)(y)) / n;
    return [r * (0, _math.sin)(x *= n), r0 - r * (0, _math.cos)(x)];
  }

  project.invert = function (x, y) {
    var r0y = r0 - y;
    return [(0, _math.atan2)(x, (0, _math.abs)(r0y)) / n * (0, _math.sign)(r0y), (0, _math.asin)((c - (x * x + r0y * r0y) * n * n) / (2 * n))];
  };

  return project;
}

function _default() {
  return (0, _conic.conicProjection)(conicEqualAreaRaw).scale(155.424).center([0, 33.6442]);
}
},{"../math":"sEgP","./conic":"FzMl","./cylindricalEqualArea":"xg50"}],"HUYT":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _conicEqualArea = _interopRequireDefault(require("./conicEqualArea"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default() {
  return (0, _conicEqualArea.default)().parallels([29.5, 45.5]).scale(1070).translate([480, 250]).rotate([96, 0]).center([-0.6, 38.7]);
}
},{"./conicEqualArea":"uvEu"}],"WyCU":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _math = require("../math");

var _albers = _interopRequireDefault(require("./albers"));

var _conicEqualArea = _interopRequireDefault(require("./conicEqualArea"));

var _fit = require("./fit");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// The projections must have mutually exclusive clip regions on the sphere,
// as this will avoid emitting interleaving lines and polygons.
function multiplex(streams) {
  var n = streams.length;
  return {
    point: function (x, y) {
      var i = -1;

      while (++i < n) streams[i].point(x, y);
    },
    sphere: function () {
      var i = -1;

      while (++i < n) streams[i].sphere();
    },
    lineStart: function () {
      var i = -1;

      while (++i < n) streams[i].lineStart();
    },
    lineEnd: function () {
      var i = -1;

      while (++i < n) streams[i].lineEnd();
    },
    polygonStart: function () {
      var i = -1;

      while (++i < n) streams[i].polygonStart();
    },
    polygonEnd: function () {
      var i = -1;

      while (++i < n) streams[i].polygonEnd();
    }
  };
} // A composite projection for the United States, configured by default for
// 960×500. The projection also works quite well at 960×600 if you change the
// scale to 1285 and adjust the translate accordingly. The set of standard
// parallels for each region comes from USGS, which is published here:
// http://egsc.usgs.gov/isb/pubs/MapProjections/projections.html#albers


function _default() {
  var cache,
      cacheStream,
      lower48 = (0, _albers.default)(),
      lower48Point,
      alaska = (0, _conicEqualArea.default)().rotate([154, 0]).center([-2, 58.5]).parallels([55, 65]),
      alaskaPoint,
      // EPSG:3338
  hawaii = (0, _conicEqualArea.default)().rotate([157, 0]).center([-3, 19.9]).parallels([8, 18]),
      hawaiiPoint,
      // ESRI:102007
  point,
      pointStream = {
    point: function (x, y) {
      point = [x, y];
    }
  };

  function albersUsa(coordinates) {
    var x = coordinates[0],
        y = coordinates[1];
    return point = null, (lower48Point.point(x, y), point) || (alaskaPoint.point(x, y), point) || (hawaiiPoint.point(x, y), point);
  }

  albersUsa.invert = function (coordinates) {
    var k = lower48.scale(),
        t = lower48.translate(),
        x = (coordinates[0] - t[0]) / k,
        y = (coordinates[1] - t[1]) / k;
    return (y >= 0.120 && y < 0.234 && x >= -0.425 && x < -0.214 ? alaska : y >= 0.166 && y < 0.234 && x >= -0.214 && x < -0.115 ? hawaii : lower48).invert(coordinates);
  };

  albersUsa.stream = function (stream) {
    return cache && cacheStream === stream ? cache : cache = multiplex([lower48.stream(cacheStream = stream), alaska.stream(stream), hawaii.stream(stream)]);
  };

  albersUsa.precision = function (_) {
    if (!arguments.length) return lower48.precision();
    lower48.precision(_), alaska.precision(_), hawaii.precision(_);
    return reset();
  };

  albersUsa.scale = function (_) {
    if (!arguments.length) return lower48.scale();
    lower48.scale(_), alaska.scale(_ * 0.35), hawaii.scale(_);
    return albersUsa.translate(lower48.translate());
  };

  albersUsa.translate = function (_) {
    if (!arguments.length) return lower48.translate();
    var k = lower48.scale(),
        x = +_[0],
        y = +_[1];
    lower48Point = lower48.translate(_).clipExtent([[x - 0.455 * k, y - 0.238 * k], [x + 0.455 * k, y + 0.238 * k]]).stream(pointStream);
    alaskaPoint = alaska.translate([x - 0.307 * k, y + 0.201 * k]).clipExtent([[x - 0.425 * k + _math.epsilon, y + 0.120 * k + _math.epsilon], [x - 0.214 * k - _math.epsilon, y + 0.234 * k - _math.epsilon]]).stream(pointStream);
    hawaiiPoint = hawaii.translate([x - 0.205 * k, y + 0.212 * k]).clipExtent([[x - 0.214 * k + _math.epsilon, y + 0.166 * k + _math.epsilon], [x - 0.115 * k - _math.epsilon, y + 0.234 * k - _math.epsilon]]).stream(pointStream);
    return reset();
  };

  albersUsa.fitExtent = function (extent, object) {
    return (0, _fit.fitExtent)(albersUsa, extent, object);
  };

  albersUsa.fitSize = function (size, object) {
    return (0, _fit.fitSize)(albersUsa, size, object);
  };

  albersUsa.fitWidth = function (width, object) {
    return (0, _fit.fitWidth)(albersUsa, width, object);
  };

  albersUsa.fitHeight = function (height, object) {
    return (0, _fit.fitHeight)(albersUsa, height, object);
  };

  function reset() {
    cache = cacheStream = null;
    return albersUsa;
  }

  return albersUsa.scale(1070);
}
},{"../math":"sEgP","./albers":"HUYT","./conicEqualArea":"uvEu","./fit":"Ty3O"}],"FJmT":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.azimuthalRaw = azimuthalRaw;
exports.azimuthalInvert = azimuthalInvert;

var _math = require("../math");

function azimuthalRaw(scale) {
  return function (x, y) {
    var cx = (0, _math.cos)(x),
        cy = (0, _math.cos)(y),
        k = scale(cx * cy);
    return [k * cy * (0, _math.sin)(x), k * (0, _math.sin)(y)];
  };
}

function azimuthalInvert(angle) {
  return function (x, y) {
    var z = (0, _math.sqrt)(x * x + y * y),
        c = angle(z),
        sc = (0, _math.sin)(c),
        cc = (0, _math.cos)(c);
    return [(0, _math.atan2)(x * sc, z * cc), (0, _math.asin)(z && y * sc / z)];
  };
}
},{"../math":"sEgP"}],"c9jZ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.azimuthalEqualAreaRaw = void 0;

var _math = require("../math");

var _azimuthal = require("./azimuthal");

var _index = _interopRequireDefault(require("./index"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var azimuthalEqualAreaRaw = (0, _azimuthal.azimuthalRaw)(function (cxcy) {
  return (0, _math.sqrt)(2 / (1 + cxcy));
});
exports.azimuthalEqualAreaRaw = azimuthalEqualAreaRaw;
azimuthalEqualAreaRaw.invert = (0, _azimuthal.azimuthalInvert)(function (z) {
  return 2 * (0, _math.asin)(z / 2);
});

function _default() {
  return (0, _index.default)(azimuthalEqualAreaRaw).scale(124.75).clipAngle(180 - 1e-3);
}
},{"../math":"sEgP","./azimuthal":"FJmT","./index":"t1yD"}],"DPfU":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.azimuthalEquidistantRaw = void 0;

var _math = require("../math");

var _azimuthal = require("./azimuthal");

var _index = _interopRequireDefault(require("./index"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var azimuthalEquidistantRaw = (0, _azimuthal.azimuthalRaw)(function (c) {
  return (c = (0, _math.acos)(c)) && c / (0, _math.sin)(c);
});
exports.azimuthalEquidistantRaw = azimuthalEquidistantRaw;
azimuthalEquidistantRaw.invert = (0, _azimuthal.azimuthalInvert)(function (z) {
  return z;
});

function _default() {
  return (0, _index.default)(azimuthalEquidistantRaw).scale(79.4188).clipAngle(180 - 1e-3);
}
},{"../math":"sEgP","./azimuthal":"FJmT","./index":"t1yD"}],"Yvwi":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.mercatorRaw = mercatorRaw;
exports.default = _default;
exports.mercatorProjection = mercatorProjection;

var _math = require("../math");

var _rotation = _interopRequireDefault(require("../rotation"));

var _index = _interopRequireDefault(require("./index"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function mercatorRaw(lambda, phi) {
  return [lambda, (0, _math.log)((0, _math.tan)((_math.halfPi + phi) / 2))];
}

mercatorRaw.invert = function (x, y) {
  return [x, 2 * (0, _math.atan)((0, _math.exp)(y)) - _math.halfPi];
};

function _default() {
  return mercatorProjection(mercatorRaw).scale(961 / _math.tau);
}

function mercatorProjection(project) {
  var m = (0, _index.default)(project),
      center = m.center,
      scale = m.scale,
      translate = m.translate,
      clipExtent = m.clipExtent,
      x0 = null,
      y0,
      x1,
      y1; // clip extent

  m.scale = function (_) {
    return arguments.length ? (scale(_), reclip()) : scale();
  };

  m.translate = function (_) {
    return arguments.length ? (translate(_), reclip()) : translate();
  };

  m.center = function (_) {
    return arguments.length ? (center(_), reclip()) : center();
  };

  m.clipExtent = function (_) {
    return arguments.length ? (_ == null ? x0 = y0 = x1 = y1 = null : (x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reclip()) : x0 == null ? null : [[x0, y0], [x1, y1]];
  };

  function reclip() {
    var k = _math.pi * scale(),
        t = m((0, _rotation.default)(m.rotate()).invert([0, 0]));
    return clipExtent(x0 == null ? [[t[0] - k, t[1] - k], [t[0] + k, t[1] + k]] : project === mercatorRaw ? [[Math.max(t[0] - k, x0), y0], [Math.min(t[0] + k, x1), y1]] : [[x0, Math.max(t[1] - k, y0)], [x1, Math.min(t[1] + k, y1)]]);
  }

  return reclip();
}
},{"../math":"sEgP","../rotation":"KwdP","./index":"t1yD"}],"QZHg":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.conicConformalRaw = conicConformalRaw;
exports.default = _default;

var _math = require("../math");

var _conic = require("./conic");

var _mercator = require("./mercator");

function tany(y) {
  return (0, _math.tan)((_math.halfPi + y) / 2);
}

function conicConformalRaw(y0, y1) {
  var cy0 = (0, _math.cos)(y0),
      n = y0 === y1 ? (0, _math.sin)(y0) : (0, _math.log)(cy0 / (0, _math.cos)(y1)) / (0, _math.log)(tany(y1) / tany(y0)),
      f = cy0 * (0, _math.pow)(tany(y0), n) / n;
  if (!n) return _mercator.mercatorRaw;

  function project(x, y) {
    if (f > 0) {
      if (y < -_math.halfPi + _math.epsilon) y = -_math.halfPi + _math.epsilon;
    } else {
      if (y > _math.halfPi - _math.epsilon) y = _math.halfPi - _math.epsilon;
    }

    var r = f / (0, _math.pow)(tany(y), n);
    return [r * (0, _math.sin)(n * x), f - r * (0, _math.cos)(n * x)];
  }

  project.invert = function (x, y) {
    var fy = f - y,
        r = (0, _math.sign)(n) * (0, _math.sqrt)(x * x + fy * fy);
    return [(0, _math.atan2)(x, (0, _math.abs)(fy)) / n * (0, _math.sign)(fy), 2 * (0, _math.atan)((0, _math.pow)(f / r, 1 / n)) - _math.halfPi];
  };

  return project;
}

function _default() {
  return (0, _conic.conicProjection)(conicConformalRaw).scale(109.5).parallels([30, 30]);
}
},{"../math":"sEgP","./conic":"FzMl","./mercator":"Yvwi"}],"xN4O":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.equirectangularRaw = equirectangularRaw;
exports.default = _default;

var _index = _interopRequireDefault(require("./index"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function equirectangularRaw(lambda, phi) {
  return [lambda, phi];
}

equirectangularRaw.invert = equirectangularRaw;

function _default() {
  return (0, _index.default)(equirectangularRaw).scale(152.63);
}
},{"./index":"t1yD"}],"wKng":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.conicEquidistantRaw = conicEquidistantRaw;
exports.default = _default;

var _math = require("../math");

var _conic = require("./conic");

var _equirectangular = require("./equirectangular");

function conicEquidistantRaw(y0, y1) {
  var cy0 = (0, _math.cos)(y0),
      n = y0 === y1 ? (0, _math.sin)(y0) : (cy0 - (0, _math.cos)(y1)) / (y1 - y0),
      g = cy0 / n + y0;
  if ((0, _math.abs)(n) < _math.epsilon) return _equirectangular.equirectangularRaw;

  function project(x, y) {
    var gy = g - y,
        nx = n * x;
    return [gy * (0, _math.sin)(nx), g - gy * (0, _math.cos)(nx)];
  }

  project.invert = function (x, y) {
    var gy = g - y;
    return [(0, _math.atan2)(x, (0, _math.abs)(gy)) / n * (0, _math.sign)(gy), g - (0, _math.sign)(n) * (0, _math.sqrt)(x * x + gy * gy)];
  };

  return project;
}

function _default() {
  return (0, _conic.conicProjection)(conicEquidistantRaw).scale(131.154).center([0, 13.9389]);
}
},{"../math":"sEgP","./conic":"FzMl","./equirectangular":"xN4O"}],"bmsS":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.gnomonicRaw = gnomonicRaw;
exports.default = _default;

var _math = require("../math");

var _azimuthal = require("./azimuthal");

var _index = _interopRequireDefault(require("./index"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function gnomonicRaw(x, y) {
  var cy = (0, _math.cos)(y),
      k = (0, _math.cos)(x) * cy;
  return [cy * (0, _math.sin)(x) / k, (0, _math.sin)(y) / k];
}

gnomonicRaw.invert = (0, _azimuthal.azimuthalInvert)(_math.atan);

function _default() {
  return (0, _index.default)(gnomonicRaw).scale(144.049).clipAngle(60);
}
},{"../math":"sEgP","./azimuthal":"FJmT","./index":"t1yD"}],"LapZ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _rectangle = _interopRequireDefault(require("../clip/rectangle"));

var _identity = _interopRequireDefault(require("../identity"));

var _transform = require("../transform");

var _fit = require("./fit");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function scaleTranslate(kx, ky, tx, ty) {
  return kx === 1 && ky === 1 && tx === 0 && ty === 0 ? _identity.default : (0, _transform.transformer)({
    point: function (x, y) {
      this.stream.point(x * kx + tx, y * ky + ty);
    }
  });
}

function _default() {
  var k = 1,
      tx = 0,
      ty = 0,
      sx = 1,
      sy = 1,
      transform = _identity.default,
      // scale, translate and reflect
  x0 = null,
      y0,
      x1,
      y1,
      // clip extent
  postclip = _identity.default,
      cache,
      cacheStream,
      projection;

  function reset() {
    cache = cacheStream = null;
    return projection;
  }

  return projection = {
    stream: function (stream) {
      return cache && cacheStream === stream ? cache : cache = transform(postclip(cacheStream = stream));
    },
    postclip: function (_) {
      return arguments.length ? (postclip = _, x0 = y0 = x1 = y1 = null, reset()) : postclip;
    },
    clipExtent: function (_) {
      return arguments.length ? (postclip = _ == null ? (x0 = y0 = x1 = y1 = null, _identity.default) : (0, _rectangle.default)(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]), reset()) : x0 == null ? null : [[x0, y0], [x1, y1]];
    },
    scale: function (_) {
      return arguments.length ? (transform = scaleTranslate((k = +_) * sx, k * sy, tx, ty), reset()) : k;
    },
    translate: function (_) {
      return arguments.length ? (transform = scaleTranslate(k * sx, k * sy, tx = +_[0], ty = +_[1]), reset()) : [tx, ty];
    },
    reflectX: function (_) {
      return arguments.length ? (transform = scaleTranslate(k * (sx = _ ? -1 : 1), k * sy, tx, ty), reset()) : sx < 0;
    },
    reflectY: function (_) {
      return arguments.length ? (transform = scaleTranslate(k * sx, k * (sy = _ ? -1 : 1), tx, ty), reset()) : sy < 0;
    },
    fitExtent: function (extent, object) {
      return (0, _fit.fitExtent)(projection, extent, object);
    },
    fitSize: function (size, object) {
      return (0, _fit.fitSize)(projection, size, object);
    },
    fitWidth: function (width, object) {
      return (0, _fit.fitWidth)(projection, width, object);
    },
    fitHeight: function (height, object) {
      return (0, _fit.fitHeight)(projection, height, object);
    }
  };
}
},{"../clip/rectangle":"E6SH","../identity":"nPOL","../transform":"ubFV","./fit":"Ty3O"}],"yWpl":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.naturalEarth1Raw = naturalEarth1Raw;
exports.default = _default;

var _index = _interopRequireDefault(require("./index"));

var _math = require("../math");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function naturalEarth1Raw(lambda, phi) {
  var phi2 = phi * phi,
      phi4 = phi2 * phi2;
  return [lambda * (0.8707 - 0.131979 * phi2 + phi4 * (-0.013791 + phi4 * (0.003971 * phi2 - 0.001529 * phi4))), phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4)))];
}

naturalEarth1Raw.invert = function (x, y) {
  var phi = y,
      i = 25,
      delta;

  do {
    var phi2 = phi * phi,
        phi4 = phi2 * phi2;
    phi -= delta = (phi * (1.007226 + phi2 * (0.015085 + phi4 * (-0.044475 + 0.028874 * phi2 - 0.005916 * phi4))) - y) / (1.007226 + phi2 * (0.015085 * 3 + phi4 * (-0.044475 * 7 + 0.028874 * 9 * phi2 - 0.005916 * 11 * phi4)));
  } while ((0, _math.abs)(delta) > _math.epsilon && --i > 0);

  return [x / (0.8707 + (phi2 = phi * phi) * (-0.131979 + phi2 * (-0.013791 + phi2 * phi2 * phi2 * (0.003971 - 0.001529 * phi2)))), phi];
};

function _default() {
  return (0, _index.default)(naturalEarth1Raw).scale(175.295);
}
},{"./index":"t1yD","../math":"sEgP"}],"H7pW":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.orthographicRaw = orthographicRaw;
exports.default = _default;

var _math = require("../math");

var _azimuthal = require("./azimuthal");

var _index = _interopRequireDefault(require("./index"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function orthographicRaw(x, y) {
  return [(0, _math.cos)(y) * (0, _math.sin)(x), (0, _math.sin)(y)];
}

orthographicRaw.invert = (0, _azimuthal.azimuthalInvert)(_math.asin);

function _default() {
  return (0, _index.default)(orthographicRaw).scale(249.5).clipAngle(90 + _math.epsilon);
}
},{"../math":"sEgP","./azimuthal":"FJmT","./index":"t1yD"}],"bNxf":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.stereographicRaw = stereographicRaw;
exports.default = _default;

var _math = require("../math");

var _azimuthal = require("./azimuthal");

var _index = _interopRequireDefault(require("./index"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stereographicRaw(x, y) {
  var cy = (0, _math.cos)(y),
      k = 1 + (0, _math.cos)(x) * cy;
  return [cy * (0, _math.sin)(x) / k, (0, _math.sin)(y) / k];
}

stereographicRaw.invert = (0, _azimuthal.azimuthalInvert)(function (z) {
  return 2 * (0, _math.atan)(z);
});

function _default() {
  return (0, _index.default)(stereographicRaw).scale(250).clipAngle(142);
}
},{"../math":"sEgP","./azimuthal":"FJmT","./index":"t1yD"}],"BGbj":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.transverseMercatorRaw = transverseMercatorRaw;
exports.default = _default;

var _math = require("../math");

var _mercator = require("./mercator");

function transverseMercatorRaw(lambda, phi) {
  return [(0, _math.log)((0, _math.tan)((_math.halfPi + phi) / 2)), -lambda];
}

transverseMercatorRaw.invert = function (x, y) {
  return [-y, 2 * (0, _math.atan)((0, _math.exp)(x)) - _math.halfPi];
};

function _default() {
  var m = (0, _mercator.mercatorProjection)(transverseMercatorRaw),
      center = m.center,
      rotate = m.rotate;

  m.center = function (_) {
    return arguments.length ? center([-_[1], _[0]]) : (_ = center(), [_[1], -_[0]]);
  };

  m.rotate = function (_) {
    return arguments.length ? rotate([_[0], _[1], _.length > 2 ? _[2] + 90 : 90]) : (_ = rotate(), [_[0], _[1], _[2] - 90]);
  };

  return rotate([0, 0, 90]).scale(159.155);
}
},{"../math":"sEgP","./mercator":"Yvwi"}],"EnIL":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "geoArea", {
  enumerable: true,
  get: function () {
    return _area.default;
  }
});
Object.defineProperty(exports, "geoBounds", {
  enumerable: true,
  get: function () {
    return _bounds.default;
  }
});
Object.defineProperty(exports, "geoCentroid", {
  enumerable: true,
  get: function () {
    return _centroid.default;
  }
});
Object.defineProperty(exports, "geoCircle", {
  enumerable: true,
  get: function () {
    return _circle.default;
  }
});
Object.defineProperty(exports, "geoClipAntimeridian", {
  enumerable: true,
  get: function () {
    return _antimeridian.default;
  }
});
Object.defineProperty(exports, "geoClipCircle", {
  enumerable: true,
  get: function () {
    return _circle2.default;
  }
});
Object.defineProperty(exports, "geoClipExtent", {
  enumerable: true,
  get: function () {
    return _extent.default;
  }
});
Object.defineProperty(exports, "geoClipRectangle", {
  enumerable: true,
  get: function () {
    return _rectangle.default;
  }
});
Object.defineProperty(exports, "geoContains", {
  enumerable: true,
  get: function () {
    return _contains.default;
  }
});
Object.defineProperty(exports, "geoDistance", {
  enumerable: true,
  get: function () {
    return _distance.default;
  }
});
Object.defineProperty(exports, "geoGraticule", {
  enumerable: true,
  get: function () {
    return _graticule.default;
  }
});
Object.defineProperty(exports, "geoGraticule10", {
  enumerable: true,
  get: function () {
    return _graticule.graticule10;
  }
});
Object.defineProperty(exports, "geoInterpolate", {
  enumerable: true,
  get: function () {
    return _interpolate.default;
  }
});
Object.defineProperty(exports, "geoLength", {
  enumerable: true,
  get: function () {
    return _length.default;
  }
});
Object.defineProperty(exports, "geoPath", {
  enumerable: true,
  get: function () {
    return _index.default;
  }
});
Object.defineProperty(exports, "geoAlbers", {
  enumerable: true,
  get: function () {
    return _albers.default;
  }
});
Object.defineProperty(exports, "geoAlbersUsa", {
  enumerable: true,
  get: function () {
    return _albersUsa.default;
  }
});
Object.defineProperty(exports, "geoAzimuthalEqualArea", {
  enumerable: true,
  get: function () {
    return _azimuthalEqualArea.default;
  }
});
Object.defineProperty(exports, "geoAzimuthalEqualAreaRaw", {
  enumerable: true,
  get: function () {
    return _azimuthalEqualArea.azimuthalEqualAreaRaw;
  }
});
Object.defineProperty(exports, "geoAzimuthalEquidistant", {
  enumerable: true,
  get: function () {
    return _azimuthalEquidistant.default;
  }
});
Object.defineProperty(exports, "geoAzimuthalEquidistantRaw", {
  enumerable: true,
  get: function () {
    return _azimuthalEquidistant.azimuthalEquidistantRaw;
  }
});
Object.defineProperty(exports, "geoConicConformal", {
  enumerable: true,
  get: function () {
    return _conicConformal.default;
  }
});
Object.defineProperty(exports, "geoConicConformalRaw", {
  enumerable: true,
  get: function () {
    return _conicConformal.conicConformalRaw;
  }
});
Object.defineProperty(exports, "geoConicEqualArea", {
  enumerable: true,
  get: function () {
    return _conicEqualArea.default;
  }
});
Object.defineProperty(exports, "geoConicEqualAreaRaw", {
  enumerable: true,
  get: function () {
    return _conicEqualArea.conicEqualAreaRaw;
  }
});
Object.defineProperty(exports, "geoConicEquidistant", {
  enumerable: true,
  get: function () {
    return _conicEquidistant.default;
  }
});
Object.defineProperty(exports, "geoConicEquidistantRaw", {
  enumerable: true,
  get: function () {
    return _conicEquidistant.conicEquidistantRaw;
  }
});
Object.defineProperty(exports, "geoEquirectangular", {
  enumerable: true,
  get: function () {
    return _equirectangular.default;
  }
});
Object.defineProperty(exports, "geoEquirectangularRaw", {
  enumerable: true,
  get: function () {
    return _equirectangular.equirectangularRaw;
  }
});
Object.defineProperty(exports, "geoGnomonic", {
  enumerable: true,
  get: function () {
    return _gnomonic.default;
  }
});
Object.defineProperty(exports, "geoGnomonicRaw", {
  enumerable: true,
  get: function () {
    return _gnomonic.gnomonicRaw;
  }
});
Object.defineProperty(exports, "geoIdentity", {
  enumerable: true,
  get: function () {
    return _identity.default;
  }
});
Object.defineProperty(exports, "geoProjection", {
  enumerable: true,
  get: function () {
    return _index2.default;
  }
});
Object.defineProperty(exports, "geoProjectionMutator", {
  enumerable: true,
  get: function () {
    return _index2.projectionMutator;
  }
});
Object.defineProperty(exports, "geoMercator", {
  enumerable: true,
  get: function () {
    return _mercator.default;
  }
});
Object.defineProperty(exports, "geoMercatorRaw", {
  enumerable: true,
  get: function () {
    return _mercator.mercatorRaw;
  }
});
Object.defineProperty(exports, "geoNaturalEarth1", {
  enumerable: true,
  get: function () {
    return _naturalEarth.default;
  }
});
Object.defineProperty(exports, "geoNaturalEarth1Raw", {
  enumerable: true,
  get: function () {
    return _naturalEarth.naturalEarth1Raw;
  }
});
Object.defineProperty(exports, "geoOrthographic", {
  enumerable: true,
  get: function () {
    return _orthographic.default;
  }
});
Object.defineProperty(exports, "geoOrthographicRaw", {
  enumerable: true,
  get: function () {
    return _orthographic.orthographicRaw;
  }
});
Object.defineProperty(exports, "geoStereographic", {
  enumerable: true,
  get: function () {
    return _stereographic.default;
  }
});
Object.defineProperty(exports, "geoStereographicRaw", {
  enumerable: true,
  get: function () {
    return _stereographic.stereographicRaw;
  }
});
Object.defineProperty(exports, "geoTransverseMercator", {
  enumerable: true,
  get: function () {
    return _transverseMercator.default;
  }
});
Object.defineProperty(exports, "geoTransverseMercatorRaw", {
  enumerable: true,
  get: function () {
    return _transverseMercator.transverseMercatorRaw;
  }
});
Object.defineProperty(exports, "geoRotation", {
  enumerable: true,
  get: function () {
    return _rotation.default;
  }
});
Object.defineProperty(exports, "geoStream", {
  enumerable: true,
  get: function () {
    return _stream.default;
  }
});
Object.defineProperty(exports, "geoTransform", {
  enumerable: true,
  get: function () {
    return _transform.default;
  }
});

var _area = _interopRequireDefault(require("./src/area"));

var _bounds = _interopRequireDefault(require("./src/bounds"));

var _centroid = _interopRequireDefault(require("./src/centroid"));

var _circle = _interopRequireDefault(require("./src/circle"));

var _antimeridian = _interopRequireDefault(require("./src/clip/antimeridian"));

var _circle2 = _interopRequireDefault(require("./src/clip/circle"));

var _extent = _interopRequireDefault(require("./src/clip/extent"));

var _rectangle = _interopRequireDefault(require("./src/clip/rectangle"));

var _contains = _interopRequireDefault(require("./src/contains"));

var _distance = _interopRequireDefault(require("./src/distance"));

var _graticule = _interopRequireWildcard(require("./src/graticule"));

var _interpolate = _interopRequireDefault(require("./src/interpolate"));

var _length = _interopRequireDefault(require("./src/length"));

var _index = _interopRequireDefault(require("./src/path/index"));

var _albers = _interopRequireDefault(require("./src/projection/albers"));

var _albersUsa = _interopRequireDefault(require("./src/projection/albersUsa"));

var _azimuthalEqualArea = _interopRequireWildcard(require("./src/projection/azimuthalEqualArea"));

var _azimuthalEquidistant = _interopRequireWildcard(require("./src/projection/azimuthalEquidistant"));

var _conicConformal = _interopRequireWildcard(require("./src/projection/conicConformal"));

var _conicEqualArea = _interopRequireWildcard(require("./src/projection/conicEqualArea"));

var _conicEquidistant = _interopRequireWildcard(require("./src/projection/conicEquidistant"));

var _equirectangular = _interopRequireWildcard(require("./src/projection/equirectangular"));

var _gnomonic = _interopRequireWildcard(require("./src/projection/gnomonic"));

var _identity = _interopRequireDefault(require("./src/projection/identity"));

var _index2 = _interopRequireWildcard(require("./src/projection/index"));

var _mercator = _interopRequireWildcard(require("./src/projection/mercator"));

var _naturalEarth = _interopRequireWildcard(require("./src/projection/naturalEarth1"));

var _orthographic = _interopRequireWildcard(require("./src/projection/orthographic"));

var _stereographic = _interopRequireWildcard(require("./src/projection/stereographic"));

var _transverseMercator = _interopRequireWildcard(require("./src/projection/transverseMercator"));

var _rotation = _interopRequireDefault(require("./src/rotation"));

var _stream = _interopRequireDefault(require("./src/stream"));

var _transform = _interopRequireDefault(require("./src/transform"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./src/area":"dpXv","./src/bounds":"wXR4","./src/centroid":"pQGp","./src/circle":"dbGM","./src/clip/antimeridian":"CWnN","./src/clip/circle":"uulM","./src/clip/extent":"Pttt","./src/clip/rectangle":"E6SH","./src/contains":"bl00","./src/distance":"IoFW","./src/graticule":"fWgv","./src/interpolate":"PyvU","./src/length":"rgN9","./src/path/index":"A7VF","./src/projection/albers":"HUYT","./src/projection/albersUsa":"WyCU","./src/projection/azimuthalEqualArea":"c9jZ","./src/projection/azimuthalEquidistant":"DPfU","./src/projection/conicConformal":"QZHg","./src/projection/conicEqualArea":"uvEu","./src/projection/conicEquidistant":"wKng","./src/projection/equirectangular":"xN4O","./src/projection/gnomonic":"bmsS","./src/projection/identity":"LapZ","./src/projection/index":"t1yD","./src/projection/mercator":"Yvwi","./src/projection/naturalEarth1":"yWpl","./src/projection/orthographic":"H7pW","./src/projection/stereographic":"bNxf","./src/projection/transverseMercator":"BGbj","./src/rotation":"KwdP","./src/stream":"XBFK","./src/transform":"ubFV"}],"brcY":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function defaultSeparation(a, b) {
  return a.parent === b.parent ? 1 : 2;
}

function meanX(children) {
  return children.reduce(meanXReduce, 0) / children.length;
}

function meanXReduce(x, c) {
  return x + c.x;
}

function maxY(children) {
  return 1 + children.reduce(maxYReduce, 0);
}

function maxYReduce(y, c) {
  return Math.max(y, c.y);
}

function leafLeft(node) {
  var children;

  while (children = node.children) node = children[0];

  return node;
}

function leafRight(node) {
  var children;

  while (children = node.children) node = children[children.length - 1];

  return node;
}

function _default() {
  var separation = defaultSeparation,
      dx = 1,
      dy = 1,
      nodeSize = false;

  function cluster(root) {
    var previousNode,
        x = 0; // First walk, computing the initial x & y values.

    root.eachAfter(function (node) {
      var children = node.children;

      if (children) {
        node.x = meanX(children);
        node.y = maxY(children);
      } else {
        node.x = previousNode ? x += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });
    var left = leafLeft(root),
        right = leafRight(root),
        x0 = left.x - separation(left, right) / 2,
        x1 = right.x + separation(right, left) / 2; // Second walk, normalizing x & y to the desired size.

    return root.eachAfter(nodeSize ? function (node) {
      node.x = (node.x - root.x) * dx;
      node.y = (root.y - node.y) * dy;
    } : function (node) {
      node.x = (node.x - x0) / (x1 - x0) * dx;
      node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
    });
  }

  cluster.separation = function (x) {
    return arguments.length ? (separation = x, cluster) : separation;
  };

  cluster.size = function (x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster) : nodeSize ? null : [dx, dy];
  };

  cluster.nodeSize = function (x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster) : nodeSize ? [dx, dy] : null;
  };

  return cluster;
}
},{}],"jJjM":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function count(node) {
  var sum = 0,
      children = node.children,
      i = children && children.length;
  if (!i) sum = 1;else while (--i >= 0) sum += children[i].value;
  node.value = sum;
}

function _default() {
  return this.eachAfter(count);
}
},{}],"YN75":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(callback) {
  var node = this,
      current,
      next = [node],
      children,
      i,
      n;

  do {
    current = next.reverse(), next = [];

    while (node = current.pop()) {
      callback(node), children = node.children;
      if (children) for (i = 0, n = children.length; i < n; ++i) {
        next.push(children[i]);
      }
    }
  } while (next.length);

  return this;
}
},{}],"b04E":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(callback) {
  var node = this,
      nodes = [node],
      children,
      i;

  while (node = nodes.pop()) {
    callback(node), children = node.children;
    if (children) for (i = children.length - 1; i >= 0; --i) {
      nodes.push(children[i]);
    }
  }

  return this;
}
},{}],"oHKJ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(callback) {
  var node = this,
      nodes = [node],
      next = [],
      children,
      i,
      n;

  while (node = nodes.pop()) {
    next.push(node), children = node.children;
    if (children) for (i = 0, n = children.length; i < n; ++i) {
      nodes.push(children[i]);
    }
  }

  while (node = next.pop()) {
    callback(node);
  }

  return this;
}
},{}],"Btd4":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(value) {
  return this.eachAfter(function (node) {
    var sum = +value(node.data) || 0,
        children = node.children,
        i = children && children.length;

    while (--i >= 0) sum += children[i].value;

    node.value = sum;
  });
}
},{}],"q7tv":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(compare) {
  return this.eachBefore(function (node) {
    if (node.children) {
      node.children.sort(compare);
    }
  });
}
},{}],"x0YQ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(end) {
  var start = this,
      ancestor = leastCommonAncestor(start, end),
      nodes = [start];

  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }

  var k = nodes.length;

  while (end !== ancestor) {
    nodes.splice(k, 0, end);
    end = end.parent;
  }

  return nodes;
}

function leastCommonAncestor(a, b) {
  if (a === b) return a;
  var aNodes = a.ancestors(),
      bNodes = b.ancestors(),
      c = null;
  a = aNodes.pop();
  b = bNodes.pop();

  while (a === b) {
    c = a;
    a = aNodes.pop();
    b = bNodes.pop();
  }

  return c;
}
},{}],"fOge":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default() {
  var node = this,
      nodes = [node];

  while (node = node.parent) {
    nodes.push(node);
  }

  return nodes;
}
},{}],"chHE":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default() {
  var nodes = [];
  this.each(function (node) {
    nodes.push(node);
  });
  return nodes;
}
},{}],"ResT":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default() {
  var leaves = [];
  this.eachBefore(function (node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}
},{}],"gBUX":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default() {
  var root = this,
      links = [];
  root.each(function (node) {
    if (node !== root) {
      // Don’t include the root’s parent, if any.
      links.push({
        source: node.parent,
        target: node
      });
    }
  });
  return links;
}
},{}],"LCo2":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = hierarchy;
exports.computeHeight = computeHeight;
exports.Node = Node;

var _count = _interopRequireDefault(require("./count"));

var _each = _interopRequireDefault(require("./each"));

var _eachBefore = _interopRequireDefault(require("./eachBefore"));

var _eachAfter = _interopRequireDefault(require("./eachAfter"));

var _sum = _interopRequireDefault(require("./sum"));

var _sort = _interopRequireDefault(require("./sort"));

var _path = _interopRequireDefault(require("./path"));

var _ancestors = _interopRequireDefault(require("./ancestors"));

var _descendants = _interopRequireDefault(require("./descendants"));

var _leaves = _interopRequireDefault(require("./leaves"));

var _links = _interopRequireDefault(require("./links"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function hierarchy(data, children) {
  var root = new Node(data),
      valued = +data.value && (root.value = data.value),
      node,
      nodes = [root],
      child,
      childs,
      i,
      n;
  if (children == null) children = defaultChildren;

  while (node = nodes.pop()) {
    if (valued) node.value = +node.data.value;

    if ((childs = children(node.data)) && (n = childs.length)) {
      node.children = new Array(n);

      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new Node(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }

  return root.eachBefore(computeHeight);
}

function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}

function defaultChildren(d) {
  return d.children;
}

function copyData(node) {
  node.data = node.data.data;
}

function computeHeight(node) {
  var height = 0;

  do node.height = height; while ((node = node.parent) && node.height < ++height);
}

function Node(data) {
  this.data = data;
  this.depth = this.height = 0;
  this.parent = null;
}

Node.prototype = hierarchy.prototype = {
  constructor: Node,
  count: _count.default,
  each: _each.default,
  eachAfter: _eachAfter.default,
  eachBefore: _eachBefore.default,
  sum: _sum.default,
  sort: _sort.default,
  path: _path.default,
  ancestors: _ancestors.default,
  descendants: _descendants.default,
  leaves: _leaves.default,
  links: _links.default,
  copy: node_copy
};
},{"./count":"jJjM","./each":"YN75","./eachBefore":"b04E","./eachAfter":"oHKJ","./sum":"Btd4","./sort":"q7tv","./path":"x0YQ","./ancestors":"fOge","./descendants":"chHE","./leaves":"ResT","./links":"gBUX"}],"Wl9w":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.shuffle = shuffle;
exports.slice = void 0;
var slice = Array.prototype.slice;
exports.slice = slice;

function shuffle(array) {
  var m = array.length,
      t,
      i;

  while (m) {
    i = Math.random() * m-- | 0;
    t = array[m];
    array[m] = array[i];
    array[i] = t;
  }

  return array;
}
},{}],"ZzhU":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _array = require("../array");

function _default(circles) {
  var i = 0,
      n = (circles = (0, _array.shuffle)(_array.slice.call(circles))).length,
      B = [],
      p,
      e;

  while (i < n) {
    p = circles[i];
    if (e && enclosesWeak(e, p)) ++i;else e = encloseBasis(B = extendBasis(B, p)), i = 0;
  }

  return e;
}

function extendBasis(B, p) {
  var i, j;
  if (enclosesWeakAll(p, B)) return [p]; // If we get here then B must have at least one element.

  for (i = 0; i < B.length; ++i) {
    if (enclosesNot(p, B[i]) && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
      return [B[i], p];
    }
  } // If we get here then B must have at least two elements.


  for (i = 0; i < B.length - 1; ++i) {
    for (j = i + 1; j < B.length; ++j) {
      if (enclosesNot(encloseBasis2(B[i], B[j]), p) && enclosesNot(encloseBasis2(B[i], p), B[j]) && enclosesNot(encloseBasis2(B[j], p), B[i]) && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
        return [B[i], B[j], p];
      }
    }
  } // If we get here then something is very wrong.


  throw new Error();
}

function enclosesNot(a, b) {
  var dr = a.r - b.r,
      dx = b.x - a.x,
      dy = b.y - a.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}

function enclosesWeak(a, b) {
  var dr = a.r - b.r + 1e-6,
      dx = b.x - a.x,
      dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}

function enclosesWeakAll(a, B) {
  for (var i = 0; i < B.length; ++i) {
    if (!enclosesWeak(a, B[i])) {
      return false;
    }
  }

  return true;
}

function encloseBasis(B) {
  switch (B.length) {
    case 1:
      return encloseBasis1(B[0]);

    case 2:
      return encloseBasis2(B[0], B[1]);

    case 3:
      return encloseBasis3(B[0], B[1], B[2]);
  }
}

function encloseBasis1(a) {
  return {
    x: a.x,
    y: a.y,
    r: a.r
  };
}

function encloseBasis2(a, b) {
  var x1 = a.x,
      y1 = a.y,
      r1 = a.r,
      x2 = b.x,
      y2 = b.y,
      r2 = b.r,
      x21 = x2 - x1,
      y21 = y2 - y1,
      r21 = r2 - r1,
      l = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x1 + x2 + x21 / l * r21) / 2,
    y: (y1 + y2 + y21 / l * r21) / 2,
    r: (l + r1 + r2) / 2
  };
}

function encloseBasis3(a, b, c) {
  var x1 = a.x,
      y1 = a.y,
      r1 = a.r,
      x2 = b.x,
      y2 = b.y,
      r2 = b.r,
      x3 = c.x,
      y3 = c.y,
      r3 = c.r,
      a2 = x1 - x2,
      a3 = x1 - x3,
      b2 = y1 - y2,
      b3 = y1 - y3,
      c2 = r2 - r1,
      c3 = r3 - r1,
      d1 = x1 * x1 + y1 * y1 - r1 * r1,
      d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2,
      d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3,
      ab = a3 * b2 - a2 * b3,
      xa = (b2 * d3 - b3 * d2) / (ab * 2) - x1,
      xb = (b3 * c2 - b2 * c3) / ab,
      ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1,
      yb = (a2 * c3 - a3 * c2) / ab,
      A = xb * xb + yb * yb - 1,
      B = 2 * (r1 + xa * xb + ya * yb),
      C = xa * xa + ya * ya - r1 * r1,
      r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
  return {
    x: x1 + xa + xb * r,
    y: y1 + ya + yb * r,
    r: r
  };
}
},{"../array":"Wl9w"}],"efS5":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.packEnclose = packEnclose;
exports.default = _default;

var _enclose = _interopRequireDefault(require("./enclose"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function place(a, b, c) {
  var ax = a.x,
      ay = a.y,
      da = b.r + c.r,
      db = a.r + c.r,
      dx = b.x - ax,
      dy = b.y - ay,
      dc = dx * dx + dy * dy;

  if (dc) {
    var x = 0.5 + ((db *= db) - (da *= da)) / (2 * dc),
        y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);
    c.x = ax + x * dx + y * dy;
    c.y = ay + x * dy - y * dx;
  } else {
    c.x = ax + db;
    c.y = ay;
  }
}

function intersects(a, b) {
  var dx = b.x - a.x,
      dy = b.y - a.y,
      dr = a.r + b.r;
  return dr * dr - 1e-6 > dx * dx + dy * dy;
}

function score(node) {
  var a = node._,
      b = node.next._,
      ab = a.r + b.r,
      dx = (a.x * b.r + b.x * a.r) / ab,
      dy = (a.y * b.r + b.y * a.r) / ab;
  return dx * dx + dy * dy;
}

function Node(circle) {
  this._ = circle;
  this.next = null;
  this.previous = null;
}

function packEnclose(circles) {
  if (!(n = circles.length)) return 0;
  var a, b, c, n, aa, ca, i, j, k, sj, sk; // Place the first circle.

  a = circles[0], a.x = 0, a.y = 0;
  if (!(n > 1)) return a.r; // Place the second circle.

  b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
  if (!(n > 2)) return a.r + b.r; // Place the third circle.

  place(b, a, c = circles[2]); // Initialize the front-chain using the first three circles a, b and c.

  a = new Node(a), b = new Node(b), c = new Node(c);
  a.next = c.previous = b;
  b.next = a.previous = c;
  c.next = b.previous = a; // Attempt to place each remaining circle…

  pack: for (i = 3; i < n; ++i) {
    place(a._, b._, c = circles[i]), c = new Node(c); // Find the closest intersecting circle on the front-chain, if any.
    // “Closeness” is determined by linear distance along the front-chain.
    // “Ahead” or “behind” is likewise determined by linear distance.

    j = b.next, k = a.previous, sj = b._.r, sk = a._.r;

    do {
      if (sj <= sk) {
        if (intersects(j._, c._)) {
          b = j, a.next = b, b.previous = a, --i;
          continue pack;
        }

        sj += j._.r, j = j.next;
      } else {
        if (intersects(k._, c._)) {
          a = k, a.next = b, b.previous = a, --i;
          continue pack;
        }

        sk += k._.r, k = k.previous;
      }
    } while (j !== k.next); // Success! Insert the new circle c between a and b.


    c.previous = a, c.next = b, a.next = b.previous = b = c; // Compute the new closest circle pair to the centroid.

    aa = score(a);

    while ((c = c.next) !== b) {
      if ((ca = score(c)) < aa) {
        a = c, aa = ca;
      }
    }

    b = a.next;
  } // Compute the enclosing circle of the front chain.


  a = [b._], c = b;

  while ((c = c.next) !== b) a.push(c._);

  c = (0, _enclose.default)(a); // Translate the circles to put the enclosing circle around the origin.

  for (i = 0; i < n; ++i) a = circles[i], a.x -= c.x, a.y -= c.y;

  return c.r;
}

function _default(circles) {
  packEnclose(circles);
  return circles;
}
},{"./enclose":"ZzhU"}],"OleL":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.optional = optional;
exports.required = required;

function optional(f) {
  return f == null ? null : required(f);
}

function required(f) {
  if (typeof f !== "function") throw new Error();
  return f;
}
},{}],"kYMf":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.constantZero = constantZero;
exports.default = _default;

function constantZero() {
  return 0;
}

function _default(x) {
  return function () {
    return x;
  };
}
},{}],"aVuj":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _siblings = require("./siblings");

var _accessors = require("../accessors");

var _constant = _interopRequireWildcard(require("../constant"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function defaultRadius(d) {
  return Math.sqrt(d.value);
}

function _default() {
  var radius = null,
      dx = 1,
      dy = 1,
      padding = _constant.constantZero;

  function pack(root) {
    root.x = dx / 2, root.y = dy / 2;

    if (radius) {
      root.eachBefore(radiusLeaf(radius)).eachAfter(packChildren(padding, 0.5)).eachBefore(translateChild(1));
    } else {
      root.eachBefore(radiusLeaf(defaultRadius)).eachAfter(packChildren(_constant.constantZero, 1)).eachAfter(packChildren(padding, root.r / Math.min(dx, dy))).eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
    }

    return root;
  }

  pack.radius = function (x) {
    return arguments.length ? (radius = (0, _accessors.optional)(x), pack) : radius;
  };

  pack.size = function (x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], pack) : [dx, dy];
  };

  pack.padding = function (x) {
    return arguments.length ? (padding = typeof x === "function" ? x : (0, _constant.default)(+x), pack) : padding;
  };

  return pack;
}

function radiusLeaf(radius) {
  return function (node) {
    if (!node.children) {
      node.r = Math.max(0, +radius(node) || 0);
    }
  };
}

function packChildren(padding, k) {
  return function (node) {
    if (children = node.children) {
      var children,
          i,
          n = children.length,
          r = padding(node) * k || 0,
          e;
      if (r) for (i = 0; i < n; ++i) children[i].r += r;
      e = (0, _siblings.packEnclose)(children);
      if (r) for (i = 0; i < n; ++i) children[i].r -= r;
      node.r = e + r;
    }
  };
}

function translateChild(k) {
  return function (node) {
    var parent = node.parent;
    node.r *= k;

    if (parent) {
      node.x = parent.x + k * node.x;
      node.y = parent.y + k * node.y;
    }
  };
}
},{"./siblings":"efS5","../accessors":"OleL","../constant":"kYMf"}],"PETl":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
}
},{}],"L3aV":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (x1 - x0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.y0 = y0, node.y1 = y1;
    node.x0 = x0, node.x1 = x0 += node.value * k;
  }
}
},{}],"hWBO":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _round = _interopRequireDefault(require("./treemap/round"));

var _dice = _interopRequireDefault(require("./treemap/dice"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default() {
  var dx = 1,
      dy = 1,
      padding = 0,
      round = false;

  function partition(root) {
    var n = root.height + 1;
    root.x0 = root.y0 = padding;
    root.x1 = dx;
    root.y1 = dy / n;
    root.eachBefore(positionNode(dy, n));
    if (round) root.eachBefore(_round.default);
    return root;
  }

  function positionNode(dy, n) {
    return function (node) {
      if (node.children) {
        (0, _dice.default)(node, node.x0, dy * (node.depth + 1) / n, node.x1, dy * (node.depth + 2) / n);
      }

      var x0 = node.x0,
          y0 = node.y0,
          x1 = node.x1 - padding,
          y1 = node.y1 - padding;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      node.x0 = x0;
      node.y0 = y0;
      node.x1 = x1;
      node.y1 = y1;
    };
  }

  partition.round = function (x) {
    return arguments.length ? (round = !!x, partition) : round;
  };

  partition.size = function (x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], partition) : [dx, dy];
  };

  partition.padding = function (x) {
    return arguments.length ? (padding = +x, partition) : padding;
  };

  return partition;
}
},{"./treemap/round":"PETl","./treemap/dice":"L3aV"}],"bJDQ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _accessors = require("./accessors");

var _index = require("./hierarchy/index");

var keyPrefix = "$",
    // Protect against keys like “__proto__”.
preroot = {
  depth: -1
},
    ambiguous = {};

function defaultId(d) {
  return d.id;
}

function defaultParentId(d) {
  return d.parentId;
}

function _default() {
  var id = defaultId,
      parentId = defaultParentId;

  function stratify(data) {
    var d,
        i,
        n = data.length,
        root,
        parent,
        node,
        nodes = new Array(n),
        nodeId,
        nodeKey,
        nodeByKey = {};

    for (i = 0; i < n; ++i) {
      d = data[i], node = nodes[i] = new _index.Node(d);

      if ((nodeId = id(d, i, data)) != null && (nodeId += "")) {
        nodeKey = keyPrefix + (node.id = nodeId);
        nodeByKey[nodeKey] = nodeKey in nodeByKey ? ambiguous : node;
      }
    }

    for (i = 0; i < n; ++i) {
      node = nodes[i], nodeId = parentId(data[i], i, data);

      if (nodeId == null || !(nodeId += "")) {
        if (root) throw new Error("multiple roots");
        root = node;
      } else {
        parent = nodeByKey[keyPrefix + nodeId];
        if (!parent) throw new Error("missing: " + nodeId);
        if (parent === ambiguous) throw new Error("ambiguous: " + nodeId);
        if (parent.children) parent.children.push(node);else parent.children = [node];
        node.parent = parent;
      }
    }

    if (!root) throw new Error("no root");
    root.parent = preroot;
    root.eachBefore(function (node) {
      node.depth = node.parent.depth + 1;
      --n;
    }).eachBefore(_index.computeHeight);
    root.parent = null;
    if (n > 0) throw new Error("cycle");
    return root;
  }

  stratify.id = function (x) {
    return arguments.length ? (id = (0, _accessors.required)(x), stratify) : id;
  };

  stratify.parentId = function (x) {
    return arguments.length ? (parentId = (0, _accessors.required)(x), stratify) : parentId;
  };

  return stratify;
}
},{"./accessors":"OleL","./hierarchy/index":"LCo2"}],"nrLh":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _index = require("./hierarchy/index");

function defaultSeparation(a, b) {
  return a.parent === b.parent ? 1 : 2;
} // function radialSeparation(a, b) {
//   return (a.parent === b.parent ? 1 : 2) / a.depth;
// }
// This function is used to traverse the left contour of a subtree (or
// subforest). It returns the successor of v on this contour. This successor is
// either given by the leftmost child of v or by the thread of v. The function
// returns null if and only if v is on the highest level of its subtree.


function nextLeft(v) {
  var children = v.children;
  return children ? children[0] : v.t;
} // This function works analogously to nextLeft.


function nextRight(v) {
  var children = v.children;
  return children ? children[children.length - 1] : v.t;
} // Shifts the current subtree rooted at w+. This is done by increasing
// prelim(w+) and mod(w+) by shift.


function moveSubtree(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
} // All other shifts, applied to the smaller subtrees between w- and w+, are
// performed by this function. To prepare the shifts, we have to adjust
// change(w+), shift(w+), and change(w-).


function executeShifts(v) {
  var shift = 0,
      change = 0,
      children = v.children,
      i = children.length,
      w;

  while (--i >= 0) {
    w = children[i];
    w.z += shift;
    w.m += shift;
    shift += w.s + (change += w.c);
  }
} // If vi-’s ancestor is a sibling of v, returns vi-’s ancestor. Otherwise,
// returns the specified (default) ancestor.


function nextAncestor(vim, v, ancestor) {
  return vim.a.parent === v.parent ? vim.a : ancestor;
}

function TreeNode(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null; // default ancestor

  this.a = this; // ancestor

  this.z = 0; // prelim

  this.m = 0; // mod

  this.c = 0; // change

  this.s = 0; // shift

  this.t = null; // thread

  this.i = i; // number
}

TreeNode.prototype = Object.create(_index.Node.prototype);

function treeRoot(root) {
  var tree = new TreeNode(root, 0),
      node,
      nodes = [tree],
      child,
      children,
      i,
      n;

  while (node = nodes.pop()) {
    if (children = node._.children) {
      node.children = new Array(n = children.length);

      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new TreeNode(children[i], i));
        child.parent = node;
      }
    }
  }

  (tree.parent = new TreeNode(null, 0)).children = [tree];
  return tree;
} // Node-link tree diagram using the Reingold-Tilford "tidy" algorithm


function _default() {
  var separation = defaultSeparation,
      dx = 1,
      dy = 1,
      nodeSize = null;

  function tree(root) {
    var t = treeRoot(root); // Compute the layout using Buchheim et al.’s algorithm.

    t.eachAfter(firstWalk), t.parent.m = -t.z;
    t.eachBefore(secondWalk); // If a fixed node size is specified, scale x and y.

    if (nodeSize) root.eachBefore(sizeNode); // If a fixed tree size is specified, scale x and y based on the extent.
    // Compute the left-most, right-most, and depth-most nodes for extents.
    else {
        var left = root,
            right = root,
            bottom = root;
        root.eachBefore(function (node) {
          if (node.x < left.x) left = node;
          if (node.x > right.x) right = node;
          if (node.depth > bottom.depth) bottom = node;
        });
        var s = left === right ? 1 : separation(left, right) / 2,
            tx = s - left.x,
            kx = dx / (right.x + s + tx),
            ky = dy / (bottom.depth || 1);
        root.eachBefore(function (node) {
          node.x = (node.x + tx) * kx;
          node.y = node.depth * ky;
        });
      }
    return root;
  } // Computes a preliminary x-coordinate for v. Before that, FIRST WALK is
  // applied recursively to the children of v, as well as the function
  // APPORTION. After spacing out the children by calling EXECUTE SHIFTS, the
  // node v is placed to the midpoint of its outermost children.


  function firstWalk(v) {
    var children = v.children,
        siblings = v.parent.children,
        w = v.i ? siblings[v.i - 1] : null;

    if (children) {
      executeShifts(v);
      var midpoint = (children[0].z + children[children.length - 1].z) / 2;

      if (w) {
        v.z = w.z + separation(v._, w._);
        v.m = v.z - midpoint;
      } else {
        v.z = midpoint;
      }
    } else if (w) {
      v.z = w.z + separation(v._, w._);
    }

    v.parent.A = apportion(v, w, v.parent.A || siblings[0]);
  } // Computes all real x-coordinates by summing up the modifiers recursively.


  function secondWalk(v) {
    v._.x = v.z + v.parent.m;
    v.m += v.parent.m;
  } // The core of the algorithm. Here, a new subtree is combined with the
  // previous subtrees. Threads are used to traverse the inside and outside
  // contours of the left and right subtree up to the highest common level. The
  // vertices used for the traversals are vi+, vi-, vo-, and vo+, where the
  // superscript o means outside and i means inside, the subscript - means left
  // subtree and + means right subtree. For summing up the modifiers along the
  // contour, we use respective variables si+, si-, so-, and so+. Whenever two
  // nodes of the inside contours conflict, we compute the left one of the
  // greatest uncommon ancestors using the function ANCESTOR and call MOVE
  // SUBTREE to shift the subtree and prepare the shifts of smaller subtrees.
  // Finally, we add a new thread (if necessary).


  function apportion(v, w, ancestor) {
    if (w) {
      var vip = v,
          vop = v,
          vim = w,
          vom = vip.parent.children[0],
          sip = vip.m,
          sop = vop.m,
          sim = vim.m,
          som = vom.m,
          shift;

      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);

        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
          sip += shift;
          sop += shift;
        }

        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }

      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }

      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v;
      }
    }

    return ancestor;
  }

  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }

  tree.separation = function (x) {
    return arguments.length ? (separation = x, tree) : separation;
  };

  tree.size = function (x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree) : nodeSize ? null : [dx, dy];
  };

  tree.nodeSize = function (x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree) : nodeSize ? [dx, dy] : null;
  };

  return tree;
}
},{"./hierarchy/index":"LCo2"}],"RVbL":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      node,
      i = -1,
      n = nodes.length,
      k = parent.value && (y1 - y0) / parent.value;

  while (++i < n) {
    node = nodes[i], node.x0 = x0, node.x1 = x1;
    node.y0 = y0, node.y1 = y0 += node.value * k;
  }
}
},{}],"jyLZ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.squarifyRatio = squarifyRatio;
exports.default = exports.phi = void 0;

var _dice = _interopRequireDefault(require("./dice"));

var _slice = _interopRequireDefault(require("./slice"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var phi = (1 + Math.sqrt(5)) / 2;
exports.phi = phi;

function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
  var rows = [],
      nodes = parent.children,
      row,
      nodeValue,
      i0 = 0,
      i1 = 0,
      n = nodes.length,
      dx,
      dy,
      value = parent.value,
      sumValue,
      minValue,
      maxValue,
      newRatio,
      minRatio,
      alpha,
      beta;

  while (i0 < n) {
    dx = x1 - x0, dy = y1 - y0; // Find the next non-empty node.

    do sumValue = nodes[i1++].value; while (!sumValue && i1 < n);

    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue); // Keep adding nodes while the aspect ratio maintains or improves.

    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue) minValue = nodeValue;
      if (nodeValue > maxValue) maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);

      if (newRatio > minRatio) {
        sumValue -= nodeValue;
        break;
      }

      minRatio = newRatio;
    } // Position and record the row orientation.


    rows.push(row = {
      value: sumValue,
      dice: dx < dy,
      children: nodes.slice(i0, i1)
    });
    if (row.dice) (0, _dice.default)(row, x0, y0, x1, value ? y0 += dy * sumValue / value : y1);else (0, _slice.default)(row, x0, y0, value ? x0 += dx * sumValue / value : x1, y1);
    value -= sumValue, i0 = i1;
  }

  return rows;
}

var _default = function custom(ratio) {
  function squarify(parent, x0, y0, x1, y1) {
    squarifyRatio(ratio, parent, x0, y0, x1, y1);
  }

  squarify.ratio = function (x) {
    return custom((x = +x) > 1 ? x : 1);
  };

  return squarify;
}(phi);

exports.default = _default;
},{"./dice":"L3aV","./slice":"RVbL"}],"cC5L":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _round = _interopRequireDefault(require("./round"));

var _squarify = _interopRequireDefault(require("./squarify"));

var _accessors = require("../accessors");

var _constant = _interopRequireWildcard(require("../constant"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default() {
  var tile = _squarify.default,
      round = false,
      dx = 1,
      dy = 1,
      paddingStack = [0],
      paddingInner = _constant.constantZero,
      paddingTop = _constant.constantZero,
      paddingRight = _constant.constantZero,
      paddingBottom = _constant.constantZero,
      paddingLeft = _constant.constantZero;

  function treemap(root) {
    root.x0 = root.y0 = 0;
    root.x1 = dx;
    root.y1 = dy;
    root.eachBefore(positionNode);
    paddingStack = [0];
    if (round) root.eachBefore(_round.default);
    return root;
  }

  function positionNode(node) {
    var p = paddingStack[node.depth],
        x0 = node.x0 + p,
        y0 = node.y0 + p,
        x1 = node.x1 - p,
        y1 = node.y1 - p;
    if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
    if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
    node.x0 = x0;
    node.y0 = y0;
    node.x1 = x1;
    node.y1 = y1;

    if (node.children) {
      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x0 += paddingLeft(node) - p;
      y0 += paddingTop(node) - p;
      x1 -= paddingRight(node) - p;
      y1 -= paddingBottom(node) - p;
      if (x1 < x0) x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0) y0 = y1 = (y0 + y1) / 2;
      tile(node, x0, y0, x1, y1);
    }
  }

  treemap.round = function (x) {
    return arguments.length ? (round = !!x, treemap) : round;
  };

  treemap.size = function (x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], treemap) : [dx, dy];
  };

  treemap.tile = function (x) {
    return arguments.length ? (tile = (0, _accessors.required)(x), treemap) : tile;
  };

  treemap.padding = function (x) {
    return arguments.length ? treemap.paddingInner(x).paddingOuter(x) : treemap.paddingInner();
  };

  treemap.paddingInner = function (x) {
    return arguments.length ? (paddingInner = typeof x === "function" ? x : (0, _constant.default)(+x), treemap) : paddingInner;
  };

  treemap.paddingOuter = function (x) {
    return arguments.length ? treemap.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap.paddingTop();
  };

  treemap.paddingTop = function (x) {
    return arguments.length ? (paddingTop = typeof x === "function" ? x : (0, _constant.default)(+x), treemap) : paddingTop;
  };

  treemap.paddingRight = function (x) {
    return arguments.length ? (paddingRight = typeof x === "function" ? x : (0, _constant.default)(+x), treemap) : paddingRight;
  };

  treemap.paddingBottom = function (x) {
    return arguments.length ? (paddingBottom = typeof x === "function" ? x : (0, _constant.default)(+x), treemap) : paddingBottom;
  };

  treemap.paddingLeft = function (x) {
    return arguments.length ? (paddingLeft = typeof x === "function" ? x : (0, _constant.default)(+x), treemap) : paddingLeft;
  };

  return treemap;
}
},{"./round":"PETl","./squarify":"jyLZ","../accessors":"OleL","../constant":"kYMf"}],"cDuG":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(parent, x0, y0, x1, y1) {
  var nodes = parent.children,
      i,
      n = nodes.length,
      sum,
      sums = new Array(n + 1);

  for (sums[0] = sum = i = 0; i < n; ++i) {
    sums[i + 1] = sum += nodes[i].value;
  }

  partition(0, n, parent.value, x0, y0, x1, y1);

  function partition(i, j, value, x0, y0, x1, y1) {
    if (i >= j - 1) {
      var node = nodes[i];
      node.x0 = x0, node.y0 = y0;
      node.x1 = x1, node.y1 = y1;
      return;
    }

    var valueOffset = sums[i],
        valueTarget = value / 2 + valueOffset,
        k = i + 1,
        hi = j - 1;

    while (k < hi) {
      var mid = k + hi >>> 1;
      if (sums[mid] < valueTarget) k = mid + 1;else hi = mid;
    }

    if (valueTarget - sums[k - 1] < sums[k] - valueTarget && i + 1 < k) --k;
    var valueLeft = sums[k] - valueOffset,
        valueRight = value - valueLeft;

    if (x1 - x0 > y1 - y0) {
      var xk = (x0 * valueRight + x1 * valueLeft) / value;
      partition(i, k, valueLeft, x0, y0, xk, y1);
      partition(k, j, valueRight, xk, y0, x1, y1);
    } else {
      var yk = (y0 * valueRight + y1 * valueLeft) / value;
      partition(i, k, valueLeft, x0, y0, x1, yk);
      partition(k, j, valueRight, x0, yk, x1, y1);
    }
  }
}
},{}],"dACy":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _dice = _interopRequireDefault(require("./dice"));

var _slice = _interopRequireDefault(require("./slice"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(parent, x0, y0, x1, y1) {
  (parent.depth & 1 ? _slice.default : _dice.default)(parent, x0, y0, x1, y1);
}
},{"./dice":"L3aV","./slice":"RVbL"}],"GrWc":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _dice = _interopRequireDefault(require("./dice"));

var _slice = _interopRequireDefault(require("./slice"));

var _squarify = require("./squarify");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = function custom(ratio) {
  function resquarify(parent, x0, y0, x1, y1) {
    if ((rows = parent._squarify) && rows.ratio === ratio) {
      var rows,
          row,
          nodes,
          i,
          j = -1,
          n,
          m = rows.length,
          value = parent.value;

      while (++j < m) {
        row = rows[j], nodes = row.children;

        for (i = row.value = 0, n = nodes.length; i < n; ++i) row.value += nodes[i].value;

        if (row.dice) (0, _dice.default)(row, x0, y0, x1, y0 += (y1 - y0) * row.value / value);else (0, _slice.default)(row, x0, y0, x0 += (x1 - x0) * row.value / value, y1);
        value -= row.value;
      }
    } else {
      parent._squarify = rows = (0, _squarify.squarifyRatio)(ratio, parent, x0, y0, x1, y1);
      rows.ratio = ratio;
    }
  }

  resquarify.ratio = function (x) {
    return custom((x = +x) > 1 ? x : 1);
  };

  return resquarify;
}(_squarify.phi);

exports.default = _default;
},{"./dice":"L3aV","./slice":"RVbL","./squarify":"jyLZ"}],"Eids":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "cluster", {
  enumerable: true,
  get: function () {
    return _cluster.default;
  }
});
Object.defineProperty(exports, "hierarchy", {
  enumerable: true,
  get: function () {
    return _index.default;
  }
});
Object.defineProperty(exports, "pack", {
  enumerable: true,
  get: function () {
    return _index2.default;
  }
});
Object.defineProperty(exports, "packSiblings", {
  enumerable: true,
  get: function () {
    return _siblings.default;
  }
});
Object.defineProperty(exports, "packEnclose", {
  enumerable: true,
  get: function () {
    return _enclose.default;
  }
});
Object.defineProperty(exports, "partition", {
  enumerable: true,
  get: function () {
    return _partition.default;
  }
});
Object.defineProperty(exports, "stratify", {
  enumerable: true,
  get: function () {
    return _stratify.default;
  }
});
Object.defineProperty(exports, "tree", {
  enumerable: true,
  get: function () {
    return _tree.default;
  }
});
Object.defineProperty(exports, "treemap", {
  enumerable: true,
  get: function () {
    return _index3.default;
  }
});
Object.defineProperty(exports, "treemapBinary", {
  enumerable: true,
  get: function () {
    return _binary.default;
  }
});
Object.defineProperty(exports, "treemapDice", {
  enumerable: true,
  get: function () {
    return _dice.default;
  }
});
Object.defineProperty(exports, "treemapSlice", {
  enumerable: true,
  get: function () {
    return _slice.default;
  }
});
Object.defineProperty(exports, "treemapSliceDice", {
  enumerable: true,
  get: function () {
    return _sliceDice.default;
  }
});
Object.defineProperty(exports, "treemapSquarify", {
  enumerable: true,
  get: function () {
    return _squarify.default;
  }
});
Object.defineProperty(exports, "treemapResquarify", {
  enumerable: true,
  get: function () {
    return _resquarify.default;
  }
});

var _cluster = _interopRequireDefault(require("./src/cluster"));

var _index = _interopRequireDefault(require("./src/hierarchy/index"));

var _index2 = _interopRequireDefault(require("./src/pack/index"));

var _siblings = _interopRequireDefault(require("./src/pack/siblings"));

var _enclose = _interopRequireDefault(require("./src/pack/enclose"));

var _partition = _interopRequireDefault(require("./src/partition"));

var _stratify = _interopRequireDefault(require("./src/stratify"));

var _tree = _interopRequireDefault(require("./src/tree"));

var _index3 = _interopRequireDefault(require("./src/treemap/index"));

var _binary = _interopRequireDefault(require("./src/treemap/binary"));

var _dice = _interopRequireDefault(require("./src/treemap/dice"));

var _slice = _interopRequireDefault(require("./src/treemap/slice"));

var _sliceDice = _interopRequireDefault(require("./src/treemap/sliceDice"));

var _squarify = _interopRequireDefault(require("./src/treemap/squarify"));

var _resquarify = _interopRequireDefault(require("./src/treemap/resquarify"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./src/cluster":"brcY","./src/hierarchy/index":"LCo2","./src/pack/index":"aVuj","./src/pack/siblings":"efS5","./src/pack/enclose":"ZzhU","./src/partition":"hWBO","./src/stratify":"bJDQ","./src/tree":"nrLh","./src/treemap/index":"cC5L","./src/treemap/binary":"cDuG","./src/treemap/dice":"L3aV","./src/treemap/slice":"RVbL","./src/treemap/sliceDice":"dACy","./src/treemap/squarify":"jyLZ","./src/treemap/resquarify":"GrWc"}],"xGSp":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(polygon) {
  var i = -1,
      n = polygon.length,
      a,
      b = polygon[n - 1],
      area = 0;

  while (++i < n) {
    a = b;
    b = polygon[i];
    area += a[1] * b[0] - a[0] * b[1];
  }

  return area / 2;
}
},{}],"ySB4":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(polygon) {
  var i = -1,
      n = polygon.length,
      x = 0,
      y = 0,
      a,
      b = polygon[n - 1],
      c,
      k = 0;

  while (++i < n) {
    a = b;
    b = polygon[i];
    k += c = a[0] * b[1] - b[0] * a[1];
    x += (a[0] + b[0]) * c;
    y += (a[1] + b[1]) * c;
  }

  return k *= 3, [x / k, y / k];
}
},{}],"Q4Lv":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

// Returns the 2D cross product of AB and AC vectors, i.e., the z-component of
// the 3D cross product in a quadrant I Cartesian coordinate system (+x is
// right, +y is up). Returns a positive value if ABC is counter-clockwise,
// negative if clockwise, and zero if the points are collinear.
function _default(a, b, c) {
  return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);
}
},{}],"tgjV":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _cross = _interopRequireDefault(require("./cross"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function lexicographicOrder(a, b) {
  return a[0] - b[0] || a[1] - b[1];
} // Computes the upper convex hull per the monotone chain algorithm.
// Assumes points.length >= 3, is sorted by x, unique in y.
// Returns an array of indices into points in left-to-right order.


function computeUpperHullIndexes(points) {
  var n = points.length,
      indexes = [0, 1],
      size = 2;

  for (var i = 2; i < n; ++i) {
    while (size > 1 && (0, _cross.default)(points[indexes[size - 2]], points[indexes[size - 1]], points[i]) <= 0) --size;

    indexes[size++] = i;
  }

  return indexes.slice(0, size); // remove popped points
}

function _default(points) {
  if ((n = points.length) < 3) return null;
  var i,
      n,
      sortedPoints = new Array(n),
      flippedPoints = new Array(n);

  for (i = 0; i < n; ++i) sortedPoints[i] = [+points[i][0], +points[i][1], i];

  sortedPoints.sort(lexicographicOrder);

  for (i = 0; i < n; ++i) flippedPoints[i] = [sortedPoints[i][0], -sortedPoints[i][1]];

  var upperIndexes = computeUpperHullIndexes(sortedPoints),
      lowerIndexes = computeUpperHullIndexes(flippedPoints); // Construct the hull polygon, removing possible duplicate endpoints.

  var skipLeft = lowerIndexes[0] === upperIndexes[0],
      skipRight = lowerIndexes[lowerIndexes.length - 1] === upperIndexes[upperIndexes.length - 1],
      hull = []; // Add upper hull in right-to-l order.
  // Then add lower hull in left-to-right order.

  for (i = upperIndexes.length - 1; i >= 0; --i) hull.push(points[sortedPoints[upperIndexes[i]][2]]);

  for (i = +skipLeft; i < lowerIndexes.length - skipRight; ++i) hull.push(points[sortedPoints[lowerIndexes[i]][2]]);

  return hull;
}
},{"./cross":"Q4Lv"}],"pcph":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(polygon, point) {
  var n = polygon.length,
      p = polygon[n - 1],
      x = point[0],
      y = point[1],
      x0 = p[0],
      y0 = p[1],
      x1,
      y1,
      inside = false;

  for (var i = 0; i < n; ++i) {
    p = polygon[i], x1 = p[0], y1 = p[1];
    if (y1 > y !== y0 > y && x < (x0 - x1) * (y - y1) / (y0 - y1) + x1) inside = !inside;
    x0 = x1, y0 = y1;
  }

  return inside;
}
},{}],"naEA":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(polygon) {
  var i = -1,
      n = polygon.length,
      b = polygon[n - 1],
      xa,
      ya,
      xb = b[0],
      yb = b[1],
      perimeter = 0;

  while (++i < n) {
    xa = xb;
    ya = yb;
    b = polygon[i];
    xb = b[0];
    yb = b[1];
    xa -= xb;
    ya -= yb;
    perimeter += Math.sqrt(xa * xa + ya * ya);
  }

  return perimeter;
}
},{}],"H6zy":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "polygonArea", {
  enumerable: true,
  get: function () {
    return _area.default;
  }
});
Object.defineProperty(exports, "polygonCentroid", {
  enumerable: true,
  get: function () {
    return _centroid.default;
  }
});
Object.defineProperty(exports, "polygonHull", {
  enumerable: true,
  get: function () {
    return _hull.default;
  }
});
Object.defineProperty(exports, "polygonContains", {
  enumerable: true,
  get: function () {
    return _contains.default;
  }
});
Object.defineProperty(exports, "polygonLength", {
  enumerable: true,
  get: function () {
    return _length.default;
  }
});

var _area = _interopRequireDefault(require("./src/area"));

var _centroid = _interopRequireDefault(require("./src/centroid"));

var _hull = _interopRequireDefault(require("./src/hull"));

var _contains = _interopRequireDefault(require("./src/contains"));

var _length = _interopRequireDefault(require("./src/length"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./src/area":"xGSp","./src/centroid":"ySB4","./src/hull":"tgjV","./src/contains":"pcph","./src/length":"naEA"}],"XTmM":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.slice = void 0;
var slice = [].slice;
exports.slice = slice;
},{}],"Tmdq":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = queue;

var _array = require("./array");

var noabort = {};

function Queue(size) {
  this._size = size;
  this._call = this._error = null;
  this._tasks = [];
  this._data = [];
  this._waiting = this._active = this._ended = this._start = 0; // inside a synchronous task callback?
}

Queue.prototype = queue.prototype = {
  constructor: Queue,
  defer: function (callback) {
    if (typeof callback !== "function") throw new Error("invalid callback");
    if (this._call) throw new Error("defer after await");
    if (this._error != null) return this;

    var t = _array.slice.call(arguments, 1);

    t.push(callback);
    ++this._waiting, this._tasks.push(t);
    poke(this);
    return this;
  },
  abort: function () {
    if (this._error == null) abort(this, new Error("abort"));
    return this;
  },
  await: function (callback) {
    if (typeof callback !== "function") throw new Error("invalid callback");
    if (this._call) throw new Error("multiple await");

    this._call = function (error, results) {
      callback.apply(null, [error].concat(results));
    };

    maybeNotify(this);
    return this;
  },
  awaitAll: function (callback) {
    if (typeof callback !== "function") throw new Error("invalid callback");
    if (this._call) throw new Error("multiple await");
    this._call = callback;
    maybeNotify(this);
    return this;
  }
};

function poke(q) {
  if (!q._start) {
    try {
      start(q);
    } // let the current task complete
    catch (e) {
      if (q._tasks[q._ended + q._active - 1]) abort(q, e); // task errored synchronously
      else if (!q._data) throw e; // await callback errored synchronously
    }
  }
}

function start(q) {
  while (q._start = q._waiting && q._active < q._size) {
    var i = q._ended + q._active,
        t = q._tasks[i],
        j = t.length - 1,
        c = t[j];
    t[j] = end(q, i);
    --q._waiting, ++q._active;
    t = c.apply(null, t);
    if (!q._tasks[i]) continue; // task finished synchronously

    q._tasks[i] = t || noabort;
  }
}

function end(q, i) {
  return function (e, r) {
    if (!q._tasks[i]) return; // ignore multiple callbacks

    --q._active, ++q._ended;
    q._tasks[i] = null;
    if (q._error != null) return; // ignore secondary errors

    if (e != null) {
      abort(q, e);
    } else {
      q._data[i] = r;
      if (q._waiting) poke(q);else maybeNotify(q);
    }
  };
}

function abort(q, e) {
  var i = q._tasks.length,
      t;
  q._error = e; // ignore active callbacks

  q._data = undefined; // allow gc

  q._waiting = NaN; // prevent starting

  while (--i >= 0) {
    if (t = q._tasks[i]) {
      q._tasks[i] = null;

      if (t.abort) {
        try {
          t.abort();
        } catch (e) {
          /* ignore */
        }
      }
    }
  }

  q._active = NaN; // allow notification

  maybeNotify(q);
}

function maybeNotify(q) {
  if (!q._active && q._call) {
    var d = q._data;
    q._data = undefined; // allow gc

    q._call(q._error, d);
  }
}

function queue(concurrency) {
  if (concurrency == null) concurrency = Infinity;else if (!((concurrency = +concurrency) >= 1)) throw new Error("invalid concurrency");
  return new Queue(concurrency);
}
},{"./array":"XTmM"}],"oAMu":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "queue", {
  enumerable: true,
  get: function () {
    return _queue.default;
  }
});

var _queue = _interopRequireDefault(require("./src/queue"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./src/queue":"Tmdq"}],"uDia":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default() {
  return Math.random();
}
},{}],"hmOZ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defaultSource = _interopRequireDefault(require("./defaultSource"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = function sourceRandomUniform(source) {
  function randomUniform(min, max) {
    min = min == null ? 0 : +min;
    max = max == null ? 1 : +max;
    if (arguments.length === 1) max = min, min = 0;else max -= min;
    return function () {
      return source() * max + min;
    };
  }

  randomUniform.source = sourceRandomUniform;
  return randomUniform;
}(_defaultSource.default);

exports.default = _default;
},{"./defaultSource":"uDia"}],"pjsZ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defaultSource = _interopRequireDefault(require("./defaultSource"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = function sourceRandomNormal(source) {
  function randomNormal(mu, sigma) {
    var x, r;
    mu = mu == null ? 0 : +mu;
    sigma = sigma == null ? 1 : +sigma;
    return function () {
      var y; // If available, use the second previously-generated uniform random.

      if (x != null) y = x, x = null; // Otherwise, generate a new x and y.
      else do {
          x = source() * 2 - 1;
          y = source() * 2 - 1;
          r = x * x + y * y;
        } while (!r || r > 1);
      return mu + sigma * y * Math.sqrt(-2 * Math.log(r) / r);
    };
  }

  randomNormal.source = sourceRandomNormal;
  return randomNormal;
}(_defaultSource.default);

exports.default = _default;
},{"./defaultSource":"uDia"}],"lZpB":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defaultSource = _interopRequireDefault(require("./defaultSource"));

var _normal = _interopRequireDefault(require("./normal"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = function sourceRandomLogNormal(source) {
  function randomLogNormal() {
    var randomNormal = _normal.default.source(source).apply(this, arguments);

    return function () {
      return Math.exp(randomNormal());
    };
  }

  randomLogNormal.source = sourceRandomLogNormal;
  return randomLogNormal;
}(_defaultSource.default);

exports.default = _default;
},{"./defaultSource":"uDia","./normal":"pjsZ"}],"DMHS":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defaultSource = _interopRequireDefault(require("./defaultSource"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = function sourceRandomIrwinHall(source) {
  function randomIrwinHall(n) {
    return function () {
      for (var sum = 0, i = 0; i < n; ++i) sum += source();

      return sum;
    };
  }

  randomIrwinHall.source = sourceRandomIrwinHall;
  return randomIrwinHall;
}(_defaultSource.default);

exports.default = _default;
},{"./defaultSource":"uDia"}],"gL6I":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defaultSource = _interopRequireDefault(require("./defaultSource"));

var _irwinHall = _interopRequireDefault(require("./irwinHall"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = function sourceRandomBates(source) {
  function randomBates(n) {
    var randomIrwinHall = _irwinHall.default.source(source)(n);

    return function () {
      return randomIrwinHall() / n;
    };
  }

  randomBates.source = sourceRandomBates;
  return randomBates;
}(_defaultSource.default);

exports.default = _default;
},{"./defaultSource":"uDia","./irwinHall":"DMHS"}],"gEmS":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _defaultSource = _interopRequireDefault(require("./defaultSource"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = function sourceRandomExponential(source) {
  function randomExponential(lambda) {
    return function () {
      return -Math.log(1 - source()) / lambda;
    };
  }

  randomExponential.source = sourceRandomExponential;
  return randomExponential;
}(_defaultSource.default);

exports.default = _default;
},{"./defaultSource":"uDia"}],"sJSR":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "randomUniform", {
  enumerable: true,
  get: function () {
    return _uniform.default;
  }
});
Object.defineProperty(exports, "randomNormal", {
  enumerable: true,
  get: function () {
    return _normal.default;
  }
});
Object.defineProperty(exports, "randomLogNormal", {
  enumerable: true,
  get: function () {
    return _logNormal.default;
  }
});
Object.defineProperty(exports, "randomBates", {
  enumerable: true,
  get: function () {
    return _bates.default;
  }
});
Object.defineProperty(exports, "randomIrwinHall", {
  enumerable: true,
  get: function () {
    return _irwinHall.default;
  }
});
Object.defineProperty(exports, "randomExponential", {
  enumerable: true,
  get: function () {
    return _exponential.default;
  }
});

var _uniform = _interopRequireDefault(require("./src/uniform"));

var _normal = _interopRequireDefault(require("./src/normal"));

var _logNormal = _interopRequireDefault(require("./src/logNormal"));

var _bates = _interopRequireDefault(require("./src/bates"));

var _irwinHall = _interopRequireDefault(require("./src/irwinHall"));

var _exponential = _interopRequireDefault(require("./src/exponential"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./src/uniform":"hmOZ","./src/normal":"pjsZ","./src/logNormal":"lZpB","./src/bates":"gL6I","./src/irwinHall":"DMHS","./src/exponential":"gEmS"}],"ZuZ9":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _d3Collection = require("d3-collection");

var _d3Dispatch = require("d3-dispatch");

function _default(url, callback) {
  var request,
      event = (0, _d3Dispatch.dispatch)("beforesend", "progress", "load", "error"),
      mimeType,
      headers = (0, _d3Collection.map)(),
      xhr = new XMLHttpRequest(),
      user = null,
      password = null,
      response,
      responseType,
      timeout = 0; // If IE does not support CORS, use XDomainRequest.

  if (typeof XDomainRequest !== "undefined" && !("withCredentials" in xhr) && /^(http(s)?:)?\/\//.test(url)) xhr = new XDomainRequest();
  "onload" in xhr ? xhr.onload = xhr.onerror = xhr.ontimeout = respond : xhr.onreadystatechange = function (o) {
    xhr.readyState > 3 && respond(o);
  };

  function respond(o) {
    var status = xhr.status,
        result;

    if (!status && hasResponse(xhr) || status >= 200 && status < 300 || status === 304) {
      if (response) {
        try {
          result = response.call(request, xhr);
        } catch (e) {
          event.call("error", request, e);
          return;
        }
      } else {
        result = xhr;
      }

      event.call("load", request, result);
    } else {
      event.call("error", request, o);
    }
  }

  xhr.onprogress = function (e) {
    event.call("progress", request, e);
  };

  request = {
    header: function (name, value) {
      name = (name + "").toLowerCase();
      if (arguments.length < 2) return headers.get(name);
      if (value == null) headers.remove(name);else headers.set(name, value + "");
      return request;
    },
    // If mimeType is non-null and no Accept header is set, a default is used.
    mimeType: function (value) {
      if (!arguments.length) return mimeType;
      mimeType = value == null ? null : value + "";
      return request;
    },
    // Specifies what type the response value should take;
    // for instance, arraybuffer, blob, document, or text.
    responseType: function (value) {
      if (!arguments.length) return responseType;
      responseType = value;
      return request;
    },
    timeout: function (value) {
      if (!arguments.length) return timeout;
      timeout = +value;
      return request;
    },
    user: function (value) {
      return arguments.length < 1 ? user : (user = value == null ? null : value + "", request);
    },
    password: function (value) {
      return arguments.length < 1 ? password : (password = value == null ? null : value + "", request);
    },
    // Specify how to convert the response content to a specific type;
    // changes the callback value on "load" events.
    response: function (value) {
      response = value;
      return request;
    },
    // Alias for send("GET", …).
    get: function (data, callback) {
      return request.send("GET", data, callback);
    },
    // Alias for send("POST", …).
    post: function (data, callback) {
      return request.send("POST", data, callback);
    },
    // If callback is non-null, it will be used for error and load events.
    send: function (method, data, callback) {
      xhr.open(method, url, true, user, password);
      if (mimeType != null && !headers.has("accept")) headers.set("accept", mimeType + ",*/*");
      if (xhr.setRequestHeader) headers.each(function (value, name) {
        xhr.setRequestHeader(name, value);
      });
      if (mimeType != null && xhr.overrideMimeType) xhr.overrideMimeType(mimeType);
      if (responseType != null) xhr.responseType = responseType;
      if (timeout > 0) xhr.timeout = timeout;
      if (callback == null && typeof data === "function") callback = data, data = null;
      if (callback != null && callback.length === 1) callback = fixCallback(callback);
      if (callback != null) request.on("error", callback).on("load", function (xhr) {
        callback(null, xhr);
      });
      event.call("beforesend", request, xhr);
      xhr.send(data == null ? null : data);
      return request;
    },
    abort: function () {
      xhr.abort();
      return request;
    },
    on: function () {
      var value = event.on.apply(event, arguments);
      return value === event ? request : value;
    }
  };

  if (callback != null) {
    if (typeof callback !== "function") throw new Error("invalid callback: " + callback);
    return request.get(callback);
  }

  return request;
}

function fixCallback(callback) {
  return function (error, xhr) {
    callback(error == null ? xhr : null);
  };
}

function hasResponse(xhr) {
  var type = xhr.responseType;
  return type && type !== "text" ? xhr.response // null on error
  : xhr.responseText; // "" on error
}
},{"d3-collection":"GTGQ","d3-dispatch":"FHGa"}],"fw1g":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _request = _interopRequireDefault(require("./request"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(defaultMimeType, response) {
  return function (url, callback) {
    var r = (0, _request.default)(url).mimeType(defaultMimeType).response(response);

    if (callback != null) {
      if (typeof callback !== "function") throw new Error("invalid callback: " + callback);
      return r.get(callback);
    }

    return r;
  };
}
},{"./request":"ZuZ9"}],"eS4X":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _type = _interopRequireDefault(require("./type"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = (0, _type.default)("text/html", function (xhr) {
  return document.createRange().createContextualFragment(xhr.responseText);
});

exports.default = _default;
},{"./type":"fw1g"}],"fWTf":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _type = _interopRequireDefault(require("./type"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = (0, _type.default)("application/json", function (xhr) {
  return JSON.parse(xhr.responseText);
});

exports.default = _default;
},{"./type":"fw1g"}],"tPpd":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _type = _interopRequireDefault(require("./type"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = (0, _type.default)("text/plain", function (xhr) {
  return xhr.responseText;
});

exports.default = _default;
},{"./type":"fw1g"}],"m26X":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _type = _interopRequireDefault(require("./type"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = (0, _type.default)("application/xml", function (xhr) {
  var xml = xhr.responseXML;
  if (!xml) throw new Error("parse error");
  return xml;
});

exports.default = _default;
},{"./type":"fw1g"}],"Yo1B":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _request = _interopRequireDefault(require("./request"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(defaultMimeType, parse) {
  return function (url, row, callback) {
    if (arguments.length < 3) callback = row, row = null;
    var r = (0, _request.default)(url).mimeType(defaultMimeType);

    r.row = function (_) {
      return arguments.length ? r.response(responseOf(parse, row = _)) : row;
    };

    r.row(row);
    return callback ? r.get(callback) : r;
  };
}

function responseOf(parse, row) {
  return function (request) {
    return parse(request.responseText, row);
  };
}
},{"./request":"ZuZ9"}],"HPRE":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _d3Dsv = require("d3-dsv");

var _dsv = _interopRequireDefault(require("./dsv"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = (0, _dsv.default)("text/csv", _d3Dsv.csvParse);

exports.default = _default;
},{"d3-dsv":"NYIA","./dsv":"Yo1B"}],"f4Vu":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _d3Dsv = require("d3-dsv");

var _dsv = _interopRequireDefault(require("./dsv"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = (0, _dsv.default)("text/tab-separated-values", _d3Dsv.tsvParse);

exports.default = _default;
},{"d3-dsv":"NYIA","./dsv":"Yo1B"}],"DXex":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "request", {
  enumerable: true,
  get: function () {
    return _request.default;
  }
});
Object.defineProperty(exports, "html", {
  enumerable: true,
  get: function () {
    return _html.default;
  }
});
Object.defineProperty(exports, "json", {
  enumerable: true,
  get: function () {
    return _json.default;
  }
});
Object.defineProperty(exports, "text", {
  enumerable: true,
  get: function () {
    return _text.default;
  }
});
Object.defineProperty(exports, "xml", {
  enumerable: true,
  get: function () {
    return _xml.default;
  }
});
Object.defineProperty(exports, "csv", {
  enumerable: true,
  get: function () {
    return _csv.default;
  }
});
Object.defineProperty(exports, "tsv", {
  enumerable: true,
  get: function () {
    return _tsv.default;
  }
});

var _request = _interopRequireDefault(require("./src/request"));

var _html = _interopRequireDefault(require("./src/html"));

var _json = _interopRequireDefault(require("./src/json"));

var _text = _interopRequireDefault(require("./src/text"));

var _xml = _interopRequireDefault(require("./src/xml"));

var _csv = _interopRequireDefault(require("./src/csv"));

var _tsv = _interopRequireDefault(require("./src/tsv"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./src/request":"ZuZ9","./src/html":"eS4X","./src/json":"fWTf","./src/text":"tPpd","./src/xml":"m26X","./src/csv":"HPRE","./src/tsv":"f4Vu"}],"lLkj":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.slice = exports.map = void 0;
var array = Array.prototype;
var map = array.map;
exports.map = map;
var slice = array.slice;
exports.slice = slice;
},{}],"ELIM":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ordinal;
exports.implicit = void 0;

var _d3Collection = require("d3-collection");

var _array = require("./array");

var implicit = {
  name: "implicit"
};
exports.implicit = implicit;

function ordinal(range) {
  var index = (0, _d3Collection.map)(),
      domain = [],
      unknown = implicit;
  range = range == null ? [] : _array.slice.call(range);

  function scale(d) {
    var key = d + "",
        i = index.get(key);

    if (!i) {
      if (unknown !== implicit) return unknown;
      index.set(key, i = domain.push(d));
    }

    return range[(i - 1) % range.length];
  }

  scale.domain = function (_) {
    if (!arguments.length) return domain.slice();
    domain = [], index = (0, _d3Collection.map)();
    var i = -1,
        n = _.length,
        d,
        key;

    while (++i < n) if (!index.has(key = (d = _[i]) + "")) index.set(key, domain.push(d));

    return scale;
  };

  scale.range = function (_) {
    return arguments.length ? (range = _array.slice.call(_), scale) : range.slice();
  };

  scale.unknown = function (_) {
    return arguments.length ? (unknown = _, scale) : unknown;
  };

  scale.copy = function () {
    return ordinal().domain(domain).range(range).unknown(unknown);
  };

  return scale;
}
},{"d3-collection":"GTGQ","./array":"lLkj"}],"rJZF":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = band;
exports.point = point;

var _d3Array = require("d3-array");

var _ordinal = _interopRequireDefault(require("./ordinal"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function band() {
  var scale = (0, _ordinal.default)().unknown(undefined),
      domain = scale.domain,
      ordinalRange = scale.range,
      range = [0, 1],
      step,
      bandwidth,
      round = false,
      paddingInner = 0,
      paddingOuter = 0,
      align = 0.5;
  delete scale.unknown;

  function rescale() {
    var n = domain().length,
        reverse = range[1] < range[0],
        start = range[reverse - 0],
        stop = range[1 - reverse];
    step = (stop - start) / Math.max(1, n - paddingInner + paddingOuter * 2);
    if (round) step = Math.floor(step);
    start += (stop - start - step * (n - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round) start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = (0, _d3Array.range)(n).map(function (i) {
      return start + step * i;
    });
    return ordinalRange(reverse ? values.reverse() : values);
  }

  scale.domain = function (_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.range = function (_) {
    return arguments.length ? (range = [+_[0], +_[1]], rescale()) : range.slice();
  };

  scale.rangeRound = function (_) {
    return range = [+_[0], +_[1]], round = true, rescale();
  };

  scale.bandwidth = function () {
    return bandwidth;
  };

  scale.step = function () {
    return step;
  };

  scale.round = function (_) {
    return arguments.length ? (round = !!_, rescale()) : round;
  };

  scale.padding = function (_) {
    return arguments.length ? (paddingInner = paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
  };

  scale.paddingInner = function (_) {
    return arguments.length ? (paddingInner = Math.max(0, Math.min(1, _)), rescale()) : paddingInner;
  };

  scale.paddingOuter = function (_) {
    return arguments.length ? (paddingOuter = Math.max(0, Math.min(1, _)), rescale()) : paddingOuter;
  };

  scale.align = function (_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };

  scale.copy = function () {
    return band().domain(domain()).range(range).round(round).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
  };

  return rescale();
}

function pointish(scale) {
  var copy = scale.copy;
  scale.padding = scale.paddingOuter;
  delete scale.paddingInner;
  delete scale.paddingOuter;

  scale.copy = function () {
    return pointish(copy());
  };

  return scale;
}

function point() {
  return pointish(band().paddingInner(1));
}
},{"d3-array":"ybfZ","./ordinal":"ELIM"}],"zRWI":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(x) {
  return +x;
}
},{}],"ZpMB":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.deinterpolateLinear = deinterpolateLinear;
exports.copy = copy;
exports.default = continuous;

var _d3Array = require("d3-array");

var _d3Interpolate = require("d3-interpolate");

var _array = require("./array");

var _constant = _interopRequireDefault(require("./constant"));

var _number = _interopRequireDefault(require("./number"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var unit = [0, 1];

function deinterpolateLinear(a, b) {
  return (b -= a = +a) ? function (x) {
    return (x - a) / b;
  } : (0, _constant.default)(b);
}

function deinterpolateClamp(deinterpolate) {
  return function (a, b) {
    var d = deinterpolate(a = +a, b = +b);
    return function (x) {
      return x <= a ? 0 : x >= b ? 1 : d(x);
    };
  };
}

function reinterpolateClamp(reinterpolate) {
  return function (a, b) {
    var r = reinterpolate(a = +a, b = +b);
    return function (t) {
      return t <= 0 ? a : t >= 1 ? b : r(t);
    };
  };
}

function bimap(domain, range, deinterpolate, reinterpolate) {
  var d0 = domain[0],
      d1 = domain[1],
      r0 = range[0],
      r1 = range[1];
  if (d1 < d0) d0 = deinterpolate(d1, d0), r0 = reinterpolate(r1, r0);else d0 = deinterpolate(d0, d1), r0 = reinterpolate(r0, r1);
  return function (x) {
    return r0(d0(x));
  };
}

function polymap(domain, range, deinterpolate, reinterpolate) {
  var j = Math.min(domain.length, range.length) - 1,
      d = new Array(j),
      r = new Array(j),
      i = -1; // Reverse descending domains.

  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range = range.slice().reverse();
  }

  while (++i < j) {
    d[i] = deinterpolate(domain[i], domain[i + 1]);
    r[i] = reinterpolate(range[i], range[i + 1]);
  }

  return function (x) {
    var i = (0, _d3Array.bisect)(domain, x, 1, j) - 1;
    return r[i](d[i](x));
  };
}

function copy(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp());
} // deinterpolate(a, b)(x) takes a domain value x in [a,b] and returns the corresponding parameter t in [0,1].
// reinterpolate(a, b)(t) takes a parameter t in [0,1] and returns the corresponding domain value x in [a,b].


function continuous(deinterpolate, reinterpolate) {
  var domain = unit,
      range = unit,
      interpolate = _d3Interpolate.interpolate,
      clamp = false,
      piecewise,
      output,
      input;

  function rescale() {
    piecewise = Math.min(domain.length, range.length) > 2 ? polymap : bimap;
    output = input = null;
    return scale;
  }

  function scale(x) {
    return (output || (output = piecewise(domain, range, clamp ? deinterpolateClamp(deinterpolate) : deinterpolate, interpolate)))(+x);
  }

  scale.invert = function (y) {
    return (input || (input = piecewise(range, domain, deinterpolateLinear, clamp ? reinterpolateClamp(reinterpolate) : reinterpolate)))(+y);
  };

  scale.domain = function (_) {
    return arguments.length ? (domain = _array.map.call(_, _number.default), rescale()) : domain.slice();
  };

  scale.range = function (_) {
    return arguments.length ? (range = _array.slice.call(_), rescale()) : range.slice();
  };

  scale.rangeRound = function (_) {
    return range = _array.slice.call(_), interpolate = _d3Interpolate.interpolateRound, rescale();
  };

  scale.clamp = function (_) {
    return arguments.length ? (clamp = !!_, rescale()) : clamp;
  };

  scale.interpolate = function (_) {
    return arguments.length ? (interpolate = _, rescale()) : interpolate;
  };

  return rescale();
}
},{"d3-array":"ybfZ","d3-interpolate":"nuBz","./array":"lLkj","./constant":"OY6d","./number":"zRWI"}],"m0SA":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _d3Array = require("d3-array");

var _d3Format = require("d3-format");

function _default(domain, count, specifier) {
  var start = domain[0],
      stop = domain[domain.length - 1],
      step = (0, _d3Array.tickStep)(start, stop, count == null ? 10 : count),
      precision;
  specifier = (0, _d3Format.formatSpecifier)(specifier == null ? ",f" : specifier);

  switch (specifier.type) {
    case "s":
      {
        var value = Math.max(Math.abs(start), Math.abs(stop));
        if (specifier.precision == null && !isNaN(precision = (0, _d3Format.precisionPrefix)(step, value))) specifier.precision = precision;
        return (0, _d3Format.formatPrefix)(specifier, value);
      }

    case "":
    case "e":
    case "g":
    case "p":
    case "r":
      {
        if (specifier.precision == null && !isNaN(precision = (0, _d3Format.precisionRound)(step, Math.max(Math.abs(start), Math.abs(stop))))) specifier.precision = precision - (specifier.type === "e");
        break;
      }

    case "f":
    case "%":
      {
        if (specifier.precision == null && !isNaN(precision = (0, _d3Format.precisionFixed)(step))) specifier.precision = precision - (specifier.type === "%") * 2;
        break;
      }
  }

  return (0, _d3Format.format)(specifier);
}
},{"d3-array":"ybfZ","d3-format":"ftuj"}],"VMtl":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.linearish = linearish;
exports.default = linear;

var _d3Array = require("d3-array");

var _d3Interpolate = require("d3-interpolate");

var _continuous = _interopRequireWildcard(require("./continuous"));

var _tickFormat = _interopRequireDefault(require("./tickFormat"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function linearish(scale) {
  var domain = scale.domain;

  scale.ticks = function (count) {
    var d = domain();
    return (0, _d3Array.ticks)(d[0], d[d.length - 1], count == null ? 10 : count);
  };

  scale.tickFormat = function (count, specifier) {
    return (0, _tickFormat.default)(domain(), count, specifier);
  };

  scale.nice = function (count) {
    if (count == null) count = 10;
    var d = domain(),
        i0 = 0,
        i1 = d.length - 1,
        start = d[i0],
        stop = d[i1],
        step;

    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }

    step = (0, _d3Array.tickIncrement)(start, stop, count);

    if (step > 0) {
      start = Math.floor(start / step) * step;
      stop = Math.ceil(stop / step) * step;
      step = (0, _d3Array.tickIncrement)(start, stop, count);
    } else if (step < 0) {
      start = Math.ceil(start * step) / step;
      stop = Math.floor(stop * step) / step;
      step = (0, _d3Array.tickIncrement)(start, stop, count);
    }

    if (step > 0) {
      d[i0] = Math.floor(start / step) * step;
      d[i1] = Math.ceil(stop / step) * step;
      domain(d);
    } else if (step < 0) {
      d[i0] = Math.ceil(start * step) / step;
      d[i1] = Math.floor(stop * step) / step;
      domain(d);
    }

    return scale;
  };

  return scale;
}

function linear() {
  var scale = (0, _continuous.default)(_continuous.deinterpolateLinear, _d3Interpolate.interpolateNumber);

  scale.copy = function () {
    return (0, _continuous.copy)(scale, linear());
  };

  return linearish(scale);
}
},{"d3-array":"ybfZ","d3-interpolate":"nuBz","./continuous":"ZpMB","./tickFormat":"m0SA"}],"eP89":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = identity;

var _array = require("./array");

var _linear = require("./linear");

var _number = _interopRequireDefault(require("./number"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function identity() {
  var domain = [0, 1];

  function scale(x) {
    return +x;
  }

  scale.invert = scale;

  scale.domain = scale.range = function (_) {
    return arguments.length ? (domain = _array.map.call(_, _number.default), scale) : domain.slice();
  };

  scale.copy = function () {
    return identity().domain(domain);
  };

  return (0, _linear.linearish)(scale);
}
},{"./array":"lLkj","./linear":"VMtl","./number":"zRWI"}],"gRJQ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(domain, interval) {
  domain = domain.slice();
  var i0 = 0,
      i1 = domain.length - 1,
      x0 = domain[i0],
      x1 = domain[i1],
      t;

  if (x1 < x0) {
    t = i0, i0 = i1, i1 = t;
    t = x0, x0 = x1, x1 = t;
  }

  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
}
},{}],"X3YW":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = log;

var _d3Array = require("d3-array");

var _d3Format = require("d3-format");

var _constant = _interopRequireDefault(require("./constant"));

var _nice = _interopRequireDefault(require("./nice"));

var _continuous = _interopRequireWildcard(require("./continuous"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function deinterpolate(a, b) {
  return (b = Math.log(b / a)) ? function (x) {
    return Math.log(x / a) / b;
  } : (0, _constant.default)(b);
}

function reinterpolate(a, b) {
  return a < 0 ? function (t) {
    return -Math.pow(-b, t) * Math.pow(-a, 1 - t);
  } : function (t) {
    return Math.pow(b, t) * Math.pow(a, 1 - t);
  };
}

function pow10(x) {
  return isFinite(x) ? +("1e" + x) : x < 0 ? 0 : x;
}

function powp(base) {
  return base === 10 ? pow10 : base === Math.E ? Math.exp : function (x) {
    return Math.pow(base, x);
  };
}

function logp(base) {
  return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), function (x) {
    return Math.log(x) / base;
  });
}

function reflect(f) {
  return function (x) {
    return -f(-x);
  };
}

function log() {
  var scale = (0, _continuous.default)(deinterpolate, reinterpolate).domain([1, 10]),
      domain = scale.domain,
      base = 10,
      logs = logp(10),
      pows = powp(10);

  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) logs = reflect(logs), pows = reflect(pows);
    return scale;
  }

  scale.base = function (_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };

  scale.domain = function (_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };

  scale.ticks = function (count) {
    var d = domain(),
        u = d[0],
        v = d[d.length - 1],
        r;
    if (r = v < u) i = u, u = v, v = i;
    var i = logs(u),
        j = logs(v),
        p,
        k,
        t,
        n = count == null ? 10 : +count,
        z = [];

    if (!(base % 1) && j - i < n) {
      i = Math.round(i) - 1, j = Math.round(j) + 1;
      if (u > 0) for (; i < j; ++i) {
        for (k = 1, p = pows(i); k < base; ++k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      } else for (; i < j; ++i) {
        for (k = base - 1, p = pows(i); k >= 1; --k) {
          t = p * k;
          if (t < u) continue;
          if (t > v) break;
          z.push(t);
        }
      }
    } else {
      z = (0, _d3Array.ticks)(i, j, Math.min(j - i, n)).map(pows);
    }

    return r ? z.reverse() : z;
  };

  scale.tickFormat = function (count, specifier) {
    if (specifier == null) specifier = base === 10 ? ".0e" : ",";
    if (typeof specifier !== "function") specifier = (0, _d3Format.format)(specifier);
    if (count === Infinity) return specifier;
    if (count == null) count = 10;
    var k = Math.max(1, base * count / scale.ticks().length); // TODO fast estimate?

    return function (d) {
      var i = d / pows(Math.round(logs(d)));
      if (i * base < base - 0.5) i *= base;
      return i <= k ? specifier(d) : "";
    };
  };

  scale.nice = function () {
    return domain((0, _nice.default)(domain(), {
      floor: function (x) {
        return pows(Math.floor(logs(x)));
      },
      ceil: function (x) {
        return pows(Math.ceil(logs(x)));
      }
    }));
  };

  scale.copy = function () {
    return (0, _continuous.copy)(scale, log().base(base));
  };

  return scale;
}
},{"d3-array":"ybfZ","d3-format":"ftuj","./constant":"OY6d","./nice":"gRJQ","./continuous":"ZpMB"}],"ysea":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = pow;
exports.sqrt = sqrt;

var _constant = _interopRequireDefault(require("./constant"));

var _linear = require("./linear");

var _continuous = _interopRequireWildcard(require("./continuous"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function raise(x, exponent) {
  return x < 0 ? -Math.pow(-x, exponent) : Math.pow(x, exponent);
}

function pow() {
  var exponent = 1,
      scale = (0, _continuous.default)(deinterpolate, reinterpolate),
      domain = scale.domain;

  function deinterpolate(a, b) {
    return (b = raise(b, exponent) - (a = raise(a, exponent))) ? function (x) {
      return (raise(x, exponent) - a) / b;
    } : (0, _constant.default)(b);
  }

  function reinterpolate(a, b) {
    b = raise(b, exponent) - (a = raise(a, exponent));
    return function (t) {
      return raise(a + b * t, 1 / exponent);
    };
  }

  scale.exponent = function (_) {
    return arguments.length ? (exponent = +_, domain(domain())) : exponent;
  };

  scale.copy = function () {
    return (0, _continuous.copy)(scale, pow().exponent(exponent));
  };

  return (0, _linear.linearish)(scale);
}

function sqrt() {
  return pow().exponent(0.5);
}
},{"./constant":"OY6d","./linear":"VMtl","./continuous":"ZpMB"}],"fsZk":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = quantile;

var _d3Array = require("d3-array");

var _array = require("./array");

function quantile() {
  var domain = [],
      range = [],
      thresholds = [];

  function rescale() {
    var i = 0,
        n = Math.max(1, range.length);
    thresholds = new Array(n - 1);

    while (++i < n) thresholds[i - 1] = (0, _d3Array.quantile)(domain, i / n);

    return scale;
  }

  function scale(x) {
    if (!isNaN(x = +x)) return range[(0, _d3Array.bisect)(thresholds, x)];
  }

  scale.invertExtent = function (y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN] : [i > 0 ? thresholds[i - 1] : domain[0], i < thresholds.length ? thresholds[i] : domain[domain.length - 1]];
  };

  scale.domain = function (_) {
    if (!arguments.length) return domain.slice();
    domain = [];

    for (var i = 0, n = _.length, d; i < n; ++i) if (d = _[i], d != null && !isNaN(d = +d)) domain.push(d);

    domain.sort(_d3Array.ascending);
    return rescale();
  };

  scale.range = function (_) {
    return arguments.length ? (range = _array.slice.call(_), rescale()) : range.slice();
  };

  scale.quantiles = function () {
    return thresholds.slice();
  };

  scale.copy = function () {
    return quantile().domain(domain).range(range);
  };

  return scale;
}
},{"d3-array":"ybfZ","./array":"lLkj"}],"Z2cL":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = quantize;

var _d3Array = require("d3-array");

var _array = require("./array");

var _linear = require("./linear");

function quantize() {
  var x0 = 0,
      x1 = 1,
      n = 1,
      domain = [0.5],
      range = [0, 1];

  function scale(x) {
    if (x <= x) return range[(0, _d3Array.bisect)(domain, x, 0, n)];
  }

  function rescale() {
    var i = -1;
    domain = new Array(n);

    while (++i < n) domain[i] = ((i + 1) * x1 - (i - n) * x0) / (n + 1);

    return scale;
  }

  scale.domain = function (_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], rescale()) : [x0, x1];
  };

  scale.range = function (_) {
    return arguments.length ? (n = (range = _array.slice.call(_)).length - 1, rescale()) : range.slice();
  };

  scale.invertExtent = function (y) {
    var i = range.indexOf(y);
    return i < 0 ? [NaN, NaN] : i < 1 ? [x0, domain[0]] : i >= n ? [domain[n - 1], x1] : [domain[i - 1], domain[i]];
  };

  scale.copy = function () {
    return quantize().domain([x0, x1]).range(range);
  };

  return (0, _linear.linearish)(scale);
}
},{"d3-array":"ybfZ","./array":"lLkj","./linear":"VMtl"}],"odYE":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = threshold;

var _d3Array = require("d3-array");

var _array = require("./array");

function threshold() {
  var domain = [0.5],
      range = [0, 1],
      n = 1;

  function scale(x) {
    if (x <= x) return range[(0, _d3Array.bisect)(domain, x, 0, n)];
  }

  scale.domain = function (_) {
    return arguments.length ? (domain = _array.slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : domain.slice();
  };

  scale.range = function (_) {
    return arguments.length ? (range = _array.slice.call(_), n = Math.min(domain.length, range.length - 1), scale) : range.slice();
  };

  scale.invertExtent = function (y) {
    var i = range.indexOf(y);
    return [domain[i - 1], domain[i]];
  };

  scale.copy = function () {
    return threshold().domain(domain).range(range);
  };

  return scale;
}
},{"d3-array":"ybfZ","./array":"lLkj"}],"gsab":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = newInterval;
var t0 = new Date(),
    t1 = new Date();

function newInterval(floori, offseti, count, field) {
  function interval(date) {
    return floori(date = new Date(+date)), date;
  }

  interval.floor = interval;

  interval.ceil = function (date) {
    return floori(date = new Date(date - 1)), offseti(date, 1), floori(date), date;
  };

  interval.round = function (date) {
    var d0 = interval(date),
        d1 = interval.ceil(date);
    return date - d0 < d1 - date ? d0 : d1;
  };

  interval.offset = function (date, step) {
    return offseti(date = new Date(+date), step == null ? 1 : Math.floor(step)), date;
  };

  interval.range = function (start, stop, step) {
    var range = [],
        previous;
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0)) return range; // also handles Invalid Date

    do range.push(previous = new Date(+start)), offseti(start, step), floori(start); while (previous < start && start < stop);

    return range;
  };

  interval.filter = function (test) {
    return newInterval(function (date) {
      if (date >= date) while (floori(date), !test(date)) date.setTime(date - 1);
    }, function (date, step) {
      if (date >= date) {
        if (step < 0) while (++step <= 0) {
          while (offseti(date, -1), !test(date)) {} // eslint-disable-line no-empty

        } else while (--step >= 0) {
          while (offseti(date, +1), !test(date)) {} // eslint-disable-line no-empty

        }
      }
    });
  };

  if (count) {
    interval.count = function (start, end) {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };

    interval.every = function (step) {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? function (d) {
        return field(d) % step === 0;
      } : function (d) {
        return interval.count(0, d) % step === 0;
      });
    };
  }

  return interval;
}
},{}],"r4Yr":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.milliseconds = exports.default = void 0;

var _interval = _interopRequireDefault(require("./interval"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var millisecond = (0, _interval.default)(function () {// noop
}, function (date, step) {
  date.setTime(+date + step);
}, function (start, end) {
  return end - start;
}); // An optimized implementation for this simple case.

millisecond.every = function (k) {
  k = Math.floor(k);
  if (!isFinite(k) || !(k > 0)) return null;
  if (!(k > 1)) return millisecond;
  return (0, _interval.default)(function (date) {
    date.setTime(Math.floor(date / k) * k);
  }, function (date, step) {
    date.setTime(+date + step * k);
  }, function (start, end) {
    return (end - start) / k;
  });
};

var _default = millisecond;
exports.default = _default;
var milliseconds = millisecond.range;
exports.milliseconds = milliseconds;
},{"./interval":"gsab"}],"EMiL":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.durationWeek = exports.durationDay = exports.durationHour = exports.durationMinute = exports.durationSecond = void 0;
var durationSecond = 1e3;
exports.durationSecond = durationSecond;
var durationMinute = 6e4;
exports.durationMinute = durationMinute;
var durationHour = 36e5;
exports.durationHour = durationHour;
var durationDay = 864e5;
exports.durationDay = durationDay;
var durationWeek = 6048e5;
exports.durationWeek = durationWeek;
},{}],"K4G6":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.seconds = exports.default = void 0;

var _interval = _interopRequireDefault(require("./interval"));

var _duration = require("./duration");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var second = (0, _interval.default)(function (date) {
  date.setTime(Math.floor(date / _duration.durationSecond) * _duration.durationSecond);
}, function (date, step) {
  date.setTime(+date + step * _duration.durationSecond);
}, function (start, end) {
  return (end - start) / _duration.durationSecond;
}, function (date) {
  return date.getUTCSeconds();
});
var _default = second;
exports.default = _default;
var seconds = second.range;
exports.seconds = seconds;
},{"./interval":"gsab","./duration":"EMiL"}],"sObl":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.minutes = exports.default = void 0;

var _interval = _interopRequireDefault(require("./interval"));

var _duration = require("./duration");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var minute = (0, _interval.default)(function (date) {
  date.setTime(Math.floor(date / _duration.durationMinute) * _duration.durationMinute);
}, function (date, step) {
  date.setTime(+date + step * _duration.durationMinute);
}, function (start, end) {
  return (end - start) / _duration.durationMinute;
}, function (date) {
  return date.getMinutes();
});
var _default = minute;
exports.default = _default;
var minutes = minute.range;
exports.minutes = minutes;
},{"./interval":"gsab","./duration":"EMiL"}],"wPv4":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hours = exports.default = void 0;

var _interval = _interopRequireDefault(require("./interval"));

var _duration = require("./duration");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var hour = (0, _interval.default)(function (date) {
  var offset = date.getTimezoneOffset() * _duration.durationMinute % _duration.durationHour;

  if (offset < 0) offset += _duration.durationHour;
  date.setTime(Math.floor((+date - offset) / _duration.durationHour) * _duration.durationHour + offset);
}, function (date, step) {
  date.setTime(+date + step * _duration.durationHour);
}, function (start, end) {
  return (end - start) / _duration.durationHour;
}, function (date) {
  return date.getHours();
});
var _default = hour;
exports.default = _default;
var hours = hour.range;
exports.hours = hours;
},{"./interval":"gsab","./duration":"EMiL"}],"bZMy":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.days = exports.default = void 0;

var _interval = _interopRequireDefault(require("./interval"));

var _duration = require("./duration");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var day = (0, _interval.default)(function (date) {
  date.setHours(0, 0, 0, 0);
}, function (date, step) {
  date.setDate(date.getDate() + step);
}, function (start, end) {
  return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * _duration.durationMinute) / _duration.durationDay;
}, function (date) {
  return date.getDate() - 1;
});
var _default = day;
exports.default = _default;
var days = day.range;
exports.days = days;
},{"./interval":"gsab","./duration":"EMiL"}],"SUbU":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.saturdays = exports.fridays = exports.thursdays = exports.wednesdays = exports.tuesdays = exports.mondays = exports.sundays = exports.saturday = exports.friday = exports.thursday = exports.wednesday = exports.tuesday = exports.monday = exports.sunday = void 0;

var _interval = _interopRequireDefault(require("./interval"));

var _duration = require("./duration");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function weekday(i) {
  return (0, _interval.default)(function (date) {
    date.setDate(date.getDate() - (date.getDay() + 7 - i) % 7);
    date.setHours(0, 0, 0, 0);
  }, function (date, step) {
    date.setDate(date.getDate() + step * 7);
  }, function (start, end) {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * _duration.durationMinute) / _duration.durationWeek;
  });
}

var sunday = weekday(0);
exports.sunday = sunday;
var monday = weekday(1);
exports.monday = monday;
var tuesday = weekday(2);
exports.tuesday = tuesday;
var wednesday = weekday(3);
exports.wednesday = wednesday;
var thursday = weekday(4);
exports.thursday = thursday;
var friday = weekday(5);
exports.friday = friday;
var saturday = weekday(6);
exports.saturday = saturday;
var sundays = sunday.range;
exports.sundays = sundays;
var mondays = monday.range;
exports.mondays = mondays;
var tuesdays = tuesday.range;
exports.tuesdays = tuesdays;
var wednesdays = wednesday.range;
exports.wednesdays = wednesdays;
var thursdays = thursday.range;
exports.thursdays = thursdays;
var fridays = friday.range;
exports.fridays = fridays;
var saturdays = saturday.range;
exports.saturdays = saturdays;
},{"./interval":"gsab","./duration":"EMiL"}],"XpbA":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.months = exports.default = void 0;

var _interval = _interopRequireDefault(require("./interval"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var month = (0, _interval.default)(function (date) {
  date.setDate(1);
  date.setHours(0, 0, 0, 0);
}, function (date, step) {
  date.setMonth(date.getMonth() + step);
}, function (start, end) {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, function (date) {
  return date.getMonth();
});
var _default = month;
exports.default = _default;
var months = month.range;
exports.months = months;
},{"./interval":"gsab"}],"djmh":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.years = exports.default = void 0;

var _interval = _interopRequireDefault(require("./interval"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var year = (0, _interval.default)(function (date) {
  date.setMonth(0, 1);
  date.setHours(0, 0, 0, 0);
}, function (date, step) {
  date.setFullYear(date.getFullYear() + step);
}, function (start, end) {
  return end.getFullYear() - start.getFullYear();
}, function (date) {
  return date.getFullYear();
}); // An optimized implementation for this simple case.

year.every = function (k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : (0, _interval.default)(function (date) {
    date.setFullYear(Math.floor(date.getFullYear() / k) * k);
    date.setMonth(0, 1);
    date.setHours(0, 0, 0, 0);
  }, function (date, step) {
    date.setFullYear(date.getFullYear() + step * k);
  });
};

var _default = year;
exports.default = _default;
var years = year.range;
exports.years = years;
},{"./interval":"gsab"}],"c3Ah":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.utcMinutes = exports.default = void 0;

var _interval = _interopRequireDefault(require("./interval"));

var _duration = require("./duration");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var utcMinute = (0, _interval.default)(function (date) {
  date.setUTCSeconds(0, 0);
}, function (date, step) {
  date.setTime(+date + step * _duration.durationMinute);
}, function (start, end) {
  return (end - start) / _duration.durationMinute;
}, function (date) {
  return date.getUTCMinutes();
});
var _default = utcMinute;
exports.default = _default;
var utcMinutes = utcMinute.range;
exports.utcMinutes = utcMinutes;
},{"./interval":"gsab","./duration":"EMiL"}],"sGav":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.utcHours = exports.default = void 0;

var _interval = _interopRequireDefault(require("./interval"));

var _duration = require("./duration");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var utcHour = (0, _interval.default)(function (date) {
  date.setUTCMinutes(0, 0, 0);
}, function (date, step) {
  date.setTime(+date + step * _duration.durationHour);
}, function (start, end) {
  return (end - start) / _duration.durationHour;
}, function (date) {
  return date.getUTCHours();
});
var _default = utcHour;
exports.default = _default;
var utcHours = utcHour.range;
exports.utcHours = utcHours;
},{"./interval":"gsab","./duration":"EMiL"}],"ns65":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.utcDays = exports.default = void 0;

var _interval = _interopRequireDefault(require("./interval"));

var _duration = require("./duration");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var utcDay = (0, _interval.default)(function (date) {
  date.setUTCHours(0, 0, 0, 0);
}, function (date, step) {
  date.setUTCDate(date.getUTCDate() + step);
}, function (start, end) {
  return (end - start) / _duration.durationDay;
}, function (date) {
  return date.getUTCDate() - 1;
});
var _default = utcDay;
exports.default = _default;
var utcDays = utcDay.range;
exports.utcDays = utcDays;
},{"./interval":"gsab","./duration":"EMiL"}],"HsON":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.utcSaturdays = exports.utcFridays = exports.utcThursdays = exports.utcWednesdays = exports.utcTuesdays = exports.utcMondays = exports.utcSundays = exports.utcSaturday = exports.utcFriday = exports.utcThursday = exports.utcWednesday = exports.utcTuesday = exports.utcMonday = exports.utcSunday = void 0;

var _interval = _interopRequireDefault(require("./interval"));

var _duration = require("./duration");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function utcWeekday(i) {
  return (0, _interval.default)(function (date) {
    date.setUTCDate(date.getUTCDate() - (date.getUTCDay() + 7 - i) % 7);
    date.setUTCHours(0, 0, 0, 0);
  }, function (date, step) {
    date.setUTCDate(date.getUTCDate() + step * 7);
  }, function (start, end) {
    return (end - start) / _duration.durationWeek;
  });
}

var utcSunday = utcWeekday(0);
exports.utcSunday = utcSunday;
var utcMonday = utcWeekday(1);
exports.utcMonday = utcMonday;
var utcTuesday = utcWeekday(2);
exports.utcTuesday = utcTuesday;
var utcWednesday = utcWeekday(3);
exports.utcWednesday = utcWednesday;
var utcThursday = utcWeekday(4);
exports.utcThursday = utcThursday;
var utcFriday = utcWeekday(5);
exports.utcFriday = utcFriday;
var utcSaturday = utcWeekday(6);
exports.utcSaturday = utcSaturday;
var utcSundays = utcSunday.range;
exports.utcSundays = utcSundays;
var utcMondays = utcMonday.range;
exports.utcMondays = utcMondays;
var utcTuesdays = utcTuesday.range;
exports.utcTuesdays = utcTuesdays;
var utcWednesdays = utcWednesday.range;
exports.utcWednesdays = utcWednesdays;
var utcThursdays = utcThursday.range;
exports.utcThursdays = utcThursdays;
var utcFridays = utcFriday.range;
exports.utcFridays = utcFridays;
var utcSaturdays = utcSaturday.range;
exports.utcSaturdays = utcSaturdays;
},{"./interval":"gsab","./duration":"EMiL"}],"KWFc":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.utcMonths = exports.default = void 0;

var _interval = _interopRequireDefault(require("./interval"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var utcMonth = (0, _interval.default)(function (date) {
  date.setUTCDate(1);
  date.setUTCHours(0, 0, 0, 0);
}, function (date, step) {
  date.setUTCMonth(date.getUTCMonth() + step);
}, function (start, end) {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, function (date) {
  return date.getUTCMonth();
});
var _default = utcMonth;
exports.default = _default;
var utcMonths = utcMonth.range;
exports.utcMonths = utcMonths;
},{"./interval":"gsab"}],"LM11":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.utcYears = exports.default = void 0;

var _interval = _interopRequireDefault(require("./interval"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var utcYear = (0, _interval.default)(function (date) {
  date.setUTCMonth(0, 1);
  date.setUTCHours(0, 0, 0, 0);
}, function (date, step) {
  date.setUTCFullYear(date.getUTCFullYear() + step);
}, function (start, end) {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, function (date) {
  return date.getUTCFullYear();
}); // An optimized implementation for this simple case.

utcYear.every = function (k) {
  return !isFinite(k = Math.floor(k)) || !(k > 0) ? null : (0, _interval.default)(function (date) {
    date.setUTCFullYear(Math.floor(date.getUTCFullYear() / k) * k);
    date.setUTCMonth(0, 1);
    date.setUTCHours(0, 0, 0, 0);
  }, function (date, step) {
    date.setUTCFullYear(date.getUTCFullYear() + step * k);
  });
};

var _default = utcYear;
exports.default = _default;
var utcYears = utcYear.range;
exports.utcYears = utcYears;
},{"./interval":"gsab"}],"dsMh":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "timeInterval", {
  enumerable: true,
  get: function () {
    return _interval.default;
  }
});
Object.defineProperty(exports, "timeMillisecond", {
  enumerable: true,
  get: function () {
    return _millisecond.default;
  }
});
Object.defineProperty(exports, "timeMilliseconds", {
  enumerable: true,
  get: function () {
    return _millisecond.milliseconds;
  }
});
Object.defineProperty(exports, "utcMillisecond", {
  enumerable: true,
  get: function () {
    return _millisecond.default;
  }
});
Object.defineProperty(exports, "utcMilliseconds", {
  enumerable: true,
  get: function () {
    return _millisecond.milliseconds;
  }
});
Object.defineProperty(exports, "timeSecond", {
  enumerable: true,
  get: function () {
    return _second.default;
  }
});
Object.defineProperty(exports, "timeSeconds", {
  enumerable: true,
  get: function () {
    return _second.seconds;
  }
});
Object.defineProperty(exports, "utcSecond", {
  enumerable: true,
  get: function () {
    return _second.default;
  }
});
Object.defineProperty(exports, "utcSeconds", {
  enumerable: true,
  get: function () {
    return _second.seconds;
  }
});
Object.defineProperty(exports, "timeMinute", {
  enumerable: true,
  get: function () {
    return _minute.default;
  }
});
Object.defineProperty(exports, "timeMinutes", {
  enumerable: true,
  get: function () {
    return _minute.minutes;
  }
});
Object.defineProperty(exports, "timeHour", {
  enumerable: true,
  get: function () {
    return _hour.default;
  }
});
Object.defineProperty(exports, "timeHours", {
  enumerable: true,
  get: function () {
    return _hour.hours;
  }
});
Object.defineProperty(exports, "timeDay", {
  enumerable: true,
  get: function () {
    return _day.default;
  }
});
Object.defineProperty(exports, "timeDays", {
  enumerable: true,
  get: function () {
    return _day.days;
  }
});
Object.defineProperty(exports, "timeWeek", {
  enumerable: true,
  get: function () {
    return _week.sunday;
  }
});
Object.defineProperty(exports, "timeWeeks", {
  enumerable: true,
  get: function () {
    return _week.sundays;
  }
});
Object.defineProperty(exports, "timeSunday", {
  enumerable: true,
  get: function () {
    return _week.sunday;
  }
});
Object.defineProperty(exports, "timeSundays", {
  enumerable: true,
  get: function () {
    return _week.sundays;
  }
});
Object.defineProperty(exports, "timeMonday", {
  enumerable: true,
  get: function () {
    return _week.monday;
  }
});
Object.defineProperty(exports, "timeMondays", {
  enumerable: true,
  get: function () {
    return _week.mondays;
  }
});
Object.defineProperty(exports, "timeTuesday", {
  enumerable: true,
  get: function () {
    return _week.tuesday;
  }
});
Object.defineProperty(exports, "timeTuesdays", {
  enumerable: true,
  get: function () {
    return _week.tuesdays;
  }
});
Object.defineProperty(exports, "timeWednesday", {
  enumerable: true,
  get: function () {
    return _week.wednesday;
  }
});
Object.defineProperty(exports, "timeWednesdays", {
  enumerable: true,
  get: function () {
    return _week.wednesdays;
  }
});
Object.defineProperty(exports, "timeThursday", {
  enumerable: true,
  get: function () {
    return _week.thursday;
  }
});
Object.defineProperty(exports, "timeThursdays", {
  enumerable: true,
  get: function () {
    return _week.thursdays;
  }
});
Object.defineProperty(exports, "timeFriday", {
  enumerable: true,
  get: function () {
    return _week.friday;
  }
});
Object.defineProperty(exports, "timeFridays", {
  enumerable: true,
  get: function () {
    return _week.fridays;
  }
});
Object.defineProperty(exports, "timeSaturday", {
  enumerable: true,
  get: function () {
    return _week.saturday;
  }
});
Object.defineProperty(exports, "timeSaturdays", {
  enumerable: true,
  get: function () {
    return _week.saturdays;
  }
});
Object.defineProperty(exports, "timeMonth", {
  enumerable: true,
  get: function () {
    return _month.default;
  }
});
Object.defineProperty(exports, "timeMonths", {
  enumerable: true,
  get: function () {
    return _month.months;
  }
});
Object.defineProperty(exports, "timeYear", {
  enumerable: true,
  get: function () {
    return _year.default;
  }
});
Object.defineProperty(exports, "timeYears", {
  enumerable: true,
  get: function () {
    return _year.years;
  }
});
Object.defineProperty(exports, "utcMinute", {
  enumerable: true,
  get: function () {
    return _utcMinute.default;
  }
});
Object.defineProperty(exports, "utcMinutes", {
  enumerable: true,
  get: function () {
    return _utcMinute.utcMinutes;
  }
});
Object.defineProperty(exports, "utcHour", {
  enumerable: true,
  get: function () {
    return _utcHour.default;
  }
});
Object.defineProperty(exports, "utcHours", {
  enumerable: true,
  get: function () {
    return _utcHour.utcHours;
  }
});
Object.defineProperty(exports, "utcDay", {
  enumerable: true,
  get: function () {
    return _utcDay.default;
  }
});
Object.defineProperty(exports, "utcDays", {
  enumerable: true,
  get: function () {
    return _utcDay.utcDays;
  }
});
Object.defineProperty(exports, "utcWeek", {
  enumerable: true,
  get: function () {
    return _utcWeek.utcSunday;
  }
});
Object.defineProperty(exports, "utcWeeks", {
  enumerable: true,
  get: function () {
    return _utcWeek.utcSundays;
  }
});
Object.defineProperty(exports, "utcSunday", {
  enumerable: true,
  get: function () {
    return _utcWeek.utcSunday;
  }
});
Object.defineProperty(exports, "utcSundays", {
  enumerable: true,
  get: function () {
    return _utcWeek.utcSundays;
  }
});
Object.defineProperty(exports, "utcMonday", {
  enumerable: true,
  get: function () {
    return _utcWeek.utcMonday;
  }
});
Object.defineProperty(exports, "utcMondays", {
  enumerable: true,
  get: function () {
    return _utcWeek.utcMondays;
  }
});
Object.defineProperty(exports, "utcTuesday", {
  enumerable: true,
  get: function () {
    return _utcWeek.utcTuesday;
  }
});
Object.defineProperty(exports, "utcTuesdays", {
  enumerable: true,
  get: function () {
    return _utcWeek.utcTuesdays;
  }
});
Object.defineProperty(exports, "utcWednesday", {
  enumerable: true,
  get: function () {
    return _utcWeek.utcWednesday;
  }
});
Object.defineProperty(exports, "utcWednesdays", {
  enumerable: true,
  get: function () {
    return _utcWeek.utcWednesdays;
  }
});
Object.defineProperty(exports, "utcThursday", {
  enumerable: true,
  get: function () {
    return _utcWeek.utcThursday;
  }
});
Object.defineProperty(exports, "utcThursdays", {
  enumerable: true,
  get: function () {
    return _utcWeek.utcThursdays;
  }
});
Object.defineProperty(exports, "utcFriday", {
  enumerable: true,
  get: function () {
    return _utcWeek.utcFriday;
  }
});
Object.defineProperty(exports, "utcFridays", {
  enumerable: true,
  get: function () {
    return _utcWeek.utcFridays;
  }
});
Object.defineProperty(exports, "utcSaturday", {
  enumerable: true,
  get: function () {
    return _utcWeek.utcSaturday;
  }
});
Object.defineProperty(exports, "utcSaturdays", {
  enumerable: true,
  get: function () {
    return _utcWeek.utcSaturdays;
  }
});
Object.defineProperty(exports, "utcMonth", {
  enumerable: true,
  get: function () {
    return _utcMonth.default;
  }
});
Object.defineProperty(exports, "utcMonths", {
  enumerable: true,
  get: function () {
    return _utcMonth.utcMonths;
  }
});
Object.defineProperty(exports, "utcYear", {
  enumerable: true,
  get: function () {
    return _utcYear.default;
  }
});
Object.defineProperty(exports, "utcYears", {
  enumerable: true,
  get: function () {
    return _utcYear.utcYears;
  }
});

var _interval = _interopRequireDefault(require("./src/interval"));

var _millisecond = _interopRequireWildcard(require("./src/millisecond"));

var _second = _interopRequireWildcard(require("./src/second"));

var _minute = _interopRequireWildcard(require("./src/minute"));

var _hour = _interopRequireWildcard(require("./src/hour"));

var _day = _interopRequireWildcard(require("./src/day"));

var _week = require("./src/week");

var _month = _interopRequireWildcard(require("./src/month"));

var _year = _interopRequireWildcard(require("./src/year"));

var _utcMinute = _interopRequireWildcard(require("./src/utcMinute"));

var _utcHour = _interopRequireWildcard(require("./src/utcHour"));

var _utcDay = _interopRequireWildcard(require("./src/utcDay"));

var _utcWeek = require("./src/utcWeek");

var _utcMonth = _interopRequireWildcard(require("./src/utcMonth"));

var _utcYear = _interopRequireWildcard(require("./src/utcYear"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./src/interval":"gsab","./src/millisecond":"r4Yr","./src/second":"K4G6","./src/minute":"sObl","./src/hour":"wPv4","./src/day":"bZMy","./src/week":"SUbU","./src/month":"XpbA","./src/year":"djmh","./src/utcMinute":"c3Ah","./src/utcHour":"sGav","./src/utcDay":"ns65","./src/utcWeek":"HsON","./src/utcMonth":"KWFc","./src/utcYear":"LM11"}],"rf9h":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = formatLocale;

var _d3Time = require("d3-time");

function localDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(-1, d.m, d.d, d.H, d.M, d.S, d.L);
    date.setFullYear(d.y);
    return date;
  }

  return new Date(d.y, d.m, d.d, d.H, d.M, d.S, d.L);
}

function utcDate(d) {
  if (0 <= d.y && d.y < 100) {
    var date = new Date(Date.UTC(-1, d.m, d.d, d.H, d.M, d.S, d.L));
    date.setUTCFullYear(d.y);
    return date;
  }

  return new Date(Date.UTC(d.y, d.m, d.d, d.H, d.M, d.S, d.L));
}

function newYear(y) {
  return {
    y: y,
    m: 0,
    d: 1,
    H: 0,
    M: 0,
    S: 0,
    L: 0
  };
}

function formatLocale(locale) {
  var locale_dateTime = locale.dateTime,
      locale_date = locale.date,
      locale_time = locale.time,
      locale_periods = locale.periods,
      locale_weekdays = locale.days,
      locale_shortWeekdays = locale.shortDays,
      locale_months = locale.months,
      locale_shortMonths = locale.shortMonths;
  var periodRe = formatRe(locale_periods),
      periodLookup = formatLookup(locale_periods),
      weekdayRe = formatRe(locale_weekdays),
      weekdayLookup = formatLookup(locale_weekdays),
      shortWeekdayRe = formatRe(locale_shortWeekdays),
      shortWeekdayLookup = formatLookup(locale_shortWeekdays),
      monthRe = formatRe(locale_months),
      monthLookup = formatLookup(locale_months),
      shortMonthRe = formatRe(locale_shortMonths),
      shortMonthLookup = formatLookup(locale_shortMonths);
  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  }; // These recursive directive definitions must be deferred.

  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);

  function newFormat(specifier, formats) {
    return function (date) {
      var string = [],
          i = -1,
          j = 0,
          n = specifier.length,
          c,
          pad,
          format;
      if (!(date instanceof Date)) date = new Date(+date);

      while (++i < n) {
        if (specifier.charCodeAt(i) === 37) {
          string.push(specifier.slice(j, i));
          if ((pad = pads[c = specifier.charAt(++i)]) != null) c = specifier.charAt(++i);else pad = c === "e" ? " " : "0";
          if (format = formats[c]) c = format(date, pad);
          string.push(c);
          j = i + 1;
        }
      }

      string.push(specifier.slice(j, i));
      return string.join("");
    };
  }

  function newParse(specifier, newDate) {
    return function (string) {
      var d = newYear(1900),
          i = parseSpecifier(d, specifier, string += "", 0),
          week,
          day;
      if (i != string.length) return null; // If a UNIX timestamp is specified, return it.

      if ("Q" in d) return new Date(d.Q); // The am-pm flag is 0 for AM, and 1 for PM.

      if ("p" in d) d.H = d.H % 12 + d.p * 12; // Convert day-of-week and week-of-year to day-of-year.

      if ("V" in d) {
        if (d.V < 1 || d.V > 53) return null;
        if (!("w" in d)) d.w = 1;

        if ("Z" in d) {
          week = utcDate(newYear(d.y)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? _d3Time.utcMonday.ceil(week) : (0, _d3Time.utcMonday)(week);
          week = _d3Time.utcDay.offset(week, (d.V - 1) * 7);
          d.y = week.getUTCFullYear();
          d.m = week.getUTCMonth();
          d.d = week.getUTCDate() + (d.w + 6) % 7;
        } else {
          week = newDate(newYear(d.y)), day = week.getDay();
          week = day > 4 || day === 0 ? _d3Time.timeMonday.ceil(week) : (0, _d3Time.timeMonday)(week);
          week = _d3Time.timeDay.offset(week, (d.V - 1) * 7);
          d.y = week.getFullYear();
          d.m = week.getMonth();
          d.d = week.getDate() + (d.w + 6) % 7;
        }
      } else if ("W" in d || "U" in d) {
        if (!("w" in d)) d.w = "u" in d ? d.u % 7 : "W" in d ? 1 : 0;
        day = "Z" in d ? utcDate(newYear(d.y)).getUTCDay() : newDate(newYear(d.y)).getDay();
        d.m = 0;
        d.d = "W" in d ? (d.w + 6) % 7 + d.W * 7 - (day + 5) % 7 : d.w + d.U * 7 - (day + 6) % 7;
      } // If a time zone is specified, all fields are interpreted as UTC and then
      // offset according to the specified time zone.


      if ("Z" in d) {
        d.H += d.Z / 100 | 0;
        d.M += d.Z % 100;
        return utcDate(d);
      } // Otherwise, all fields are in local time.


      return newDate(d);
    };
  }

  function parseSpecifier(d, specifier, string, j) {
    var i = 0,
        n = specifier.length,
        m = string.length,
        c,
        parse;

    while (i < n) {
      if (j >= m) return -1;
      c = specifier.charCodeAt(i++);

      if (c === 37) {
        c = specifier.charAt(i++);
        parse = parses[c in pads ? specifier.charAt(i++) : c];
        if (!parse || (j = parse(d, string, j)) < 0) return -1;
      } else if (c != string.charCodeAt(j++)) {
        return -1;
      }
    }

    return j;
  }

  function parsePeriod(d, string, i) {
    var n = periodRe.exec(string.slice(i));
    return n ? (d.p = periodLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortWeekday(d, string, i) {
    var n = shortWeekdayRe.exec(string.slice(i));
    return n ? (d.w = shortWeekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseWeekday(d, string, i) {
    var n = weekdayRe.exec(string.slice(i));
    return n ? (d.w = weekdayLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseShortMonth(d, string, i) {
    var n = shortMonthRe.exec(string.slice(i));
    return n ? (d.m = shortMonthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseMonth(d, string, i) {
    var n = monthRe.exec(string.slice(i));
    return n ? (d.m = monthLookup[n[0].toLowerCase()], i + n[0].length) : -1;
  }

  function parseLocaleDateTime(d, string, i) {
    return parseSpecifier(d, locale_dateTime, string, i);
  }

  function parseLocaleDate(d, string, i) {
    return parseSpecifier(d, locale_date, string, i);
  }

  function parseLocaleTime(d, string, i) {
    return parseSpecifier(d, locale_time, string, i);
  }

  function formatShortWeekday(d) {
    return locale_shortWeekdays[d.getDay()];
  }

  function formatWeekday(d) {
    return locale_weekdays[d.getDay()];
  }

  function formatShortMonth(d) {
    return locale_shortMonths[d.getMonth()];
  }

  function formatMonth(d) {
    return locale_months[d.getMonth()];
  }

  function formatPeriod(d) {
    return locale_periods[+(d.getHours() >= 12)];
  }

  function formatUTCShortWeekday(d) {
    return locale_shortWeekdays[d.getUTCDay()];
  }

  function formatUTCWeekday(d) {
    return locale_weekdays[d.getUTCDay()];
  }

  function formatUTCShortMonth(d) {
    return locale_shortMonths[d.getUTCMonth()];
  }

  function formatUTCMonth(d) {
    return locale_months[d.getUTCMonth()];
  }

  function formatUTCPeriod(d) {
    return locale_periods[+(d.getUTCHours() >= 12)];
  }

  return {
    format: function (specifier) {
      var f = newFormat(specifier += "", formats);

      f.toString = function () {
        return specifier;
      };

      return f;
    },
    parse: function (specifier) {
      var p = newParse(specifier += "", localDate);

      p.toString = function () {
        return specifier;
      };

      return p;
    },
    utcFormat: function (specifier) {
      var f = newFormat(specifier += "", utcFormats);

      f.toString = function () {
        return specifier;
      };

      return f;
    },
    utcParse: function (specifier) {
      var p = newParse(specifier, utcDate);

      p.toString = function () {
        return specifier;
      };

      return p;
    }
  };
}

var pads = {
  "-": "",
  "_": " ",
  "0": "0"
},
    numberRe = /^\s*\d+/,
    // note: ignores next directive
percentRe = /^%/,
    requoteRe = /[\\^$*+?|[\]().{}]/g;

function pad(value, fill, width) {
  var sign = value < 0 ? "-" : "",
      string = (sign ? -value : value) + "",
      length = string.length;
  return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);
}

function requote(s) {
  return s.replace(requoteRe, "\\$&");
}

function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}

function formatLookup(names) {
  var map = {},
      i = -1,
      n = names.length;

  while (++i < n) map[names[i].toLowerCase()] = i;

  return map;
}

function parseWeekdayNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.w = +n[0], i + n[0].length) : -1;
}

function parseWeekdayNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 1));
  return n ? (d.u = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberSunday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.U = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberISO(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.V = +n[0], i + n[0].length) : -1;
}

function parseWeekNumberMonday(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.W = +n[0], i + n[0].length) : -1;
}

function parseFullYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 4));
  return n ? (d.y = +n[0], i + n[0].length) : -1;
}

function parseYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.y = +n[0] + (+n[0] > 68 ? 1900 : 2000), i + n[0].length) : -1;
}

function parseZone(d, string, i) {
  var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string.slice(i, i + 6));
  return n ? (d.Z = n[1] ? 0 : -(n[2] + (n[3] || "00")), i + n[0].length) : -1;
}

function parseMonthNumber(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.m = n[0] - 1, i + n[0].length) : -1;
}

function parseDayOfMonth(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.d = +n[0], i + n[0].length) : -1;
}

function parseDayOfYear(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.m = 0, d.d = +n[0], i + n[0].length) : -1;
}

function parseHour24(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.H = +n[0], i + n[0].length) : -1;
}

function parseMinutes(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.M = +n[0], i + n[0].length) : -1;
}

function parseSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 2));
  return n ? (d.S = +n[0], i + n[0].length) : -1;
}

function parseMilliseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 3));
  return n ? (d.L = +n[0], i + n[0].length) : -1;
}

function parseMicroseconds(d, string, i) {
  var n = numberRe.exec(string.slice(i, i + 6));
  return n ? (d.L = Math.floor(n[0] / 1000), i + n[0].length) : -1;
}

function parseLiteralPercent(d, string, i) {
  var n = percentRe.exec(string.slice(i, i + 1));
  return n ? i + n[0].length : -1;
}

function parseUnixTimestamp(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0], i + n[0].length) : -1;
}

function parseUnixTimestampSeconds(d, string, i) {
  var n = numberRe.exec(string.slice(i));
  return n ? (d.Q = +n[0] * 1000, i + n[0].length) : -1;
}

function formatDayOfMonth(d, p) {
  return pad(d.getDate(), p, 2);
}

function formatHour24(d, p) {
  return pad(d.getHours(), p, 2);
}

function formatHour12(d, p) {
  return pad(d.getHours() % 12 || 12, p, 2);
}

function formatDayOfYear(d, p) {
  return pad(1 + _d3Time.timeDay.count((0, _d3Time.timeYear)(d), d), p, 3);
}

function formatMilliseconds(d, p) {
  return pad(d.getMilliseconds(), p, 3);
}

function formatMicroseconds(d, p) {
  return formatMilliseconds(d, p) + "000";
}

function formatMonthNumber(d, p) {
  return pad(d.getMonth() + 1, p, 2);
}

function formatMinutes(d, p) {
  return pad(d.getMinutes(), p, 2);
}

function formatSeconds(d, p) {
  return pad(d.getSeconds(), p, 2);
}

function formatWeekdayNumberMonday(d) {
  var day = d.getDay();
  return day === 0 ? 7 : day;
}

function formatWeekNumberSunday(d, p) {
  return pad(_d3Time.timeSunday.count((0, _d3Time.timeYear)(d), d), p, 2);
}

function formatWeekNumberISO(d, p) {
  var day = d.getDay();
  d = day >= 4 || day === 0 ? (0, _d3Time.timeThursday)(d) : _d3Time.timeThursday.ceil(d);
  return pad(_d3Time.timeThursday.count((0, _d3Time.timeYear)(d), d) + ((0, _d3Time.timeYear)(d).getDay() === 4), p, 2);
}

function formatWeekdayNumberSunday(d) {
  return d.getDay();
}

function formatWeekNumberMonday(d, p) {
  return pad(_d3Time.timeMonday.count((0, _d3Time.timeYear)(d), d), p, 2);
}

function formatYear(d, p) {
  return pad(d.getFullYear() % 100, p, 2);
}

function formatFullYear(d, p) {
  return pad(d.getFullYear() % 10000, p, 4);
}

function formatZone(d) {
  var z = d.getTimezoneOffset();
  return (z > 0 ? "-" : (z *= -1, "+")) + pad(z / 60 | 0, "0", 2) + pad(z % 60, "0", 2);
}

function formatUTCDayOfMonth(d, p) {
  return pad(d.getUTCDate(), p, 2);
}

function formatUTCHour24(d, p) {
  return pad(d.getUTCHours(), p, 2);
}

function formatUTCHour12(d, p) {
  return pad(d.getUTCHours() % 12 || 12, p, 2);
}

function formatUTCDayOfYear(d, p) {
  return pad(1 + _d3Time.utcDay.count((0, _d3Time.utcYear)(d), d), p, 3);
}

function formatUTCMilliseconds(d, p) {
  return pad(d.getUTCMilliseconds(), p, 3);
}

function formatUTCMicroseconds(d, p) {
  return formatUTCMilliseconds(d, p) + "000";
}

function formatUTCMonthNumber(d, p) {
  return pad(d.getUTCMonth() + 1, p, 2);
}

function formatUTCMinutes(d, p) {
  return pad(d.getUTCMinutes(), p, 2);
}

function formatUTCSeconds(d, p) {
  return pad(d.getUTCSeconds(), p, 2);
}

function formatUTCWeekdayNumberMonday(d) {
  var dow = d.getUTCDay();
  return dow === 0 ? 7 : dow;
}

function formatUTCWeekNumberSunday(d, p) {
  return pad(_d3Time.utcSunday.count((0, _d3Time.utcYear)(d), d), p, 2);
}

function formatUTCWeekNumberISO(d, p) {
  var day = d.getUTCDay();
  d = day >= 4 || day === 0 ? (0, _d3Time.utcThursday)(d) : _d3Time.utcThursday.ceil(d);
  return pad(_d3Time.utcThursday.count((0, _d3Time.utcYear)(d), d) + ((0, _d3Time.utcYear)(d).getUTCDay() === 4), p, 2);
}

function formatUTCWeekdayNumberSunday(d) {
  return d.getUTCDay();
}

function formatUTCWeekNumberMonday(d, p) {
  return pad(_d3Time.utcMonday.count((0, _d3Time.utcYear)(d), d), p, 2);
}

function formatUTCYear(d, p) {
  return pad(d.getUTCFullYear() % 100, p, 2);
}

function formatUTCFullYear(d, p) {
  return pad(d.getUTCFullYear() % 10000, p, 4);
}

function formatUTCZone() {
  return "+0000";
}

function formatLiteralPercent() {
  return "%";
}

function formatUnixTimestamp(d) {
  return +d;
}

function formatUnixTimestampSeconds(d) {
  return Math.floor(+d / 1000);
}
},{"d3-time":"dsMh"}],"LmVV":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = defaultLocale;
exports.utcParse = exports.utcFormat = exports.timeParse = exports.timeFormat = void 0;

var _locale = _interopRequireDefault(require("./locale"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var locale;
var timeFormat;
exports.timeFormat = timeFormat;
var timeParse;
exports.timeParse = timeParse;
var utcFormat;
exports.utcFormat = utcFormat;
var utcParse;
exports.utcParse = utcParse;
defaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});

function defaultLocale(definition) {
  locale = (0, _locale.default)(definition);
  exports.timeFormat = timeFormat = locale.format;
  exports.timeParse = timeParse = locale.parse;
  exports.utcFormat = utcFormat = locale.utcFormat;
  exports.utcParse = utcParse = locale.utcParse;
  return locale;
}
},{"./locale":"rf9h"}],"UFnF":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.isoSpecifier = void 0;

var _defaultLocale = require("./defaultLocale");

var isoSpecifier = "%Y-%m-%dT%H:%M:%S.%LZ";
exports.isoSpecifier = isoSpecifier;

function formatIsoNative(date) {
  return date.toISOString();
}

var formatIso = Date.prototype.toISOString ? formatIsoNative : (0, _defaultLocale.utcFormat)(isoSpecifier);
var _default = formatIso;
exports.default = _default;
},{"./defaultLocale":"LmVV"}],"hAdq":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isoFormat = require("./isoFormat");

var _defaultLocale = require("./defaultLocale");

function parseIsoNative(string) {
  var date = new Date(string);
  return isNaN(date) ? null : date;
}

var parseIso = +new Date("2000-01-01T00:00:00.000Z") ? parseIsoNative : (0, _defaultLocale.utcParse)(_isoFormat.isoSpecifier);
var _default = parseIso;
exports.default = _default;
},{"./isoFormat":"UFnF","./defaultLocale":"LmVV"}],"JCkU":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "timeFormatDefaultLocale", {
  enumerable: true,
  get: function () {
    return _defaultLocale.default;
  }
});
Object.defineProperty(exports, "timeFormat", {
  enumerable: true,
  get: function () {
    return _defaultLocale.timeFormat;
  }
});
Object.defineProperty(exports, "timeParse", {
  enumerable: true,
  get: function () {
    return _defaultLocale.timeParse;
  }
});
Object.defineProperty(exports, "utcFormat", {
  enumerable: true,
  get: function () {
    return _defaultLocale.utcFormat;
  }
});
Object.defineProperty(exports, "utcParse", {
  enumerable: true,
  get: function () {
    return _defaultLocale.utcParse;
  }
});
Object.defineProperty(exports, "timeFormatLocale", {
  enumerable: true,
  get: function () {
    return _locale.default;
  }
});
Object.defineProperty(exports, "isoFormat", {
  enumerable: true,
  get: function () {
    return _isoFormat.default;
  }
});
Object.defineProperty(exports, "isoParse", {
  enumerable: true,
  get: function () {
    return _isoParse.default;
  }
});

var _defaultLocale = _interopRequireWildcard(require("./src/defaultLocale"));

var _locale = _interopRequireDefault(require("./src/locale"));

var _isoFormat = _interopRequireDefault(require("./src/isoFormat"));

var _isoParse = _interopRequireDefault(require("./src/isoParse"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
},{"./src/defaultLocale":"LmVV","./src/locale":"rf9h","./src/isoFormat":"UFnF","./src/isoParse":"hAdq"}],"QHrh":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.calendar = calendar;
exports.default = _default;

var _d3Array = require("d3-array");

var _d3Interpolate = require("d3-interpolate");

var _d3Time = require("d3-time");

var _d3TimeFormat = require("d3-time-format");

var _array = require("./array");

var _continuous = _interopRequireWildcard(require("./continuous"));

var _nice = _interopRequireDefault(require("./nice"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

var durationSecond = 1000,
    durationMinute = durationSecond * 60,
    durationHour = durationMinute * 60,
    durationDay = durationHour * 24,
    durationWeek = durationDay * 7,
    durationMonth = durationDay * 30,
    durationYear = durationDay * 365;

function date(t) {
  return new Date(t);
}

function number(t) {
  return t instanceof Date ? +t : +new Date(+t);
}

function calendar(year, month, week, day, hour, minute, second, millisecond, format) {
  var scale = (0, _continuous.default)(_continuous.deinterpolateLinear, _d3Interpolate.interpolateNumber),
      invert = scale.invert,
      domain = scale.domain;
  var formatMillisecond = format(".%L"),
      formatSecond = format(":%S"),
      formatMinute = format("%I:%M"),
      formatHour = format("%I %p"),
      formatDay = format("%a %d"),
      formatWeek = format("%b %d"),
      formatMonth = format("%B"),
      formatYear = format("%Y");
  var tickIntervals = [[second, 1, durationSecond], [second, 5, 5 * durationSecond], [second, 15, 15 * durationSecond], [second, 30, 30 * durationSecond], [minute, 1, durationMinute], [minute, 5, 5 * durationMinute], [minute, 15, 15 * durationMinute], [minute, 30, 30 * durationMinute], [hour, 1, durationHour], [hour, 3, 3 * durationHour], [hour, 6, 6 * durationHour], [hour, 12, 12 * durationHour], [day, 1, durationDay], [day, 2, 2 * durationDay], [week, 1, durationWeek], [month, 1, durationMonth], [month, 3, 3 * durationMonth], [year, 1, durationYear]];

  function tickFormat(date) {
    return (second(date) < date ? formatMillisecond : minute(date) < date ? formatSecond : hour(date) < date ? formatMinute : day(date) < date ? formatHour : month(date) < date ? week(date) < date ? formatDay : formatWeek : year(date) < date ? formatMonth : formatYear)(date);
  }

  function tickInterval(interval, start, stop, step) {
    if (interval == null) interval = 10; // If a desired tick count is specified, pick a reasonable tick interval
    // based on the extent of the domain and a rough estimate of tick size.
    // Otherwise, assume interval is already a time interval and use it.

    if (typeof interval === "number") {
      var target = Math.abs(stop - start) / interval,
          i = (0, _d3Array.bisector)(function (i) {
        return i[2];
      }).right(tickIntervals, target);

      if (i === tickIntervals.length) {
        step = (0, _d3Array.tickStep)(start / durationYear, stop / durationYear, interval);
        interval = year;
      } else if (i) {
        i = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
        step = i[1];
        interval = i[0];
      } else {
        step = Math.max((0, _d3Array.tickStep)(start, stop, interval), 1);
        interval = millisecond;
      }
    }

    return step == null ? interval : interval.every(step);
  }

  scale.invert = function (y) {
    return new Date(invert(y));
  };

  scale.domain = function (_) {
    return arguments.length ? domain(_array.map.call(_, number)) : domain().map(date);
  };

  scale.ticks = function (interval, step) {
    var d = domain(),
        t0 = d[0],
        t1 = d[d.length - 1],
        r = t1 < t0,
        t;
    if (r) t = t0, t0 = t1, t1 = t;
    t = tickInterval(interval, t0, t1, step);
    t = t ? t.range(t0, t1 + 1) : []; // inclusive stop

    return r ? t.reverse() : t;
  };

  scale.tickFormat = function (count, specifier) {
    return specifier == null ? tickFormat : format(specifier);
  };

  scale.nice = function (interval, step) {
    var d = domain();
    return (interval = tickInterval(interval, d[0], d[d.length - 1], step)) ? domain((0, _nice.default)(d, interval)) : scale;
  };

  scale.copy = function () {
    return (0, _continuous.copy)(scale, calendar(year, month, week, day, hour, minute, second, millisecond, format));
  };

  return scale;
}

function _default() {
  return calendar(_d3Time.timeYear, _d3Time.timeMonth, _d3Time.timeWeek, _d3Time.timeDay, _d3Time.timeHour, _d3Time.timeMinute, _d3Time.timeSecond, _d3Time.timeMillisecond, _d3TimeFormat.timeFormat).domain([new Date(2000, 0, 1), new Date(2000, 0, 2)]);
}
},{"d3-array":"ybfZ","d3-interpolate":"nuBz","d3-time":"dsMh","d3-time-format":"JCkU","./array":"lLkj","./continuous":"ZpMB","./nice":"gRJQ"}],"D6Mr":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _time = require("./time");

var _d3TimeFormat = require("d3-time-format");

var _d3Time = require("d3-time");

function _default() {
  return (0, _time.calendar)(_d3Time.utcYear, _d3Time.utcMonth, _d3Time.utcWeek, _d3Time.utcDay, _d3Time.utcHour, _d3Time.utcMinute, _d3Time.utcSecond, _d3Time.utcMillisecond, _d3TimeFormat.utcFormat).domain([Date.UTC(2000, 0, 1), Date.UTC(2000, 0, 2)]);
}
},{"./time":"QHrh","d3-time-format":"JCkU","d3-time":"dsMh"}],"Tmn2":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(s) {
  return s.match(/.{6}/g).map(function (x) {
    return "#" + x;
  });
}
},{}],"qJ0X":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _colors = _interopRequireDefault(require("./colors"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = (0, _colors.default)("1f77b4ff7f0e2ca02cd627289467bd8c564be377c27f7f7fbcbd2217becf");

exports.default = _default;
},{"./colors":"Tmn2"}],"C9nM":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _colors = _interopRequireDefault(require("./colors"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = (0, _colors.default)("393b795254a36b6ecf9c9ede6379398ca252b5cf6bcedb9c8c6d31bd9e39e7ba52e7cb94843c39ad494ad6616be7969c7b4173a55194ce6dbdde9ed6");

exports.default = _default;
},{"./colors":"Tmn2"}],"Xza9":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _colors = _interopRequireDefault(require("./colors"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = (0, _colors.default)("3182bd6baed69ecae1c6dbefe6550dfd8d3cfdae6bfdd0a231a35474c476a1d99bc7e9c0756bb19e9ac8bcbddcdadaeb636363969696bdbdbdd9d9d9");

exports.default = _default;
},{"./colors":"Tmn2"}],"vUCQ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _colors = _interopRequireDefault(require("./colors"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = (0, _colors.default)("1f77b4aec7e8ff7f0effbb782ca02c98df8ad62728ff98969467bdc5b0d58c564bc49c94e377c2f7b6d27f7f7fc7c7c7bcbd22dbdb8d17becf9edae5");

exports.default = _default;
},{"./colors":"Tmn2"}],"M450":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _d3Color = require("d3-color");

var _d3Interpolate = require("d3-interpolate");

var _default = (0, _d3Interpolate.interpolateCubehelixLong)((0, _d3Color.cubehelix)(300, 0.5, 0.0), (0, _d3Color.cubehelix)(-240, 0.5, 1.0));

exports.default = _default;
},{"d3-color":"RuBy","d3-interpolate":"nuBz"}],"pu2q":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.cool = exports.warm = void 0;

var _d3Color = require("d3-color");

var _d3Interpolate = require("d3-interpolate");

var warm = (0, _d3Interpolate.interpolateCubehelixLong)((0, _d3Color.cubehelix)(-100, 0.75, 0.35), (0, _d3Color.cubehelix)(80, 1.50, 0.8));
exports.warm = warm;
var cool = (0, _d3Interpolate.interpolateCubehelixLong)((0, _d3Color.cubehelix)(260, 0.75, 0.35), (0, _d3Color.cubehelix)(80, 1.50, 0.8));
exports.cool = cool;
var rainbow = (0, _d3Color.cubehelix)();

function _default(t) {
  if (t < 0 || t > 1) t -= Math.floor(t);
  var ts = Math.abs(t - 0.5);
  rainbow.h = 360 * t - 100;
  rainbow.s = 1.5 - 1.5 * ts;
  rainbow.l = 0.8 - 0.9 * ts;
  return rainbow + "";
}
},{"d3-color":"RuBy","d3-interpolate":"nuBz"}],"Kdyr":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.plasma = exports.inferno = exports.magma = exports.default = void 0;

var _colors = _interopRequireDefault(require("./colors"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function ramp(range) {
  var n = range.length;
  return function (t) {
    return range[Math.max(0, Math.min(n - 1, Math.floor(t * n)))];
  };
}

var _default = ramp((0, _colors.default)("44015444025645045745055946075a46085c460a5d460b5e470d60470e6147106347116447136548146748166848176948186a481a6c481b6d481c6e481d6f481f70482071482173482374482475482576482677482878482979472a7a472c7a472d7b472e7c472f7d46307e46327e46337f463480453581453781453882443983443a83443b84433d84433e85423f854240864241864142874144874045884046883f47883f48893e49893e4a893e4c8a3d4d8a3d4e8a3c4f8a3c508b3b518b3b528b3a538b3a548c39558c39568c38588c38598c375a8c375b8d365c8d365d8d355e8d355f8d34608d34618d33628d33638d32648e32658e31668e31678e31688e30698e306a8e2f6b8e2f6c8e2e6d8e2e6e8e2e6f8e2d708e2d718e2c718e2c728e2c738e2b748e2b758e2a768e2a778e2a788e29798e297a8e297b8e287c8e287d8e277e8e277f8e27808e26818e26828e26828e25838e25848e25858e24868e24878e23888e23898e238a8d228b8d228c8d228d8d218e8d218f8d21908d21918c20928c20928c20938c1f948c1f958b1f968b1f978b1f988b1f998a1f9a8a1e9b8a1e9c891e9d891f9e891f9f881fa0881fa1881fa1871fa28720a38620a48621a58521a68522a78522a88423a98324aa8325ab8225ac8226ad8127ad8128ae8029af7f2ab07f2cb17e2db27d2eb37c2fb47c31b57b32b67a34b67935b77937b87838b9773aba763bbb753dbc743fbc7340bd7242be7144bf7046c06f48c16e4ac16d4cc26c4ec36b50c46a52c56954c56856c66758c7655ac8645cc8635ec96260ca6063cb5f65cb5e67cc5c69cd5b6ccd5a6ece5870cf5773d05675d05477d1537ad1517cd2507fd34e81d34d84d44b86d54989d5488bd6468ed64590d74393d74195d84098d83e9bd93c9dd93ba0da39a2da37a5db36a8db34aadc32addc30b0dd2fb2dd2db5de2bb8de29bade28bddf26c0df25c2df23c5e021c8e020cae11fcde11dd0e11cd2e21bd5e21ad8e219dae319dde318dfe318e2e418e5e419e7e419eae51aece51befe51cf1e51df4e61ef6e620f8e621fbe723fde725"));

exports.default = _default;
var magma = ramp((0, _colors.default)("00000401000501010601010802010902020b02020d03030f03031204041405041606051806051a07061c08071e0907200a08220b09240c09260d0a290e0b2b100b2d110c2f120d31130d34140e36150e38160f3b180f3d19103f1a10421c10441d11471e114920114b21114e22115024125325125527125829115a2a115c2c115f2d11612f116331116533106734106936106b38106c390f6e3b0f703d0f713f0f72400f74420f75440f764510774710784910784a10794c117a4e117b4f127b51127c52137c54137d56147d57157e59157e5a167e5c167f5d177f5f187f601880621980641a80651a80671b80681c816a1c816b1d816d1d816e1e81701f81721f817320817521817621817822817922827b23827c23827e24828025828125818326818426818627818827818928818b29818c29818e2a81902a81912b81932b80942c80962c80982d80992d809b2e7f9c2e7f9e2f7fa02f7fa1307ea3307ea5317ea6317da8327daa337dab337cad347cae347bb0357bb2357bb3367ab5367ab73779b83779ba3878bc3978bd3977bf3a77c03a76c23b75c43c75c53c74c73d73c83e73ca3e72cc3f71cd4071cf4070d0416fd2426fd3436ed5446dd6456cd8456cd9466bdb476adc4869de4968df4a68e04c67e24d66e34e65e44f64e55064e75263e85362e95462ea5661eb5760ec5860ed5a5fee5b5eef5d5ef05f5ef1605df2625df2645cf3655cf4675cf4695cf56b5cf66c5cf66e5cf7705cf7725cf8745cf8765cf9785df9795df97b5dfa7d5efa7f5efa815ffb835ffb8560fb8761fc8961fc8a62fc8c63fc8e64fc9065fd9266fd9467fd9668fd9869fd9a6afd9b6bfe9d6cfe9f6dfea16efea36ffea571fea772fea973feaa74feac76feae77feb078feb27afeb47bfeb67cfeb77efeb97ffebb81febd82febf84fec185fec287fec488fec68afec88cfeca8dfecc8ffecd90fecf92fed194fed395fed597fed799fed89afdda9cfddc9efddea0fde0a1fde2a3fde3a5fde5a7fde7a9fde9aafdebacfcecaefceeb0fcf0b2fcf2b4fcf4b6fcf6b8fcf7b9fcf9bbfcfbbdfcfdbf"));
exports.magma = magma;
var inferno = ramp((0, _colors.default)("00000401000501010601010802010a02020c02020e03021004031204031405041706041907051b08051d09061f0a07220b07240c08260d08290e092b10092d110a30120a32140b34150b37160b39180c3c190c3e1b0c411c0c431e0c451f0c48210c4a230c4c240c4f260c51280b53290b552b0b572d0b592f0a5b310a5c320a5e340a5f3609613809623909633b09643d09653e0966400a67420a68440a68450a69470b6a490b6a4a0c6b4c0c6b4d0d6c4f0d6c510e6c520e6d540f6d550f6d57106e59106e5a116e5c126e5d126e5f136e61136e62146e64156e65156e67166e69166e6a176e6c186e6d186e6f196e71196e721a6e741a6e751b6e771c6d781c6d7a1d6d7c1d6d7d1e6d7f1e6c801f6c82206c84206b85216b87216b88226a8a226a8c23698d23698f24699025689225689326679526679727669827669a28659b29649d29649f2a63a02a63a22b62a32c61a52c60a62d60a82e5fa92e5eab2f5ead305dae305cb0315bb1325ab3325ab43359b63458b73557b93556ba3655bc3754bd3853bf3952c03a51c13a50c33b4fc43c4ec63d4dc73e4cc83f4bca404acb4149cc4248ce4347cf4446d04545d24644d34743d44842d54a41d74b3fd84c3ed94d3dda4e3cdb503bdd513ade5238df5337e05536e15635e25734e35933e45a31e55c30e65d2fe75e2ee8602de9612bea632aeb6429eb6628ec6726ed6925ee6a24ef6c23ef6e21f06f20f1711ff1731df2741cf3761bf37819f47918f57b17f57d15f67e14f68013f78212f78410f8850ff8870ef8890cf98b0bf98c0af98e09fa9008fa9207fa9407fb9606fb9706fb9906fb9b06fb9d07fc9f07fca108fca309fca50afca60cfca80dfcaa0ffcac11fcae12fcb014fcb216fcb418fbb61afbb81dfbba1ffbbc21fbbe23fac026fac228fac42afac62df9c72ff9c932f9cb35f8cd37f8cf3af7d13df7d340f6d543f6d746f5d949f5db4cf4dd4ff4df53f4e156f3e35af3e55df2e661f2e865f2ea69f1ec6df1ed71f1ef75f1f179f2f27df2f482f3f586f3f68af4f88ef5f992f6fa96f8fb9af9fc9dfafda1fcffa4"));
exports.inferno = inferno;
var plasma = ramp((0, _colors.default)("0d088710078813078916078a19068c1b068d1d068e20068f2206902406912605912805922a05932c05942e05952f059631059733059735049837049938049a3a049a3c049b3e049c3f049c41049d43039e44039e46039f48039f4903a04b03a14c02a14e02a25002a25102a35302a35502a45601a45801a45901a55b01a55c01a65e01a66001a66100a76300a76400a76600a76700a86900a86a00a86c00a86e00a86f00a87100a87201a87401a87501a87701a87801a87a02a87b02a87d03a87e03a88004a88104a78305a78405a78606a68707a68808a68a09a58b0aa58d0ba58e0ca48f0da4910ea3920fa39410a29511a19613a19814a099159f9a169f9c179e9d189d9e199da01a9ca11b9ba21d9aa31e9aa51f99a62098a72197a82296aa2395ab2494ac2694ad2793ae2892b02991b12a90b22b8fb32c8eb42e8db52f8cb6308bb7318ab83289ba3388bb3488bc3587bd3786be3885bf3984c03a83c13b82c23c81c33d80c43e7fc5407ec6417dc7427cc8437bc9447aca457acb4679cc4778cc4977cd4a76ce4b75cf4c74d04d73d14e72d24f71d35171d45270d5536fd5546ed6556dd7566cd8576bd9586ada5a6ada5b69db5c68dc5d67dd5e66de5f65de6164df6263e06363e16462e26561e26660e3685fe4695ee56a5de56b5de66c5ce76e5be76f5ae87059e97158e97257ea7457eb7556eb7655ec7754ed7953ed7a52ee7b51ef7c51ef7e50f07f4ff0804ef1814df1834cf2844bf3854bf3874af48849f48948f58b47f58c46f68d45f68f44f79044f79143f79342f89441f89540f9973ff9983ef99a3efa9b3dfa9c3cfa9e3bfb9f3afba139fba238fca338fca537fca636fca835fca934fdab33fdac33fdae32fdaf31fdb130fdb22ffdb42ffdb52efeb72dfeb82cfeba2cfebb2bfebd2afebe2afec029fdc229fdc328fdc527fdc627fdc827fdca26fdcb26fccd25fcce25fcd025fcd225fbd324fbd524fbd724fad824fada24f9dc24f9dd25f8df25f8e125f7e225f7e425f6e626f6e826f5e926f5eb27f4ed27f3ee27f3f027f2f227f1f426f1f525f0f724f0f921"));
exports.plasma = plasma;
},{"./colors":"Tmn2"}],"O1DZ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = sequential;

var _linear = require("./linear");

function sequential(interpolator) {
  var x0 = 0,
      x1 = 1,
      clamp = false;

  function scale(x) {
    var t = (x - x0) / (x1 - x0);
    return interpolator(clamp ? Math.max(0, Math.min(1, t)) : t);
  }

  scale.domain = function (_) {
    return arguments.length ? (x0 = +_[0], x1 = +_[1], scale) : [x0, x1];
  };

  scale.clamp = function (_) {
    return arguments.length ? (clamp = !!_, scale) : clamp;
  };

  scale.interpolator = function (_) {
    return arguments.length ? (interpolator = _, scale) : interpolator;
  };

  scale.copy = function () {
    return sequential(interpolator).domain([x0, x1]).clamp(clamp);
  };

  return (0, _linear.linearish)(scale);
}
},{"./linear":"VMtl"}],"uY15":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "scaleBand", {
  enumerable: true,
  get: function () {
    return _band.default;
  }
});
Object.defineProperty(exports, "scalePoint", {
  enumerable: true,
  get: function () {
    return _band.point;
  }
});
Object.defineProperty(exports, "scaleIdentity", {
  enumerable: true,
  get: function () {
    return _identity.default;
  }
});
Object.defineProperty(exports, "scaleLinear", {
  enumerable: true,
  get: function () {
    return _linear.default;
  }
});
Object.defineProperty(exports, "scaleLog", {
  enumerable: true,
  get: function () {
    return _log.default;
  }
});
Object.defineProperty(exports, "scaleOrdinal", {
  enumerable: true,
  get: function () {
    return _ordinal.default;
  }
});
Object.defineProperty(exports, "scaleImplicit", {
  enumerable: true,
  get: function () {
    return _ordinal.implicit;
  }
});
Object.defineProperty(exports, "scalePow", {
  enumerable: true,
  get: function () {
    return _pow.default;
  }
});
Object.defineProperty(exports, "scaleSqrt", {
  enumerable: true,
  get: function () {
    return _pow.sqrt;
  }
});
Object.defineProperty(exports, "scaleQuantile", {
  enumerable: true,
  get: function () {
    return _quantile.default;
  }
});
Object.defineProperty(exports, "scaleQuantize", {
  enumerable: true,
  get: function () {
    return _quantize.default;
  }
});
Object.defineProperty(exports, "scaleThreshold", {
  enumerable: true,
  get: function () {
    return _threshold.default;
  }
});
Object.defineProperty(exports, "scaleTime", {
  enumerable: true,
  get: function () {
    return _time.default;
  }
});
Object.defineProperty(exports, "scaleUtc", {
  enumerable: true,
  get: function () {
    return _utcTime.default;
  }
});
Object.defineProperty(exports, "schemeCategory10", {
  enumerable: true,
  get: function () {
    return _category.default;
  }
});
Object.defineProperty(exports, "schemeCategory20b", {
  enumerable: true,
  get: function () {
    return _category20b.default;
  }
});
Object.defineProperty(exports, "schemeCategory20c", {
  enumerable: true,
  get: function () {
    return _category20c.default;
  }
});
Object.defineProperty(exports, "schemeCategory20", {
  enumerable: true,
  get: function () {
    return _category2.default;
  }
});
Object.defineProperty(exports, "interpolateCubehelixDefault", {
  enumerable: true,
  get: function () {
    return _cubehelix.default;
  }
});
Object.defineProperty(exports, "interpolateRainbow", {
  enumerable: true,
  get: function () {
    return _rainbow.default;
  }
});
Object.defineProperty(exports, "interpolateWarm", {
  enumerable: true,
  get: function () {
    return _rainbow.warm;
  }
});
Object.defineProperty(exports, "interpolateCool", {
  enumerable: true,
  get: function () {
    return _rainbow.cool;
  }
});
Object.defineProperty(exports, "interpolateViridis", {
  enumerable: true,
  get: function () {
    return _viridis.default;
  }
});
Object.defineProperty(exports, "interpolateMagma", {
  enumerable: true,
  get: function () {
    return _viridis.magma;
  }
});
Object.defineProperty(exports, "interpolateInferno", {
  enumerable: true,
  get: function () {
    return _viridis.inferno;
  }
});
Object.defineProperty(exports, "interpolatePlasma", {
  enumerable: true,
  get: function () {
    return _viridis.plasma;
  }
});
Object.defineProperty(exports, "scaleSequential", {
  enumerable: true,
  get: function () {
    return _sequential.default;
  }
});

var _band = _interopRequireWildcard(require("./src/band"));

var _identity = _interopRequireDefault(require("./src/identity"));

var _linear = _interopRequireDefault(require("./src/linear"));

var _log = _interopRequireDefault(require("./src/log"));

var _ordinal = _interopRequireWildcard(require("./src/ordinal"));

var _pow = _interopRequireWildcard(require("./src/pow"));

var _quantile = _interopRequireDefault(require("./src/quantile"));

var _quantize = _interopRequireDefault(require("./src/quantize"));

var _threshold = _interopRequireDefault(require("./src/threshold"));

var _time = _interopRequireDefault(require("./src/time"));

var _utcTime = _interopRequireDefault(require("./src/utcTime"));

var _category = _interopRequireDefault(require("./src/category10"));

var _category20b = _interopRequireDefault(require("./src/category20b"));

var _category20c = _interopRequireDefault(require("./src/category20c"));

var _category2 = _interopRequireDefault(require("./src/category20"));

var _cubehelix = _interopRequireDefault(require("./src/cubehelix"));

var _rainbow = _interopRequireWildcard(require("./src/rainbow"));

var _viridis = _interopRequireWildcard(require("./src/viridis"));

var _sequential = _interopRequireDefault(require("./src/sequential"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
},{"./src/band":"rJZF","./src/identity":"eP89","./src/linear":"VMtl","./src/log":"X3YW","./src/ordinal":"ELIM","./src/pow":"ysea","./src/quantile":"fsZk","./src/quantize":"Z2cL","./src/threshold":"odYE","./src/time":"QHrh","./src/utcTime":"D6Mr","./src/category10":"qJ0X","./src/category20b":"C9nM","./src/category20c":"Xza9","./src/category20":"vUCQ","./src/cubehelix":"M450","./src/rainbow":"pu2q","./src/viridis":"Kdyr","./src/sequential":"O1DZ"}],"D3Ln":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(x) {
  return function constant() {
    return x;
  };
}
},{}],"R8vA":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.acos = acos;
exports.asin = asin;
exports.tau = exports.halfPi = exports.pi = exports.epsilon = exports.sqrt = exports.sin = exports.min = exports.max = exports.cos = exports.atan2 = exports.abs = void 0;
var abs = Math.abs;
exports.abs = abs;
var atan2 = Math.atan2;
exports.atan2 = atan2;
var cos = Math.cos;
exports.cos = cos;
var max = Math.max;
exports.max = max;
var min = Math.min;
exports.min = min;
var sin = Math.sin;
exports.sin = sin;
var sqrt = Math.sqrt;
exports.sqrt = sqrt;
var epsilon = 1e-12;
exports.epsilon = epsilon;
var pi = Math.PI;
exports.pi = pi;
var halfPi = pi / 2;
exports.halfPi = halfPi;
var tau = 2 * pi;
exports.tau = tau;

function acos(x) {
  return x > 1 ? 0 : x < -1 ? pi : Math.acos(x);
}

function asin(x) {
  return x >= 1 ? halfPi : x <= -1 ? -halfPi : Math.asin(x);
}
},{}],"TV07":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _d3Path = require("d3-path");

var _constant = _interopRequireDefault(require("./constant"));

var _math = require("./math");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function arcInnerRadius(d) {
  return d.innerRadius;
}

function arcOuterRadius(d) {
  return d.outerRadius;
}

function arcStartAngle(d) {
  return d.startAngle;
}

function arcEndAngle(d) {
  return d.endAngle;
}

function arcPadAngle(d) {
  return d && d.padAngle; // Note: optional!
}

function intersect(x0, y0, x1, y1, x2, y2, x3, y3) {
  var x10 = x1 - x0,
      y10 = y1 - y0,
      x32 = x3 - x2,
      y32 = y3 - y2,
      t = (x32 * (y0 - y2) - y32 * (x0 - x2)) / (y32 * x10 - x32 * y10);
  return [x0 + t * x10, y0 + t * y10];
} // Compute perpendicular offset line of length rc.
// http://mathworld.wolfram.com/Circle-LineIntersection.html


function cornerTangents(x0, y0, x1, y1, r1, rc, cw) {
  var x01 = x0 - x1,
      y01 = y0 - y1,
      lo = (cw ? rc : -rc) / (0, _math.sqrt)(x01 * x01 + y01 * y01),
      ox = lo * y01,
      oy = -lo * x01,
      x11 = x0 + ox,
      y11 = y0 + oy,
      x10 = x1 + ox,
      y10 = y1 + oy,
      x00 = (x11 + x10) / 2,
      y00 = (y11 + y10) / 2,
      dx = x10 - x11,
      dy = y10 - y11,
      d2 = dx * dx + dy * dy,
      r = r1 - rc,
      D = x11 * y10 - x10 * y11,
      d = (dy < 0 ? -1 : 1) * (0, _math.sqrt)((0, _math.max)(0, r * r * d2 - D * D)),
      cx0 = (D * dy - dx * d) / d2,
      cy0 = (-D * dx - dy * d) / d2,
      cx1 = (D * dy + dx * d) / d2,
      cy1 = (-D * dx + dy * d) / d2,
      dx0 = cx0 - x00,
      dy0 = cy0 - y00,
      dx1 = cx1 - x00,
      dy1 = cy1 - y00; // Pick the closer of the two intersection points.
  // TODO Is there a faster way to determine which intersection to use?

  if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;
  return {
    cx: cx0,
    cy: cy0,
    x01: -ox,
    y01: -oy,
    x11: cx0 * (r1 / r - 1),
    y11: cy0 * (r1 / r - 1)
  };
}

function _default() {
  var innerRadius = arcInnerRadius,
      outerRadius = arcOuterRadius,
      cornerRadius = (0, _constant.default)(0),
      padRadius = null,
      startAngle = arcStartAngle,
      endAngle = arcEndAngle,
      padAngle = arcPadAngle,
      context = null;

  function arc() {
    var buffer,
        r,
        r0 = +innerRadius.apply(this, arguments),
        r1 = +outerRadius.apply(this, arguments),
        a0 = startAngle.apply(this, arguments) - _math.halfPi,
        a1 = endAngle.apply(this, arguments) - _math.halfPi,
        da = (0, _math.abs)(a1 - a0),
        cw = a1 > a0;

    if (!context) context = buffer = (0, _d3Path.path)(); // Ensure that the outer radius is always larger than the inner radius.

    if (r1 < r0) r = r1, r1 = r0, r0 = r; // Is it a point?

    if (!(r1 > _math.epsilon)) context.moveTo(0, 0); // Or is it a circle or annulus?
    else if (da > _math.tau - _math.epsilon) {
        context.moveTo(r1 * (0, _math.cos)(a0), r1 * (0, _math.sin)(a0));
        context.arc(0, 0, r1, a0, a1, !cw);

        if (r0 > _math.epsilon) {
          context.moveTo(r0 * (0, _math.cos)(a1), r0 * (0, _math.sin)(a1));
          context.arc(0, 0, r0, a1, a0, cw);
        }
      } // Or is it a circular or annular sector?
      else {
          var a01 = a0,
              a11 = a1,
              a00 = a0,
              a10 = a1,
              da0 = da,
              da1 = da,
              ap = padAngle.apply(this, arguments) / 2,
              rp = ap > _math.epsilon && (padRadius ? +padRadius.apply(this, arguments) : (0, _math.sqrt)(r0 * r0 + r1 * r1)),
              rc = (0, _math.min)((0, _math.abs)(r1 - r0) / 2, +cornerRadius.apply(this, arguments)),
              rc0 = rc,
              rc1 = rc,
              t0,
              t1; // Apply padding? Note that since r1 ≥ r0, da1 ≥ da0.

          if (rp > _math.epsilon) {
            var p0 = (0, _math.asin)(rp / r0 * (0, _math.sin)(ap)),
                p1 = (0, _math.asin)(rp / r1 * (0, _math.sin)(ap));
            if ((da0 -= p0 * 2) > _math.epsilon) p0 *= cw ? 1 : -1, a00 += p0, a10 -= p0;else da0 = 0, a00 = a10 = (a0 + a1) / 2;
            if ((da1 -= p1 * 2) > _math.epsilon) p1 *= cw ? 1 : -1, a01 += p1, a11 -= p1;else da1 = 0, a01 = a11 = (a0 + a1) / 2;
          }

          var x01 = r1 * (0, _math.cos)(a01),
              y01 = r1 * (0, _math.sin)(a01),
              x10 = r0 * (0, _math.cos)(a10),
              y10 = r0 * (0, _math.sin)(a10); // Apply rounded corners?

          if (rc > _math.epsilon) {
            var x11 = r1 * (0, _math.cos)(a11),
                y11 = r1 * (0, _math.sin)(a11),
                x00 = r0 * (0, _math.cos)(a00),
                y00 = r0 * (0, _math.sin)(a00); // Restrict the corner radius according to the sector angle.

            if (da < _math.pi) {
              var oc = da0 > _math.epsilon ? intersect(x01, y01, x00, y00, x11, y11, x10, y10) : [x10, y10],
                  ax = x01 - oc[0],
                  ay = y01 - oc[1],
                  bx = x11 - oc[0],
                  by = y11 - oc[1],
                  kc = 1 / (0, _math.sin)((0, _math.acos)((ax * bx + ay * by) / ((0, _math.sqrt)(ax * ax + ay * ay) * (0, _math.sqrt)(bx * bx + by * by))) / 2),
                  lc = (0, _math.sqrt)(oc[0] * oc[0] + oc[1] * oc[1]);
              rc0 = (0, _math.min)(rc, (r0 - lc) / (kc - 1));
              rc1 = (0, _math.min)(rc, (r1 - lc) / (kc + 1));
            }
          } // Is the sector collapsed to a line?


          if (!(da1 > _math.epsilon)) context.moveTo(x01, y01); // Does the sector’s outer ring have rounded corners?
          else if (rc1 > _math.epsilon) {
              t0 = cornerTangents(x00, y00, x01, y01, r1, rc1, cw);
              t1 = cornerTangents(x11, y11, x10, y10, r1, rc1, cw);
              context.moveTo(t0.cx + t0.x01, t0.cy + t0.y01); // Have the corners merged?

              if (rc1 < rc) context.arc(t0.cx, t0.cy, rc1, (0, _math.atan2)(t0.y01, t0.x01), (0, _math.atan2)(t1.y01, t1.x01), !cw); // Otherwise, draw the two corners and the ring.
              else {
                  context.arc(t0.cx, t0.cy, rc1, (0, _math.atan2)(t0.y01, t0.x01), (0, _math.atan2)(t0.y11, t0.x11), !cw);
                  context.arc(0, 0, r1, (0, _math.atan2)(t0.cy + t0.y11, t0.cx + t0.x11), (0, _math.atan2)(t1.cy + t1.y11, t1.cx + t1.x11), !cw);
                  context.arc(t1.cx, t1.cy, rc1, (0, _math.atan2)(t1.y11, t1.x11), (0, _math.atan2)(t1.y01, t1.x01), !cw);
                }
            } // Or is the outer ring just a circular arc?
            else context.moveTo(x01, y01), context.arc(0, 0, r1, a01, a11, !cw); // Is there no inner ring, and it’s a circular sector?
          // Or perhaps it’s an annular sector collapsed due to padding?

          if (!(r0 > _math.epsilon) || !(da0 > _math.epsilon)) context.lineTo(x10, y10); // Does the sector’s inner ring (or point) have rounded corners?
          else if (rc0 > _math.epsilon) {
              t0 = cornerTangents(x10, y10, x11, y11, r0, -rc0, cw);
              t1 = cornerTangents(x01, y01, x00, y00, r0, -rc0, cw);
              context.lineTo(t0.cx + t0.x01, t0.cy + t0.y01); // Have the corners merged?

              if (rc0 < rc) context.arc(t0.cx, t0.cy, rc0, (0, _math.atan2)(t0.y01, t0.x01), (0, _math.atan2)(t1.y01, t1.x01), !cw); // Otherwise, draw the two corners and the ring.
              else {
                  context.arc(t0.cx, t0.cy, rc0, (0, _math.atan2)(t0.y01, t0.x01), (0, _math.atan2)(t0.y11, t0.x11), !cw);
                  context.arc(0, 0, r0, (0, _math.atan2)(t0.cy + t0.y11, t0.cx + t0.x11), (0, _math.atan2)(t1.cy + t1.y11, t1.cx + t1.x11), cw);
                  context.arc(t1.cx, t1.cy, rc0, (0, _math.atan2)(t1.y11, t1.x11), (0, _math.atan2)(t1.y01, t1.x01), !cw);
                }
            } // Or is the inner ring just a circular arc?
            else context.arc(0, 0, r0, a10, a00, cw);
        }
    context.closePath();
    if (buffer) return context = null, buffer + "" || null;
  }

  arc.centroid = function () {
    var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2,
        a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - _math.pi / 2;
    return [(0, _math.cos)(a) * r, (0, _math.sin)(a) * r];
  };

  arc.innerRadius = function (_) {
    return arguments.length ? (innerRadius = typeof _ === "function" ? _ : (0, _constant.default)(+_), arc) : innerRadius;
  };

  arc.outerRadius = function (_) {
    return arguments.length ? (outerRadius = typeof _ === "function" ? _ : (0, _constant.default)(+_), arc) : outerRadius;
  };

  arc.cornerRadius = function (_) {
    return arguments.length ? (cornerRadius = typeof _ === "function" ? _ : (0, _constant.default)(+_), arc) : cornerRadius;
  };

  arc.padRadius = function (_) {
    return arguments.length ? (padRadius = _ == null ? null : typeof _ === "function" ? _ : (0, _constant.default)(+_), arc) : padRadius;
  };

  arc.startAngle = function (_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : (0, _constant.default)(+_), arc) : startAngle;
  };

  arc.endAngle = function (_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : (0, _constant.default)(+_), arc) : endAngle;
  };

  arc.padAngle = function (_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : (0, _constant.default)(+_), arc) : padAngle;
  };

  arc.context = function (_) {
    return arguments.length ? (context = _ == null ? null : _, arc) : context;
  };

  return arc;
}
},{"d3-path":"ZiSL","./constant":"D3Ln","./math":"R8vA"}],"VCF9":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function Linear(context) {
  this._context = context;
}

Linear.prototype = {
  areaStart: function () {
    this._line = 0;
  },
  areaEnd: function () {
    this._line = NaN;
  },
  lineStart: function () {
    this._point = 0;
  },
  lineEnd: function () {
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function (x, y) {
    x = +x, y = +y;

    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
        break;

      case 1:
        this._point = 2;
      // proceed

      default:
        this._context.lineTo(x, y);

        break;
    }
  }
};

function _default(context) {
  return new Linear(context);
}
},{}],"aLIe":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.x = x;
exports.y = y;

function x(p) {
  return p[0];
}

function y(p) {
  return p[1];
}
},{}],"UmeQ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _d3Path = require("d3-path");

var _constant = _interopRequireDefault(require("./constant"));

var _linear = _interopRequireDefault(require("./curve/linear"));

var _point = require("./point");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default() {
  var x = _point.x,
      y = _point.y,
      defined = (0, _constant.default)(true),
      context = null,
      curve = _linear.default,
      output = null;

  function line(data) {
    var i,
        n = data.length,
        d,
        defined0 = false,
        buffer;
    if (context == null) output = curve(buffer = (0, _d3Path.path)());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) output.lineStart();else output.lineEnd();
      }

      if (defined0) output.point(+x(d, i, data), +y(d, i, data));
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  line.x = function (_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : (0, _constant.default)(+_), line) : x;
  };

  line.y = function (_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : (0, _constant.default)(+_), line) : y;
  };

  line.defined = function (_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : (0, _constant.default)(!!_), line) : defined;
  };

  line.curve = function (_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };

  line.context = function (_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };

  return line;
}
},{"d3-path":"ZiSL","./constant":"D3Ln","./curve/linear":"VCF9","./point":"aLIe"}],"UWil":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _d3Path = require("d3-path");

var _constant = _interopRequireDefault(require("./constant"));

var _linear = _interopRequireDefault(require("./curve/linear"));

var _line = _interopRequireDefault(require("./line"));

var _point = require("./point");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default() {
  var x0 = _point.x,
      x1 = null,
      y0 = (0, _constant.default)(0),
      y1 = _point.y,
      defined = (0, _constant.default)(true),
      context = null,
      curve = _linear.default,
      output = null;

  function area(data) {
    var i,
        j,
        k,
        n = data.length,
        d,
        defined0 = false,
        buffer,
        x0z = new Array(n),
        y0z = new Array(n);
    if (context == null) output = curve(buffer = (0, _d3Path.path)());

    for (i = 0; i <= n; ++i) {
      if (!(i < n && defined(d = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();

          for (k = i - 1; k >= j; --k) {
            output.point(x0z[k], y0z[k]);
          }

          output.lineEnd();
          output.areaEnd();
        }
      }

      if (defined0) {
        x0z[i] = +x0(d, i, data), y0z[i] = +y0(d, i, data);
        output.point(x1 ? +x1(d, i, data) : x0z[i], y1 ? +y1(d, i, data) : y0z[i]);
      }
    }

    if (buffer) return output = null, buffer + "" || null;
  }

  function arealine() {
    return (0, _line.default)().defined(defined).curve(curve).context(context);
  }

  area.x = function (_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : (0, _constant.default)(+_), x1 = null, area) : x0;
  };

  area.x0 = function (_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : (0, _constant.default)(+_), area) : x0;
  };

  area.x1 = function (_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : (0, _constant.default)(+_), area) : x1;
  };

  area.y = function (_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : (0, _constant.default)(+_), y1 = null, area) : y0;
  };

  area.y0 = function (_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : (0, _constant.default)(+_), area) : y0;
  };

  area.y1 = function (_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : (0, _constant.default)(+_), area) : y1;
  };

  area.lineX0 = area.lineY0 = function () {
    return arealine().x(x0).y(y0);
  };

  area.lineY1 = function () {
    return arealine().x(x0).y(y1);
  };

  area.lineX1 = function () {
    return arealine().x(x1).y(y0);
  };

  area.defined = function (_) {
    return arguments.length ? (defined = typeof _ === "function" ? _ : (0, _constant.default)(!!_), area) : defined;
  };

  area.curve = function (_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };

  area.context = function (_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };

  return area;
}
},{"d3-path":"ZiSL","./constant":"D3Ln","./curve/linear":"VCF9","./line":"UmeQ","./point":"aLIe"}],"RovL":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(d) {
  return d;
}
},{}],"OJYo":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _constant = _interopRequireDefault(require("./constant"));

var _descending = _interopRequireDefault(require("./descending"));

var _identity = _interopRequireDefault(require("./identity"));

var _math = require("./math");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default() {
  var value = _identity.default,
      sortValues = _descending.default,
      sort = null,
      startAngle = (0, _constant.default)(0),
      endAngle = (0, _constant.default)(_math.tau),
      padAngle = (0, _constant.default)(0);

  function pie(data) {
    var i,
        n = data.length,
        j,
        k,
        sum = 0,
        index = new Array(n),
        arcs = new Array(n),
        a0 = +startAngle.apply(this, arguments),
        da = Math.min(_math.tau, Math.max(-_math.tau, endAngle.apply(this, arguments) - a0)),
        a1,
        p = Math.min(Math.abs(da) / n, padAngle.apply(this, arguments)),
        pa = p * (da < 0 ? -1 : 1),
        v;

    for (i = 0; i < n; ++i) {
      if ((v = arcs[index[i] = i] = +value(data[i], i, data)) > 0) {
        sum += v;
      }
    } // Optionally sort the arcs by previously-computed values or by data.


    if (sortValues != null) index.sort(function (i, j) {
      return sortValues(arcs[i], arcs[j]);
    });else if (sort != null) index.sort(function (i, j) {
      return sort(data[i], data[j]);
    }); // Compute the arcs! They are stored in the original data's order.

    for (i = 0, k = sum ? (da - n * pa) / sum : 0; i < n; ++i, a0 = a1) {
      j = index[i], v = arcs[j], a1 = a0 + (v > 0 ? v * k : 0) + pa, arcs[j] = {
        data: data[j],
        index: i,
        value: v,
        startAngle: a0,
        endAngle: a1,
        padAngle: p
      };
    }

    return arcs;
  }

  pie.value = function (_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : (0, _constant.default)(+_), pie) : value;
  };

  pie.sortValues = function (_) {
    return arguments.length ? (sortValues = _, sort = null, pie) : sortValues;
  };

  pie.sort = function (_) {
    return arguments.length ? (sort = _, sortValues = null, pie) : sort;
  };

  pie.startAngle = function (_) {
    return arguments.length ? (startAngle = typeof _ === "function" ? _ : (0, _constant.default)(+_), pie) : startAngle;
  };

  pie.endAngle = function (_) {
    return arguments.length ? (endAngle = typeof _ === "function" ? _ : (0, _constant.default)(+_), pie) : endAngle;
  };

  pie.padAngle = function (_) {
    return arguments.length ? (padAngle = typeof _ === "function" ? _ : (0, _constant.default)(+_), pie) : padAngle;
  };

  return pie;
}
},{"./constant":"D3Ln","./descending":"wjXp","./identity":"RovL","./math":"R8vA"}],"m9TD":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = curveRadial;
exports.curveRadialLinear = void 0;

var _linear = _interopRequireDefault(require("./linear"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var curveRadialLinear = curveRadial(_linear.default);
exports.curveRadialLinear = curveRadialLinear;

function Radial(curve) {
  this._curve = curve;
}

Radial.prototype = {
  areaStart: function () {
    this._curve.areaStart();
  },
  areaEnd: function () {
    this._curve.areaEnd();
  },
  lineStart: function () {
    this._curve.lineStart();
  },
  lineEnd: function () {
    this._curve.lineEnd();
  },
  point: function (a, r) {
    this._curve.point(r * Math.sin(a), r * -Math.cos(a));
  }
};

function curveRadial(curve) {
  function radial(context) {
    return new Radial(curve(context));
  }

  radial._curve = curve;
  return radial;
}
},{"./linear":"VCF9"}],"p8dR":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.lineRadial = lineRadial;
exports.default = _default;

var _radial = _interopRequireWildcard(require("./curve/radial"));

var _line = _interopRequireDefault(require("./line"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function lineRadial(l) {
  var c = l.curve;
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;

  l.curve = function (_) {
    return arguments.length ? c((0, _radial.default)(_)) : c()._curve;
  };

  return l;
}

function _default() {
  return lineRadial((0, _line.default)().curve(_radial.curveRadialLinear));
}
},{"./curve/radial":"m9TD","./line":"UmeQ"}],"HIqu":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _radial = _interopRequireWildcard(require("./curve/radial"));

var _area = _interopRequireDefault(require("./area"));

var _lineRadial = require("./lineRadial");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _default() {
  var a = (0, _area.default)().curve(_radial.curveRadialLinear),
      c = a.curve,
      x0 = a.lineX0,
      x1 = a.lineX1,
      y0 = a.lineY0,
      y1 = a.lineY1;
  a.angle = a.x, delete a.x;
  a.startAngle = a.x0, delete a.x0;
  a.endAngle = a.x1, delete a.x1;
  a.radius = a.y, delete a.y;
  a.innerRadius = a.y0, delete a.y0;
  a.outerRadius = a.y1, delete a.y1;
  a.lineStartAngle = function () {
    return (0, _lineRadial.lineRadial)(x0());
  }, delete a.lineX0;
  a.lineEndAngle = function () {
    return (0, _lineRadial.lineRadial)(x1());
  }, delete a.lineX1;
  a.lineInnerRadius = function () {
    return (0, _lineRadial.lineRadial)(y0());
  }, delete a.lineY0;
  a.lineOuterRadius = function () {
    return (0, _lineRadial.lineRadial)(y1());
  }, delete a.lineY1;

  a.curve = function (_) {
    return arguments.length ? c((0, _radial.default)(_)) : c()._curve;
  };

  return a;
}
},{"./curve/radial":"m9TD","./area":"UWil","./lineRadial":"p8dR"}],"wQOf":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(x, y) {
  return [(y = +y) * Math.cos(x -= Math.PI / 2), y * Math.sin(x)];
}
},{}],"CMsX":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.linkHorizontal = linkHorizontal;
exports.linkVertical = linkVertical;
exports.linkRadial = linkRadial;

var _d3Path = require("d3-path");

var _array = require("../array");

var _constant = _interopRequireDefault(require("../constant"));

var _point = require("../point");

var _pointRadial = _interopRequireDefault(require("../pointRadial"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function linkSource(d) {
  return d.source;
}

function linkTarget(d) {
  return d.target;
}

function link(curve) {
  var source = linkSource,
      target = linkTarget,
      x = _point.x,
      y = _point.y,
      context = null;

  function link() {
    var buffer,
        argv = _array.slice.call(arguments),
        s = source.apply(this, argv),
        t = target.apply(this, argv);

    if (!context) context = buffer = (0, _d3Path.path)();
    curve(context, +x.apply(this, (argv[0] = s, argv)), +y.apply(this, argv), +x.apply(this, (argv[0] = t, argv)), +y.apply(this, argv));
    if (buffer) return context = null, buffer + "" || null;
  }

  link.source = function (_) {
    return arguments.length ? (source = _, link) : source;
  };

  link.target = function (_) {
    return arguments.length ? (target = _, link) : target;
  };

  link.x = function (_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : (0, _constant.default)(+_), link) : x;
  };

  link.y = function (_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : (0, _constant.default)(+_), link) : y;
  };

  link.context = function (_) {
    return arguments.length ? (context = _ == null ? null : _, link) : context;
  };

  return link;
}

function curveHorizontal(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0 = (x0 + x1) / 2, y0, x0, y1, x1, y1);
}

function curveVertical(context, x0, y0, x1, y1) {
  context.moveTo(x0, y0);
  context.bezierCurveTo(x0, y0 = (y0 + y1) / 2, x1, y0, x1, y1);
}

function curveRadial(context, x0, y0, x1, y1) {
  var p0 = (0, _pointRadial.default)(x0, y0),
      p1 = (0, _pointRadial.default)(x0, y0 = (y0 + y1) / 2),
      p2 = (0, _pointRadial.default)(x1, y0),
      p3 = (0, _pointRadial.default)(x1, y1);
  context.moveTo(p0[0], p0[1]);
  context.bezierCurveTo(p1[0], p1[1], p2[0], p2[1], p3[0], p3[1]);
}

function linkHorizontal() {
  return link(curveHorizontal);
}

function linkVertical() {
  return link(curveVertical);
}

function linkRadial() {
  var l = link(curveRadial);
  l.angle = l.x, delete l.x;
  l.radius = l.y, delete l.y;
  return l;
}
},{"d3-path":"ZiSL","../array":"rv5q","../constant":"D3Ln","../point":"aLIe","../pointRadial":"wQOf"}],"NEs3":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _math = require("../math");

var _default = {
  draw: function (context, size) {
    var r = Math.sqrt(size / _math.pi);
    context.moveTo(r, 0);
    context.arc(0, 0, r, 0, _math.tau);
  }
};
exports.default = _default;
},{"../math":"R8vA"}],"ODxl":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = {
  draw: function (context, size) {
    var r = Math.sqrt(size / 5) / 2;
    context.moveTo(-3 * r, -r);
    context.lineTo(-r, -r);
    context.lineTo(-r, -3 * r);
    context.lineTo(r, -3 * r);
    context.lineTo(r, -r);
    context.lineTo(3 * r, -r);
    context.lineTo(3 * r, r);
    context.lineTo(r, r);
    context.lineTo(r, 3 * r);
    context.lineTo(-r, 3 * r);
    context.lineTo(-r, r);
    context.lineTo(-3 * r, r);
    context.closePath();
  }
};
exports.default = _default;
},{}],"nSnU":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var tan30 = Math.sqrt(1 / 3),
    tan30_2 = tan30 * 2;
var _default = {
  draw: function (context, size) {
    var y = Math.sqrt(size / tan30_2),
        x = y * tan30;
    context.moveTo(0, -y);
    context.lineTo(x, 0);
    context.lineTo(0, y);
    context.lineTo(-x, 0);
    context.closePath();
  }
};
exports.default = _default;
},{}],"SkCp":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _math = require("../math");

var ka = 0.89081309152928522810,
    kr = Math.sin(_math.pi / 10) / Math.sin(7 * _math.pi / 10),
    kx = Math.sin(_math.tau / 10) * kr,
    ky = -Math.cos(_math.tau / 10) * kr;
var _default = {
  draw: function (context, size) {
    var r = Math.sqrt(size * ka),
        x = kx * r,
        y = ky * r;
    context.moveTo(0, -r);
    context.lineTo(x, y);

    for (var i = 1; i < 5; ++i) {
      var a = _math.tau * i / 5,
          c = Math.cos(a),
          s = Math.sin(a);
      context.lineTo(s * r, -c * r);
      context.lineTo(c * x - s * y, s * x + c * y);
    }

    context.closePath();
  }
};
exports.default = _default;
},{"../math":"R8vA"}],"lQ43":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var _default = {
  draw: function (context, size) {
    var w = Math.sqrt(size),
        x = -w / 2;
    context.rect(x, x, w, w);
  }
};
exports.default = _default;
},{}],"Z5SN":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var sqrt3 = Math.sqrt(3);
var _default = {
  draw: function (context, size) {
    var y = -Math.sqrt(size / (sqrt3 * 3));
    context.moveTo(0, y * 2);
    context.lineTo(-sqrt3 * y, -y);
    context.lineTo(sqrt3 * y, -y);
    context.closePath();
  }
};
exports.default = _default;
},{}],"JWBh":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;
var c = -0.5,
    s = Math.sqrt(3) / 2,
    k = 1 / Math.sqrt(12),
    a = (k / 2 + 1) * 3;
var _default = {
  draw: function (context, size) {
    var r = Math.sqrt(size / a),
        x0 = r / 2,
        y0 = r * k,
        x1 = x0,
        y1 = r * k + r,
        x2 = -x1,
        y2 = y1;
    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
    context.closePath();
  }
};
exports.default = _default;
},{}],"XBPQ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.symbols = void 0;

var _d3Path = require("d3-path");

var _circle = _interopRequireDefault(require("./symbol/circle"));

var _cross = _interopRequireDefault(require("./symbol/cross"));

var _diamond = _interopRequireDefault(require("./symbol/diamond"));

var _star = _interopRequireDefault(require("./symbol/star"));

var _square = _interopRequireDefault(require("./symbol/square"));

var _triangle = _interopRequireDefault(require("./symbol/triangle"));

var _wye = _interopRequireDefault(require("./symbol/wye"));

var _constant = _interopRequireDefault(require("./constant"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var symbols = [_circle.default, _cross.default, _diamond.default, _square.default, _star.default, _triangle.default, _wye.default];
exports.symbols = symbols;

function _default() {
  var type = (0, _constant.default)(_circle.default),
      size = (0, _constant.default)(64),
      context = null;

  function symbol() {
    var buffer;
    if (!context) context = buffer = (0, _d3Path.path)();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer) return context = null, buffer + "" || null;
  }

  symbol.type = function (_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : (0, _constant.default)(_), symbol) : type;
  };

  symbol.size = function (_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : (0, _constant.default)(+_), symbol) : size;
  };

  symbol.context = function (_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };

  return symbol;
}
},{"d3-path":"ZiSL","./symbol/circle":"NEs3","./symbol/cross":"ODxl","./symbol/diamond":"nSnU","./symbol/star":"SkCp","./symbol/square":"lQ43","./symbol/triangle":"Z5SN","./symbol/wye":"JWBh","./constant":"D3Ln"}],"eWqU":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default() {}
},{}],"XakR":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.point = point;
exports.Basis = Basis;
exports.default = _default;

function point(that, x, y) {
  that._context.bezierCurveTo((2 * that._x0 + that._x1) / 3, (2 * that._y0 + that._y1) / 3, (that._x0 + 2 * that._x1) / 3, (that._y0 + 2 * that._y1) / 3, (that._x0 + 4 * that._x1 + x) / 6, (that._y0 + 4 * that._y1 + y) / 6);
}

function Basis(context) {
  this._context = context;
}

Basis.prototype = {
  areaStart: function () {
    this._line = 0;
  },
  areaEnd: function () {
    this._line = NaN;
  },
  lineStart: function () {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function () {
    switch (this._point) {
      case 3:
        point(this, this._x1, this._y1);
      // proceed

      case 2:
        this._context.lineTo(this._x1, this._y1);

        break;
    }

    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function (x, y) {
    x = +x, y = +y;

    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
        break;

      case 1:
        this._point = 2;
        break;

      case 2:
        this._point = 3;

        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);

      // proceed

      default:
        point(this, x, y);
        break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

function _default(context) {
  return new Basis(context);
}
},{}],"WkDE":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _noop = _interopRequireDefault(require("../noop"));

var _basis = require("./basis");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function BasisClosed(context) {
  this._context = context;
}

BasisClosed.prototype = {
  areaStart: _noop.default,
  areaEnd: _noop.default,
  lineStart: function () {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function () {
    switch (this._point) {
      case 1:
        {
          this._context.moveTo(this._x2, this._y2);

          this._context.closePath();

          break;
        }

      case 2:
        {
          this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);

          this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);

          this._context.closePath();

          break;
        }

      case 3:
        {
          this.point(this._x2, this._y2);
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          break;
        }
    }
  },
  point: function (x, y) {
    x = +x, y = +y;

    switch (this._point) {
      case 0:
        this._point = 1;
        this._x2 = x, this._y2 = y;
        break;

      case 1:
        this._point = 2;
        this._x3 = x, this._y3 = y;
        break;

      case 2:
        this._point = 3;
        this._x4 = x, this._y4 = y;

        this._context.moveTo((this._x0 + 4 * this._x1 + x) / 6, (this._y0 + 4 * this._y1 + y) / 6);

        break;

      default:
        (0, _basis.point)(this, x, y);
        break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

function _default(context) {
  return new BasisClosed(context);
}
},{"../noop":"eWqU","./basis":"XakR"}],"Ggyx":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _basis = require("./basis");

function BasisOpen(context) {
  this._context = context;
}

BasisOpen.prototype = {
  areaStart: function () {
    this._line = 0;
  },
  areaEnd: function () {
    this._line = NaN;
  },
  lineStart: function () {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function () {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function (x, y) {
    x = +x, y = +y;

    switch (this._point) {
      case 0:
        this._point = 1;
        break;

      case 1:
        this._point = 2;
        break;

      case 2:
        this._point = 3;
        var x0 = (this._x0 + 4 * this._x1 + x) / 6,
            y0 = (this._y0 + 4 * this._y1 + y) / 6;
        this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);
        break;

      case 3:
        this._point = 4;
      // proceed

      default:
        (0, _basis.point)(this, x, y);
        break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
  }
};

function _default(context) {
  return new BasisOpen(context);
}
},{"./basis":"XakR"}],"eh91":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _basis = require("./basis");

function Bundle(context, beta) {
  this._basis = new _basis.Basis(context);
  this._beta = beta;
}

Bundle.prototype = {
  lineStart: function () {
    this._x = [];
    this._y = [];

    this._basis.lineStart();
  },
  lineEnd: function () {
    var x = this._x,
        y = this._y,
        j = x.length - 1;

    if (j > 0) {
      var x0 = x[0],
          y0 = y[0],
          dx = x[j] - x0,
          dy = y[j] - y0,
          i = -1,
          t;

      while (++i <= j) {
        t = i / j;

        this._basis.point(this._beta * x[i] + (1 - this._beta) * (x0 + t * dx), this._beta * y[i] + (1 - this._beta) * (y0 + t * dy));
      }
    }

    this._x = this._y = null;

    this._basis.lineEnd();
  },
  point: function (x, y) {
    this._x.push(+x);

    this._y.push(+y);
  }
};

var _default = function custom(beta) {
  function bundle(context) {
    return beta === 1 ? new _basis.Basis(context) : new Bundle(context, beta);
  }

  bundle.beta = function (beta) {
    return custom(+beta);
  };

  return bundle;
}(0.85);

exports.default = _default;
},{"./basis":"XakR"}],"fNTp":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.point = point;
exports.Cardinal = Cardinal;
exports.default = void 0;

function point(that, x, y) {
  that._context.bezierCurveTo(that._x1 + that._k * (that._x2 - that._x0), that._y1 + that._k * (that._y2 - that._y0), that._x2 + that._k * (that._x1 - x), that._y2 + that._k * (that._y1 - y), that._x2, that._y2);
}

function Cardinal(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

Cardinal.prototype = {
  areaStart: function () {
    this._line = 0;
  },
  areaEnd: function () {
    this._line = NaN;
  },
  lineStart: function () {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function () {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);

        break;

      case 3:
        point(this, this._x1, this._y1);
        break;
    }

    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function (x, y) {
    x = +x, y = +y;

    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
        break;

      case 1:
        this._point = 2;
        this._x1 = x, this._y1 = y;
        break;

      case 2:
        this._point = 3;
      // proceed

      default:
        point(this, x, y);
        break;
    }

    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var _default = function custom(tension) {
  function cardinal(context) {
    return new Cardinal(context, tension);
  }

  cardinal.tension = function (tension) {
    return custom(+tension);
  };

  return cardinal;
}(0);

exports.default = _default;
},{}],"euEz":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CardinalClosed = CardinalClosed;
exports.default = void 0;

var _noop = _interopRequireDefault(require("../noop"));

var _cardinal = require("./cardinal");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function CardinalClosed(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalClosed.prototype = {
  areaStart: _noop.default,
  areaEnd: _noop.default,
  lineStart: function () {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._point = 0;
  },
  lineEnd: function () {
    switch (this._point) {
      case 1:
        {
          this._context.moveTo(this._x3, this._y3);

          this._context.closePath();

          break;
        }

      case 2:
        {
          this._context.lineTo(this._x3, this._y3);

          this._context.closePath();

          break;
        }

      case 3:
        {
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          this.point(this._x5, this._y5);
          break;
        }
    }
  },
  point: function (x, y) {
    x = +x, y = +y;

    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x, this._y3 = y;
        break;

      case 1:
        this._point = 2;

        this._context.moveTo(this._x4 = x, this._y4 = y);

        break;

      case 2:
        this._point = 3;
        this._x5 = x, this._y5 = y;
        break;

      default:
        (0, _cardinal.point)(this, x, y);
        break;
    }

    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var _default = function custom(tension) {
  function cardinal(context) {
    return new CardinalClosed(context, tension);
  }

  cardinal.tension = function (tension) {
    return custom(+tension);
  };

  return cardinal;
}(0);

exports.default = _default;
},{"../noop":"eWqU","./cardinal":"fNTp"}],"it46":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CardinalOpen = CardinalOpen;
exports.default = void 0;

var _cardinal = require("./cardinal");

function CardinalOpen(context, tension) {
  this._context = context;
  this._k = (1 - tension) / 6;
}

CardinalOpen.prototype = {
  areaStart: function () {
    this._line = 0;
  },
  areaEnd: function () {
    this._line = NaN;
  },
  lineStart: function () {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._point = 0;
  },
  lineEnd: function () {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function (x, y) {
    x = +x, y = +y;

    switch (this._point) {
      case 0:
        this._point = 1;
        break;

      case 1:
        this._point = 2;
        break;

      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;

      case 3:
        this._point = 4;
      // proceed

      default:
        (0, _cardinal.point)(this, x, y);
        break;
    }

    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var _default = function custom(tension) {
  function cardinal(context) {
    return new CardinalOpen(context, tension);
  }

  cardinal.tension = function (tension) {
    return custom(+tension);
  };

  return cardinal;
}(0);

exports.default = _default;
},{"./cardinal":"fNTp"}],"oWDJ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.point = point;
exports.default = void 0;

var _math = require("../math");

var _cardinal = require("./cardinal");

function point(that, x, y) {
  var x1 = that._x1,
      y1 = that._y1,
      x2 = that._x2,
      y2 = that._y2;

  if (that._l01_a > _math.epsilon) {
    var a = 2 * that._l01_2a + 3 * that._l01_a * that._l12_a + that._l12_2a,
        n = 3 * that._l01_a * (that._l01_a + that._l12_a);
    x1 = (x1 * a - that._x0 * that._l12_2a + that._x2 * that._l01_2a) / n;
    y1 = (y1 * a - that._y0 * that._l12_2a + that._y2 * that._l01_2a) / n;
  }

  if (that._l23_a > _math.epsilon) {
    var b = 2 * that._l23_2a + 3 * that._l23_a * that._l12_a + that._l12_2a,
        m = 3 * that._l23_a * (that._l23_a + that._l12_a);
    x2 = (x2 * b + that._x1 * that._l23_2a - x * that._l12_2a) / m;
    y2 = (y2 * b + that._y1 * that._l23_2a - y * that._l12_2a) / m;
  }

  that._context.bezierCurveTo(x1, y1, x2, y2, that._x2, that._y2);
}

function CatmullRom(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRom.prototype = {
  areaStart: function () {
    this._line = 0;
  },
  areaEnd: function () {
    this._line = NaN;
  },
  lineStart: function () {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function () {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x2, this._y2);

        break;

      case 3:
        this.point(this._x2, this._y2);
        break;
    }

    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function (x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
        break;

      case 1:
        this._point = 2;
        break;

      case 2:
        this._point = 3;
      // proceed

      default:
        point(this, x, y);
        break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var _default = function custom(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRom(context, alpha) : new _cardinal.Cardinal(context, 0);
  }

  catmullRom.alpha = function (alpha) {
    return custom(+alpha);
  };

  return catmullRom;
}(0.5);

exports.default = _default;
},{"../math":"R8vA","./cardinal":"fNTp"}],"CsSZ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _cardinalClosed = require("./cardinalClosed");

var _noop = _interopRequireDefault(require("../noop"));

var _catmullRom = require("./catmullRom");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function CatmullRomClosed(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomClosed.prototype = {
  areaStart: _noop.default,
  areaEnd: _noop.default,
  lineStart: function () {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._x5 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = this._y5 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function () {
    switch (this._point) {
      case 1:
        {
          this._context.moveTo(this._x3, this._y3);

          this._context.closePath();

          break;
        }

      case 2:
        {
          this._context.lineTo(this._x3, this._y3);

          this._context.closePath();

          break;
        }

      case 3:
        {
          this.point(this._x3, this._y3);
          this.point(this._x4, this._y4);
          this.point(this._x5, this._y5);
          break;
        }
    }
  },
  point: function (x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0:
        this._point = 1;
        this._x3 = x, this._y3 = y;
        break;

      case 1:
        this._point = 2;

        this._context.moveTo(this._x4 = x, this._y4 = y);

        break;

      case 2:
        this._point = 3;
        this._x5 = x, this._y5 = y;
        break;

      default:
        (0, _catmullRom.point)(this, x, y);
        break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var _default = function custom(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomClosed(context, alpha) : new _cardinalClosed.CardinalClosed(context, 0);
  }

  catmullRom.alpha = function (alpha) {
    return custom(+alpha);
  };

  return catmullRom;
}(0.5);

exports.default = _default;
},{"./cardinalClosed":"euEz","../noop":"eWqU","./catmullRom":"oWDJ"}],"Vf6b":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _cardinalOpen = require("./cardinalOpen");

var _catmullRom = require("./catmullRom");

function CatmullRomOpen(context, alpha) {
  this._context = context;
  this._alpha = alpha;
}

CatmullRomOpen.prototype = {
  areaStart: function () {
    this._line = 0;
  },
  areaEnd: function () {
    this._line = NaN;
  },
  lineStart: function () {
    this._x0 = this._x1 = this._x2 = this._y0 = this._y1 = this._y2 = NaN;
    this._l01_a = this._l12_a = this._l23_a = this._l01_2a = this._l12_2a = this._l23_2a = this._point = 0;
  },
  lineEnd: function () {
    if (this._line || this._line !== 0 && this._point === 3) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function (x, y) {
    x = +x, y = +y;

    if (this._point) {
      var x23 = this._x2 - x,
          y23 = this._y2 - y;
      this._l23_a = Math.sqrt(this._l23_2a = Math.pow(x23 * x23 + y23 * y23, this._alpha));
    }

    switch (this._point) {
      case 0:
        this._point = 1;
        break;

      case 1:
        this._point = 2;
        break;

      case 2:
        this._point = 3;
        this._line ? this._context.lineTo(this._x2, this._y2) : this._context.moveTo(this._x2, this._y2);
        break;

      case 3:
        this._point = 4;
      // proceed

      default:
        (0, _catmullRom.point)(this, x, y);
        break;
    }

    this._l01_a = this._l12_a, this._l12_a = this._l23_a;
    this._l01_2a = this._l12_2a, this._l12_2a = this._l23_2a;
    this._x0 = this._x1, this._x1 = this._x2, this._x2 = x;
    this._y0 = this._y1, this._y1 = this._y2, this._y2 = y;
  }
};

var _default = function custom(alpha) {
  function catmullRom(context) {
    return alpha ? new CatmullRomOpen(context, alpha) : new _cardinalOpen.CardinalOpen(context, 0);
  }

  catmullRom.alpha = function (alpha) {
    return custom(+alpha);
  };

  return catmullRom;
}(0.5);

exports.default = _default;
},{"./cardinalOpen":"it46","./catmullRom":"oWDJ"}],"QDqS":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _noop = _interopRequireDefault(require("../noop"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function LinearClosed(context) {
  this._context = context;
}

LinearClosed.prototype = {
  areaStart: _noop.default,
  areaEnd: _noop.default,
  lineStart: function () {
    this._point = 0;
  },
  lineEnd: function () {
    if (this._point) this._context.closePath();
  },
  point: function (x, y) {
    x = +x, y = +y;
    if (this._point) this._context.lineTo(x, y);else this._point = 1, this._context.moveTo(x, y);
  }
};

function _default(context) {
  return new LinearClosed(context);
}
},{"../noop":"eWqU"}],"Vaer":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.monotoneX = monotoneX;
exports.monotoneY = monotoneY;

function sign(x) {
  return x < 0 ? -1 : 1;
} // Calculate the slopes of the tangents (Hermite-type interpolation) based on
// the following paper: Steffen, M. 1990. A Simple Method for Monotonic
// Interpolation in One Dimension. Astronomy and Astrophysics, Vol. 239, NO.
// NOV(II), P. 443, 1990.


function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0,
      h1 = x2 - that._x1,
      s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0),
      s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0),
      p = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p)) || 0;
} // Calculate a one-sided slope.


function slope2(that, t) {
  var h = that._x1 - that._x0;
  return h ? (3 * (that._y1 - that._y0) / h - t) / 2 : t;
} // According to https://en.wikipedia.org/wiki/Cubic_Hermite_spline#Representations
// "you can express cubic Hermite interpolation in terms of cubic Bézier curves
// with respect to the four values p0, p0 + m0 / 3, p1 - m1 / 3, p1".


function point(that, t0, t1) {
  var x0 = that._x0,
      y0 = that._y0,
      x1 = that._x1,
      y1 = that._y1,
      dx = (x1 - x0) / 3;

  that._context.bezierCurveTo(x0 + dx, y0 + dx * t0, x1 - dx, y1 - dx * t1, x1, y1);
}

function MonotoneX(context) {
  this._context = context;
}

MonotoneX.prototype = {
  areaStart: function () {
    this._line = 0;
  },
  areaEnd: function () {
    this._line = NaN;
  },
  lineStart: function () {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function () {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);

        break;

      case 3:
        point(this, this._t0, slope2(this, this._t0));
        break;
    }

    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function (x, y) {
    var t1 = NaN;
    x = +x, y = +y;
    if (x === this._x1 && y === this._y1) return; // Ignore coincident points.

    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
        break;

      case 1:
        this._point = 2;
        break;

      case 2:
        this._point = 3;
        point(this, slope2(this, t1 = slope3(this, x, y)), t1);
        break;

      default:
        point(this, this._t0, t1 = slope3(this, x, y));
        break;
    }

    this._x0 = this._x1, this._x1 = x;
    this._y0 = this._y1, this._y1 = y;
    this._t0 = t1;
  }
};

function MonotoneY(context) {
  this._context = new ReflectContext(context);
}

(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function (x, y) {
  MonotoneX.prototype.point.call(this, y, x);
};

function ReflectContext(context) {
  this._context = context;
}

ReflectContext.prototype = {
  moveTo: function (x, y) {
    this._context.moveTo(y, x);
  },
  closePath: function () {
    this._context.closePath();
  },
  lineTo: function (x, y) {
    this._context.lineTo(y, x);
  },
  bezierCurveTo: function (x1, y1, x2, y2, x, y) {
    this._context.bezierCurveTo(y1, x1, y2, x2, y, x);
  }
};

function monotoneX(context) {
  return new MonotoneX(context);
}

function monotoneY(context) {
  return new MonotoneY(context);
}
},{}],"T3BW":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function Natural(context) {
  this._context = context;
}

Natural.prototype = {
  areaStart: function () {
    this._line = 0;
  },
  areaEnd: function () {
    this._line = NaN;
  },
  lineStart: function () {
    this._x = [];
    this._y = [];
  },
  lineEnd: function () {
    var x = this._x,
        y = this._y,
        n = x.length;

    if (n) {
      this._line ? this._context.lineTo(x[0], y[0]) : this._context.moveTo(x[0], y[0]);

      if (n === 2) {
        this._context.lineTo(x[1], y[1]);
      } else {
        var px = controlPoints(x),
            py = controlPoints(y);

        for (var i0 = 0, i1 = 1; i1 < n; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x[i1], y[i1]);
        }
      }
    }

    if (this._line || this._line !== 0 && n === 1) this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function (x, y) {
    this._x.push(+x);

    this._y.push(+y);
  }
}; // See https://www.particleincell.com/2012/bezier-splines/ for derivation.

function controlPoints(x) {
  var i,
      n = x.length - 1,
      m,
      a = new Array(n),
      b = new Array(n),
      r = new Array(n);
  a[0] = 0, b[0] = 2, r[0] = x[0] + 2 * x[1];

  for (i = 1; i < n - 1; ++i) a[i] = 1, b[i] = 4, r[i] = 4 * x[i] + 2 * x[i + 1];

  a[n - 1] = 2, b[n - 1] = 7, r[n - 1] = 8 * x[n - 1] + x[n];

  for (i = 1; i < n; ++i) m = a[i] / b[i - 1], b[i] -= m, r[i] -= m * r[i - 1];

  a[n - 1] = r[n - 1] / b[n - 1];

  for (i = n - 2; i >= 0; --i) a[i] = (r[i] - a[i + 1]) / b[i];

  b[n - 1] = (x[n] + a[n - 1]) / 2;

  for (i = 0; i < n - 1; ++i) b[i] = 2 * x[i + 1] - a[i + 1];

  return [a, b];
}

function _default(context) {
  return new Natural(context);
}
},{}],"UYn4":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.stepBefore = stepBefore;
exports.stepAfter = stepAfter;

function Step(context, t) {
  this._context = context;
  this._t = t;
}

Step.prototype = {
  areaStart: function () {
    this._line = 0;
  },
  areaEnd: function () {
    this._line = NaN;
  },
  lineStart: function () {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function () {
    if (0 < this._t && this._t < 1 && this._point === 2) this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1) this._context.closePath();
    if (this._line >= 0) this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function (x, y) {
    x = +x, y = +y;

    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x, y) : this._context.moveTo(x, y);
        break;

      case 1:
        this._point = 2;
      // proceed

      default:
        {
          if (this._t <= 0) {
            this._context.lineTo(this._x, y);

            this._context.lineTo(x, y);
          } else {
            var x1 = this._x * (1 - this._t) + x * this._t;

            this._context.lineTo(x1, this._y);

            this._context.lineTo(x1, y);
          }

          break;
        }
    }

    this._x = x, this._y = y;
  }
};

function _default(context) {
  return new Step(context, 0.5);
}

function stepBefore(context) {
  return new Step(context, 0);
}

function stepAfter(context) {
  return new Step(context, 1);
}
},{}],"x5Mk":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(series, order) {
  if (!((n = series.length) > 1)) return;

  for (var i = 1, j, s0, s1 = series[order[0]], n, m = s1.length; i < n; ++i) {
    s0 = s1, s1 = series[order[i]];

    for (j = 0; j < m; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
}
},{}],"IgCe":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(series) {
  var n = series.length,
      o = new Array(n);

  while (--n >= 0) o[n] = n;

  return o;
}
},{}],"S7q8":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _array = require("./array");

var _constant = _interopRequireDefault(require("./constant"));

var _none = _interopRequireDefault(require("./offset/none"));

var _none2 = _interopRequireDefault(require("./order/none"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function stackValue(d, key) {
  return d[key];
}

function _default() {
  var keys = (0, _constant.default)([]),
      order = _none2.default,
      offset = _none.default,
      value = stackValue;

  function stack(data) {
    var kz = keys.apply(this, arguments),
        i,
        m = data.length,
        n = kz.length,
        sz = new Array(n),
        oz;

    for (i = 0; i < n; ++i) {
      for (var ki = kz[i], si = sz[i] = new Array(m), j = 0, sij; j < m; ++j) {
        si[j] = sij = [0, +value(data[j], ki, j, data)];
        sij.data = data[j];
      }

      si.key = ki;
    }

    for (i = 0, oz = order(sz); i < n; ++i) {
      sz[oz[i]].index = i;
    }

    offset(sz, oz);
    return sz;
  }

  stack.keys = function (_) {
    return arguments.length ? (keys = typeof _ === "function" ? _ : (0, _constant.default)(_array.slice.call(_)), stack) : keys;
  };

  stack.value = function (_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : (0, _constant.default)(+_), stack) : value;
  };

  stack.order = function (_) {
    return arguments.length ? (order = _ == null ? _none2.default : typeof _ === "function" ? _ : (0, _constant.default)(_array.slice.call(_)), stack) : order;
  };

  stack.offset = function (_) {
    return arguments.length ? (offset = _ == null ? _none.default : _, stack) : offset;
  };

  return stack;
}
},{"./array":"rv5q","./constant":"D3Ln","./offset/none":"x5Mk","./order/none":"IgCe"}],"jY6Y":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _none = _interopRequireDefault(require("./none"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(series, order) {
  if (!((n = series.length) > 0)) return;

  for (var i, n, j = 0, m = series[0].length, y; j < m; ++j) {
    for (y = i = 0; i < n; ++i) y += series[i][j][1] || 0;

    if (y) for (i = 0; i < n; ++i) series[i][j][1] /= y;
  }

  (0, _none.default)(series, order);
}
},{"./none":"x5Mk"}],"P6QD":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

function _default(series, order) {
  if (!((n = series.length) > 1)) return;

  for (var i, j = 0, d, dy, yp, yn, n, m = series[order[0]].length; j < m; ++j) {
    for (yp = yn = 0, i = 0; i < n; ++i) {
      if ((dy = (d = series[order[i]][j])[1] - d[0]) >= 0) {
        d[0] = yp, d[1] = yp += dy;
      } else if (dy < 0) {
        d[1] = yn, d[0] = yn += dy;
      } else {
        d[0] = yp;
      }
    }
  }
}
},{}],"sf4d":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _none = _interopRequireDefault(require("./none"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(series, order) {
  if (!((n = series.length) > 0)) return;

  for (var j = 0, s0 = series[order[0]], n, m = s0.length; j < m; ++j) {
    for (var i = 0, y = 0; i < n; ++i) y += series[i][j][1] || 0;

    s0[j][1] += s0[j][0] = -y / 2;
  }

  (0, _none.default)(series, order);
}
},{"./none":"x5Mk"}],"EH71":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _none = _interopRequireDefault(require("./none"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(series, order) {
  if (!((n = series.length) > 0) || !((m = (s0 = series[order[0]]).length) > 0)) return;

  for (var y = 0, j = 1, s0, m, n; j < m; ++j) {
    for (var i = 0, s1 = 0, s2 = 0; i < n; ++i) {
      var si = series[order[i]],
          sij0 = si[j][1] || 0,
          sij1 = si[j - 1][1] || 0,
          s3 = (sij0 - sij1) / 2;

      for (var k = 0; k < i; ++k) {
        var sk = series[order[k]],
            skj0 = sk[j][1] || 0,
            skj1 = sk[j - 1][1] || 0;
        s3 += skj0 - skj1;
      }

      s1 += sij0, s2 += s3 * sij0;
    }

    s0[j - 1][1] += s0[j - 1][0] = y;
    if (s1) y -= s2 / s1;
  }

  s0[j - 1][1] += s0[j - 1][0] = y;
  (0, _none.default)(series, order);
}
},{"./none":"x5Mk"}],"koeA":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;
exports.sum = sum;

var _none = _interopRequireDefault(require("./none"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(series) {
  var sums = series.map(sum);
  return (0, _none.default)(series).sort(function (a, b) {
    return sums[a] - sums[b];
  });
}

function sum(series) {
  var s = 0,
      i = -1,
      n = series.length,
      v;

  while (++i < n) if (v = +series[i][1]) s += v;

  return s;
}
},{"./none":"IgCe"}],"i2th":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _ascending = _interopRequireDefault(require("./ascending"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(series) {
  return (0, _ascending.default)(series).reverse();
}
},{"./ascending":"koeA"}],"msEL":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _none = _interopRequireDefault(require("./none"));

var _ascending = require("./ascending");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(series) {
  var n = series.length,
      i,
      j,
      sums = series.map(_ascending.sum),
      order = (0, _none.default)(series).sort(function (a, b) {
    return sums[b] - sums[a];
  }),
      top = 0,
      bottom = 0,
      tops = [],
      bottoms = [];

  for (i = 0; i < n; ++i) {
    j = order[i];

    if (top < bottom) {
      top += sums[j];
      tops.push(j);
    } else {
      bottom += sums[j];
      bottoms.push(j);
    }
  }

  return bottoms.reverse().concat(tops);
}
},{"./none":"IgCe","./ascending":"koeA"}],"w5Iz":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _none = _interopRequireDefault(require("./none"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default(series) {
  return (0, _none.default)(series).reverse();
}
},{"./none":"IgCe"}],"EIxe":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "arc", {
  enumerable: true,
  get: function () {
    return _arc.default;
  }
});
Object.defineProperty(exports, "area", {
  enumerable: true,
  get: function () {
    return _area.default;
  }
});
Object.defineProperty(exports, "line", {
  enumerable: true,
  get: function () {
    return _line.default;
  }
});
Object.defineProperty(exports, "pie", {
  enumerable: true,
  get: function () {
    return _pie.default;
  }
});
Object.defineProperty(exports, "areaRadial", {
  enumerable: true,
  get: function () {
    return _areaRadial.default;
  }
});
Object.defineProperty(exports, "radialArea", {
  enumerable: true,
  get: function () {
    return _areaRadial.default;
  }
});
Object.defineProperty(exports, "lineRadial", {
  enumerable: true,
  get: function () {
    return _lineRadial.default;
  }
});
Object.defineProperty(exports, "radialLine", {
  enumerable: true,
  get: function () {
    return _lineRadial.default;
  }
});
Object.defineProperty(exports, "pointRadial", {
  enumerable: true,
  get: function () {
    return _pointRadial.default;
  }
});
Object.defineProperty(exports, "linkHorizontal", {
  enumerable: true,
  get: function () {
    return _index.linkHorizontal;
  }
});
Object.defineProperty(exports, "linkVertical", {
  enumerable: true,
  get: function () {
    return _index.linkVertical;
  }
});
Object.defineProperty(exports, "linkRadial", {
  enumerable: true,
  get: function () {
    return _index.linkRadial;
  }
});
Object.defineProperty(exports, "symbol", {
  enumerable: true,
  get: function () {
    return _symbol.default;
  }
});
Object.defineProperty(exports, "symbols", {
  enumerable: true,
  get: function () {
    return _symbol.symbols;
  }
});
Object.defineProperty(exports, "symbolCircle", {
  enumerable: true,
  get: function () {
    return _circle.default;
  }
});
Object.defineProperty(exports, "symbolCross", {
  enumerable: true,
  get: function () {
    return _cross.default;
  }
});
Object.defineProperty(exports, "symbolDiamond", {
  enumerable: true,
  get: function () {
    return _diamond.default;
  }
});
Object.defineProperty(exports, "symbolSquare", {
  enumerable: true,
  get: function () {
    return _square.default;
  }
});
Object.defineProperty(exports, "symbolStar", {
  enumerable: true,
  get: function () {
    return _star.default;
  }
});
Object.defineProperty(exports, "symbolTriangle", {
  enumerable: true,
  get: function () {
    return _triangle.default;
  }
});
Object.defineProperty(exports, "symbolWye", {
  enumerable: true,
  get: function () {
    return _wye.default;
  }
});
Object.defineProperty(exports, "curveBasisClosed", {
  enumerable: true,
  get: function () {
    return _basisClosed.default;
  }
});
Object.defineProperty(exports, "curveBasisOpen", {
  enumerable: true,
  get: function () {
    return _basisOpen.default;
  }
});
Object.defineProperty(exports, "curveBasis", {
  enumerable: true,
  get: function () {
    return _basis.default;
  }
});
Object.defineProperty(exports, "curveBundle", {
  enumerable: true,
  get: function () {
    return _bundle.default;
  }
});
Object.defineProperty(exports, "curveCardinalClosed", {
  enumerable: true,
  get: function () {
    return _cardinalClosed.default;
  }
});
Object.defineProperty(exports, "curveCardinalOpen", {
  enumerable: true,
  get: function () {
    return _cardinalOpen.default;
  }
});
Object.defineProperty(exports, "curveCardinal", {
  enumerable: true,
  get: function () {
    return _cardinal.default;
  }
});
Object.defineProperty(exports, "curveCatmullRomClosed", {
  enumerable: true,
  get: function () {
    return _catmullRomClosed.default;
  }
});
Object.defineProperty(exports, "curveCatmullRomOpen", {
  enumerable: true,
  get: function () {
    return _catmullRomOpen.default;
  }
});
Object.defineProperty(exports, "curveCatmullRom", {
  enumerable: true,
  get: function () {
    return _catmullRom.default;
  }
});
Object.defineProperty(exports, "curveLinearClosed", {
  enumerable: true,
  get: function () {
    return _linearClosed.default;
  }
});
Object.defineProperty(exports, "curveLinear", {
  enumerable: true,
  get: function () {
    return _linear.default;
  }
});
Object.defineProperty(exports, "curveMonotoneX", {
  enumerable: true,
  get: function () {
    return _monotone.monotoneX;
  }
});
Object.defineProperty(exports, "curveMonotoneY", {
  enumerable: true,
  get: function () {
    return _monotone.monotoneY;
  }
});
Object.defineProperty(exports, "curveNatural", {
  enumerable: true,
  get: function () {
    return _natural.default;
  }
});
Object.defineProperty(exports, "curveStep", {
  enumerable: true,
  get: function () {
    return _step.default;
  }
});
Object.defineProperty(exports, "curveStepAfter", {
  enumerable: true,
  get: function () {
    return _step.stepAfter;
  }
});
Object.defineProperty(exports, "curveStepBefore", {
  enumerable: true,
  get: function () {
    return _step.stepBefore;
  }
});
Object.defineProperty(exports, "stack", {
  enumerable: true,
  get: function () {
    return _stack.default;
  }
});
Object.defineProperty(exports, "stackOffsetExpand", {
  enumerable: true,
  get: function () {
    return _expand.default;
  }
});
Object.defineProperty(exports, "stackOffsetDiverging", {
  enumerable: true,
  get: function () {
    return _diverging.default;
  }
});
Object.defineProperty(exports, "stackOffsetNone", {
  enumerable: true,
  get: function () {
    return _none.default;
  }
});
Object.defineProperty(exports, "stackOffsetSilhouette", {
  enumerable: true,
  get: function () {
    return _silhouette.default;
  }
});
Object.defineProperty(exports, "stackOffsetWiggle", {
  enumerable: true,
  get: function () {
    return _wiggle.default;
  }
});
Object.defineProperty(exports, "stackOrderAscending", {
  enumerable: true,
  get: function () {
    return _ascending.default;
  }
});
Object.defineProperty(exports, "stackOrderDescending", {
  enumerable: true,
  get: function () {
    return _descending.default;
  }
});
Object.defineProperty(exports, "stackOrderInsideOut", {
  enumerable: true,
  get: function () {
    return _insideOut.default;
  }
});
Object.defineProperty(exports, "stackOrderNone", {
  enumerable: true,
  get: function () {
    return _none2.default;
  }
});
Object.defineProperty(exports, "stackOrderReverse", {
  enumerable: true,
  get: function () {
    return _reverse.default;
  }
});

var _arc = _interopRequireDefault(require("./src/arc"));

var _area = _interopRequireDefault(require("./src/area"));

var _line = _interopRequireDefault(require("./src/line"));

var _pie = _interopRequireDefault(require("./src/pie"));

var _areaRadial = _interopRequireDefault(require("./src/areaRadial"));

var _lineRadial = _interopRequireDefault(require("./src/lineRadial"));

var _pointRadial = _interopRequireDefault(require("./src/pointRadial"));

var _index = require("./src/link/index");

var _symbol = _interopRequireWildcard(require("./src/symbol"));

var _circle = _interopRequireDefault(require("./src/symbol/circle"));

var _cross = _interopRequireDefault(require("./src/symbol/cross"));

var _diamond = _interopRequireDefault(require("./src/symbol/diamond"));

var _square = _interopRequireDefault(require("./src/symbol/square"));

var _star = _interopRequireDefault(require("./src/symbol/star"));

var _triangle = _interopRequireDefault(require("./src/symbol/triangle"));

var _wye = _interopRequireDefault(require("./src/symbol/wye"));

var _basisClosed = _interopRequireDefault(require("./src/curve/basisClosed"));

var _basisOpen = _interopRequireDefault(require("./src/curve/basisOpen"));

var _basis = _interopRequireDefault(require("./src/curve/basis"));

var _bundle = _interopRequireDefault(require("./src/curve/bundle"));

var _cardinalClosed = _interopRequireDefault(require("./src/curve/cardinalClosed"));

var _cardinalOpen = _interopRequireDefault(require("./src/curve/cardinalOpen"));

var _cardinal = _interopRequireDefault(require("./src/curve/cardinal"));

var _catmullRomClosed = _interopRequireDefault(require("./src/curve/catmullRomClosed"));

var _catmullRomOpen = _interopRequireDefault(require("./src/curve/catmullRomOpen"));

var _catmullRom = _interopRequireDefault(require("./src/curve/catmullRom"));

var _linearClosed = _interopRequireDefault(require("./src/curve/linearClosed"));

var _linear = _interopRequireDefault(require("./src/curve/linear"));

var _monotone = require("./src/curve/monotone");

var _natural = _interopRequireDefault(require("./src/curve/natural"));

var _step = _interopRequireWildcard(require("./src/curve/step"));

var _stack = _interopRequireDefault(require("./src/stack"));

var _expand = _interopRequireDefault(require("./src/offset/expand"));

var _diverging = _interopRequireDefault(require("./src/offset/diverging"));

var _none = _interopRequireDefault(require("./src/offset/none"));

var _silhouette = _interopRequireDefault(require("./src/offset/silhouette"));

var _wiggle = _interopRequireDefault(require("./src/offset/wiggle"));

var _ascending = _interopRequireDefault(require("./src/order/ascending"));

var _descending = _interopRequireDefault(require("./src/order/descending"));

var _insideOut = _interopRequireDefault(require("./src/order/insideOut"));

var _none2 = _interopRequireDefault(require("./src/order/none"));

var _reverse = _interopRequireDefault(require("./src/order/reverse"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./src/arc":"TV07","./src/area":"UWil","./src/line":"UmeQ","./src/pie":"OJYo","./src/areaRadial":"HIqu","./src/lineRadial":"p8dR","./src/pointRadial":"wQOf","./src/link/index":"CMsX","./src/symbol":"XBPQ","./src/symbol/circle":"NEs3","./src/symbol/cross":"ODxl","./src/symbol/diamond":"nSnU","./src/symbol/square":"lQ43","./src/symbol/star":"SkCp","./src/symbol/triangle":"Z5SN","./src/symbol/wye":"JWBh","./src/curve/basisClosed":"WkDE","./src/curve/basisOpen":"Ggyx","./src/curve/basis":"XakR","./src/curve/bundle":"eh91","./src/curve/cardinalClosed":"euEz","./src/curve/cardinalOpen":"it46","./src/curve/cardinal":"fNTp","./src/curve/catmullRomClosed":"CsSZ","./src/curve/catmullRomOpen":"Vf6b","./src/curve/catmullRom":"oWDJ","./src/curve/linearClosed":"QDqS","./src/curve/linear":"VCF9","./src/curve/monotone":"Vaer","./src/curve/natural":"T3BW","./src/curve/step":"UYn4","./src/stack":"S7q8","./src/offset/expand":"jY6Y","./src/offset/diverging":"P6QD","./src/offset/none":"x5Mk","./src/offset/silhouette":"sf4d","./src/offset/wiggle":"EH71","./src/order/ascending":"koeA","./src/order/descending":"i2th","./src/order/insideOut":"msEL","./src/order/none":"IgCe","./src/order/reverse":"w5Iz"}],"mmRi":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.x = x;
exports.y = y;

function x(d) {
  return d[0];
}

function y(d) {
  return d[1];
}
},{}],"cyhV":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.RedBlackNode = RedBlackNode;
exports.default = void 0;

function RedBlackTree() {
  this._ = null; // root node
}

function RedBlackNode(node) {
  node.U = // parent node
  node.C = // color - true for red, false for black
  node.L = // left node
  node.R = // right node
  node.P = // previous node
  node.N = null; // next node
}

RedBlackTree.prototype = {
  constructor: RedBlackTree,
  insert: function (after, node) {
    var parent, grandpa, uncle;

    if (after) {
      node.P = after;
      node.N = after.N;
      if (after.N) after.N.P = node;
      after.N = node;

      if (after.R) {
        after = after.R;

        while (after.L) after = after.L;

        after.L = node;
      } else {
        after.R = node;
      }

      parent = after;
    } else if (this._) {
      after = RedBlackFirst(this._);
      node.P = null;
      node.N = after;
      after.P = after.L = node;
      parent = after;
    } else {
      node.P = node.N = null;
      this._ = node;
      parent = null;
    }

    node.L = node.R = null;
    node.U = parent;
    node.C = true;
    after = node;

    while (parent && parent.C) {
      grandpa = parent.U;

      if (parent === grandpa.L) {
        uncle = grandpa.R;

        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.R) {
            RedBlackRotateLeft(this, parent);
            after = parent;
            parent = after.U;
          }

          parent.C = false;
          grandpa.C = true;
          RedBlackRotateRight(this, grandpa);
        }
      } else {
        uncle = grandpa.L;

        if (uncle && uncle.C) {
          parent.C = uncle.C = false;
          grandpa.C = true;
          after = grandpa;
        } else {
          if (after === parent.L) {
            RedBlackRotateRight(this, parent);
            after = parent;
            parent = after.U;
          }

          parent.C = false;
          grandpa.C = true;
          RedBlackRotateLeft(this, grandpa);
        }
      }

      parent = after.U;
    }

    this._.C = false;
  },
  remove: function (node) {
    if (node.N) node.N.P = node.P;
    if (node.P) node.P.N = node.N;
    node.N = node.P = null;
    var parent = node.U,
        sibling,
        left = node.L,
        right = node.R,
        next,
        red;
    if (!left) next = right;else if (!right) next = left;else next = RedBlackFirst(right);

    if (parent) {
      if (parent.L === node) parent.L = next;else parent.R = next;
    } else {
      this._ = next;
    }

    if (left && right) {
      red = next.C;
      next.C = node.C;
      next.L = left;
      left.U = next;

      if (next !== right) {
        parent = next.U;
        next.U = node.U;
        node = next.R;
        parent.L = node;
        next.R = right;
        right.U = next;
      } else {
        next.U = parent;
        parent = next;
        node = next.R;
      }
    } else {
      red = node.C;
      node = next;
    }

    if (node) node.U = parent;
    if (red) return;

    if (node && node.C) {
      node.C = false;
      return;
    }

    do {
      if (node === this._) break;

      if (node === parent.L) {
        sibling = parent.R;

        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateLeft(this, parent);
          sibling = parent.R;
        }

        if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
          if (!sibling.R || !sibling.R.C) {
            sibling.L.C = false;
            sibling.C = true;
            RedBlackRotateRight(this, sibling);
            sibling = parent.R;
          }

          sibling.C = parent.C;
          parent.C = sibling.R.C = false;
          RedBlackRotateLeft(this, parent);
          node = this._;
          break;
        }
      } else {
        sibling = parent.L;

        if (sibling.C) {
          sibling.C = false;
          parent.C = true;
          RedBlackRotateRight(this, parent);
          sibling = parent.L;
        }

        if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {
          if (!sibling.L || !sibling.L.C) {
            sibling.R.C = false;
            sibling.C = true;
            RedBlackRotateLeft(this, sibling);
            sibling = parent.L;
          }

          sibling.C = parent.C;
          parent.C = sibling.L.C = false;
          RedBlackRotateRight(this, parent);
          node = this._;
          break;
        }
      }

      sibling.C = true;
      node = parent;
      parent = parent.U;
    } while (!node.C);

    if (node) node.C = false;
  }
};

function RedBlackRotateLeft(tree, node) {
  var p = node,
      q = node.R,
      parent = p.U;

  if (parent) {
    if (parent.L === p) parent.L = q;else parent.R = q;
  } else {
    tree._ = q;
  }

  q.U = parent;
  p.U = q;
  p.R = q.L;
  if (p.R) p.R.U = p;
  q.L = p;
}

function RedBlackRotateRight(tree, node) {
  var p = node,
      q = node.L,
      parent = p.U;

  if (parent) {
    if (parent.L === p) parent.L = q;else parent.R = q;
  } else {
    tree._ = q;
  }

  q.U = parent;
  p.U = q;
  p.L = q.R;
  if (p.L) p.L.U = p;
  q.R = p;
}

function RedBlackFirst(node) {
  while (node.L) node = node.L;

  return node;
}

var _default = RedBlackTree;
exports.default = _default;
},{}],"Tkpe":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createEdge = createEdge;
exports.createBorderEdge = createBorderEdge;
exports.setEdgeEnd = setEdgeEnd;
exports.clipEdges = clipEdges;

var _Diagram = require("./Diagram");

function createEdge(left, right, v0, v1) {
  var edge = [null, null],
      index = _Diagram.edges.push(edge) - 1;
  edge.left = left;
  edge.right = right;
  if (v0) setEdgeEnd(edge, left, right, v0);
  if (v1) setEdgeEnd(edge, right, left, v1);

  _Diagram.cells[left.index].halfedges.push(index);

  _Diagram.cells[right.index].halfedges.push(index);

  return edge;
}

function createBorderEdge(left, v0, v1) {
  var edge = [v0, v1];
  edge.left = left;
  return edge;
}

function setEdgeEnd(edge, left, right, vertex) {
  if (!edge[0] && !edge[1]) {
    edge[0] = vertex;
    edge.left = left;
    edge.right = right;
  } else if (edge.left === right) {
    edge[1] = vertex;
  } else {
    edge[0] = vertex;
  }
} // Liang–Barsky line clipping.


function clipEdge(edge, x0, y0, x1, y1) {
  var a = edge[0],
      b = edge[1],
      ax = a[0],
      ay = a[1],
      bx = b[0],
      by = b[1],
      t0 = 0,
      t1 = 1,
      dx = bx - ax,
      dy = by - ay,
      r;
  r = x0 - ax;
  if (!dx && r > 0) return;
  r /= dx;

  if (dx < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dx > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = x1 - ax;
  if (!dx && r < 0) return;
  r /= dx;

  if (dx < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dx > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  r = y0 - ay;
  if (!dy && r > 0) return;
  r /= dy;

  if (dy < 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  } else if (dy > 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  }

  r = y1 - ay;
  if (!dy && r < 0) return;
  r /= dy;

  if (dy < 0) {
    if (r > t1) return;
    if (r > t0) t0 = r;
  } else if (dy > 0) {
    if (r < t0) return;
    if (r < t1) t1 = r;
  }

  if (!(t0 > 0) && !(t1 < 1)) return true; // TODO Better check?

  if (t0 > 0) edge[0] = [ax + t0 * dx, ay + t0 * dy];
  if (t1 < 1) edge[1] = [ax + t1 * dx, ay + t1 * dy];
  return true;
}

function connectEdge(edge, x0, y0, x1, y1) {
  var v1 = edge[1];
  if (v1) return true;
  var v0 = edge[0],
      left = edge.left,
      right = edge.right,
      lx = left[0],
      ly = left[1],
      rx = right[0],
      ry = right[1],
      fx = (lx + rx) / 2,
      fy = (ly + ry) / 2,
      fm,
      fb;

  if (ry === ly) {
    if (fx < x0 || fx >= x1) return;

    if (lx > rx) {
      if (!v0) v0 = [fx, y0];else if (v0[1] >= y1) return;
      v1 = [fx, y1];
    } else {
      if (!v0) v0 = [fx, y1];else if (v0[1] < y0) return;
      v1 = [fx, y0];
    }
  } else {
    fm = (lx - rx) / (ry - ly);
    fb = fy - fm * fx;

    if (fm < -1 || fm > 1) {
      if (lx > rx) {
        if (!v0) v0 = [(y0 - fb) / fm, y0];else if (v0[1] >= y1) return;
        v1 = [(y1 - fb) / fm, y1];
      } else {
        if (!v0) v0 = [(y1 - fb) / fm, y1];else if (v0[1] < y0) return;
        v1 = [(y0 - fb) / fm, y0];
      }
    } else {
      if (ly < ry) {
        if (!v0) v0 = [x0, fm * x0 + fb];else if (v0[0] >= x1) return;
        v1 = [x1, fm * x1 + fb];
      } else {
        if (!v0) v0 = [x1, fm * x1 + fb];else if (v0[0] < x0) return;
        v1 = [x0, fm * x0 + fb];
      }
    }
  }

  edge[0] = v0;
  edge[1] = v1;
  return true;
}

function clipEdges(x0, y0, x1, y1) {
  var i = _Diagram.edges.length,
      edge;

  while (i--) {
    if (!connectEdge(edge = _Diagram.edges[i], x0, y0, x1, y1) || !clipEdge(edge, x0, y0, x1, y1) || !(Math.abs(edge[0][0] - edge[1][0]) > _Diagram.epsilon || Math.abs(edge[0][1] - edge[1][1]) > _Diagram.epsilon)) {
      delete _Diagram.edges[i];
    }
  }
}
},{"./Diagram":"Jn8D"}],"zWBx":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createCell = createCell;
exports.cellHalfedgeStart = cellHalfedgeStart;
exports.cellHalfedgeEnd = cellHalfedgeEnd;
exports.sortCellHalfedges = sortCellHalfedges;
exports.clipCells = clipCells;

var _Edge = require("./Edge");

var _Diagram = require("./Diagram");

function createCell(site) {
  return _Diagram.cells[site.index] = {
    site: site,
    halfedges: []
  };
}

function cellHalfedgeAngle(cell, edge) {
  var site = cell.site,
      va = edge.left,
      vb = edge.right;
  if (site === vb) vb = va, va = site;
  if (vb) return Math.atan2(vb[1] - va[1], vb[0] - va[0]);
  if (site === va) va = edge[1], vb = edge[0];else va = edge[0], vb = edge[1];
  return Math.atan2(va[0] - vb[0], vb[1] - va[1]);
}

function cellHalfedgeStart(cell, edge) {
  return edge[+(edge.left !== cell.site)];
}

function cellHalfedgeEnd(cell, edge) {
  return edge[+(edge.left === cell.site)];
}

function sortCellHalfedges() {
  for (var i = 0, n = _Diagram.cells.length, cell, halfedges, j, m; i < n; ++i) {
    if ((cell = _Diagram.cells[i]) && (m = (halfedges = cell.halfedges).length)) {
      var index = new Array(m),
          array = new Array(m);

      for (j = 0; j < m; ++j) index[j] = j, array[j] = cellHalfedgeAngle(cell, _Diagram.edges[halfedges[j]]);

      index.sort(function (i, j) {
        return array[j] - array[i];
      });

      for (j = 0; j < m; ++j) array[j] = halfedges[index[j]];

      for (j = 0; j < m; ++j) halfedges[j] = array[j];
    }
  }
}

function clipCells(x0, y0, x1, y1) {
  var nCells = _Diagram.cells.length,
      iCell,
      cell,
      site,
      iHalfedge,
      halfedges,
      nHalfedges,
      start,
      startX,
      startY,
      end,
      endX,
      endY,
      cover = true;

  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = _Diagram.cells[iCell]) {
      site = cell.site;
      halfedges = cell.halfedges;
      iHalfedge = halfedges.length; // Remove any dangling clipped edges.

      while (iHalfedge--) {
        if (!_Diagram.edges[halfedges[iHalfedge]]) {
          halfedges.splice(iHalfedge, 1);
        }
      } // Insert any border edges as necessary.


      iHalfedge = 0, nHalfedges = halfedges.length;

      while (iHalfedge < nHalfedges) {
        end = cellHalfedgeEnd(cell, _Diagram.edges[halfedges[iHalfedge]]), endX = end[0], endY = end[1];
        start = cellHalfedgeStart(cell, _Diagram.edges[halfedges[++iHalfedge % nHalfedges]]), startX = start[0], startY = start[1];

        if (Math.abs(endX - startX) > _Diagram.epsilon || Math.abs(endY - startY) > _Diagram.epsilon) {
          halfedges.splice(iHalfedge, 0, _Diagram.edges.push((0, _Edge.createBorderEdge)(site, end, Math.abs(endX - x0) < _Diagram.epsilon && y1 - endY > _Diagram.epsilon ? [x0, Math.abs(startX - x0) < _Diagram.epsilon ? startY : y1] : Math.abs(endY - y1) < _Diagram.epsilon && x1 - endX > _Diagram.epsilon ? [Math.abs(startY - y1) < _Diagram.epsilon ? startX : x1, y1] : Math.abs(endX - x1) < _Diagram.epsilon && endY - y0 > _Diagram.epsilon ? [x1, Math.abs(startX - x1) < _Diagram.epsilon ? startY : y0] : Math.abs(endY - y0) < _Diagram.epsilon && endX - x0 > _Diagram.epsilon ? [Math.abs(startY - y0) < _Diagram.epsilon ? startX : x0, y0] : null)) - 1);
          ++nHalfedges;
        }
      }

      if (nHalfedges) cover = false;
    }
  } // If there weren’t any edges, have the closest site cover the extent.
  // It doesn’t matter which corner of the extent we measure!


  if (cover) {
    var dx,
        dy,
        d2,
        dc = Infinity;

    for (iCell = 0, cover = null; iCell < nCells; ++iCell) {
      if (cell = _Diagram.cells[iCell]) {
        site = cell.site;
        dx = site[0] - x0;
        dy = site[1] - y0;
        d2 = dx * dx + dy * dy;
        if (d2 < dc) dc = d2, cover = cell;
      }
    }

    if (cover) {
      var v00 = [x0, y0],
          v01 = [x0, y1],
          v11 = [x1, y1],
          v10 = [x1, y0];
      cover.halfedges.push(_Diagram.edges.push((0, _Edge.createBorderEdge)(site = cover.site, v00, v01)) - 1, _Diagram.edges.push((0, _Edge.createBorderEdge)(site, v01, v11)) - 1, _Diagram.edges.push((0, _Edge.createBorderEdge)(site, v11, v10)) - 1, _Diagram.edges.push((0, _Edge.createBorderEdge)(site, v10, v00)) - 1);
    }
  } // Lastly delete any cells with no edges; these were entirely clipped.


  for (iCell = 0; iCell < nCells; ++iCell) {
    if (cell = _Diagram.cells[iCell]) {
      if (!cell.halfedges.length) {
        delete _Diagram.cells[iCell];
      }
    }
  }
}
},{"./Edge":"Tkpe","./Diagram":"Jn8D"}],"HznJ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.attachCircle = attachCircle;
exports.detachCircle = detachCircle;
exports.firstCircle = void 0;

var _RedBlackTree = require("./RedBlackTree");

var _Diagram = require("./Diagram");

var circlePool = [];
var firstCircle;
exports.firstCircle = firstCircle;

function Circle() {
  (0, _RedBlackTree.RedBlackNode)(this);
  this.x = this.y = this.arc = this.site = this.cy = null;
}

function attachCircle(arc) {
  var lArc = arc.P,
      rArc = arc.N;
  if (!lArc || !rArc) return;
  var lSite = lArc.site,
      cSite = arc.site,
      rSite = rArc.site;
  if (lSite === rSite) return;
  var bx = cSite[0],
      by = cSite[1],
      ax = lSite[0] - bx,
      ay = lSite[1] - by,
      cx = rSite[0] - bx,
      cy = rSite[1] - by;
  var d = 2 * (ax * cy - ay * cx);
  if (d >= -_Diagram.epsilon2) return;
  var ha = ax * ax + ay * ay,
      hc = cx * cx + cy * cy,
      x = (cy * ha - ay * hc) / d,
      y = (ax * hc - cx * ha) / d;
  var circle = circlePool.pop() || new Circle();
  circle.arc = arc;
  circle.site = cSite;
  circle.x = x + bx;
  circle.y = (circle.cy = y + by) + Math.sqrt(x * x + y * y); // y bottom

  arc.circle = circle;
  var before = null,
      node = _Diagram.circles._;

  while (node) {
    if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {
      if (node.L) node = node.L;else {
        before = node.P;
        break;
      }
    } else {
      if (node.R) node = node.R;else {
        before = node;
        break;
      }
    }
  }

  _Diagram.circles.insert(before, circle);

  if (!before) exports.firstCircle = firstCircle = circle;
}

function detachCircle(arc) {
  var circle = arc.circle;

  if (circle) {
    if (!circle.P) exports.firstCircle = firstCircle = circle.N;

    _Diagram.circles.remove(circle);

    circlePool.push(circle);
    (0, _RedBlackTree.RedBlackNode)(circle);
    arc.circle = null;
  }
}
},{"./RedBlackTree":"cyhV","./Diagram":"Jn8D"}],"vrdo":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.removeBeach = removeBeach;
exports.addBeach = addBeach;

var _RedBlackTree = require("./RedBlackTree");

var _Cell = require("./Cell");

var _Circle = require("./Circle");

var _Edge = require("./Edge");

var _Diagram = require("./Diagram");

var beachPool = [];

function Beach() {
  (0, _RedBlackTree.RedBlackNode)(this);
  this.edge = this.site = this.circle = null;
}

function createBeach(site) {
  var beach = beachPool.pop() || new Beach();
  beach.site = site;
  return beach;
}

function detachBeach(beach) {
  (0, _Circle.detachCircle)(beach);

  _Diagram.beaches.remove(beach);

  beachPool.push(beach);
  (0, _RedBlackTree.RedBlackNode)(beach);
}

function removeBeach(beach) {
  var circle = beach.circle,
      x = circle.x,
      y = circle.cy,
      vertex = [x, y],
      previous = beach.P,
      next = beach.N,
      disappearing = [beach];
  detachBeach(beach);
  var lArc = previous;

  while (lArc.circle && Math.abs(x - lArc.circle.x) < _Diagram.epsilon && Math.abs(y - lArc.circle.cy) < _Diagram.epsilon) {
    previous = lArc.P;
    disappearing.unshift(lArc);
    detachBeach(lArc);
    lArc = previous;
  }

  disappearing.unshift(lArc);
  (0, _Circle.detachCircle)(lArc);
  var rArc = next;

  while (rArc.circle && Math.abs(x - rArc.circle.x) < _Diagram.epsilon && Math.abs(y - rArc.circle.cy) < _Diagram.epsilon) {
    next = rArc.N;
    disappearing.push(rArc);
    detachBeach(rArc);
    rArc = next;
  }

  disappearing.push(rArc);
  (0, _Circle.detachCircle)(rArc);
  var nArcs = disappearing.length,
      iArc;

  for (iArc = 1; iArc < nArcs; ++iArc) {
    rArc = disappearing[iArc];
    lArc = disappearing[iArc - 1];
    (0, _Edge.setEdgeEnd)(rArc.edge, lArc.site, rArc.site, vertex);
  }

  lArc = disappearing[0];
  rArc = disappearing[nArcs - 1];
  rArc.edge = (0, _Edge.createEdge)(lArc.site, rArc.site, null, vertex);
  (0, _Circle.attachCircle)(lArc);
  (0, _Circle.attachCircle)(rArc);
}

function addBeach(site) {
  var x = site[0],
      directrix = site[1],
      lArc,
      rArc,
      dxl,
      dxr,
      node = _Diagram.beaches._;

  while (node) {
    dxl = leftBreakPoint(node, directrix) - x;
    if (dxl > _Diagram.epsilon) node = node.L;else {
      dxr = x - rightBreakPoint(node, directrix);

      if (dxr > _Diagram.epsilon) {
        if (!node.R) {
          lArc = node;
          break;
        }

        node = node.R;
      } else {
        if (dxl > -_Diagram.epsilon) {
          lArc = node.P;
          rArc = node;
        } else if (dxr > -_Diagram.epsilon) {
          lArc = node;
          rArc = node.N;
        } else {
          lArc = rArc = node;
        }

        break;
      }
    }
  }

  (0, _Cell.createCell)(site);
  var newArc = createBeach(site);

  _Diagram.beaches.insert(lArc, newArc);

  if (!lArc && !rArc) return;

  if (lArc === rArc) {
    (0, _Circle.detachCircle)(lArc);
    rArc = createBeach(lArc.site);

    _Diagram.beaches.insert(newArc, rArc);

    newArc.edge = rArc.edge = (0, _Edge.createEdge)(lArc.site, newArc.site);
    (0, _Circle.attachCircle)(lArc);
    (0, _Circle.attachCircle)(rArc);
    return;
  }

  if (!rArc) {
    // && lArc
    newArc.edge = (0, _Edge.createEdge)(lArc.site, newArc.site);
    return;
  } // else lArc !== rArc


  (0, _Circle.detachCircle)(lArc);
  (0, _Circle.detachCircle)(rArc);
  var lSite = lArc.site,
      ax = lSite[0],
      ay = lSite[1],
      bx = site[0] - ax,
      by = site[1] - ay,
      rSite = rArc.site,
      cx = rSite[0] - ax,
      cy = rSite[1] - ay,
      d = 2 * (bx * cy - by * cx),
      hb = bx * bx + by * by,
      hc = cx * cx + cy * cy,
      vertex = [(cy * hb - by * hc) / d + ax, (bx * hc - cx * hb) / d + ay];
  (0, _Edge.setEdgeEnd)(rArc.edge, lSite, rSite, vertex);
  newArc.edge = (0, _Edge.createEdge)(lSite, site, null, vertex);
  rArc.edge = (0, _Edge.createEdge)(site, rSite, null, vertex);
  (0, _Circle.attachCircle)(lArc);
  (0, _Circle.attachCircle)(rArc);
}

function leftBreakPoint(arc, directrix) {
  var site = arc.site,
      rfocx = site[0],
      rfocy = site[1],
      pby2 = rfocy - directrix;
  if (!pby2) return rfocx;
  var lArc = arc.P;
  if (!lArc) return -Infinity;
  site = lArc.site;
  var lfocx = site[0],
      lfocy = site[1],
      plby2 = lfocy - directrix;
  if (!plby2) return lfocx;
  var hl = lfocx - rfocx,
      aby2 = 1 / pby2 - 1 / plby2,
      b = hl / plby2;
  if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;
  return (rfocx + lfocx) / 2;
}

function rightBreakPoint(arc, directrix) {
  var rArc = arc.N;
  if (rArc) return leftBreakPoint(rArc, directrix);
  var site = arc.site;
  return site[1] === directrix ? site[0] : Infinity;
}
},{"./RedBlackTree":"cyhV","./Cell":"zWBx","./Circle":"HznJ","./Edge":"Tkpe","./Diagram":"Jn8D"}],"Jn8D":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = Diagram;
exports.edges = exports.circles = exports.cells = exports.beaches = exports.epsilon2 = exports.epsilon = void 0;

var _Beach = require("./Beach");

var _Cell = require("./Cell");

var _Circle = require("./Circle");

var _Edge = require("./Edge");

var _RedBlackTree = _interopRequireDefault(require("./RedBlackTree"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var epsilon = 1e-6;
exports.epsilon = epsilon;
var epsilon2 = 1e-12;
exports.epsilon2 = epsilon2;
var beaches;
exports.beaches = beaches;
var cells;
exports.cells = cells;
var circles;
exports.circles = circles;
var edges;
exports.edges = edges;

function triangleArea(a, b, c) {
  return (a[0] - c[0]) * (b[1] - a[1]) - (a[0] - b[0]) * (c[1] - a[1]);
}

function lexicographic(a, b) {
  return b[1] - a[1] || b[0] - a[0];
}

function Diagram(sites, extent) {
  var site = sites.sort(lexicographic).pop(),
      x,
      y,
      circle;
  exports.edges = edges = [];
  exports.cells = cells = new Array(sites.length);
  exports.beaches = beaches = new _RedBlackTree.default();
  exports.circles = circles = new _RedBlackTree.default();

  while (true) {
    circle = _Circle.firstCircle;

    if (site && (!circle || site[1] < circle.y || site[1] === circle.y && site[0] < circle.x)) {
      if (site[0] !== x || site[1] !== y) {
        (0, _Beach.addBeach)(site);
        x = site[0], y = site[1];
      }

      site = sites.pop();
    } else if (circle) {
      (0, _Beach.removeBeach)(circle.arc);
    } else {
      break;
    }
  }

  (0, _Cell.sortCellHalfedges)();

  if (extent) {
    var x0 = +extent[0][0],
        y0 = +extent[0][1],
        x1 = +extent[1][0],
        y1 = +extent[1][1];
    (0, _Edge.clipEdges)(x0, y0, x1, y1);
    (0, _Cell.clipCells)(x0, y0, x1, y1);
  }

  this.edges = edges;
  this.cells = cells;
  exports.beaches = beaches = exports.circles = circles = exports.edges = edges = exports.cells = cells = null;
}

Diagram.prototype = {
  constructor: Diagram,
  polygons: function () {
    var edges = this.edges;
    return this.cells.map(function (cell) {
      var polygon = cell.halfedges.map(function (i) {
        return (0, _Cell.cellHalfedgeStart)(cell, edges[i]);
      });
      polygon.data = cell.site.data;
      return polygon;
    });
  },
  triangles: function () {
    var triangles = [],
        edges = this.edges;
    this.cells.forEach(function (cell, i) {
      if (!(m = (halfedges = cell.halfedges).length)) return;
      var site = cell.site,
          halfedges,
          j = -1,
          m,
          s0,
          e1 = edges[halfedges[m - 1]],
          s1 = e1.left === site ? e1.right : e1.left;

      while (++j < m) {
        s0 = s1;
        e1 = edges[halfedges[j]];
        s1 = e1.left === site ? e1.right : e1.left;

        if (s0 && s1 && i < s0.index && i < s1.index && triangleArea(site, s0, s1) < 0) {
          triangles.push([site.data, s0.data, s1.data]);
        }
      }
    });
    return triangles;
  },
  links: function () {
    return this.edges.filter(function (edge) {
      return edge.right;
    }).map(function (edge) {
      return {
        source: edge.left.data,
        target: edge.right.data
      };
    });
  },
  find: function (x, y, radius) {
    var that = this,
        i0,
        i1 = that._found || 0,
        n = that.cells.length,
        cell; // Use the previously-found cell, or start with an arbitrary one.

    while (!(cell = that.cells[i1])) if (++i1 >= n) return null;

    var dx = x - cell.site[0],
        dy = y - cell.site[1],
        d2 = dx * dx + dy * dy; // Traverse the half-edges to find a closer cell, if any.

    do {
      cell = that.cells[i0 = i1], i1 = null;
      cell.halfedges.forEach(function (e) {
        var edge = that.edges[e],
            v = edge.left;
        if ((v === cell.site || !v) && !(v = edge.right)) return;
        var vx = x - v[0],
            vy = y - v[1],
            v2 = vx * vx + vy * vy;
        if (v2 < d2) d2 = v2, i1 = v.index;
      });
    } while (i1 !== null);

    that._found = i0;
    return radius == null || d2 <= radius * radius ? cell.site : null;
  }
};
},{"./Beach":"vrdo","./Cell":"zWBx","./Circle":"HznJ","./Edge":"Tkpe","./RedBlackTree":"cyhV"}],"rzeD":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _constant = _interopRequireDefault(require("./constant"));

var _point = require("./point");

var _Diagram = _interopRequireWildcard(require("./Diagram"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _default() {
  var x = _point.x,
      y = _point.y,
      extent = null;

  function voronoi(data) {
    return new _Diagram.default(data.map(function (d, i) {
      var s = [Math.round(x(d, i, data) / _Diagram.epsilon) * _Diagram.epsilon, Math.round(y(d, i, data) / _Diagram.epsilon) * _Diagram.epsilon];
      s.index = i;
      s.data = d;
      return s;
    }), extent);
  }

  voronoi.polygons = function (data) {
    return voronoi(data).polygons();
  };

  voronoi.links = function (data) {
    return voronoi(data).links();
  };

  voronoi.triangles = function (data) {
    return voronoi(data).triangles();
  };

  voronoi.x = function (_) {
    return arguments.length ? (x = typeof _ === "function" ? _ : (0, _constant.default)(+_), voronoi) : x;
  };

  voronoi.y = function (_) {
    return arguments.length ? (y = typeof _ === "function" ? _ : (0, _constant.default)(+_), voronoi) : y;
  };

  voronoi.extent = function (_) {
    return arguments.length ? (extent = _ == null ? null : [[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]], voronoi) : extent && [[extent[0][0], extent[0][1]], [extent[1][0], extent[1][1]]];
  };

  voronoi.size = function (_) {
    return arguments.length ? (extent = _ == null ? null : [[0, 0], [+_[0], +_[1]]], voronoi) : extent && [extent[1][0] - extent[0][0], extent[1][1] - extent[0][1]];
  };

  return voronoi;
}
},{"./constant":"OY6d","./point":"mmRi","./Diagram":"Jn8D"}],"ikBk":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "voronoi", {
  enumerable: true,
  get: function () {
    return _voronoi.default;
  }
});

var _voronoi = _interopRequireDefault(require("./src/voronoi"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./src/voronoi":"rzeD"}],"pmu8":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = ZoomEvent;

function ZoomEvent(target, type, transform) {
  this.target = target;
  this.type = type;
  this.transform = transform;
}
},{}],"RGu5":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.Transform = Transform;
exports.default = transform;
exports.identity = void 0;

function Transform(k, x, y) {
  this.k = k;
  this.x = x;
  this.y = y;
}

Transform.prototype = {
  constructor: Transform,
  scale: function (k) {
    return k === 1 ? this : new Transform(this.k * k, this.x, this.y);
  },
  translate: function (x, y) {
    return x === 0 & y === 0 ? this : new Transform(this.k, this.x + this.k * x, this.y + this.k * y);
  },
  apply: function (point) {
    return [point[0] * this.k + this.x, point[1] * this.k + this.y];
  },
  applyX: function (x) {
    return x * this.k + this.x;
  },
  applyY: function (y) {
    return y * this.k + this.y;
  },
  invert: function (location) {
    return [(location[0] - this.x) / this.k, (location[1] - this.y) / this.k];
  },
  invertX: function (x) {
    return (x - this.x) / this.k;
  },
  invertY: function (y) {
    return (y - this.y) / this.k;
  },
  rescaleX: function (x) {
    return x.copy().domain(x.range().map(this.invertX, this).map(x.invert, x));
  },
  rescaleY: function (y) {
    return y.copy().domain(y.range().map(this.invertY, this).map(y.invert, y));
  },
  toString: function () {
    return "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")";
  }
};
var identity = new Transform(1, 0, 0);
exports.identity = identity;
transform.prototype = Transform.prototype;

function transform(node) {
  return node.__zoom || identity;
}
},{}],"T0tZ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = _default;

var _d3Dispatch = require("d3-dispatch");

var _d3Drag = require("d3-drag");

var _d3Interpolate = require("d3-interpolate");

var _d3Selection = require("d3-selection");

var _d3Transition = require("d3-transition");

var _constant = _interopRequireDefault(require("./constant"));

var _event = _interopRequireDefault(require("./event"));

var _transform = require("./transform");

var _noevent = _interopRequireWildcard(require("./noevent"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Ignore right-click, since that should open the context menu.
function defaultFilter() {
  return !_d3Selection.event.button;
}

function defaultExtent() {
  var e = this,
      w,
      h;

  if (e instanceof SVGElement) {
    e = e.ownerSVGElement || e;
    w = e.width.baseVal.value;
    h = e.height.baseVal.value;
  } else {
    w = e.clientWidth;
    h = e.clientHeight;
  }

  return [[0, 0], [w, h]];
}

function defaultTransform() {
  return this.__zoom || _transform.identity;
}

function defaultWheelDelta() {
  return -_d3Selection.event.deltaY * (_d3Selection.event.deltaMode ? 120 : 1) / 500;
}

function defaultTouchable() {
  return "ontouchstart" in this;
}

function defaultConstrain(transform, extent, translateExtent) {
  var dx0 = transform.invertX(extent[0][0]) - translateExtent[0][0],
      dx1 = transform.invertX(extent[1][0]) - translateExtent[1][0],
      dy0 = transform.invertY(extent[0][1]) - translateExtent[0][1],
      dy1 = transform.invertY(extent[1][1]) - translateExtent[1][1];
  return transform.translate(dx1 > dx0 ? (dx0 + dx1) / 2 : Math.min(0, dx0) || Math.max(0, dx1), dy1 > dy0 ? (dy0 + dy1) / 2 : Math.min(0, dy0) || Math.max(0, dy1));
}

function _default() {
  var filter = defaultFilter,
      extent = defaultExtent,
      constrain = defaultConstrain,
      wheelDelta = defaultWheelDelta,
      touchable = defaultTouchable,
      scaleExtent = [0, Infinity],
      translateExtent = [[-Infinity, -Infinity], [Infinity, Infinity]],
      duration = 250,
      interpolate = _d3Interpolate.interpolateZoom,
      gestures = [],
      listeners = (0, _d3Dispatch.dispatch)("start", "zoom", "end"),
      touchstarting,
      touchending,
      touchDelay = 500,
      wheelDelay = 150,
      clickDistance2 = 0;

  function zoom(selection) {
    selection.property("__zoom", defaultTransform).on("wheel.zoom", wheeled).on("mousedown.zoom", mousedowned).on("dblclick.zoom", dblclicked).filter(touchable).on("touchstart.zoom", touchstarted).on("touchmove.zoom", touchmoved).on("touchend.zoom touchcancel.zoom", touchended).style("touch-action", "none").style("-webkit-tap-highlight-color", "rgba(0,0,0,0)");
  }

  zoom.transform = function (collection, transform) {
    var selection = collection.selection ? collection.selection() : collection;
    selection.property("__zoom", defaultTransform);

    if (collection !== selection) {
      schedule(collection, transform);
    } else {
      selection.interrupt().each(function () {
        gesture(this, arguments).start().zoom(null, typeof transform === "function" ? transform.apply(this, arguments) : transform).end();
      });
    }
  };

  zoom.scaleBy = function (selection, k) {
    zoom.scaleTo(selection, function () {
      var k0 = this.__zoom.k,
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return k0 * k1;
    });
  };

  zoom.scaleTo = function (selection, k) {
    zoom.transform(selection, function () {
      var e = extent.apply(this, arguments),
          t0 = this.__zoom,
          p0 = centroid(e),
          p1 = t0.invert(p0),
          k1 = typeof k === "function" ? k.apply(this, arguments) : k;
      return constrain(translate(scale(t0, k1), p0, p1), e, translateExtent);
    });
  };

  zoom.translateBy = function (selection, x, y) {
    zoom.transform(selection, function () {
      return constrain(this.__zoom.translate(typeof x === "function" ? x.apply(this, arguments) : x, typeof y === "function" ? y.apply(this, arguments) : y), extent.apply(this, arguments), translateExtent);
    });
  };

  zoom.translateTo = function (selection, x, y) {
    zoom.transform(selection, function () {
      var e = extent.apply(this, arguments),
          t = this.__zoom,
          p = centroid(e);
      return constrain(_transform.identity.translate(p[0], p[1]).scale(t.k).translate(typeof x === "function" ? -x.apply(this, arguments) : -x, typeof y === "function" ? -y.apply(this, arguments) : -y), e, translateExtent);
    });
  };

  function scale(transform, k) {
    k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], k));
    return k === transform.k ? transform : new _transform.Transform(k, transform.x, transform.y);
  }

  function translate(transform, p0, p1) {
    var x = p0[0] - p1[0] * transform.k,
        y = p0[1] - p1[1] * transform.k;
    return x === transform.x && y === transform.y ? transform : new _transform.Transform(transform.k, x, y);
  }

  function centroid(extent) {
    return [(+extent[0][0] + +extent[1][0]) / 2, (+extent[0][1] + +extent[1][1]) / 2];
  }

  function schedule(transition, transform, center) {
    transition.on("start.zoom", function () {
      gesture(this, arguments).start();
    }).on("interrupt.zoom end.zoom", function () {
      gesture(this, arguments).end();
    }).tween("zoom", function () {
      var that = this,
          args = arguments,
          g = gesture(that, args),
          e = extent.apply(that, args),
          p = center || centroid(e),
          w = Math.max(e[1][0] - e[0][0], e[1][1] - e[0][1]),
          a = that.__zoom,
          b = typeof transform === "function" ? transform.apply(that, args) : transform,
          i = interpolate(a.invert(p).concat(w / a.k), b.invert(p).concat(w / b.k));
      return function (t) {
        if (t === 1) t = b; // Avoid rounding error on end.
        else {
            var l = i(t),
                k = w / l[2];
            t = new _transform.Transform(k, p[0] - l[0] * k, p[1] - l[1] * k);
          }
        g.zoom(null, t);
      };
    });
  }

  function gesture(that, args) {
    for (var i = 0, n = gestures.length, g; i < n; ++i) {
      if ((g = gestures[i]).that === that) {
        return g;
      }
    }

    return new Gesture(that, args);
  }

  function Gesture(that, args) {
    this.that = that;
    this.args = args;
    this.index = -1;
    this.active = 0;
    this.extent = extent.apply(that, args);
  }

  Gesture.prototype = {
    start: function () {
      if (++this.active === 1) {
        this.index = gestures.push(this) - 1;
        this.emit("start");
      }

      return this;
    },
    zoom: function (key, transform) {
      if (this.mouse && key !== "mouse") this.mouse[1] = transform.invert(this.mouse[0]);
      if (this.touch0 && key !== "touch") this.touch0[1] = transform.invert(this.touch0[0]);
      if (this.touch1 && key !== "touch") this.touch1[1] = transform.invert(this.touch1[0]);
      this.that.__zoom = transform;
      this.emit("zoom");
      return this;
    },
    end: function () {
      if (--this.active === 0) {
        gestures.splice(this.index, 1);
        this.index = -1;
        this.emit("end");
      }

      return this;
    },
    emit: function (type) {
      (0, _d3Selection.customEvent)(new _event.default(zoom, type, this.that.__zoom), listeners.apply, listeners, [type, this.that, this.args]);
    }
  };

  function wheeled() {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, arguments),
        t = this.__zoom,
        k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], t.k * Math.pow(2, wheelDelta.apply(this, arguments)))),
        p = (0, _d3Selection.mouse)(this); // If the mouse is in the same location as before, reuse it.
    // If there were recent wheel events, reset the wheel idle timeout.

    if (g.wheel) {
      if (g.mouse[0][0] !== p[0] || g.mouse[0][1] !== p[1]) {
        g.mouse[1] = t.invert(g.mouse[0] = p);
      }

      clearTimeout(g.wheel);
    } // If this wheel event won’t trigger a transform change, ignore it.
    else if (t.k === k) return; // Otherwise, capture the mouse point and location at the start.
      else {
          g.mouse = [p, t.invert(p)];
          (0, _d3Transition.interrupt)(this);
          g.start();
        }

    (0, _noevent.default)();
    g.wheel = setTimeout(wheelidled, wheelDelay);
    g.zoom("mouse", constrain(translate(scale(t, k), g.mouse[0], g.mouse[1]), g.extent, translateExtent));

    function wheelidled() {
      g.wheel = null;
      g.end();
    }
  }

  function mousedowned() {
    if (touchending || !filter.apply(this, arguments)) return;
    var g = gesture(this, arguments),
        v = (0, _d3Selection.select)(_d3Selection.event.view).on("mousemove.zoom", mousemoved, true).on("mouseup.zoom", mouseupped, true),
        p = (0, _d3Selection.mouse)(this),
        x0 = _d3Selection.event.clientX,
        y0 = _d3Selection.event.clientY;
    (0, _d3Drag.dragDisable)(_d3Selection.event.view);
    (0, _noevent.nopropagation)();
    g.mouse = [p, this.__zoom.invert(p)];
    (0, _d3Transition.interrupt)(this);
    g.start();

    function mousemoved() {
      (0, _noevent.default)();

      if (!g.moved) {
        var dx = _d3Selection.event.clientX - x0,
            dy = _d3Selection.event.clientY - y0;
        g.moved = dx * dx + dy * dy > clickDistance2;
      }

      g.zoom("mouse", constrain(translate(g.that.__zoom, g.mouse[0] = (0, _d3Selection.mouse)(g.that), g.mouse[1]), g.extent, translateExtent));
    }

    function mouseupped() {
      v.on("mousemove.zoom mouseup.zoom", null);
      (0, _d3Drag.dragEnable)(_d3Selection.event.view, g.moved);
      (0, _noevent.default)();
      g.end();
    }
  }

  function dblclicked() {
    if (!filter.apply(this, arguments)) return;
    var t0 = this.__zoom,
        p0 = (0, _d3Selection.mouse)(this),
        p1 = t0.invert(p0),
        k1 = t0.k * (_d3Selection.event.shiftKey ? 0.5 : 2),
        t1 = constrain(translate(scale(t0, k1), p0, p1), extent.apply(this, arguments), translateExtent);
    (0, _noevent.default)();
    if (duration > 0) (0, _d3Selection.select)(this).transition().duration(duration).call(schedule, t1, p0);else (0, _d3Selection.select)(this).call(zoom.transform, t1);
  }

  function touchstarted() {
    if (!filter.apply(this, arguments)) return;
    var g = gesture(this, arguments),
        touches = _d3Selection.event.changedTouches,
        started,
        n = touches.length,
        i,
        t,
        p;
    (0, _noevent.nopropagation)();

    for (i = 0; i < n; ++i) {
      t = touches[i], p = (0, _d3Selection.touch)(this, touches, t.identifier);
      p = [p, this.__zoom.invert(p), t.identifier];
      if (!g.touch0) g.touch0 = p, started = true;else if (!g.touch1) g.touch1 = p;
    } // If this is a dbltap, reroute to the (optional) dblclick.zoom handler.


    if (touchstarting) {
      touchstarting = clearTimeout(touchstarting);

      if (!g.touch1) {
        g.end();
        p = (0, _d3Selection.select)(this).on("dblclick.zoom");
        if (p) p.apply(this, arguments);
        return;
      }
    }

    if (started) {
      touchstarting = setTimeout(function () {
        touchstarting = null;
      }, touchDelay);
      (0, _d3Transition.interrupt)(this);
      g.start();
    }
  }

  function touchmoved() {
    var g = gesture(this, arguments),
        touches = _d3Selection.event.changedTouches,
        n = touches.length,
        i,
        t,
        p,
        l;
    (0, _noevent.default)();
    if (touchstarting) touchstarting = clearTimeout(touchstarting);

    for (i = 0; i < n; ++i) {
      t = touches[i], p = (0, _d3Selection.touch)(this, touches, t.identifier);
      if (g.touch0 && g.touch0[2] === t.identifier) g.touch0[0] = p;else if (g.touch1 && g.touch1[2] === t.identifier) g.touch1[0] = p;
    }

    t = g.that.__zoom;

    if (g.touch1) {
      var p0 = g.touch0[0],
          l0 = g.touch0[1],
          p1 = g.touch1[0],
          l1 = g.touch1[1],
          dp = (dp = p1[0] - p0[0]) * dp + (dp = p1[1] - p0[1]) * dp,
          dl = (dl = l1[0] - l0[0]) * dl + (dl = l1[1] - l0[1]) * dl;
      t = scale(t, Math.sqrt(dp / dl));
      p = [(p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2];
      l = [(l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2];
    } else if (g.touch0) p = g.touch0[0], l = g.touch0[1];else return;

    g.zoom("touch", constrain(translate(t, p, l), g.extent, translateExtent));
  }

  function touchended() {
    var g = gesture(this, arguments),
        touches = _d3Selection.event.changedTouches,
        n = touches.length,
        i,
        t;
    (0, _noevent.nopropagation)();
    if (touchending) clearTimeout(touchending);
    touchending = setTimeout(function () {
      touchending = null;
    }, touchDelay);

    for (i = 0; i < n; ++i) {
      t = touches[i];
      if (g.touch0 && g.touch0[2] === t.identifier) delete g.touch0;else if (g.touch1 && g.touch1[2] === t.identifier) delete g.touch1;
    }

    if (g.touch1 && !g.touch0) g.touch0 = g.touch1, delete g.touch1;
    if (g.touch0) g.touch0[1] = this.__zoom.invert(g.touch0[0]);else g.end();
  }

  zoom.wheelDelta = function (_) {
    return arguments.length ? (wheelDelta = typeof _ === "function" ? _ : (0, _constant.default)(+_), zoom) : wheelDelta;
  };

  zoom.filter = function (_) {
    return arguments.length ? (filter = typeof _ === "function" ? _ : (0, _constant.default)(!!_), zoom) : filter;
  };

  zoom.touchable = function (_) {
    return arguments.length ? (touchable = typeof _ === "function" ? _ : (0, _constant.default)(!!_), zoom) : touchable;
  };

  zoom.extent = function (_) {
    return arguments.length ? (extent = typeof _ === "function" ? _ : (0, _constant.default)([[+_[0][0], +_[0][1]], [+_[1][0], +_[1][1]]]), zoom) : extent;
  };

  zoom.scaleExtent = function (_) {
    return arguments.length ? (scaleExtent[0] = +_[0], scaleExtent[1] = +_[1], zoom) : [scaleExtent[0], scaleExtent[1]];
  };

  zoom.translateExtent = function (_) {
    return arguments.length ? (translateExtent[0][0] = +_[0][0], translateExtent[1][0] = +_[1][0], translateExtent[0][1] = +_[0][1], translateExtent[1][1] = +_[1][1], zoom) : [[translateExtent[0][0], translateExtent[0][1]], [translateExtent[1][0], translateExtent[1][1]]];
  };

  zoom.constrain = function (_) {
    return arguments.length ? (constrain = _, zoom) : constrain;
  };

  zoom.duration = function (_) {
    return arguments.length ? (duration = +_, zoom) : duration;
  };

  zoom.interpolate = function (_) {
    return arguments.length ? (interpolate = _, zoom) : interpolate;
  };

  zoom.on = function () {
    var value = listeners.on.apply(listeners, arguments);
    return value === listeners ? zoom : value;
  };

  zoom.clickDistance = function (_) {
    return arguments.length ? (clickDistance2 = (_ = +_) * _, zoom) : Math.sqrt(clickDistance2);
  };

  return zoom;
}
},{"d3-dispatch":"FHGa","d3-drag":"IqNk","d3-interpolate":"nuBz","d3-selection":"ObH6","d3-transition":"RVDI","./constant":"OY6d","./event":"pmu8","./transform":"RGu5","./noevent":"DCEg"}],"oH5m":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
Object.defineProperty(exports, "zoom", {
  enumerable: true,
  get: function () {
    return _zoom.default;
  }
});
Object.defineProperty(exports, "zoomTransform", {
  enumerable: true,
  get: function () {
    return _transform.default;
  }
});
Object.defineProperty(exports, "zoomIdentity", {
  enumerable: true,
  get: function () {
    return _transform.identity;
  }
});

var _zoom = _interopRequireDefault(require("./src/zoom"));

var _transform = _interopRequireWildcard(require("./src/transform"));

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
},{"./src/zoom":"T0tZ","./src/transform":"RGu5"}],"BG5c":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
var _exportNames = {
  version: true
};
Object.defineProperty(exports, "version", {
  enumerable: true,
  get: function () {
    return _package.version;
  }
});

var _package = require("./build/package");

var _d3Array = require("d3-array");

Object.keys(_d3Array).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Array[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Array[key];
    }
  });
});

var _d3Axis = require("d3-axis");

Object.keys(_d3Axis).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Axis[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Axis[key];
    }
  });
});

var _d3Brush = require("d3-brush");

Object.keys(_d3Brush).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Brush[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Brush[key];
    }
  });
});

var _d3Chord = require("d3-chord");

Object.keys(_d3Chord).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Chord[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Chord[key];
    }
  });
});

var _d3Collection = require("d3-collection");

Object.keys(_d3Collection).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Collection[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Collection[key];
    }
  });
});

var _d3Color = require("d3-color");

Object.keys(_d3Color).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Color[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Color[key];
    }
  });
});

var _d3Dispatch = require("d3-dispatch");

Object.keys(_d3Dispatch).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Dispatch[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Dispatch[key];
    }
  });
});

var _d3Drag = require("d3-drag");

Object.keys(_d3Drag).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Drag[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Drag[key];
    }
  });
});

var _d3Dsv = require("d3-dsv");

Object.keys(_d3Dsv).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Dsv[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Dsv[key];
    }
  });
});

var _d3Ease = require("d3-ease");

Object.keys(_d3Ease).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Ease[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Ease[key];
    }
  });
});

var _d3Force = require("d3-force");

Object.keys(_d3Force).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Force[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Force[key];
    }
  });
});

var _d3Format = require("d3-format");

Object.keys(_d3Format).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Format[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Format[key];
    }
  });
});

var _d3Geo = require("d3-geo");

Object.keys(_d3Geo).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Geo[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Geo[key];
    }
  });
});

var _d3Hierarchy = require("d3-hierarchy");

Object.keys(_d3Hierarchy).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Hierarchy[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Hierarchy[key];
    }
  });
});

var _d3Interpolate = require("d3-interpolate");

Object.keys(_d3Interpolate).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Interpolate[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Interpolate[key];
    }
  });
});

var _d3Path = require("d3-path");

Object.keys(_d3Path).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Path[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Path[key];
    }
  });
});

var _d3Polygon = require("d3-polygon");

Object.keys(_d3Polygon).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Polygon[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Polygon[key];
    }
  });
});

var _d3Quadtree = require("d3-quadtree");

Object.keys(_d3Quadtree).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Quadtree[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Quadtree[key];
    }
  });
});

var _d3Queue = require("d3-queue");

Object.keys(_d3Queue).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Queue[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Queue[key];
    }
  });
});

var _d3Random = require("d3-random");

Object.keys(_d3Random).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Random[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Random[key];
    }
  });
});

var _d3Request = require("d3-request");

Object.keys(_d3Request).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Request[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Request[key];
    }
  });
});

var _d3Scale = require("d3-scale");

Object.keys(_d3Scale).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Scale[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Scale[key];
    }
  });
});

var _d3Selection = require("d3-selection");

Object.keys(_d3Selection).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Selection[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Selection[key];
    }
  });
});

var _d3Shape = require("d3-shape");

Object.keys(_d3Shape).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Shape[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Shape[key];
    }
  });
});

var _d3Time = require("d3-time");

Object.keys(_d3Time).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Time[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Time[key];
    }
  });
});

var _d3TimeFormat = require("d3-time-format");

Object.keys(_d3TimeFormat).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3TimeFormat[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3TimeFormat[key];
    }
  });
});

var _d3Timer = require("d3-timer");

Object.keys(_d3Timer).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Timer[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Timer[key];
    }
  });
});

var _d3Transition = require("d3-transition");

Object.keys(_d3Transition).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Transition[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Transition[key];
    }
  });
});

var _d3Voronoi = require("d3-voronoi");

Object.keys(_d3Voronoi).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Voronoi[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Voronoi[key];
    }
  });
});

var _d3Zoom = require("d3-zoom");

Object.keys(_d3Zoom).forEach(function (key) {
  if (key === "default" || key === "__esModule") return;
  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
  if (key in exports && exports[key] === _d3Zoom[key]) return;
  Object.defineProperty(exports, key, {
    enumerable: true,
    get: function () {
      return _d3Zoom[key];
    }
  });
});
},{"./build/package":"Q2ym","d3-array":"ybfZ","d3-axis":"cGCd","d3-brush":"mXZn","d3-chord":"HrqC","d3-collection":"GTGQ","d3-color":"RuBy","d3-dispatch":"FHGa","d3-drag":"IqNk","d3-dsv":"NYIA","d3-ease":"Ufrd","d3-force":"Cxwz","d3-format":"ftuj","d3-geo":"EnIL","d3-hierarchy":"Eids","d3-interpolate":"nuBz","d3-path":"ZiSL","d3-polygon":"H6zy","d3-quadtree":"LBnY","d3-queue":"oAMu","d3-random":"sJSR","d3-request":"DXex","d3-scale":"uY15","d3-selection":"ObH6","d3-shape":"EIxe","d3-time":"dsMh","d3-time-format":"JCkU","d3-timer":"Gc7n","d3-transition":"RVDI","d3-voronoi":"ikBk","d3-zoom":"oH5m"}],"ZNE1":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.json = void 0;
var json = {
  "children": [{
    "children": [{
      "children": [{
        "children": [{
          "data": {
            "uri": "http://edamontology.org/topic_0208"
          },
          "definition": "The influence of genotype on drug response, for example by correlating gene expression or single-nucleotide polymorphisms with drug efficacy or toxicity.",
          "narrow_synonyms": ["Pharmacogenetics"],
          "text": "Pharmacogenomics"
        }],
        "data": {
          "uri": "http://edamontology.org/topic_0202"
        },
        "definition": "The study of drugs and their effects or responses in living systems.",
        "narrow_synonyms": ["Pharmacoinformatics", "Computational pharmacology"],
        "text": "Pharmacology"
      }, {
        "children": [{
          "comment": ["This involves the study of often complex genetic traits underlying diseases involving defects in the immune system. For example, identifying target genes for therapeutic approaches, or genetic variations involved in immunological pathology."],
          "data": {
            "uri": "http://edamontology.org/topic_3948"
          },
          "definition": "Immunoinformatics is the field of computational biology that deals with the study of immunoloogical questions. Immunoinformatics is at the interface between immunology and computer science. It takes advantage of computational, statistical, mathematical approaches and enhances the understanding of immunological knowledge.",
          "exact_synonyms": ["Computational immunology"],
          "text": "Immunoinformatics"
        }, {
          "comment": ["This includes T cell receptors (TR), major histocompatibility complex (MHC), immunoglobulin superfamily (IgSF) / antibodies, major histocompatibility complex superfamily (MhcSF), etc.\""],
          "data": {
            "uri": "http://edamontology.org/topic_2830"
          },
          "definition": "Immunity-related proteins and their ligands.",
          "narrow_synonyms": ["Immunopeptides", "Immunoproteins", "Therapeutic antibodies", "Antigens"],
          "text": "Immunoproteins and antigens"
        }, {
          "comment": ["This involves the study of often complex genetic traits underlying diseases involving defects in the immune system. For example, identifying target genes for therapeutic approaches, or genetic variations involved in immunological pathology."],
          "data": {
            "uri": "http://edamontology.org/topic_3930"
          },
          "definition": "A biomedical field that bridges immunology and genetics, to study the genetic basis of the immune system.",
          "exact_synonyms": ["Immungenetics", "Immunology and genetics", "Immune system genetics"],
          "narrow_synonyms": ["Immunogenes"],
          "text": "Immunogenetics"
        }],
        "data": {
          "uri": "http://edamontology.org/topic_0804"
        },
        "definition": "The application of information technology to immunology such as immunological processes, immunological genes, proteins and peptide ligands, antigens and so on.",
        "text": "Immunology"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/topic_3340"
          },
          "definition": "Collections of cells grown under laboratory conditions, specifically, cells from multi-cellular eukaryotes and especially animal cells.",
          "text": "Cell culture collection"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3339"
          },
          "definition": "Collections of microbial cells including bacteria, yeasts and moulds.",
          "text": "Microbial collection"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3341"
          },
          "definition": "Collections of DNA, including both collections of cloned molecules, and populations of micro-organisms that store and propagate cloned DNA.",
          "text": "Clone library"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3337"
          },
          "definition": "Repositories of biological samples, typically human, for basic biological and clinical research.",
          "exact_synonyms": ["Tissue collection", "biobanking"],
          "text": "Biobank"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3338"
          },
          "definition": "Laboratory study of mice, for example, phenotyping, and mutagenesis of mouse cell lines.",
          "text": "Mouse clinic"
        }],
        "data": {
          "uri": "http://edamontology.org/topic_3277"
        },
        "definition": "Biological samples and specimens.",
        "exact_synonyms": ["Specimen collections"],
        "narrow_synonyms": ["samples", "biosamples"],
        "text": "Sample collections"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3304"
        },
        "definition": "The study of the nervous system and brain; its anatomy, physiology and function.",
        "narrow_synonyms": ["Systemetic neuroscience", "Neurophysiology", "Molecular neuroscience"],
        "text": "Neurobiology"
      }, {
        "children": [{
          "children": [{
            "data": {
              "uri": "http://edamontology.org/topic_2840"
            },
            "definition": "Toxins and the adverse effects of these chemical substances on living organisms.",
            "narrow_synonyms": ["Computational toxicology", "Toxicoinformatics"],
            "text": "Toxicology"
          }, {
            "comment": ["Pharmacovigilence concerns safety once a drug has gone to market."],
            "data": {
              "uri": "http://edamontology.org/topic_3378"
            },
            "definition": "The detection, assesment, understanding and prevention of adverse effects of medicines.",
            "text": "Pharmacovigilance"
          }],
          "data": {
            "uri": "http://edamontology.org/topic_3377"
          },
          "definition": "The safety (or lack) of drugs and other medical interventions.",
          "narrow_synonyms": ["Drug safety"],
          "text": "Safety sciences"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3379"
          },
          "definition": "The testing of new medicines, vaccines or procedures on animals (preclinical) and humans (clinical) prior to their approval by regulatory authorities.",
          "narrow_synonyms": ["Drug trials", "Clinical studies", "Preclinical studies", "Clinical study", "Preclinical study", "Clinical trial"],
          "text": "Preclinical and clinical studies"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/topic_3343"
            },
            "definition": "Collections of chemicals, typically for use in high-throughput screening experiments.",
            "narrow_synonyms": ["Small chemical compounds libraries", "Target identification and validation", "Small compounds libraries", "Chemical screening", "Compound library", "Chemical library"],
            "text": "Compound libraries and screening"
          }, {
            "comment": ["This includes methods that search compound collections, generate or analyse drug 3D conformations, identify drug targets with structural docking etc."],
            "data": {
              "uri": "http://edamontology.org/topic_0209"
            },
            "definition": "The design and chemical synthesis of bioactive molecules, for example drugs or potential drug compounds, for medicinal purposes.",
            "exact_synonyms": ["Drug design"],
            "text": "Medicinal chemistry"
          }],
          "comment": ["This includes methods that search compound collections, generate or analyse drug 3D conformations, identify drug targets with structural docking etc."],
          "data": {
            "uri": "http://edamontology.org/topic_3336"
          },
          "definition": "The discovery and design of drugs or potential drug compounds.",
          "text": "Drug discovery"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3393"
          },
          "definition": "The processes that need to be in place to ensure the quality of products for human or animal use.",
          "exact_synonyms": ["Quality assurance"],
          "narrow_synonyms": ["Good clinical practice", "Good manufacturing practice", "Good laboratory practice"],
          "text": "Quality affairs"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3375"
          },
          "definition": "The study of how a drug interacts with the body.",
          "narrow_synonyms": ["Drug distribution", "Drug absorption", "ADME", "Pharmacokinetics", "Drug excretion", "Pharmacodynamics", "Pharmacokinetics and pharmacodynamics"],
          "text": "Drug metabolism"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3373"
          },
          "definition": "The process of bringing a new drug to market once a lead compounds has been identified through drug discovery.",
          "exact_synonyms": ["Medicine development", "Drug development science", "Medicines development"],
          "text": "Drug development"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3394"
          },
          "definition": "The protection of public health by controlling the safety and efficacy of products in areas including pharmaceuticals, veterinary medicine, medical devices, pesticides, agrochemicals, cosmetics, and complementary medicines.",
          "exact_synonyms": ["Healthcare RA"],
          "text": "Regulatory affairs"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3966"
          },
          "definition": "The design of vaccines to protect against a particular pathogen, including antigens, delivery systems, and adjuvants to elicit a predictable immune response against specific epitopes.",
          "narrow_synonyms": ["Rational vaccine design", "Reverse vaccinology", "Structure-based immunogen design", "Structural vaccinology", "Vaccine design"],
          "text": "Vaccinology"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3374"
          },
          "definition": "The process of formulating and administering a pharmaceutical compound to achieve a therapeutic effect.",
          "text": "Biotherapeutics"
        }],
        "data": {
          "uri": "http://edamontology.org/topic_3376"
        },
        "definition": "The discovery, development and approval of medicines.",
        "exact_synonyms": ["Drug discovery and development"],
        "text": "Medicines research and development"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3390"
        },
        "definition": "The study of the effects of food components on the metabolism, health, performance and disease resistance of humans and animals.  It also includes the study of human behaviours related to food choices.",
        "exact_synonyms": ["Nutrition science", "Nutrition"],
        "narrow_synonyms": ["Dietetics"],
        "text": "Nutritional science"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/topic_3679"
          },
          "definition": "The design of an experiment involving non-human animals.",
          "narrow_synonyms": ["Challenge study"],
          "text": "Animal study"
        }],
        "data": {
          "uri": "http://edamontology.org/topic_3386"
        },
        "definition": "The use of animals and alternatives in experimental research.",
        "exact_synonyms": ["Animal testing", "In vivo testing", "Animal experimentation", "Animal research"],
        "text": "Laboratory animal science"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3302"
        },
        "definition": "The biology of parasites.",
        "text": "Parasitology"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3067"
        },
        "definition": "The form and function of the structures of living organisms.",
        "text": "Anatomy"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3395"
        },
        "definition": "Biomedical approaches to clinical interventions that involve the use of stem cells.",
        "exact_synonyms": ["Stem cell research"],
        "text": "Regenerative medicine"
      }],
      "data": {
        "uri": "http://edamontology.org/topic_3344"
      },
      "definition": "Topic concerning biological science that is (typically) performed in the context of medicine.",
      "exact_synonyms": ["Biomedical sciences", "Health science"],
      "text": "Biomedical science"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/topic_3569"
        },
        "definition": "The application of mathematics to specific problems in science, typically by the formulation and analysis of mathematical models.",
        "text": "Applied mathematics"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3570"
        },
        "definition": "The study of abstract mathematical concepts.",
        "narrow_synonyms": ["Linear algebra"],
        "text": "Pure mathematics"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_2269"
        },
        "definition": "The application of statistical methods to biological problems.",
        "narrow_synonyms": ["Descriptive statistics", "Markov processes", "Probabilistic graphical model", "Inferential statistics", "Gaussian processes", "Statistics", "Biostatistics", "Probability", "Multivariate statistics", "Bayesian methods"],
        "text": "Statistics and probability"
      }],
      "data": {
        "uri": "http://edamontology.org/topic_3315"
      },
      "definition": "The study of numbers (quantity) and other topics including structure, space, and change.",
      "exact_synonyms": ["Maths"],
      "narrow_synonyms": ["Dynamical systems", "Multivariate analysis", "Dynamic systems", "Graph analytics", "Monte Carlo methods", "Dynymical systems theory"],
      "text": "Mathematics"
    }, {
      "children": [{
        "children": [{
          "comment": ["This includes experimental (e.g. yeast two-hybrid) and computational analysis techniques."],
          "data": {
            "uri": "http://edamontology.org/topic_0128"
          },
          "definition": "Protein-protein, protein-DNA/RNA and protein-ligand interactions, including analysis of known interactions and prediction of putative interactions.",
          "narrow_synonyms": ["Protein-RNA interactions", "Protein-protein interactions", "Protein-DNA interaction", "Protein interactome", "Protein interaction map", "Protein interaction networks", "Protein-DNA interactions", "Protein-nucleic acid interactions", "Protein-ligand interactions", "Protein-RNA interaction"],
          "text": "Protein interactions"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_0820"
          },
          "definition": "Lipoproteins (protein-lipid assemblies), and proteins or region of a protein that spans or are associated with a membrane.",
          "narrow_synonyms": ["Transmembrane proteins", "Membrane proteins", "Lipoproteins"],
          "text": "Membrane and lipoproteins"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/topic_3534"
            },
            "definition": "Binding sites in proteins, including cleavage sites (for a proteolytic enzyme or agent), key residues involved in protein folding, catalytic residues (active site) of an enzyme, ligand-binding (non-catalytic) residues of a protein, such as sites that bind metal, prosthetic groups or lipids, RNA and DNA-binding proteins and binding sites etc.",
            "narrow_synonyms": ["Protein key folding sites", "Protein cleavage sites", "Enzyme active site", "Protein functional sites", "Protein-nucleic acid binding sites"],
            "text": "Protein binding sites"
          }],
          "comment": ["A signal peptide coding sequence encodes an N-terminal domain of a secreted protein, which is involved in attaching the polypeptide to a membrane leader sequence. A transit peptide coding sequence encodes an N-terminal domain of a nuclear-encoded organellar protein; which is involved in import of the protein into the organelle."],
          "data": {
            "uri": "http://edamontology.org/topic_3510"
          },
          "definition": "The biology, archival, detection, prediction and analysis of positional features such as functional and other key sites, in protein sequences and the conserved patterns (motifs, profiles etc.) that may be used to describe them.",
          "narrow_synonyms": ["Signal peptide cleavage sites", "Protein sequence features"],
          "text": "Protein sites, features and motifs"
        }, {
          "children": [{
            "comment": ["This includes conformation of conserved substructures, conserved geometry (spatial arrangement) of secondary structure or protein backbone, solvent-exposed surfaces, internal cavities, the analysis of shape, hydropathy, electrostatic patches, role and functions etc."],
            "data": {
              "uri": "http://edamontology.org/topic_0166"
            },
            "definition": "Structural features or common 3D motifs within protein structures, including the surface of a protein structure, such as biological interfaces with other molecules.",
            "exact_synonyms": ["Protein 3D motifs"],
            "narrow_synonyms": ["Protein structural features", "Protein structural motifs", "Protein surfaces", "Structural motifs"],
            "text": "Protein structural motifs and surfaces"
          }, {
            "comment": ["Super-secondary structures include leucine zippers, coiled coils, Helix-Turn-Helix etc.", "The location and size of the secondary structure elements and intervening loop regions is typically given.  The report can include disulphide bonds and post-translationally formed peptide bonds (crosslinks)."],
            "data": {
              "uri": "http://edamontology.org/topic_3542"
            },
            "definition": "Secondary structure (predicted or real) of a protein, including super-secondary structure.",
            "exact_synonyms": ["Protein features (secondary structure)"],
            "narrow_synonyms": ["Protein super-secondary structure"],
            "text": "Protein secondary structure"
          }, {
            "comment": ["This includes topological domains such as cytoplasmic regions in a protein.", "This includes trans- or intra-membrane regions of a protein, typically describing physicochemical properties of the secondary structure elements.  For example, the location and size of the membrane spanning segments and intervening loop regions, transmembrane region IN/OUT orientation relative to the membrane, plus the following data for each amino acid: A Z-coordinate (the distance to the membrane center), the free energy of membrane insertion (calculated in a sliding window over the sequence) and a reliability score. The z-coordinate implies information about re-entrant helices, interfacial helices, the tilt of a transmembrane helix and loop lengths."],
            "data": {
              "uri": "http://edamontology.org/topic_0736"
            },
            "definition": "Protein tertiary structural domains and folds in a protein or polypeptide chain.",
            "narrow_synonyms": ["Intramembrane regions", "Protein structural domains", "Protein domains", "Protein transmembrane regions", "Protein topological domains", "Transmembrane regions", "Protein folds", "Protein membrane regions"],
            "text": "Protein folds and structural domains"
          }, {
            "data": {
              "uri": "http://edamontology.org/topic_0130"
            },
            "definition": "Protein stability, folding (in 3D space) and protein sequence-structure-function relationships.  This includes for example study of inter-atomic or inter-residue interactions in protein (3D) structures, the effect of mutation, and the design of proteins with specific properties, typically by designing changes (via site-directed mutagenesis) to an existing protein.",
            "narrow_synonyms": ["Protein residue interactions", "Protein folding", "Protein stability", "Rational protein design", "Protein design"],
            "text": "Protein folding, stability and design"
          }, {
            "data": {
              "uri": "http://edamontology.org/topic_3538"
            },
            "definition": "Disordered structure in a protein.",
            "exact_synonyms": ["Protein features (disordered structure)"],
            "text": "Protein disordered structure"
          }],
          "data": {
            "uri": "http://edamontology.org/topic_2814"
          },
          "definition": "Protein secondary or tertiary structural data and/or associated annotation.",
          "exact_synonyms": ["Protein structure"],
          "narrow_synonyms": ["Protein tertiary structure"],
          "text": "Protein structure analysis"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_0123"
          },
          "definition": "The study of the physical and biochemical properties of peptides and proteins, for example the hydrophobic, hydrophilic and charge properties of a protein.",
          "exact_synonyms": ["Protein physicochemistry"],
          "narrow_synonyms": ["Protein hydropathy"],
          "text": "Protein properties"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_0821"
          },
          "definition": "Proteins that catalyze chemical reaction, the kinetics of enzyme-catalysed reactions, enzyme nomenclature etc.",
          "exact_synonyms": ["Enzymology"],
          "text": "Enzymes"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/topic_3120"
            },
            "definition": "Protein sequence variants produced e.g. from alternative splicing, alternative promoter usage, alternative initiation and ribosomal frameshifting.",
            "text": "Protein variants"
          }, {
            "comment": ["EDAM does not describe all possible protein modifications. For fine-grained annotation of protein modification use the Gene Ontology (children of concept GO:0006464) and/or the Protein Modifications ontology (children of concept MOD:00000)"],
            "data": {
              "uri": "http://edamontology.org/topic_0601"
            },
            "definition": "Protein chemical modifications, e.g. post-translational modifications.",
            "exact_synonyms": ["Post-translational modifications", "Protein post-translational modification", "PTMs"],
            "narrow_synonyms": ["Protein chemical modifications", "Post-translation modifications", "Protein post-translational modifications"],
            "text": "Protein modifications"
          }, {
            "data": {
              "uri": "http://edamontology.org/topic_0140"
            },
            "definition": "The study of how proteins are transported within and without the cell, including signal peptides, protein subcellular localisation and export.",
            "narrow_synonyms": ["Protein targeting", "Protein sorting", "Protein localisation"],
            "text": "Protein targeting and localisation"
          }],
          "data": {
            "uri": "http://edamontology.org/topic_0108"
          },
          "definition": "The translation of mRNA into protein and subsequent protein processing in the cell.",
          "narrow_synonyms": ["Translation"],
          "text": "Protein expression"
        }, {
          "children": [{
            "comment": ["This includes T cell receptors (TR), major histocompatibility complex (MHC), immunoglobulin superfamily (IgSF) / antibodies, major histocompatibility complex superfamily (MhcSF), etc.\""],
            "data": {
              "uri": "http://edamontology.org/topic_2830"
            },
            "definition": "Immunity-related proteins and their ligands.",
            "narrow_synonyms": ["Immunopeptides", "Immunoproteins", "Therapeutic antibodies", "Antigens"],
            "text": "Immunoproteins and antigens"
          }],
          "comment": ["A protein families database might include the classifier (e.g. a sequence profile) used to build the classification."],
          "data": {
            "uri": "http://edamontology.org/topic_0623"
          },
          "definition": "Particular gene(s), gene family or other gene group or system and their encoded proteins.Primarily the classification of proteins (from sequence or structural data) into clusters, groups, families etc., curation of a particular protein or protein family, or any other proteins that have been classified as members of a common group.",
          "exact_synonyms": ["Genes, gene family or system"],
          "narrow_synonyms": ["Gene families", "Protein sequence classification", "Protein families", "Gene family", "Gene system"],
          "text": "Gene and protein families"
        }, {
          "comment": ["This includes CpG rich regions (isochores) in a nucleotide sequence.", "Transcription factor proteins either promote (as an activator) or block (as a repressor) the binding to DNA of RNA polymerase.  Regulatory sites including transcription factor binding site as well as promoters, enhancers, silencers and boundary elements / insulators.", "This includes promoters, CAAT signals, TATA signals, -35 signals, -10 signals, GC signals, primer binding sites for initiation of transcription or reverse transcription, enhancer, attenuator, terminators and ribosome binding sites."],
          "data": {
            "uri": "http://edamontology.org/topic_0749"
          },
          "definition": "Proteins that bind to DNA and control transcription of DNA to mRNA (transcription factors) and also transcriptional regulatory sites, elements and regions (such as promoters, enhancers, silencers and boundary elements / insulators) in nucleotide sequences.",
          "narrow_synonyms": ["GC signals", "Attenuators", "Transcriptional regulatory sites", "CCAAT box", "CAT box", "Promoters", "-35 signals", "Transcription factors", "Transcription factor binding sites", "CpG islands", "Terminators", "Enhancers", "TATA signals", "Isochores", "TFBS", "CAAT signals", "-10 signals"],
          "text": "Transcription factors and regulatory sites"
        }],
        "data": {
          "uri": "http://edamontology.org/topic_0078"
        },
        "definition": "Archival, processing and analysis of protein data, typically molecular sequence and structural data.",
        "exact_synonyms": ["Protein bioinformatics", "Protein informatics"],
        "narrow_synonyms": ["Protein databases"],
        "text": "Proteins"
      }, {
        "children": [{
          "comment": ["Includes secondary and tertiary nucleic acid structural data, nucleic acid thermodynamic, thermal and conformational properties including DNA or DNA/RNA denaturation (melting) etc."],
          "data": {
            "uri": "http://edamontology.org/topic_0097"
          },
          "definition": "The archival, curation, processing and analysis of nucleic acid structural information, such as whole structures, structural features and alignments, and associated annotation.",
          "exact_synonyms": ["Nucleic acid structure"],
          "narrow_synonyms": ["DNA melting", "Nucleic acid denaturation", "DNA structure", "RNA alignment", "RNA structure", "RNA structure alignment", "Nucleic acid thermodynamics"],
          "text": "Nucleic acid structure analysis"
        }, {
          "children": [{
            "comment": ["This includes the study of splice sites, splicing patterns, alternative splicing events and variants, isoforms, etc.."],
            "data": {
              "uri": "http://edamontology.org/topic_3320"
            },
            "definition": "RNA splicing; post-transcription RNA modification involving the removal of introns and joining of exons.",
            "exact_synonyms": ["Alternative splicing"],
            "narrow_synonyms": ["Splice sites"],
            "text": "RNA splicing"
          }, {
            "comment": ["Non-coding RNA includes  piwi-interacting RNA (piRNA), small nuclear RNA (snRNA) and small nucleolar RNA (snoRNA).  Regulatory RNA includes microRNA (miRNA) - short single stranded RNA molecules that regulate gene expression, and small interfering RNA (siRNA)."],
            "data": {
              "uri": "http://edamontology.org/topic_0659"
            },
            "definition": "Non-coding or functional RNA sequences, including regulatory RNA sequences, ribosomal RNA (rRNA) and transfer RNA (tRNA).",
            "narrow_synonyms": ["Long ncRNA", "siRNA", "Regulatory RNA", "snRNA", "Small non-coding RNA", "Long non-coding RNA", "snoRNA", "Small nuclear RNA", "microRNA", "piwi-interacting RNA", "Small ncRNA", "Small interfering RNA", "miRNA", "Functional RNA", "piRNA", "Small nucleolar RNA", "Non-coding RNA", "Small and long non-coding RNAs", "ncRNA", "lncRNA"],
            "text": "Functional, regulatory and non-coding RNA"
          }, {
            "comment": ["This includes Introns, and protein-coding regions including coding sequences (CDS), exons, translation initiation sites and open reading frames.  Also expressed sequence tag (EST) or complementary DNA (cDNA) sequences.", "This includes coding sequences for a signal or transit peptide.  A signal peptide coding sequence encodes an N-terminal domain of a secreted protein, which is involved in attaching the polypeptide to a membrane leader sequence. A transit peptide coding sequence encodes an N-terminal domain of a nuclear-encoded organellar protein; which is involved in import of the protein into the organelle.", "This includes regions or sites in a eukaryotic and eukaryotic viral RNA sequence which directs endonuclease cleavage or polyadenylation of an RNA transcript.  A polyA signal is required for endonuclease cleavage of an RNA transcript that is followed by polyadenylation. A polyA site is a site on an RNA transcript to which adenine residues will be added during post-transcriptional polyadenylation.", "This includes 5'untranslated region (5'UTR), coding sequences (CDS), exons, intervening sequences (intron) and 3'untranslated regions (3'UTR)."],
            "data": {
              "uri": "http://edamontology.org/topic_3512"
            },
            "definition": "Transcription of DNA into RNA and features of a messenger RNA (mRNA) molecules including precursor RNA, primary (unprocessed) transcript and fully processed molecules.",
            "exact_synonyms": ["mRNA features"],
            "narrow_synonyms": ["PolyA site", "mRNA", "Introns", "cDNA", "Exons", "Gene transcript features", "Coding RNA", "Fusion transcripts", "Signal peptide coding sequence", "EST", "Transit peptide coding sequence", "PolyA signal"],
            "text": "Gene transcripts"
          }],
          "data": {
            "uri": "http://edamontology.org/topic_0099"
          },
          "definition": "RNA sequences and structures.",
          "narrow_synonyms": ["Small RNA"],
          "text": "RNA"
        }, {
          "children": [{
            "children": [{
              "comment": ["This includes CpG rich regions (isochores) in a nucleotide sequence.", "Transcription factor proteins either promote (as an activator) or block (as a repressor) the binding to DNA of RNA polymerase.  Regulatory sites including transcription factor binding site as well as promoters, enhancers, silencers and boundary elements / insulators.", "This includes promoters, CAAT signals, TATA signals, -35 signals, -10 signals, GC signals, primer binding sites for initiation of transcription or reverse transcription, enhancer, attenuator, terminators and ribosome binding sites."],
              "data": {
                "uri": "http://edamontology.org/topic_0749"
              },
              "definition": "Proteins that bind to DNA and control transcription of DNA to mRNA (transcription factors) and also transcriptional regulatory sites, elements and regions (such as promoters, enhancers, silencers and boundary elements / insulators) in nucleotide sequences.",
              "narrow_synonyms": ["GC signals", "Attenuators", "Transcriptional regulatory sites", "CCAAT box", "CAT box", "Promoters", "-35 signals", "Transcription factors", "Transcription factor binding sites", "CpG islands", "Terminators", "Enhancers", "TATA signals", "Isochores", "TFBS", "CAAT signals", "-10 signals"],
              "text": "Transcription factors and regulatory sites"
            }],
            "comment": ["This includes ribosome binding sites (Shine-Dalgarno sequence in prokaryotes), restriction enzyme recognition sites (restriction sites) etc.", "This includes sites involved with DNA replication and recombination.  This includes binding sites for initiation of replication (origin of replication), regions where transfer is initiated during the conjugation or mobilisation (origin of transfer), starting sites for DNA duplication (origin of replication) and regions which are eliminated through any of kind of recombination.  Also nucleosome exclusion regions, i.e. specific patterns or regions which exclude nucleosomes (the basic structural units of eukaryotic chromatin which play a significant role in regulating gene expression)."],
            "data": {
              "uri": "http://edamontology.org/topic_3125"
            },
            "definition": "Nucleic acids binding to some other molecule.",
            "narrow_synonyms": ["Ribosome binding sites", "Restriction sites", "Matrix/scaffold attachment region", "Nucleosome exclusion sequences", "Scaffold-attachment region", "Matrix-attachment region"],
            "text": "DNA binding sites"
          }],
          "comment": ["Sequence tagged sites are short DNA sequences that are unique within a genome and serve as a mapping landmark, detectable by PCR they allow a genome to be mapped via an ordering of STSs."],
          "data": {
            "uri": "http://edamontology.org/topic_3511"
          },
          "definition": "The biology, archival, detection, prediction and analysis of positional features such as functional and other key sites, in nucleic acid sequences and the conserved patterns (motifs, profiles etc.) that may be used to describe them.",
          "narrow_synonyms": ["Nucleic acid sequence features", "Nucleic acid functional sites", "Sequence tagged sites", "Primer binding sites"],
          "text": "Nucleic acid sites, features and motifs"
        }, {
          "children": [{
            "comment": ["Includes restriction fragment length polymorphisms (RFLP) in a DNA sequence.  An RFLP is defined by the presence or absence of a specific restriction site of a bacterial restriction enzyme.", "Includes microsatellite polymorphism in a DNA sequence.  A microsatellite polymorphism is a very short subsequence that is repeated a variable number of times between individuals. These repeats consist of the nucleotides cytosine and adenosine.", "Includes single nucleotide polymorphisms (SNP) and associated data, for example, the discovery and annotation of SNPs.  A SNP is a DNA sequence variation where a single nucleotide differs between members of a species or paired chromosomes in an individual.", "Includes variable number of tandem repeat (VNTR) polymorphism in a DNA sequence.  VNTRs occur in non-coding regions of DNA and consists sub-sequence that is repeated a multiple (and varied) number of times."],
            "data": {
              "uri": "http://edamontology.org/topic_2885"
            },
            "definition": "DNA polymorphism.",
            "narrow_synonyms": ["VNTR", "Single nucleotide polymorphism", "SNP", "Variable number of tandem repeat polymorphism", "Microsatellites", "snps", "RFLP"],
            "text": "DNA polymorphism"
          }, {
            "children": [{
              "comment": ["This includes CpG rich regions (isochores) in a nucleotide sequence.", "Transcription factor proteins either promote (as an activator) or block (as a repressor) the binding to DNA of RNA polymerase.  Regulatory sites including transcription factor binding site as well as promoters, enhancers, silencers and boundary elements / insulators.", "This includes promoters, CAAT signals, TATA signals, -35 signals, -10 signals, GC signals, primer binding sites for initiation of transcription or reverse transcription, enhancer, attenuator, terminators and ribosome binding sites."],
              "data": {
                "uri": "http://edamontology.org/topic_0749"
              },
              "definition": "Proteins that bind to DNA and control transcription of DNA to mRNA (transcription factors) and also transcriptional regulatory sites, elements and regions (such as promoters, enhancers, silencers and boundary elements / insulators) in nucleotide sequences.",
              "narrow_synonyms": ["GC signals", "Attenuators", "Transcriptional regulatory sites", "CCAAT box", "CAT box", "Promoters", "-35 signals", "Transcription factors", "Transcription factor binding sites", "CpG islands", "Terminators", "Enhancers", "TATA signals", "Isochores", "TFBS", "CAAT signals", "-10 signals"],
              "text": "Transcription factors and regulatory sites"
            }],
            "comment": ["This includes ribosome binding sites (Shine-Dalgarno sequence in prokaryotes), restriction enzyme recognition sites (restriction sites) etc.", "This includes sites involved with DNA replication and recombination.  This includes binding sites for initiation of replication (origin of replication), regions where transfer is initiated during the conjugation or mobilisation (origin of transfer), starting sites for DNA duplication (origin of replication) and regions which are eliminated through any of kind of recombination.  Also nucleosome exclusion regions, i.e. specific patterns or regions which exclude nucleosomes (the basic structural units of eukaryotic chromatin which play a significant role in regulating gene expression)."],
            "data": {
              "uri": "http://edamontology.org/topic_3125"
            },
            "definition": "Nucleic acids binding to some other molecule.",
            "narrow_synonyms": ["Ribosome binding sites", "Restriction sites", "Matrix/scaffold attachment region", "Nucleosome exclusion sequences", "Scaffold-attachment region", "Matrix-attachment region"],
            "text": "DNA binding sites"
          }, {
            "data": {
              "uri": "http://edamontology.org/topic_3176"
            },
            "definition": "DNA-histone complexes (chromatin), organisation of chromatin into nucleosomes and packaging into higher-order structures.",
            "narrow_synonyms": ["Nucleosome positioning"],
            "text": "DNA packaging"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/topic_3958"
              },
              "definition": "A DNA structural variation, specifically a duplication or deletion event, resulting in sections of the genome to be repeated, or the number of repeats in the genome to vary between individuals.",
              "narrow_synonyms": ["Complex CNV", "CNV deletion", "CNV insertion / amplification", "Copy number variant", "CNV duplication"],
              "text": "Copy number variation"
            }],
            "data": {
              "uri": "http://edamontology.org/topic_3175"
            },
            "definition": "Variation in chromosome structure including microscopic and submicroscopic types of variation such as deletions, duplications, copy-number variants, insertions, inversions and translocations.",
            "exact_synonyms": ["Genomic structural variation", "DNA structural variation"],
            "narrow_synonyms": ["Translocation", "Deletion", "Insertion", "Inversion", "Duplication"],
            "text": "Structural variation"
          }, {
            "data": {
              "uri": "http://edamontology.org/topic_3127"
            },
            "definition": "DNA replication or recombination.",
            "text": "DNA replication and recombination"
          }, {
            "data": {
              "uri": "http://edamontology.org/topic_2533"
            },
            "definition": "DNA mutation.",
            "text": "DNA mutation"
          }],
          "comment": ["The DNA sequences might be coding or non-coding sequences."],
          "data": {
            "uri": "http://edamontology.org/topic_0654"
          },
          "definition": "DNA sequences and structure, including processes such as methylation and replication.",
          "exact_synonyms": ["DNA analysis"],
          "narrow_synonyms": ["Chromosomes", "Ancient DNA"],
          "text": "DNA"
        }],
        "data": {
          "uri": "http://edamontology.org/topic_0077"
        },
        "definition": "The processing and analysis of nucleic acid sequence, structural and other data.",
        "exact_synonyms": ["Nucleic acid informatics", "Nucleic acid bioinformatics"],
        "narrow_synonyms": ["Nucleic acid properties", "Nucleic acid physicochemistry"],
        "text": "Nucleic acids"
      }, {
        "children": [{
          "comment": ["This includes experimental (e.g. yeast two-hybrid) and computational analysis techniques."],
          "data": {
            "uri": "http://edamontology.org/topic_0128"
          },
          "definition": "Protein-protein, protein-DNA/RNA and protein-ligand interactions, including analysis of known interactions and prediction of putative interactions.",
          "narrow_synonyms": ["Protein-RNA interactions", "Protein-protein interactions", "Protein-DNA interaction", "Protein interactome", "Protein interaction map", "Protein interaction networks", "Protein-DNA interactions", "Protein-nucleic acid interactions", "Protein-ligand interactions", "Protein-RNA interaction"],
          "text": "Protein interactions"
        }],
        "data": {
          "uri": "http://edamontology.org/topic_0602"
        },
        "definition": "Molecular interactions, biological pathways, networks and other models.",
        "narrow_synonyms": ["Biological pathways", "Environmental information processing pathways", "Cellular process pathways", "Biological models", "Interactome", "Signaling pathways", "Signal transduction pathways", "Metabolic pathways", "Networks", "Disease pathways", "Biological networks", "Pathways", "Interactions", "Genetic information processing pathways", "Gene regulatory networks", "Molecular interactions"],
        "text": "Molecular interactions, pathways and networks"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/topic_3293"
          },
          "definition": "The study of evolutionary relationships amongst organisms from analysis of genetic information (typically gene or protein sequences).",
          "text": "Phylogenetics"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3944"
          },
          "definition": "The biological classification of organisms by categorizing them in groups (\"clades\") based on their most recent common ancestor.",
          "narrow_synonyms": ["Tree of life"],
          "text": "Cladistics"
        }],
        "comment": ["This includes diverse phylogenetic methods, including phylogenetic tree construction, typically from molecular sequence or morphological data, methods that simulate DNA sequence evolution, a phylogenetic tree or the underlying data, or which estimate or use molecular clock and stratigraphic (age) data, methods for studying gene evolution etc."],
        "data": {
          "uri": "http://edamontology.org/topic_0084"
        },
        "definition": "The study of evolutionary relationships amongst organisms.",
        "narrow_synonyms": ["Phylogenetic dating", "Phylogenetic clocks", "Phylogenetic stratigraphy", "Phylogeny reconstruction", "Phylogenetic simulation"],
        "text": "Phylogeny"
      }, {
        "children": [{
          "children": [{
            "comment": ["Metatranscriptomics methods can be used for whole gene expression profiling of complex microbial communities."],
            "data": {
              "uri": "http://edamontology.org/topic_3941"
            },
            "definition": "The study of microbe gene expression within natural environments (i.e. the metatranscriptome).",
            "text": "Metatranscriptomics"
          }, {
            "comment": ["This includes the study of splice sites, splicing patterns, alternative splicing events and variants, isoforms, etc.."],
            "data": {
              "uri": "http://edamontology.org/topic_3320"
            },
            "definition": "RNA splicing; post-transcription RNA modification involving the removal of introns and joining of exons.",
            "exact_synonyms": ["Alternative splicing"],
            "narrow_synonyms": ["Splice sites"],
            "text": "RNA splicing"
          }, {
            "data": {
              "uri": "http://edamontology.org/topic_0204"
            },
            "definition": "The regulation of gene expression.",
            "narrow_synonyms": ["Regulatory genomics"],
            "text": "Gene regulation"
          }, {
            "comment": ["This includes CpG rich regions (isochores) in a nucleotide sequence.", "Transcription factor proteins either promote (as an activator) or block (as a repressor) the binding to DNA of RNA polymerase.  Regulatory sites including transcription factor binding site as well as promoters, enhancers, silencers and boundary elements / insulators.", "This includes promoters, CAAT signals, TATA signals, -35 signals, -10 signals, GC signals, primer binding sites for initiation of transcription or reverse transcription, enhancer, attenuator, terminators and ribosome binding sites."],
            "data": {
              "uri": "http://edamontology.org/topic_0749"
            },
            "definition": "Proteins that bind to DNA and control transcription of DNA to mRNA (transcription factors) and also transcriptional regulatory sites, elements and regions (such as promoters, enhancers, silencers and boundary elements / insulators) in nucleotide sequences.",
            "narrow_synonyms": ["GC signals", "Attenuators", "Transcriptional regulatory sites", "CCAAT box", "CAT box", "Promoters", "-35 signals", "Transcription factors", "Transcription factor binding sites", "CpG islands", "Terminators", "Enhancers", "TATA signals", "Isochores", "TFBS", "CAAT signals", "-10 signals"],
            "text": "Transcription factors and regulatory sites"
          }, {
            "children": [{
              "comment": ["Metatranscriptomics methods can be used for whole gene expression profiling of complex microbial communities."],
              "data": {
                "uri": "http://edamontology.org/topic_3941"
              },
              "definition": "The study of microbe gene expression within natural environments (i.e. the metatranscriptome).",
              "text": "Metatranscriptomics"
            }],
            "data": {
              "uri": "http://edamontology.org/topic_3308"
            },
            "definition": "The analysis of transcriptomes, or a set of all the RNA molecules in a specific cell, tissue etc.",
            "narrow_synonyms": ["Transcriptome", "Comparative transcriptomics", "Metatranscriptomics"],
            "text": "Transcriptomics"
          }],
          "comment": ["Gene expression levels are analysed by identifying, quantifying or comparing mRNA transcripts, for example using microarrays, RNA-seq, northern blots, gene-indexed expression profiles etc.", "This includes the study of codon usage in nucleotide sequence(s), genetic codes and so on."],
          "data": {
            "uri": "http://edamontology.org/topic_0203"
          },
          "definition": "The analysis of levels and patterns of synthesis of gene products (proteins and functional RNA) including interpretation in functional terms of gene expression data.",
          "exact_synonyms": ["Expression"],
          "narrow_synonyms": ["Transcription", "DNA microarrays", "Gene expression profiling", "Codon usage", "Gene translation", "Gene transcription", "DNA chips"],
          "text": "Gene expression"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/topic_0798"
            },
            "definition": "Mobile genetic elements, such as transposons, Plasmids, Bacteriophage elements and Group II introns.",
            "narrow_synonyms": ["Transposons"],
            "text": "Mobile genetic elements"
          }, {
            "comment": ["Non-coding RNA includes  piwi-interacting RNA (piRNA), small nuclear RNA (snRNA) and small nucleolar RNA (snoRNA).  Regulatory RNA includes microRNA (miRNA) - short single stranded RNA molecules that regulate gene expression, and small interfering RNA (siRNA)."],
            "data": {
              "uri": "http://edamontology.org/topic_0659"
            },
            "definition": "Non-coding or functional RNA sequences, including regulatory RNA sequences, ribosomal RNA (rRNA) and transfer RNA (tRNA).",
            "narrow_synonyms": ["Long ncRNA", "siRNA", "Regulatory RNA", "snRNA", "Small non-coding RNA", "Long non-coding RNA", "snoRNA", "Small nuclear RNA", "microRNA", "piwi-interacting RNA", "Small ncRNA", "Small interfering RNA", "miRNA", "Functional RNA", "piRNA", "Small nucleolar RNA", "Non-coding RNA", "Small and long non-coding RNAs", "ncRNA", "lncRNA"],
            "text": "Functional, regulatory and non-coding RNA"
          }, {
            "comment": ["This includes Introns, and protein-coding regions including coding sequences (CDS), exons, translation initiation sites and open reading frames.  Also expressed sequence tag (EST) or complementary DNA (cDNA) sequences.", "This includes coding sequences for a signal or transit peptide.  A signal peptide coding sequence encodes an N-terminal domain of a secreted protein, which is involved in attaching the polypeptide to a membrane leader sequence. A transit peptide coding sequence encodes an N-terminal domain of a nuclear-encoded organellar protein; which is involved in import of the protein into the organelle.", "This includes regions or sites in a eukaryotic and eukaryotic viral RNA sequence which directs endonuclease cleavage or polyadenylation of an RNA transcript.  A polyA signal is required for endonuclease cleavage of an RNA transcript that is followed by polyadenylation. A polyA site is a site on an RNA transcript to which adenine residues will be added during post-transcriptional polyadenylation.", "This includes 5'untranslated region (5'UTR), coding sequences (CDS), exons, intervening sequences (intron) and 3'untranslated regions (3'UTR)."],
            "data": {
              "uri": "http://edamontology.org/topic_3512"
            },
            "definition": "Transcription of DNA into RNA and features of a messenger RNA (mRNA) molecules including precursor RNA, primary (unprocessed) transcript and fully processed molecules.",
            "exact_synonyms": ["mRNA features"],
            "narrow_synonyms": ["PolyA site", "mRNA", "Introns", "cDNA", "Exons", "Gene transcript features", "Coding RNA", "Fusion transcripts", "Signal peptide coding sequence", "EST", "Transit peptide coding sequence", "PolyA signal"],
            "text": "Gene transcripts"
          }],
          "comment": ["This includes the study of promoters, coding regions etc.", "This incudes operons (operators, promoters and genes) from a bacterial genome.  For example the operon leader and trailer gene, gene composition of the operon and associated information."],
          "data": {
            "uri": "http://edamontology.org/topic_0114"
          },
          "definition": "Gene structure, regions which make an RNA product and features such as promoters, coding regions, gene fusion, splice sites etc.",
          "exact_synonyms": ["Gene features"],
          "narrow_synonyms": ["Fusion genes"],
          "text": "Gene structure"
        }, {
          "children": [{
            "comment": ["This includes T cell receptors (TR), major histocompatibility complex (MHC), immunoglobulin superfamily (IgSF) / antibodies, major histocompatibility complex superfamily (MhcSF), etc.\""],
            "data": {
              "uri": "http://edamontology.org/topic_2830"
            },
            "definition": "Immunity-related proteins and their ligands.",
            "narrow_synonyms": ["Immunopeptides", "Immunoproteins", "Therapeutic antibodies", "Antigens"],
            "text": "Immunoproteins and antigens"
          }],
          "comment": ["A protein families database might include the classifier (e.g. a sequence profile) used to build the classification."],
          "data": {
            "uri": "http://edamontology.org/topic_0623"
          },
          "definition": "Particular gene(s), gene family or other gene group or system and their encoded proteins.Primarily the classification of proteins (from sequence or structural data) into clusters, groups, families etc., curation of a particular protein or protein family, or any other proteins that have been classified as members of a common group.",
          "exact_synonyms": ["Genes, gene family or system"],
          "narrow_synonyms": ["Gene families", "Protein sequence classification", "Protein families", "Gene family", "Gene system"],
          "text": "Gene and protein families"
        }, {
          "children": [{
            "comment": ["Includes restriction fragment length polymorphisms (RFLP) in a DNA sequence.  An RFLP is defined by the presence or absence of a specific restriction site of a bacterial restriction enzyme.", "Includes microsatellite polymorphism in a DNA sequence.  A microsatellite polymorphism is a very short subsequence that is repeated a variable number of times between individuals. These repeats consist of the nucleotides cytosine and adenosine.", "Includes single nucleotide polymorphisms (SNP) and associated data, for example, the discovery and annotation of SNPs.  A SNP is a DNA sequence variation where a single nucleotide differs between members of a species or paired chromosomes in an individual.", "Includes variable number of tandem repeat (VNTR) polymorphism in a DNA sequence.  VNTRs occur in non-coding regions of DNA and consists sub-sequence that is repeated a multiple (and varied) number of times."],
            "data": {
              "uri": "http://edamontology.org/topic_2885"
            },
            "definition": "DNA polymorphism.",
            "narrow_synonyms": ["VNTR", "Single nucleotide polymorphism", "SNP", "Variable number of tandem repeat polymorphism", "Microsatellites", "snps", "RFLP"],
            "text": "DNA polymorphism"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/topic_3958"
              },
              "definition": "A DNA structural variation, specifically a duplication or deletion event, resulting in sections of the genome to be repeated, or the number of repeats in the genome to vary between individuals.",
              "narrow_synonyms": ["Complex CNV", "CNV deletion", "CNV insertion / amplification", "Copy number variant", "CNV duplication"],
              "text": "Copy number variation"
            }],
            "data": {
              "uri": "http://edamontology.org/topic_3175"
            },
            "definition": "Variation in chromosome structure including microscopic and submicroscopic types of variation such as deletions, duplications, copy-number variants, insertions, inversions and translocations.",
            "exact_synonyms": ["Genomic structural variation", "DNA structural variation"],
            "narrow_synonyms": ["Translocation", "Deletion", "Insertion", "Inversion", "Duplication"],
            "text": "Structural variation"
          }, {
            "data": {
              "uri": "http://edamontology.org/topic_2533"
            },
            "definition": "DNA mutation.",
            "text": "DNA mutation"
          }],
          "data": {
            "uri": "http://edamontology.org/topic_0199"
          },
          "definition": "Stable, naturally occuring mutations in a nucleotide sequence including alleles, naturally occurring mutations such as single base nucleotide substitutions, deletions and insertions, RFLPs and other polymorphisms.",
          "exact_synonyms": ["DNA variation"],
          "narrow_synonyms": ["Genomic variation", "Polymorphism", "Somatic mutations", "Mutation"],
          "text": "Genetic variation"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3959"
          },
          "definition": "The branch of genetics concerned with the relationships between chromosomes and cellular behaviour, especially during mitosis and meiosis.",
          "text": "Cytogenetics"
        }],
        "data": {
          "uri": "http://edamontology.org/topic_3321"
        },
        "definition": "The structure and function of genes at a molecular level.",
        "text": "Molecular genetics"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/topic_0153"
          },
          "definition": "Lipids and their structures.",
          "exact_synonyms": ["Lipidomics"],
          "text": "Lipids"
        }, {
          "comment": ["Includes secondary and tertiary nucleic acid structural data, nucleic acid thermodynamic, thermal and conformational properties including DNA or DNA/RNA denaturation (melting) etc."],
          "data": {
            "uri": "http://edamontology.org/topic_0097"
          },
          "definition": "The archival, curation, processing and analysis of nucleic acid structural information, such as whole structures, structural features and alignments, and associated annotation.",
          "exact_synonyms": ["Nucleic acid structure"],
          "narrow_synonyms": ["DNA melting", "Nucleic acid denaturation", "DNA structure", "RNA alignment", "RNA structure", "RNA structure alignment", "Nucleic acid thermodynamics"],
          "text": "Nucleic acid structure analysis"
        }, {
          "children": [{
            "comment": ["This includes conformation of conserved substructures, conserved geometry (spatial arrangement) of secondary structure or protein backbone, solvent-exposed surfaces, internal cavities, the analysis of shape, hydropathy, electrostatic patches, role and functions etc."],
            "data": {
              "uri": "http://edamontology.org/topic_0166"
            },
            "definition": "Structural features or common 3D motifs within protein structures, including the surface of a protein structure, such as biological interfaces with other molecules.",
            "exact_synonyms": ["Protein 3D motifs"],
            "narrow_synonyms": ["Protein structural features", "Protein structural motifs", "Protein surfaces", "Structural motifs"],
            "text": "Protein structural motifs and surfaces"
          }, {
            "comment": ["Super-secondary structures include leucine zippers, coiled coils, Helix-Turn-Helix etc.", "The location and size of the secondary structure elements and intervening loop regions is typically given.  The report can include disulphide bonds and post-translationally formed peptide bonds (crosslinks)."],
            "data": {
              "uri": "http://edamontology.org/topic_3542"
            },
            "definition": "Secondary structure (predicted or real) of a protein, including super-secondary structure.",
            "exact_synonyms": ["Protein features (secondary structure)"],
            "narrow_synonyms": ["Protein super-secondary structure"],
            "text": "Protein secondary structure"
          }, {
            "comment": ["This includes topological domains such as cytoplasmic regions in a protein.", "This includes trans- or intra-membrane regions of a protein, typically describing physicochemical properties of the secondary structure elements.  For example, the location and size of the membrane spanning segments and intervening loop regions, transmembrane region IN/OUT orientation relative to the membrane, plus the following data for each amino acid: A Z-coordinate (the distance to the membrane center), the free energy of membrane insertion (calculated in a sliding window over the sequence) and a reliability score. The z-coordinate implies information about re-entrant helices, interfacial helices, the tilt of a transmembrane helix and loop lengths."],
            "data": {
              "uri": "http://edamontology.org/topic_0736"
            },
            "definition": "Protein tertiary structural domains and folds in a protein or polypeptide chain.",
            "narrow_synonyms": ["Intramembrane regions", "Protein structural domains", "Protein domains", "Protein transmembrane regions", "Protein topological domains", "Transmembrane regions", "Protein folds", "Protein membrane regions"],
            "text": "Protein folds and structural domains"
          }, {
            "data": {
              "uri": "http://edamontology.org/topic_0130"
            },
            "definition": "Protein stability, folding (in 3D space) and protein sequence-structure-function relationships.  This includes for example study of inter-atomic or inter-residue interactions in protein (3D) structures, the effect of mutation, and the design of proteins with specific properties, typically by designing changes (via site-directed mutagenesis) to an existing protein.",
            "narrow_synonyms": ["Protein residue interactions", "Protein folding", "Protein stability", "Rational protein design", "Protein design"],
            "text": "Protein folding, stability and design"
          }, {
            "data": {
              "uri": "http://edamontology.org/topic_3538"
            },
            "definition": "Disordered structure in a protein.",
            "exact_synonyms": ["Protein features (disordered structure)"],
            "text": "Protein disordered structure"
          }],
          "data": {
            "uri": "http://edamontology.org/topic_2814"
          },
          "definition": "Protein secondary or tertiary structural data and/or associated annotation.",
          "exact_synonyms": ["Protein structure"],
          "narrow_synonyms": ["Protein tertiary structure"],
          "text": "Protein structure analysis"
        }, {
          "comment": ["This concept excludes macromolecules such as proteins and nucleic acids.", "This includes the structures of drugs, drug target, their interactions and binding affinities.  Also the structures of reactants or products of metabolism, for example small molecules such as including vitamins, polyols, nucleotides and amino acids.  Also the physicochemical, biochemical or structural properties of amino acids or peptides.  Also structural and associated data for toxic chemical substances.", "Small molecules include organic molecules, metal-organic compounds, small polypeptides, small polysaccharides and oligonucleotides.  Structural data is usually included."],
          "data": {
            "uri": "http://edamontology.org/topic_0154"
          },
          "definition": "Small molecules of biological significance, typically archival, curation, processing and analysis of structural information.",
          "narrow_synonyms": ["Toxins", "Targets", "Drug structures", "Drug targets", "Toxins and targets", "Chemical structures", "Peptides", "Amino acids", "Drugs and target structures", "Metabolite structures", "Target structures", "Peptides and amino acids"],
          "text": "Small molecules"
        }, {
          "children": [{
            "comment": ["This includes methods such as Molecular Dynamics, Coarse-grained dynamics, metadynamics, Quantum Mechanics, QM/MM, Markov State Models, etc. This includes resources concerning flexibility and motion in protein and other molecular structures."],
            "data": {
              "uri": "http://edamontology.org/topic_0176"
            },
            "definition": "The study and simulation of molecular (typically protein) conformation using a computational model of physical forces and computer simulation.",
            "narrow_synonyms": ["Protein dynamics"],
            "text": "Molecular dynamics"
          }, {
            "data": {
              "uri": "http://edamontology.org/topic_2275"
            },
            "definition": "The construction, analysis, evaluation, refinement etc. of models of a molecules properties or behaviour, including the modelling the structure of proteins in complex with small molecules or other macromolecules (docking).",
            "narrow_synonyms": ["Comparative modelling", "Homology modelling", "Docking", "Homology modeling", "Molecular docking"],
            "text": "Molecular modelling"
          }],
          "comment": ["This includes the recognition (prediction and assignment) of known protein structural domains or folds in protein sequence(s), for example by threading, or the alignment of molecular sequences to structures, structural (3D) profiles or templates (representing a structure or structure alignment)."],
          "data": {
            "uri": "http://edamontology.org/topic_0082"
          },
          "definition": "The prediction of molecular structure, including the prediction, modelling, recognition or design of protein secondary or tertiary structure or other structural features, and the folding of nucleic acid molecules and the prediction or design of nucleic acid (typically RNA) sequences with specific conformations.",
          "narrow_synonyms": ["Nucleic acid folding", "Nucleic acid design", "RNA structure prediction", "DNA structure prediction", "Nucleic acid structure prediction", "Protein structure prediction", "Protein fold recognition"],
          "text": "Structure prediction"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_0152"
          },
          "definition": "Carbohydrates, typically including structural information.",
          "text": "Carbohydrates"
        }],
        "comment": ["This includes related concepts such as structural properties, alignments and structural motifs."],
        "data": {
          "uri": "http://edamontology.org/topic_0081"
        },
        "definition": "The curation, processing, analysis and prediction of data about the structure of biological molecules, typically proteins and nucleic acids and other macromolecules.",
        "exact_synonyms": ["Structural bioinformatics", "Biomolecular structure"],
        "narrow_synonyms": ["Structure data resources", "Molecular structure", "Computational structural biology", "Structure databases", "Structures"],
        "text": "Structure analysis"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/topic_0194"
          },
          "definition": "The integrated study of evolutionary relationships and whole genome data, for example, in the analysis of species trees, horizontal gene transfer and evolutionary reconstruction.",
          "text": "Phylogenomics"
        }, {
          "comment": ["This includes resources that aim to identify, map or analyse genetic markers in DNA sequences, for example to produce a genetic (linkage) map of a chromosome or genome or to analyse genetic linkage and synteny. It also includes resources for physical (sequence) maps of a DNA sequence showing the physical distance (base pairs) between features or landmarks such as restriction sites, cloned DNA fragments, genes and other genetic markers.  It also covers for example the alignment of sequences of (typically millions) of short reads to a reference genome."],
          "data": {
            "uri": "http://edamontology.org/topic_0102"
          },
          "definition": "The mapping of complete (typically nucleotide) sequences. Mapping (in the sense of short read alignment, or more generally, just alignment) has application in RNA-Seq analysis (mapping of transcriptomics reads), variant discovery (e.g. mapping of exome capture), and re-sequencing (mapping of WGS reads).",
          "narrow_synonyms": ["Genetic linkage", "Linkage mapping", "Synteny", "Linkage"],
          "text": "Mapping"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3293"
          },
          "definition": "The study of evolutionary relationships amongst organisms from analysis of genetic information (typically gene or protein sequences).",
          "text": "Phylogenetics"
        }, {
          "comment": ["This includes the design of primers for PCR and DNA amplification or the design of molecular probes."],
          "data": {
            "uri": "http://edamontology.org/topic_0632"
          },
          "definition": "Molecular probes (e.g. a peptide probe or DNA microarray probe) or PCR primers and hybridisation oligos in a nucleic acid sequence.",
          "narrow_synonyms": ["Primers", "Probes", "Primer quality"],
          "text": "Probes and primers"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3944"
          },
          "definition": "The biological classification of organisms by categorizing them in groups (\"clades\") based on their most recent common ancestor.",
          "narrow_synonyms": ["Tree of life"],
          "text": "Cladistics"
        }, {
          "comment": ["This includes short repetitive subsequences (repeat sequences) in a protein sequence.", "This includes repetitive elements within a nucleic acid sequence, e.g. long terminal repeats (LTRs); sequences (typically retroviral) directly repeated at  both ends of a sequence and other types of repeating unit."],
          "data": {
            "uri": "http://edamontology.org/topic_0157"
          },
          "definition": "The archival, processing and analysis of the basic character composition of molecular sequences, for example character or word frequency, ambiguity, complexity, particularly regions of low complexity, and repeats or the repetitive nature of molecular sequences.",
          "narrow_synonyms": ["Low complexity sequences", "Nucleic acid repeats", "Sequence repeats", "Repeat sequences", "Protein repeats", "Sequence complexity", "Sequence composition", "Protein sequence repeats"],
          "text": "Sequence composition, complexity and repeats"
        }, {
          "comment": ["Assembly has two broad types, de-novo and re-sequencing. Re-sequencing is a specialised case of assembly, where an assembled (typically de-novo assembled) reference genome is available and is about 95% identical to the re-sequenced genome. All other cases of assembly are 'de-novo'."],
          "data": {
            "uri": "http://edamontology.org/topic_0196"
          },
          "definition": "The assembly of fragments of a DNA sequence to reconstruct the original sequence.",
          "narrow_synonyms": ["Assembly"],
          "text": "Sequence assembly"
        }],
        "data": {
          "uri": "http://edamontology.org/topic_0080"
        },
        "definition": "The archival, processing and analysis of molecular sequences (monomer composition of polymers) including molecular sequence data resources, sequence sites, alignments, motifs and profiles.",
        "exact_synonyms": ["Sequences"],
        "narrow_synonyms": ["Biological sequences", "Sequence databases"],
        "text": "Sequence analysis"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/topic_0085"
          },
          "definition": "The study of gene or protein functions and their interactions in totality in a given organism, tissue, cell etc.",
          "text": "Functional genomics"
        }],
        "data": {
          "uri": "http://edamontology.org/topic_1775"
        },
        "definition": "The study of gene and protein function including the prediction of functional properties of a protein.",
        "exact_synonyms": ["Functional analysis"],
        "narrow_synonyms": ["Protein function prediction", "Protein function analysis"],
        "text": "Function analysis"
      }, {
        "children": [{
          "comment": ["This includes methods such as Molecular Dynamics, Coarse-grained dynamics, metadynamics, Quantum Mechanics, QM/MM, Markov State Models, etc. This includes resources concerning flexibility and motion in protein and other molecular structures."],
          "data": {
            "uri": "http://edamontology.org/topic_0176"
          },
          "definition": "The study and simulation of molecular (typically protein) conformation using a computational model of physical forces and computer simulation.",
          "narrow_synonyms": ["Protein dynamics"],
          "text": "Molecular dynamics"
        }],
        "comment": ["This includes methods such as Molecular Dynamics, Coarse-grained dynamics, metadynamics, Quantum Mechanics, QM/MM, Markov State Models, etc."],
        "data": {
          "uri": "http://edamontology.org/topic_3892"
        },
        "definition": "The study and simulation of molecular conformations using a computational model and computer simulations.",
        "text": "Biomolecular simulation"
      }, {
        "children": [{
          "children": [{
            "data": {
              "uri": "http://edamontology.org/topic_3534"
            },
            "definition": "Binding sites in proteins, including cleavage sites (for a proteolytic enzyme or agent), key residues involved in protein folding, catalytic residues (active site) of an enzyme, ligand-binding (non-catalytic) residues of a protein, such as sites that bind metal, prosthetic groups or lipids, RNA and DNA-binding proteins and binding sites etc.",
            "narrow_synonyms": ["Protein key folding sites", "Protein cleavage sites", "Enzyme active site", "Protein functional sites", "Protein-nucleic acid binding sites"],
            "text": "Protein binding sites"
          }],
          "comment": ["A signal peptide coding sequence encodes an N-terminal domain of a secreted protein, which is involved in attaching the polypeptide to a membrane leader sequence. A transit peptide coding sequence encodes an N-terminal domain of a nuclear-encoded organellar protein; which is involved in import of the protein into the organelle."],
          "data": {
            "uri": "http://edamontology.org/topic_3510"
          },
          "definition": "The biology, archival, detection, prediction and analysis of positional features such as functional and other key sites, in protein sequences and the conserved patterns (motifs, profiles etc.) that may be used to describe them.",
          "narrow_synonyms": ["Signal peptide cleavage sites", "Protein sequence features"],
          "text": "Protein sites, features and motifs"
        }, {
          "children": [{
            "children": [{
              "comment": ["This includes CpG rich regions (isochores) in a nucleotide sequence.", "Transcription factor proteins either promote (as an activator) or block (as a repressor) the binding to DNA of RNA polymerase.  Regulatory sites including transcription factor binding site as well as promoters, enhancers, silencers and boundary elements / insulators.", "This includes promoters, CAAT signals, TATA signals, -35 signals, -10 signals, GC signals, primer binding sites for initiation of transcription or reverse transcription, enhancer, attenuator, terminators and ribosome binding sites."],
              "data": {
                "uri": "http://edamontology.org/topic_0749"
              },
              "definition": "Proteins that bind to DNA and control transcription of DNA to mRNA (transcription factors) and also transcriptional regulatory sites, elements and regions (such as promoters, enhancers, silencers and boundary elements / insulators) in nucleotide sequences.",
              "narrow_synonyms": ["GC signals", "Attenuators", "Transcriptional regulatory sites", "CCAAT box", "CAT box", "Promoters", "-35 signals", "Transcription factors", "Transcription factor binding sites", "CpG islands", "Terminators", "Enhancers", "TATA signals", "Isochores", "TFBS", "CAAT signals", "-10 signals"],
              "text": "Transcription factors and regulatory sites"
            }],
            "comment": ["This includes ribosome binding sites (Shine-Dalgarno sequence in prokaryotes), restriction enzyme recognition sites (restriction sites) etc.", "This includes sites involved with DNA replication and recombination.  This includes binding sites for initiation of replication (origin of replication), regions where transfer is initiated during the conjugation or mobilisation (origin of transfer), starting sites for DNA duplication (origin of replication) and regions which are eliminated through any of kind of recombination.  Also nucleosome exclusion regions, i.e. specific patterns or regions which exclude nucleosomes (the basic structural units of eukaryotic chromatin which play a significant role in regulating gene expression)."],
            "data": {
              "uri": "http://edamontology.org/topic_3125"
            },
            "definition": "Nucleic acids binding to some other molecule.",
            "narrow_synonyms": ["Ribosome binding sites", "Restriction sites", "Matrix/scaffold attachment region", "Nucleosome exclusion sequences", "Scaffold-attachment region", "Matrix-attachment region"],
            "text": "DNA binding sites"
          }],
          "comment": ["Sequence tagged sites are short DNA sequences that are unique within a genome and serve as a mapping landmark, detectable by PCR they allow a genome to be mapped via an ordering of STSs."],
          "data": {
            "uri": "http://edamontology.org/topic_3511"
          },
          "definition": "The biology, archival, detection, prediction and analysis of positional features such as functional and other key sites, in nucleic acid sequences and the conserved patterns (motifs, profiles etc.) that may be used to describe them.",
          "narrow_synonyms": ["Nucleic acid sequence features", "Nucleic acid functional sites", "Sequence tagged sites", "Primer binding sites"],
          "text": "Nucleic acid sites, features and motifs"
        }],
        "data": {
          "uri": "http://edamontology.org/topic_0160"
        },
        "definition": "The archival, detection, prediction and analysis of positional features such as functional and other key sites, in molecular sequences and the conserved patterns (motifs, profiles etc.) that may be used to describe them.",
        "narrow_synonyms": ["Sequence features", "Functional sites", "Sequence motifs", "Sequence sites", "Sequence profiles", "HMMs"],
        "text": "Sequence sites, features and motifs"
      }],
      "comment": ["This includes the modeling and treatment of biological processes and systems in mathematical terms (theoretical biology)."],
      "data": {
        "uri": "http://edamontology.org/topic_3307"
      },
      "definition": "The development and application of theory, analytical methods, mathematical models and computational simulation of biological systems.",
      "narrow_synonyms": ["Biomathematics", "Mathematical biology", "Theoretical biology"],
      "text": "Computational biology"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/topic_3063"
        },
        "definition": "The application of information technology to health, disease and biomedicine.",
        "exact_synonyms": ["Biomedical informatics", "Health and disease", "Clinical informatics", "Health informatics", "Healthcare informatics"],
        "text": "Medical informatics"
      }, {
        "comment": ["This includes data  processing in general, including basic handling of files and databases, datatypes, workflows and annotation."],
        "data": {
          "uri": "http://edamontology.org/topic_0091"
        },
        "definition": "The archival, curation, processing and analysis of complex biological data.",
        "text": "Bioinformatics"
      }, {
        "comment": ["This involves the study of often complex genetic traits underlying diseases involving defects in the immune system. For example, identifying target genes for therapeutic approaches, or genetic variations involved in immunological pathology."],
        "data": {
          "uri": "http://edamontology.org/topic_3948"
        },
        "definition": "Immunoinformatics is the field of computational biology that deals with the study of immunoloogical questions. Immunoinformatics is at the interface between immunology and computer science. It takes advantage of computational, statistical, mathematical approaches and enhances the understanding of immunological knowledge.",
        "exact_synonyms": ["Computational immunology"],
        "text": "Immunoinformatics"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/topic_0769"
          },
          "definition": "Biological or biomedical analytical workflows or pipelines.",
          "exact_synonyms": ["Pipelines"],
          "narrow_synonyms": ["Tool integration", "Tool interoperability", "Software integration"],
          "text": "Workflows"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3572"
          },
          "definition": "The quality, integrity, and cleaning up of data.",
          "narrow_synonyms": ["Data integrity", "Data clean-up", "Data quality", "Data cleaning"],
          "text": "Data quality management"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3365"
          },
          "definition": "The development of policies, models and standards that cover data acquisition, storage and integration, such that it can be put to use, typically through a process of systematically applying statistical and / or logical techniques to describe, illustrate, summarise or evaluate data.",
          "narrow_synonyms": ["Data architecture", "Data design", "Data analysis"],
          "text": "Data architecture, analysis and design"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3366"
          },
          "definition": "The combination and integration of data from different sources, for example into a central repository or warehouse, to provide users with a unified view of these data.",
          "narrow_synonyms": ["Data warehousing", "Data integration"],
          "text": "Data integration and warehousing"
        }, {
          "comment": ["This includes databases for the results of scientific experiments, the application of high-throughput technology, computational analysis and the scientific literature.  It covers the management and manipulation of digital documents, including database records, files and reports."],
          "data": {
            "uri": "http://edamontology.org/topic_3489"
          },
          "definition": "The general handling of data stored in digital archives such as databanks, databases proper, web portals and other data resources.",
          "exact_synonyms": ["Database administration"],
          "narrow_synonyms": ["Content management", "Document management", "Data maintenance", "File management", "Record management", "Document, record and content management"],
          "text": "Database management"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3571"
          },
          "definition": "The control of data entry and maintenance to ensure the data meets defined standards, qualities or constraints.",
          "narrow_synonyms": ["Data stewardship"],
          "text": "Data governance"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3345"
          },
          "definition": "Topic concerning the identity of biological entities, or reports on such entities, and the mapping of entities and records in different databases.",
          "text": "Data identity and mapping"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_0219"
          },
          "definition": "Deposition and curation of database accessions, including annotation, typically with terms from a controlled vocabulary.",
          "narrow_synonyms": ["Data curation", "Database curation", "Data provenance"],
          "text": "Data submission, annotation and curation"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3077"
          },
          "definition": "The acquisition of data, typically measurements of physical systems using any type of sampling system, or by another other means.",
          "exact_synonyms": ["Data collection"],
          "text": "Data acquisition"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3263"
          },
          "definition": "The protection of data, such as patient health data, from damage or unwanted access from unauthorised users.",
          "exact_synonyms": ["Data privacy"],
          "text": "Data security"
        }],
        "data": {
          "uri": "http://edamontology.org/topic_3071"
        },
        "definition": "The development and use of architectures, policies, practices and procedures for management of data.",
        "exact_synonyms": ["Information systems", "Databases and information systems", "Data management"],
        "text": "Biological databases"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_0607"
        },
        "definition": "Laboratory management and resources, for example, catalogues of biological resources for use in the lab including cell lines, viruses, plasmids, phages, DNA probes and primers and so on.",
        "narrow_synonyms": ["Laboratory resources"],
        "text": "Laboratory information management"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/operation_3931"
          },
          "definition": "Interdisciplinary science focused on extracting information from chemical systems by data analytical approaches, for example multivariate statistics, applied mathematics, and computer science.",
          "text": "Chemometrics"
        }],
        "data": {
          "uri": "http://edamontology.org/topic_2258"
        },
        "definition": "The application of information technology to chemistry in biological research environment.",
        "exact_synonyms": ["Chemoinformatics", "Chemical informatics"],
        "text": "Cheminformatics"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_0089"
        },
        "definition": "The conceptualisation, categorisation and nomenclature (naming) of entities or phenomena within biology or bioinformatics. This includes formal ontologies, controlled vocabularies, structured glossary, symbols and terminology or other related resource.",
        "narrow_synonyms": ["Ontology", "Ontology relations", "Upper ontology", "Ontologies", "Applied ontology", "Terminology"],
        "text": "Ontology and terminology"
      }],
      "data": {
        "uri": "http://edamontology.org/topic_0605"
      },
      "definition": "The study and practice of information processing and use of computer information systems.",
      "exact_synonyms": ["Knowledge management", "Information management", "Information science"],
      "text": "Informatics"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/topic_0218"
        },
        "definition": "The processing and analysis of natural language, such as scientific literature in English, in order to extract data and information, or to enable human-computer interaction.",
        "exact_synonyms": ["NLP"],
        "narrow_synonyms": ["BioNLP", "Text data mining", "Literature mining", "Text analytics", "Text mining"],
        "text": "Natural language processing"
      }],
      "comment": ["This includes the documentation of resources such as tools, services and databases, user support, how to get help etc."],
      "data": {
        "uri": "http://edamontology.org/topic_3068"
      },
      "definition": "The scientific literature, language processing, reference information, and documentation.",
      "exact_synonyms": ["Language", "Literature"],
      "narrow_synonyms": ["Scientific literature", "Citations", "Bibliography", "Documentation", "References"],
      "text": "Literature and language"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/topic_3306"
        },
        "definition": "The use of physics to study biological system.",
        "narrow_synonyms": ["Medical physics"],
        "text": "Biophysics"
      }],
      "data": {
        "uri": "http://edamontology.org/topic_3318"
      },
      "definition": "The study of matter, space and time, and related concepts such as energy and force.",
      "text": "Physics"
    }, {
      "children": [{
        "children": [{
          "data": {
            "uri": "http://edamontology.org/topic_3343"
          },
          "definition": "Collections of chemicals, typically for use in high-throughput screening experiments.",
          "narrow_synonyms": ["Small chemical compounds libraries", "Target identification and validation", "Small compounds libraries", "Chemical screening", "Compound library", "Chemical library"],
          "text": "Compound libraries and screening"
        }, {
          "comment": ["This includes methods that search compound collections, generate or analyse drug 3D conformations, identify drug targets with structural docking etc."],
          "data": {
            "uri": "http://edamontology.org/topic_0209"
          },
          "definition": "The design and chemical synthesis of bioactive molecules, for example drugs or potential drug compounds, for medicinal purposes.",
          "exact_synonyms": ["Drug design"],
          "text": "Medicinal chemistry"
        }],
        "comment": ["This includes methods that search compound collections, generate or analyse drug 3D conformations, identify drug targets with structural docking etc."],
        "data": {
          "uri": "http://edamontology.org/topic_3336"
        },
        "definition": "The discovery and design of drugs or potential drug compounds.",
        "text": "Drug discovery"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3332"
        },
        "definition": "Topic concerning the development and application of theory, analytical methods, mathematical models and computational simulation of chemical systems.",
        "text": "Computational chemistry"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/topic_3369"
          },
          "definition": "The use of synthetic chemistry to study and manipulate biological systems.",
          "text": "Chemical biology"
        }, {
          "comment": ["This includes methods that search compound collections, generate or analyse drug 3D conformations, identify drug targets with structural docking etc."],
          "data": {
            "uri": "http://edamontology.org/topic_0209"
          },
          "definition": "The design and chemical synthesis of bioactive molecules, for example drugs or potential drug compounds, for medicinal purposes.",
          "exact_synonyms": ["Drug design"],
          "text": "Medicinal chemistry"
        }],
        "data": {
          "uri": "http://edamontology.org/topic_3371"
        },
        "definition": "The use of chemistry to create new compounds.",
        "narrow_synonyms": ["Synthetic organic chemistry"],
        "text": "Synthetic chemistry"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3292"
        },
        "definition": "Chemical substances and physico-chemical processes and that occur within living organisms.",
        "exact_synonyms": ["Biological chemistry"],
        "narrow_synonyms": ["Phytochemistry", "Glycomics", "Pathobiochemistry"],
        "text": "Biochemistry"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3370"
        },
        "definition": "The study of the separation, identification, and quantification of the chemical components of natural and artificial materials.",
        "text": "Analytical chemistry"
      }],
      "data": {
        "uri": "http://edamontology.org/topic_3314"
      },
      "definition": "The composition and properties of matter, reactions, and the use of reactions to create new substances.",
      "narrow_synonyms": ["Inorganic chemistry", "Mathematical chemistry", "Physical chemistry", "Nuclear chemistry", "Organic chemistry"],
      "text": "Chemistry"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/topic_3524"
        },
        "definition": "Biological computational model experiments (simulation), for example the minimum information required in order to permit its correct interpretation and reproduction.",
        "text": "Simulation experiment"
      }, {
        "comment": ["This used to have the ID http://edamontology.org/topic_3557 but the numerical part (owing to an error) duplicated http://edamontology.org/operation_3557 ('Imputation').  ID of this concept set to http://edamontology.org/topic_3957 in EDAM 1.24."],
        "data": {
          "uri": "http://edamontology.org/topic_3957"
        },
        "definition": "An experiment for studying protein-protein interactions.",
        "narrow_synonyms": ["Yeast one-hybrid", "Co-immunoprecipitation", "Phage display", "Yeast two-hybrid"],
        "text": "Protein interaction experiment"
      }, {
        "comment": ["This includes two-dimensional gel electrophoresis (2D PAGE) experiments, gels or spots in a gel.  Also mass spectrometry - an analytical chemistry technique that measures the mass-to-charge ratio and abundance of ions in the gas phase.  Also Northern blot experiments."],
        "data": {
          "uri": "http://edamontology.org/topic_3520"
        },
        "definition": "Proteomics experiments.",
        "narrow_synonyms": ["DIA", "MS", "Spectrum demultiplexing", "Mass spectrometry", "Data-independent acquisition", "MS experiments", "Mass spectrometry experiments", "Northern blot experiment", "2D PAGE experiment"],
        "text": "Proteomics experiment"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/topic_0593"
          },
          "definition": "An analytical technique that exploits the magenetic properties of certain atomic nuclei to provide information on the structure, dynamics, reaction state and chemical environment of molecules.",
          "exact_synonyms": ["NMR spectroscopy", "Nuclear magnetic resonance spectroscopy"],
          "narrow_synonyms": ["Nuclear Overhauser Effect Spectroscopy", "ROESY", "Rotational Frame Nuclear Overhauser Effect Spectroscopy", "NOESY", "Heteronuclear Overhauser Effect Spectroscopy", "HOESY"],
          "text": "NMR"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3444"
          },
          "definition": "Techniques that uses magnetic fields and radiowaves to form images, typically to investigate the anatomy and physiology of the human body.",
          "exact_synonyms": ["Magnetic resonance tomography", "NMRI", "Nuclear magnetic resonance imaging", "Magnetic resonance imaging", "MRT"],
          "text": "MRI"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3384"
          },
          "definition": "The use of imaging techniques for clinical purposes for medical research.",
          "narrow_synonyms": ["Neuroimaging", "Radiology", "Nuclear medicine"],
          "text": "Medical imaging"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3385"
          },
          "definition": "The use of optical instruments to magnify the image of an object.",
          "text": "Light microscopy"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3383"
          },
          "definition": "The use of imaging techniques to understand biology.",
          "exact_synonyms": ["Biological imaging"],
          "text": "Bioimaging"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3452"
          },
          "definition": "Imaging in sections (sectioning), through the use of a wave-generating device (tomograph) that generates an image (a tomogram).",
          "exact_synonyms": ["CT", "Computed tomography", "TDM"],
          "narrow_synonyms": ["PET", "X-ray tomography", "Electron tomography", "Positron emission tomography"],
          "text": "Tomography"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3448"
          },
          "definition": "The study of matter by studying the diffraction pattern from firing neutrons at a sample, typically to determine atomic and/or magnetic structure.",
          "exact_synonyms": ["Neutron diffraction experiment"],
          "narrow_synonyms": ["Elastic neutron scattering", "Neutron microscopy"],
          "text": "Neutron diffraction"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_0611"
          },
          "definition": "The study of matter by studying the interference pattern from firing electrons at a sample, to analyse structures at resolutions higher than can be achieved using light.",
          "narrow_synonyms": ["Scanning electron microscopy", "Transmission electron microscopy", "SEM", "Single particle electron microscopy", "TEM", "Electron crystallography"],
          "text": "Electron microscopy"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_2828"
          },
          "definition": "The study of matter and their structure by means of the diffraction of X-rays, typically the diffraction pattern caused by the regularly spaced atoms of a crystalline sample.",
          "exact_synonyms": ["Crystallography"],
          "narrow_synonyms": ["X-ray crystallography", "X-ray microscopy"],
          "text": "X-ray diffraction"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3954"
          },
          "definition": "A diagnostic imaging technique based on the application of ultrasound.",
          "exact_synonyms": ["Standardized echography", "Ultrasound imaging"],
          "narrow_synonyms": ["Ultrasonography", "Medical ultrasound", "Standard echography", "Diagnostic sonography"],
          "text": "Echography"
        }],
        "comment": ["This includes diffraction experiments that are based upon the interference of waves, typically electromagnetic waves such as  X-rays or visible light, by some object being studied, typical in order to produce an image of the object or determine its structure."],
        "data": {
          "uri": "http://edamontology.org/topic_3382"
        },
        "definition": "The visual representation of an object.",
        "narrow_synonyms": ["Microscopy imaging", "Photonic microscopy", "Photonic force microscopy", "Diffraction experiment", "Microscopy", "Optical super resolution microscopy"],
        "text": "Imaging"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3519"
        },
        "definition": "PCR experiments, e.g. quantitative real-time PCR.",
        "exact_synonyms": ["Polymerase chain reaction"],
        "narrow_synonyms": ["Real Time Quantitative PCR", "RT-qPCR", "Quantitative PCR"],
        "text": "PCR experiment"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/topic_3837"
          },
          "definition": "Approach which samples, in parallel, all genes in all organisms present in a given sample, e.g. to provide insight into biodiversity and function.",
          "exact_synonyms": ["Shotgun metagenomic sequencing"],
          "text": "Metagenomic sequencing"
        }, {
          "comment": ["Exome sequencing is considered a cheap alternative to whole genome sequencing."],
          "data": {
            "uri": "http://edamontology.org/topic_3676"
          },
          "definition": "Laboratory technique to sequence all the protein-coding regions in a genome, i.e., the exome.",
          "exact_synonyms": ["Targeted exome capture", "Exome analysis", "WES", "Exome capture", "Whole exome sequencing", "Exome"],
          "text": "Exome sequencing"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3169"
          },
          "definition": "The analysis of protein-DNA interactions where chromatin immunoprecipitation (ChIP) is used in combination with massively parallel DNA sequencing to identify the binding sites of DNA-associated proteins.",
          "exact_synonyms": ["Chip Seq", "Chip sequencing", "Chip-sequencing", "ChIP-sequencing"],
          "narrow_synonyms": ["ChIP-exo"],
          "text": "ChIP-seq"
        }, {
          "comment": ["This includes small RNA profiling (small RNA-Seq), for example to find novel small RNAs, characterize mutations and analyze expression of small RNAs."],
          "data": {
            "uri": "http://edamontology.org/topic_3170"
          },
          "definition": "A topic concerning high-throughput sequencing of cDNA to measure the RNA content (transcriptome) of a sample, for example, to investigate how different alleles of a gene are expressed, detect post-transcriptional mutations or identify gene fusions.",
          "exact_synonyms": ["Transcriptome profiling", "Whole transcriptome shotgun sequencing", "WTSS", "Small-Seq", "RNA-Seq analysis", "Small RNA sequencing", "RNA sequencing", "Small RNA-Seq"],
          "narrow_synonyms": ["miRNA-seq", "MicroRNA sequencing"],
          "text": "RNA-Seq"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3673"
          },
          "definition": "Laboratory technique to sequence the complete DNA sequence of an organism's genome at a single time.",
          "exact_synonyms": ["WGS", "Genome sequencing"],
          "narrow_synonyms": ["Whole genome resequencing", "De novo genome sequencing"],
          "text": "Whole genome sequencing"
        }, {
          "comment": ["Amplicon sequencing is the ultra-deep sequencing of PCR products (amplicons), usually for the purpose of efficient genetic variant identification and characterisation in specific genomic regions.", "Ultra-deep sequencing"],
          "data": {
            "uri": "http://edamontology.org/operation_3923"
          },
          "definition": "Laboratory experiment to identify the differences between a specific genome (of an individual) and a reference genome (developed typically from many thousands of individuals).\n\nWGS re-sequencing is used as golden standard to detect variations compared to a given reference genome, including small variants (SNP and InDels) as well as larger genome re-organisations (CNVs, translocations, etc.).\n\nows re-sequencing of complete genomes of any given organism with high resolution and high accuracy.",
          "exact_synonyms": ["Resequencing"],
          "narrow_synonyms": ["Amplicon panels", "WGR", "Highly targeted resequencing", "Amplicon sequencing", "WGRS", "Whole genome resequencing", "Amplicon-based sequencing"],
          "text": "Genome resequencing"
        }],
        "data": {
          "uri": "http://edamontology.org/topic_3168"
        },
        "definition": "The determination of complete (typically nucleotide) sequences, including those of genomes (full genome sequencing, de novo sequencing and resequencing), amplicons and transcriptomes.",
        "exact_synonyms": ["DNA-Seq"],
        "narrow_synonyms": ["High throughput sequencing", "High-throughput sequencing", "Sanger sequencing", "DNase-Seq", "Primer walking", "Panels", "Chromosome walking", "NGS", "NGS data analysis", "Next gen sequencing", "Targeted next-generation sequencing panels", "Next generation sequencing", "Clone verification"],
        "text": "Sequencing"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/topic_3179"
          },
          "definition": "Experimental techniques that combine chromatin immunoprecipitation ('ChIP') with microarray ('chip'). ChIP-on-chip is used for high-throughput study protein-DNA interactions.",
          "exact_synonyms": ["ChIP-chip"],
          "narrow_synonyms": ["ChiP"],
          "text": "ChIP-on-chip"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3674"
          },
          "definition": "Laboratory technique to sequence the methylated regions in DNA.",
          "exact_synonyms": ["MeDIP-seq", "MeDIP-chip", "mDIP"],
          "narrow_synonyms": ["Methylated DNA immunoprecipitation (MeDIP)", "BS-Seq", "MeDIP", "methyl-seq", "Whole-genome bisulfite sequencing", "methy-seq", "Bisulfite sequencing", "WGBS", "Methylation sequencing"],
          "text": "Methylated DNA immunoprecipitation"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3169"
          },
          "definition": "The analysis of protein-DNA interactions where chromatin immunoprecipitation (ChIP) is used in combination with massively parallel DNA sequencing to identify the binding sites of DNA-associated proteins.",
          "exact_synonyms": ["Chip Seq", "Chip sequencing", "Chip-sequencing", "ChIP-sequencing"],
          "narrow_synonyms": ["ChIP-exo"],
          "text": "ChIP-seq"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3794"
          },
          "definition": "An antibody-based technique used to map in vivo RNA-protein interactions.",
          "exact_synonyms": ["RIP"],
          "narrow_synonyms": ["CLIP", "iCLIP", "PAR-CLIP", "HITS-CLIP", "CLIP-seq"],
          "text": "RNA immunoprecipitation"
        }],
        "data": {
          "uri": "http://edamontology.org/topic_3656"
        },
        "definition": "Experimental techniques to purify a protein-DNA crosslinked complex.  Usually sequencing follows e.g. in the techniques ChIP-chip, ChIP-seq and MeDIP-seq.",
        "exact_synonyms": ["Chromatin immunoprecipitation"],
        "text": "Immunoprecipitation experiment"
      }, {
        "comment": ["This might specify which raw data file relates to which sample and information on hybridisations, e.g. which are technical and which are biological replicates."],
        "data": {
          "uri": "http://edamontology.org/topic_3518"
        },
        "definition": "Microarray experiments including conditions, protocol, sample:data relationships etc.",
        "exact_synonyms": ["Microarrays"],
        "narrow_synonyms": ["Genotyping array", "miRNA array", "Tiling arrays", "mRNA microarray", "aCGH microarray", "Tissue microarray", "Multichannel microarray", "RNA microarrays", "MicroRNA array", "Proprietary platform micoarray", "Two channel microarray", "Methylation array", "One channel microarray", "SNP array", "Gene expression microarray", "Reverse phase protein array", "RNA chips"],
        "text": "Microarray experiment"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3523"
        },
        "definition": "RNAi experiments.",
        "text": "RNAi experiment"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3516"
        },
        "definition": "Genotype experiment including case control, population, and family studies. These might use array based methods and re-sequencing methods.",
        "text": "Genotyping experiment"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3934"
        },
        "definition": "Cytometry is the measurement of the characteristics of cells.",
        "narrow_synonyms": ["Mass cytometry", "Flow cytometry", "Image cytometry"],
        "text": "Cytometry"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3940"
        },
        "definition": "Molecular biology methods used to analyze the spatial organization of chromatin in a cell.",
        "exact_synonyms": ["3C technologies", "Chromosome conformation analysis", "3C-based methods"],
        "narrow_synonyms": ["Chromatin accessibility assay", "Chromatin accessibility"],
        "text": "Chromosome conformation capture"
      }],
      "data": {
        "uri": "http://edamontology.org/topic_3361"
      },
      "definition": "The procedures used to conduct an experiment.",
      "exact_synonyms": ["Lab method", "Lab techniques", "Experimental techniques", "Laboratory method"],
      "narrow_synonyms": ["Experiments", "Laboratory experiments"],
      "text": "Laboratory techniques"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/topic_3419"
        },
        "definition": "The branch of medicine that deals with the mangement of mental illness, emotional disturbance and abnormal behaviour.",
        "exact_synonyms": [{
          "@id": "https://en.wikipedia.org/wiki/Psychiatry"
        }],
        "narrow_synonyms": ["Psychiatric disorders"],
        "text": "Psychiatry"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3408"
        },
        "definition": "The branch of medicine that deals with the blood, blood-forming organs and blood diseases.",
        "exact_synonyms": [{
          "@id": "https://en.wikipedia.org/wiki/Hematology"
        }],
        "narrow_synonyms": ["Haematological disorders", "Blood disorders"],
        "text": "Haematology"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3399"
        },
        "definition": "The branch of medicine dealing with the diagnosis, treatment and prevention of disease in older people, and the problems specific to aging.",
        "exact_synonyms": [{
          "@id": "https://en.wikipedia.org/wiki/Geriatrics"
        }, "Geriatrics"],
        "text": "Geriatric medicine"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3412"
        },
        "definition": "The branch of medicine that deals with the liver, gallbladder, bile ducts and bile.",
        "exact_synonyms": ["Hepatobiliary medicine"],
        "narrow_synonyms": ["Liver disorders"],
        "text": "Hepatic and biliary medicine"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3422"
        },
        "definition": "The branches of medicine and physiology focussing on the function and disorders of the urinary system in males and females, the reproductive system in males, and the kidney.",
        "narrow_synonyms": ["Urology", "Kidney disease", "Nephrology", "Urological disorders"],
        "text": "Urology and nephrology"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3418"
        },
        "definition": "The branch of medicine that deals with the medical care of infants, children and adolescents.",
        "exact_synonyms": [{
          "@id": "https://en.wikipedia.org/wiki/Pediatrics"
        }, "Child health"],
        "text": "Paediatrics"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/topic_3388"
          },
          "definition": "The identification of molecular and genetic causes of disease and the development of interventions to correct them.",
          "text": "Molecular medicine"
        }],
        "data": {
          "uri": "http://edamontology.org/topic_3342"
        },
        "definition": "'translating' the output of basic and biomedical research into better diagnostic tools, medicines, medical procedures, policies and advice.",
        "exact_synonyms": [{
          "@id": "https://en.wikipedia.org/wiki/Translational_medicine"
        }],
        "text": "Translational medicine"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_2640"
        },
        "definition": "The study of cancer, for example, genes and proteins implicated in cancer.",
        "exact_synonyms": ["Cancer biology", {
          "@id": "https://en.wikipedia.org/wiki/Oncology"
        }],
        "narrow_synonyms": ["Neoplasms", "Neoplasm", "Cancer"],
        "text": "Oncology"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3405"
        },
        "definition": "The study, diagnosis, prevention and treatments of disorders of the oral cavity, maxillofacial area and adjacent structures.",
        "exact_synonyms": [{
          "@id": "https://en.wikipedia.org/wiki/Dentistry"
        }],
        "text": "Dentistry"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3403"
        },
        "definition": "The multidisciplinary that cares for patients with acute, life-threatening illness or injury.",
        "exact_synonyms": ["Emergency medicine", "Intensive care medicine", "Acute medicine"],
        "text": "Critical care medicine"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3404"
        },
        "definition": "The branch of medicine that deals with prevention, diagnosis and treatment of disorders of the skin, scalp, hair and nails.",
        "exact_synonyms": [{
          "@id": "https://en.wikipedia.org/wiki/Dermatology"
        }],
        "narrow_synonyms": ["Dermatological disorders"],
        "text": "Dermatology"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3423"
        },
        "definition": "Medical therapies that fall beyond the scope of conventional medicine but may be used alongside it in the treatment of disease and ill health.",
        "text": "Complementary medicine"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3397"
        },
        "definition": "Topic concerning the branch of medicine that deals with the prevention, diagnosis, and treatment of disease, disorder and injury in animals.",
        "narrow_synonyms": ["Clinical veterinary medicine"],
        "text": "Veterinary medicine"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3396"
        },
        "definition": "An interdisciplinary field of study that looks at the dynamic systems of the human body as part of an integrted whole, incoporating biochemical, physiological, and environmental interactions that sustain life.",
        "exact_synonyms": [{
          "@id": "https://en.wikipedia.org/wiki/Systems_medicine"
        }],
        "text": "Systems medicine"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3300"
        },
        "definition": "The functions of living organisms and their constituent parts.",
        "exact_synonyms": [{
          "@id": "https://en.wikipedia.org/wiki/Physiology"
        }],
        "narrow_synonyms": ["Electrophysiology"],
        "text": "Physiology"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3407"
        },
        "definition": "The branch of medicine dealing with diseases of endocrine organs, hormone systems, their target organs, and disorders of the pathways of glucose and lipid metabolism.",
        "exact_synonyms": [{
          "@id": "https://en.wikipedia.org/wiki/Endocrinology"
        }],
        "narrow_synonyms": ["Metabolism", "Metabolic disorders", "Endocrine disorders", "Endocrinology"],
        "text": "Endocrinology and metabolism"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_2840"
        },
        "definition": "Toxins and the adverse effects of these chemical substances on living organisms.",
        "narrow_synonyms": ["Computational toxicology", "Toxicoinformatics"],
        "text": "Toxicology"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3305"
        },
        "definition": "Topic concerning the the patterns, cause, and effect of disease within populations.",
        "exact_synonyms": [{
          "@id": "https://en.wikipedia.org/wiki/Public_health"
        }, {
          "@id": "https://en.wikipedia.org/wiki/Epidemiology"
        }],
        "narrow_synonyms": ["Public health", "Epidemiology"],
        "text": "Public health and epidemiology"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3577"
        },
        "definition": "An approach to medicine whereby decisions, practices and are tailored to the individual patient based on their predicted response or risk of disease.",
        "exact_synonyms": [{
          "@id": "https://en.wikipedia.org/wiki/Personalized_medicine"
        }, "Precision medicine"],
        "narrow_synonyms": ["Molecular diagnostics"],
        "text": "Personalised medicine"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3575"
        },
        "definition": "Health problems that are prevalent in tropical and subtropical regions.",
        "text": "Tropical medicine"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3420"
        },
        "definition": "The health of the reproductive processes, functions and systems at all stages of life.",
        "exact_synonyms": [{
          "@id": "https://en.wikipedia.org/wiki/Reproductive_health"
        }],
        "narrow_synonyms": ["Andrology", "Fertility medicine", "Reproductive disorders", "Family planning"],
        "text": "Reproductive health"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3410"
        },
        "definition": "The study of the biological and physiological differences between males and females and how they effect differences in disease presentation and management.",
        "exact_synonyms": [{
          "@id": "https://en.wikipedia.org/wiki/Sex_differences_in_medicine"
        }],
        "text": "Gender medicine"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3401"
        },
        "definition": "The prevention of pain and the evaluation, treatment and rehabilitation of persons in pain.",
        "exact_synonyms": ["Algiatry", {
          "@id": "https://en.wikipedia.org/wiki/Pain_management"
        }],
        "text": "Pain medicine"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3334"
        },
        "definition": "The branch of medicine that deals with the anatomy, functions and disorders of the nervous system.",
        "exact_synonyms": [{
          "@id": "https://en.wikipedia.org/wiki/Neurology"
        }],
        "narrow_synonyms": ["Neurological disorders"],
        "text": "Neurology"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/topic_3325"
          },
          "definition": "The study of rare diseases.",
          "exact_synonyms": [{
            "@id": "https://en.wikipedia.org/wiki/Rare_disease"
          }],
          "text": "Rare diseases"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3324"
          },
          "definition": "The branch of medicine that deals with the prevention, diagnosis and management of transmissable disease with clinically evident illness resulting from infection with pathogenic biological agents (viruses, bacteria, fungi, protozoa, parasites and prions).",
          "exact_synonyms": ["Transmissable disease", "Communicable disease"],
          "text": "Infectious disease"
        }],
        "data": {
          "uri": "http://edamontology.org/topic_0634"
        },
        "definition": "Diseases, including diseases in general and the genes, gene variations and proteins involved in one or more specific diseases.",
        "exact_synonyms": ["Disease", {
          "@id": "https://en.wikipedia.org/wiki/Pathology"
        }],
        "text": "Pathology"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3411"
        },
        "definition": "The branch of medicine that deals with the health of the female reproductive system, pregnancy and birth.",
        "exact_synonyms": [{
          "@id": "https://en.wikipedia.org/wiki/Gynaecology"
        }, {
          "@id": "https://en.wikipedia.org/wiki/Obstetrics"
        }],
        "narrow_synonyms": ["Obstetrics", "Gynaecology", "Gynaecological disorders"],
        "text": "Gynaecology and obstetrics"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3414"
        },
        "definition": "The branch of medicine that treats body wounds or shock produced by sudden physical injury, as from violence or accident.",
        "exact_synonyms": [{
          "@id": "https://en.wikipedia.org/wiki/Traumatology"
        }, "Traumatology"],
        "text": "Trauma medicine"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3415"
        },
        "definition": "The branch of medicine that deals with the diagnosis, management and prevention of poisoning and other adverse health effects caused by medications, occupational and environmental toxins, and biological agents.",
        "exact_synonyms": [{
          "@id": "https://en.wikipedia.org/wiki/Medical_toxicology"
        }],
        "text": "Medical toxicology"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3402"
        },
        "definition": "Anaesthesia and anaesthetics.",
        "exact_synonyms": ["Anaesthetics"],
        "text": "Anaesthesiology"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3322"
        },
        "definition": "The study of respiratory system.",
        "exact_synonyms": ["Pulmonology", "Pulmonary medicine", {
          "@id": "https://en.wikipedia.org/wiki/Pulmonology"
        }],
        "narrow_synonyms": ["Respiratory disease", "Pulmonary disorders"],
        "text": "Respiratory medicine"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3335"
        },
        "definition": "The diseases and abnormalities of the heart and circulatory system.",
        "exact_synonyms": ["Cardiovascular medicine"],
        "narrow_synonyms": ["Cardiovascular disease", "Heart disease"],
        "text": "Cardiology"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3416"
        },
        "definition": "The branch of medicine that deals with the prevention, diagnosis, and treatment of disorders of the muscle, bone and connective tissue.  It incorporates aspects of orthopaedics, rheumatology, rehabilitation medicine and pain medicine.",
        "narrow_synonyms": ["Musculoskeletal disorders", "Rheumatology", "Orthopaedics"],
        "text": "Musculoskeletal medicine"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3409"
        },
        "definition": "The branch of medicine that deals with disorders of the oesophagus, stomach, duodenum, jejenum, ileum, large intestine, sigmoid colon and rectum.",
        "exact_synonyms": [{
          "@id": "https://en.wikipedia.org/wiki/Gastroenterology"
        }],
        "narrow_synonyms": ["Gastrointestinal disorders"],
        "text": "Gastroenterology"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3400"
        },
        "definition": "Health issues related to the immune system and their prevention, diagnosis and mangement.",
        "narrow_synonyms": ["Immunomodulators", "Immune disorders", "Immunotherapeutics", "Clinical immunology", "Allergy"],
        "text": "Allergy, clinical immunology and immunotherapeutics"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3406"
        },
        "definition": "The branch of medicine that deals with the prevention, diagnosis, and treatment of disorders of the ear, nose and throat.",
        "exact_synonyms": ["Otolaryngology", "Otorhinolaryngology", {
          "@id": "https://en.wikipedia.org/wiki/Otorhinolaryngology"
        }, "Audiovestibular medicine"],
        "narrow_synonyms": ["Head and neck disorders"],
        "text": "Ear, nose and throat medicine"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3417"
        },
        "definition": "The branch of medicine that deals with disorders of the eye, including eyelid, optic nerve/visual pathways and occular muscles.",
        "exact_synonyms": [{
          "@id": "https://en.wikipedia.org/wiki/Ophthalmology"
        }],
        "narrow_synonyms": ["Eye disoders"],
        "text": "Opthalmology"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3421"
        },
        "definition": "The use of operative, manual and instrumental techniques on a patient to investigate and/or treat a pathological condition or help improve bodily function or appearance.",
        "exact_synonyms": [{
          "@id": "https://en.wikipedia.org/wiki/Surgery"
        }],
        "narrow_synonyms": ["Transplantation"],
        "text": "Surgery"
      }],
      "data": {
        "uri": "http://edamontology.org/topic_3303"
      },
      "definition": "Research in support of healing by diagnosis, treatment, and prevention of disease.",
      "exact_synonyms": ["Biomedical research", "Clinical medicine", "Experimental medicine"],
      "narrow_synonyms": ["General medicine", "Internal medicine"],
      "text": "Medicine"
    }, {
      "children": [{
        "children": [{
          "data": {
            "uri": "http://edamontology.org/topic_0194"
          },
          "definition": "The integrated study of evolutionary relationships and whole genome data, for example, in the analysis of species trees, horizontal gene transfer and evolutionary reconstruction.",
          "text": "Phylogenomics"
        }, {
          "comment": ["Epigenetics concerns the heritable changes in gene expression owing to mechanisms other than DNA sequence variation."],
          "data": {
            "uri": "http://edamontology.org/topic_3173"
          },
          "definition": "The study of the epigenetic modifications of a whole cell, tissue, organism etc.",
          "text": "Epigenomics"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_0797"
          },
          "definition": "The study (typically comparison) of the sequence, structure or function of multiple genomes.",
          "text": "Comparative genomics"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3922"
          },
          "definition": "A field of biological research focused on the discovery and identification of peptides, typically by comparing mass spectra against a protein database.",
          "text": "Proteogenomics"
        }, {
          "comment": ["The study of the phenomena whereby the effects of one locus mask the allelic effects of another, such as how dominant alleles mask the effects of the recessive alleles at the same locus."],
          "data": {
            "uri": "http://edamontology.org/topic_3974"
          },
          "definition": "The study of the epigenetic modifications of a whole cell, tissue, organism etc.",
          "exact_synonyms": ["Epistatic interactions", "Epistatic genetic interaction"],
          "text": "Epistasis"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3174"
          },
          "definition": "The study of genetic material recovered from environmental samples, and associated environmental data.",
          "narrow_synonyms": ["Biome sequencing", "Shotgun metagenomics"],
          "text": "Metagenomics"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_0085"
          },
          "definition": "The study of gene or protein functions and their interactions in totality in a given organism, tissue, cell etc.",
          "text": "Functional genomics"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_0208"
          },
          "definition": "The influence of genotype on drug response, for example by correlating gene expression or single-nucleotide polymorphisms with drug efficacy or toxicity.",
          "narrow_synonyms": ["Pharmacogenetics"],
          "text": "Pharmacogenomics"
        }, {
          "children": [{
            "comment": ["Metatranscriptomics methods can be used for whole gene expression profiling of complex microbial communities."],
            "data": {
              "uri": "http://edamontology.org/topic_3941"
            },
            "definition": "The study of microbe gene expression within natural environments (i.e. the metatranscriptome).",
            "text": "Metatranscriptomics"
          }],
          "data": {
            "uri": "http://edamontology.org/topic_3308"
          },
          "definition": "The analysis of transcriptomes, or a set of all the RNA molecules in a specific cell, tissue etc.",
          "narrow_synonyms": ["Transcriptome", "Comparative transcriptomics", "Metatranscriptomics"],
          "text": "Transcriptomics"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3943"
          },
          "definition": "The reconstruction and analysis of genomic information in extinct species.",
          "narrow_synonyms": ["Ancestral genomes", "Paleogenetics"],
          "text": "Paleogenomics"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3796"
          },
          "definition": "Large-scale study (typically comparison) of DNA sequences of populations.",
          "text": "Population genomics"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_0122"
          },
          "definition": "The elucidation of the three dimensional structure for all (available) proteins in a given organism.",
          "text": "Structural genomics"
        }],
        "data": {
          "uri": "http://edamontology.org/topic_0622"
        },
        "definition": "Whole genomes of one or more organisms, or genomes in general, such as meta-information on genomes, genome projects, gene names etc.",
        "narrow_synonyms": ["Genome annotation", "Genomes", "Exomes", "Personal genomics", "Viral genomics", "Whole genomes", "Synthetic genomics"],
        "text": "Genomics"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3172"
        },
        "definition": "The systematic study of metabolites, the chemical processes they are involved, and the chemical fingerprints of specific cellular processes in a whole cell, tissue, organ or organism.",
        "narrow_synonyms": ["Metabolites", "MS-based untargeted metabolomics", "Metabonomics", "MS-based metabolomics", "MS-based targeted metabolomics", "Metabolome", "NMR-based metabolomics", "Mass spectrometry-based metabolomics", "LC-MS-based metabolomics", "Exometabolomics"],
        "text": "Metabolomics"
      }, {
        "comment": ["The \"fluxome\" is the complete set of metabolic fluxes in a cell, and is a dynamic aspect of phenotype."],
        "data": {
          "uri": "http://edamontology.org/topic_3955"
        },
        "definition": "Experimental approaches to determine the rates of metabolic reactions - the metabolic fluxes - within a biological entity.",
        "text": "Fluxomics"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3967"
        },
        "definition": "The study of immune system as a whole, its regulation and response to pathogens using genome-wide approaches.",
        "text": "Immunomics"
      }, {
        "comment": ["Includes metaproteomics: proteomics analysis of an environmental sample.", "Proteomics includes any methods (especially high-throughput) that separate, characterize and identify expressed proteins such as mass spectrometry, two-dimensional gel electrophoresis and protein microarrays, as well as in-silico methods that perform proteolytic or mass calculations on a protein sequence and other analyses of protein production data, for example in different cells or tissues."],
        "data": {
          "uri": "http://edamontology.org/topic_0121"
        },
        "definition": "Protein and peptide identification, especially in the study of whole proteomes of organisms.",
        "narrow_synonyms": ["Discovery proteomics", "Bottom-up proteomics", "MS-based untargeted proteomics", "Targeted proteomics", "Metaproteomics", "MS-based targeted proteomics", "Peptide identification", "Top-down proteomics", "Protein and peptide identification", "Quantitative proteomics"],
        "text": "Proteomics"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3945"
        },
        "definition": "The study of the process and mechanism of change of biomolecules such as DNA, RNA, and proteins across generations.",
        "text": "Molecular evolution"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3298"
        },
        "definition": "Phenomes, or the study of the change in phenotype (the physical and biochemical traits of organisms) in response to genetic and environmental factors.",
        "text": "Phenomics"
      }],
      "data": {
        "uri": "http://edamontology.org/topic_3391"
      },
      "definition": "The collective characterisation and quantification of pools of biological molecules that translate into the structure, function, and dynamics of an organism or organisms.",
      "text": "Omics"
    }, {
      "children": [{
        "children": [{
          "data": {
            "uri": "http://edamontology.org/topic_3050"
          },
          "definition": "The degree of variation of life forms within a given ecosystem, biome or an entire planet.",
          "text": "Biodiversity"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3697"
          },
          "definition": "The ecology of microorganisms including their relationship with one another and their environment.",
          "exact_synonyms": ["Environmental microbiology"],
          "narrow_synonyms": ["Community analysis", "Microbiome", "Molecular community analysis"],
          "text": "Microbial ecology"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3174"
          },
          "definition": "The study of genetic material recovered from environmental samples, and associated environmental data.",
          "narrow_synonyms": ["Biome sequencing", "Shotgun metagenomics"],
          "text": "Metagenomics"
        }],
        "data": {
          "uri": "http://edamontology.org/topic_0610"
        },
        "definition": "The ecological and environmental sciences and especially the application of information technology (ecoinformatics).",
        "narrow_synonyms": ["Ecoinformatics", "Ecological informatics", "Computational ecology", "Ecosystem science"],
        "text": "Ecology"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3047"
        },
        "definition": "The molecular basis of biological activity, particularly the macromolecules (e.g. proteins and nucleic acids) that are essential to life.",
        "narrow_synonyms": ["Biological processes"],
        "text": "Molecular biology"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3306"
        },
        "definition": "The use of physics to study biological system.",
        "narrow_synonyms": ["Medical physics"],
        "text": "Biophysics"
      }, {
        "comment": ["This includes databases of models and methods to construct or analyse a model."],
        "data": {
          "uri": "http://edamontology.org/topic_2259"
        },
        "definition": "The holistic modelling and analysis of complex biological systems and the interactions therein.",
        "narrow_synonyms": ["Systems modelling", "Biological modelling", "Biological system modelling"],
        "text": "Systems biology"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_0781"
        },
        "definition": "Study of viruses, e.g. sequence and structural data, interactions of viral proteins, or a viral genome including molecular sequences, genes and annotation.",
        "text": "Virology"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/topic_0637"
          },
          "definition": "Organism classification, identification and naming.",
          "text": "Taxonomy"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/topic_3293"
            },
            "definition": "The study of evolutionary relationships amongst organisms from analysis of genetic information (typically gene or protein sequences).",
            "text": "Phylogenetics"
          }, {
            "data": {
              "uri": "http://edamontology.org/topic_3944"
            },
            "definition": "The biological classification of organisms by categorizing them in groups (\"clades\") based on their most recent common ancestor.",
            "narrow_synonyms": ["Tree of life"],
            "text": "Cladistics"
          }],
          "comment": ["This includes diverse phylogenetic methods, including phylogenetic tree construction, typically from molecular sequence or morphological data, methods that simulate DNA sequence evolution, a phylogenetic tree or the underlying data, or which estimate or use molecular clock and stratigraphic (age) data, methods for studying gene evolution etc."],
          "data": {
            "uri": "http://edamontology.org/topic_0084"
          },
          "definition": "The study of evolutionary relationships amongst organisms.",
          "narrow_synonyms": ["Phylogenetic dating", "Phylogenetic clocks", "Phylogenetic stratigraphy", "Phylogeny reconstruction", "Phylogenetic simulation"],
          "text": "Phylogeny"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3945"
          },
          "definition": "The study of the process and mechanism of change of biomolecules such as DNA, RNA, and proteins across generations.",
          "text": "Molecular evolution"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3298"
          },
          "definition": "Phenomes, or the study of the change in phenotype (the physical and biochemical traits of organisms) in response to genetic and environmental factors.",
          "text": "Phenomics"
        }],
        "data": {
          "uri": "http://edamontology.org/topic_3299"
        },
        "definition": "The evolutionary processes, from the genetic to environmental scale, that produced life in all its diversity.",
        "exact_synonyms": ["Evolution"],
        "text": "Evolutionary biology"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/topic_3697"
          },
          "definition": "The ecology of microorganisms including their relationship with one another and their environment.",
          "exact_synonyms": ["Environmental microbiology"],
          "narrow_synonyms": ["Community analysis", "Microbiome", "Molecular community analysis"],
          "text": "Microbial ecology"
        }],
        "data": {
          "uri": "http://edamontology.org/topic_3301"
        },
        "definition": "The biology of microorganisms.",
        "narrow_synonyms": ["Molecular infection biology", "Microbial genetics", "Molecular microbiology", "Antimicrobial stewardship", "Microbiological surveillance", "Microbial physiology", "Medical microbiology", "Microbial surveillance"],
        "text": "Microbiology"
      }, {
        "comment": ["This may include information on the genome (including molecular sequences and map, genes and annotation), proteome, as well as more general information about an organism."],
        "data": {
          "uri": "http://edamontology.org/topic_0621"
        },
        "definition": "A specific organism, or group of organisms, used to study a particular aspect of biology.",
        "exact_synonyms": ["Organisms"],
        "text": "Model organisms"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3573"
        },
        "definition": "The study of organisms in freshwater ecosystems.",
        "text": "Freshwater biology"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/topic_0593"
          },
          "definition": "An analytical technique that exploits the magenetic properties of certain atomic nuclei to provide information on the structure, dynamics, reaction state and chemical environment of molecules.",
          "exact_synonyms": ["NMR spectroscopy", "Nuclear magnetic resonance spectroscopy"],
          "narrow_synonyms": ["Nuclear Overhauser Effect Spectroscopy", "ROESY", "Rotational Frame Nuclear Overhauser Effect Spectroscopy", "NOESY", "Heteronuclear Overhauser Effect Spectroscopy", "HOESY"],
          "text": "NMR"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3448"
          },
          "definition": "The study of matter by studying the diffraction pattern from firing neutrons at a sample, typically to determine atomic and/or magnetic structure.",
          "exact_synonyms": ["Neutron diffraction experiment"],
          "narrow_synonyms": ["Elastic neutron scattering", "Neutron microscopy"],
          "text": "Neutron diffraction"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_0611"
          },
          "definition": "The study of matter by studying the interference pattern from firing electrons at a sample, to analyse structures at resolutions higher than can be achieved using light.",
          "narrow_synonyms": ["Scanning electron microscopy", "Transmission electron microscopy", "SEM", "Single particle electron microscopy", "TEM", "Electron crystallography"],
          "text": "Electron microscopy"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_2828"
          },
          "definition": "The study of matter and their structure by means of the diffraction of X-rays, typically the diffraction pattern caused by the regularly spaced atoms of a crystalline sample.",
          "exact_synonyms": ["Crystallography"],
          "narrow_synonyms": ["X-ray crystallography", "X-ray microscopy"],
          "text": "X-ray diffraction"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_0122"
          },
          "definition": "The elucidation of the three dimensional structure for all (available) proteins in a given organism.",
          "text": "Structural genomics"
        }],
        "comment": ["This includes experimental methods for biomolecular structure determination, such as X-ray crystallography, nuclear magnetic resonance (NMR), circular dichroism (CD) spectroscopy, microscopy etc., including the assignment or modelling of molecular structure from such data."],
        "data": {
          "uri": "http://edamontology.org/topic_1317"
        },
        "definition": "The molecular structure of biological molecules, particularly macromolecules such as proteins and nucleic acids.",
        "narrow_synonyms": ["Structure determination", "Structural assignment", "Structural determination"],
        "text": "Structural biology"
      }, {
        "comment": ["The study of the animal kingdom."],
        "data": {
          "uri": "http://edamontology.org/topic_3500"
        },
        "definition": "Animals, e.g. information on a specific animal genome including molecular sequences, genes and annotation.",
        "exact_synonyms": ["Animal biology", "Animal", "Animals", "Metazoa"],
        "narrow_synonyms": ["Entomology", "Animal genetics", "Animal physiology"],
        "text": "Zoology"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3810"
        },
        "definition": "Multidisciplinary study, research and development within the field of agriculture.",
        "narrow_synonyms": ["Animal nutrition", "Horticulture", "Food security", "Agricultural economics", "Phytomedicine", "Animal breeding", "Plant nutrition", "Plant breeding", "Plant cultivation", "Animal husbandry", "Food process engineering", "Farming systems research", "", "Soil science", "Plant pathology", "Agricultural biotechnology"],
        "text": "Agricultural science"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3387"
        },
        "definition": "The study of organisms in the ocean or brackish waters.",
        "text": "Marine biology"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3369"
        },
        "definition": "The use of synthetic chemistry to study and manipulate biological systems.",
        "text": "Chemical biology"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3895"
        },
        "definition": "The application of multi-disciplinary science and technology for the construction of artificial biological systems for diverse applications.",
        "narrow_synonyms": ["Biomimeic chemistry"],
        "text": "Synthetic biology"
      }, {
        "comment": ["The resource may be specific to a plant, a group of plants or all plants."],
        "data": {
          "uri": "http://edamontology.org/topic_0780"
        },
        "definition": "Plants, e.g. information on a specific plant genome including molecular sequences, genes and annotation.",
        "exact_synonyms": ["Plant science", "Botany", "Plant", "Plants"],
        "narrow_synonyms": ["Plant cell biology", "Plant anatomy", "Plant genetics", "Plant physiology", "Plant ecology"],
        "text": "Plant biology"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3855"
        },
        "definition": "Study of the environment, the interactions between its physical, chemical, and biological components and it's effect on life.  Also how humans impact upon the environment, and how we can manage and utilise natural resources.",
        "exact_synonyms": ["Environment"],
        "text": "Environmental science"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3292"
        },
        "definition": "Chemical substances and physico-chemical processes and that occur within living organisms.",
        "exact_synonyms": ["Biological chemistry"],
        "narrow_synonyms": ["Phytochemistry", "Glycomics", "Pathobiochemistry"],
        "text": "Biochemistry"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_2815"
        },
        "definition": "The study of human beings in general, including the human genome and proteome.",
        "exact_synonyms": ["Humans"],
        "text": "Human biology"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3360"
        },
        "definition": "Objective indicators of biological state often used to assess health, and determinate treatment.",
        "exact_synonyms": ["Diagnostic markers"],
        "text": "Biomarkers"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/topic_3065"
          },
          "definition": "The development of organisms between the one-cell stage (typically the zygote) and the end of the embryonic stage.",
          "text": "Embryology"
        }],
        "data": {
          "uri": "http://edamontology.org/topic_3064"
        },
        "definition": "How organisms grow and develop.",
        "narrow_synonyms": ["Development"],
        "text": "Developmental biology"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/topic_3056"
          },
          "definition": "The distribution of allele frequencies in a population of organisms and its change subject to evolutionary processes including natural selection, genetic drift, mutation and gene flow.",
          "text": "Population genetics"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/topic_3055"
            },
            "definition": "The genes and genetic mechanisms such as Mendelian inheritance that underly continuous phenotypic traits (such as height or weight).",
            "text": "Quantitative genetics"
          }, {
            "data": {
              "uri": "http://edamontology.org/topic_3945"
            },
            "definition": "The study of the process and mechanism of change of biomolecules such as DNA, RNA, and proteins across generations.",
            "text": "Molecular evolution"
          }, {
            "data": {
              "uri": "http://edamontology.org/topic_3298"
            },
            "definition": "Phenomes, or the study of the change in phenotype (the physical and biochemical traits of organisms) in response to genetic and environmental factors.",
            "text": "Phenomics"
          }],
          "data": {
            "uri": "http://edamontology.org/topic_0625"
          },
          "definition": "The study of genetic constitution of a living entity, such as an individual, and organism, a cell and so on, typically with respect to a particular observable phenotypic traits, or resources concerning such traits, which might be an aspect of biochemistry, physiology, morphology, anatomy, development and so on.",
          "exact_synonyms": ["Genotype and phenotype resources", "Genotype-phenotype", "Genotype-phenotype analysis"],
          "narrow_synonyms": ["Phenotyping", "Genotype", "Phenotype", "Genotyping"],
          "text": "Genotype and phenotype"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3912"
          },
          "definition": "The application of biotechnology to directly manipulate an organism's genes.",
          "exact_synonyms": ["Genetic modification", "Genetic manipulation"],
          "narrow_synonyms": ["Genome editing", "Genome engineering"],
          "text": "Genetic engineering"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3574"
          },
          "definition": "The study of inheritance in human beings.",
          "text": "Human genetics"
        }, {
          "children": [{
            "children": [{
              "comment": ["Metatranscriptomics methods can be used for whole gene expression profiling of complex microbial communities."],
              "data": {
                "uri": "http://edamontology.org/topic_3941"
              },
              "definition": "The study of microbe gene expression within natural environments (i.e. the metatranscriptome).",
              "text": "Metatranscriptomics"
            }, {
              "comment": ["This includes the study of splice sites, splicing patterns, alternative splicing events and variants, isoforms, etc.."],
              "data": {
                "uri": "http://edamontology.org/topic_3320"
              },
              "definition": "RNA splicing; post-transcription RNA modification involving the removal of introns and joining of exons.",
              "exact_synonyms": ["Alternative splicing"],
              "narrow_synonyms": ["Splice sites"],
              "text": "RNA splicing"
            }, {
              "data": {
                "uri": "http://edamontology.org/topic_0204"
              },
              "definition": "The regulation of gene expression.",
              "narrow_synonyms": ["Regulatory genomics"],
              "text": "Gene regulation"
            }, {
              "comment": ["This includes CpG rich regions (isochores) in a nucleotide sequence.", "Transcription factor proteins either promote (as an activator) or block (as a repressor) the binding to DNA of RNA polymerase.  Regulatory sites including transcription factor binding site as well as promoters, enhancers, silencers and boundary elements / insulators.", "This includes promoters, CAAT signals, TATA signals, -35 signals, -10 signals, GC signals, primer binding sites for initiation of transcription or reverse transcription, enhancer, attenuator, terminators and ribosome binding sites."],
              "data": {
                "uri": "http://edamontology.org/topic_0749"
              },
              "definition": "Proteins that bind to DNA and control transcription of DNA to mRNA (transcription factors) and also transcriptional regulatory sites, elements and regions (such as promoters, enhancers, silencers and boundary elements / insulators) in nucleotide sequences.",
              "narrow_synonyms": ["GC signals", "Attenuators", "Transcriptional regulatory sites", "CCAAT box", "CAT box", "Promoters", "-35 signals", "Transcription factors", "Transcription factor binding sites", "CpG islands", "Terminators", "Enhancers", "TATA signals", "Isochores", "TFBS", "CAAT signals", "-10 signals"],
              "text": "Transcription factors and regulatory sites"
            }, {
              "children": [{
                "comment": ["Metatranscriptomics methods can be used for whole gene expression profiling of complex microbial communities."],
                "data": {
                  "uri": "http://edamontology.org/topic_3941"
                },
                "definition": "The study of microbe gene expression within natural environments (i.e. the metatranscriptome).",
                "text": "Metatranscriptomics"
              }],
              "data": {
                "uri": "http://edamontology.org/topic_3308"
              },
              "definition": "The analysis of transcriptomes, or a set of all the RNA molecules in a specific cell, tissue etc.",
              "narrow_synonyms": ["Transcriptome", "Comparative transcriptomics", "Metatranscriptomics"],
              "text": "Transcriptomics"
            }],
            "comment": ["Gene expression levels are analysed by identifying, quantifying or comparing mRNA transcripts, for example using microarrays, RNA-seq, northern blots, gene-indexed expression profiles etc.", "This includes the study of codon usage in nucleotide sequence(s), genetic codes and so on."],
            "data": {
              "uri": "http://edamontology.org/topic_0203"
            },
            "definition": "The analysis of levels and patterns of synthesis of gene products (proteins and functional RNA) including interpretation in functional terms of gene expression data.",
            "exact_synonyms": ["Expression"],
            "narrow_synonyms": ["Transcription", "DNA microarrays", "Gene expression profiling", "Codon usage", "Gene translation", "Gene transcription", "DNA chips"],
            "text": "Gene expression"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/topic_0798"
              },
              "definition": "Mobile genetic elements, such as transposons, Plasmids, Bacteriophage elements and Group II introns.",
              "narrow_synonyms": ["Transposons"],
              "text": "Mobile genetic elements"
            }, {
              "comment": ["Non-coding RNA includes  piwi-interacting RNA (piRNA), small nuclear RNA (snRNA) and small nucleolar RNA (snoRNA).  Regulatory RNA includes microRNA (miRNA) - short single stranded RNA molecules that regulate gene expression, and small interfering RNA (siRNA)."],
              "data": {
                "uri": "http://edamontology.org/topic_0659"
              },
              "definition": "Non-coding or functional RNA sequences, including regulatory RNA sequences, ribosomal RNA (rRNA) and transfer RNA (tRNA).",
              "narrow_synonyms": ["Long ncRNA", "siRNA", "Regulatory RNA", "snRNA", "Small non-coding RNA", "Long non-coding RNA", "snoRNA", "Small nuclear RNA", "microRNA", "piwi-interacting RNA", "Small ncRNA", "Small interfering RNA", "miRNA", "Functional RNA", "piRNA", "Small nucleolar RNA", "Non-coding RNA", "Small and long non-coding RNAs", "ncRNA", "lncRNA"],
              "text": "Functional, regulatory and non-coding RNA"
            }, {
              "comment": ["This includes Introns, and protein-coding regions including coding sequences (CDS), exons, translation initiation sites and open reading frames.  Also expressed sequence tag (EST) or complementary DNA (cDNA) sequences.", "This includes coding sequences for a signal or transit peptide.  A signal peptide coding sequence encodes an N-terminal domain of a secreted protein, which is involved in attaching the polypeptide to a membrane leader sequence. A transit peptide coding sequence encodes an N-terminal domain of a nuclear-encoded organellar protein; which is involved in import of the protein into the organelle.", "This includes regions or sites in a eukaryotic and eukaryotic viral RNA sequence which directs endonuclease cleavage or polyadenylation of an RNA transcript.  A polyA signal is required for endonuclease cleavage of an RNA transcript that is followed by polyadenylation. A polyA site is a site on an RNA transcript to which adenine residues will be added during post-transcriptional polyadenylation.", "This includes 5'untranslated region (5'UTR), coding sequences (CDS), exons, intervening sequences (intron) and 3'untranslated regions (3'UTR)."],
              "data": {
                "uri": "http://edamontology.org/topic_3512"
              },
              "definition": "Transcription of DNA into RNA and features of a messenger RNA (mRNA) molecules including precursor RNA, primary (unprocessed) transcript and fully processed molecules.",
              "exact_synonyms": ["mRNA features"],
              "narrow_synonyms": ["PolyA site", "mRNA", "Introns", "cDNA", "Exons", "Gene transcript features", "Coding RNA", "Fusion transcripts", "Signal peptide coding sequence", "EST", "Transit peptide coding sequence", "PolyA signal"],
              "text": "Gene transcripts"
            }],
            "comment": ["This includes the study of promoters, coding regions etc.", "This incudes operons (operators, promoters and genes) from a bacterial genome.  For example the operon leader and trailer gene, gene composition of the operon and associated information."],
            "data": {
              "uri": "http://edamontology.org/topic_0114"
            },
            "definition": "Gene structure, regions which make an RNA product and features such as promoters, coding regions, gene fusion, splice sites etc.",
            "exact_synonyms": ["Gene features"],
            "narrow_synonyms": ["Fusion genes"],
            "text": "Gene structure"
          }, {
            "children": [{
              "comment": ["This includes T cell receptors (TR), major histocompatibility complex (MHC), immunoglobulin superfamily (IgSF) / antibodies, major histocompatibility complex superfamily (MhcSF), etc.\""],
              "data": {
                "uri": "http://edamontology.org/topic_2830"
              },
              "definition": "Immunity-related proteins and their ligands.",
              "narrow_synonyms": ["Immunopeptides", "Immunoproteins", "Therapeutic antibodies", "Antigens"],
              "text": "Immunoproteins and antigens"
            }],
            "comment": ["A protein families database might include the classifier (e.g. a sequence profile) used to build the classification."],
            "data": {
              "uri": "http://edamontology.org/topic_0623"
            },
            "definition": "Particular gene(s), gene family or other gene group or system and their encoded proteins.Primarily the classification of proteins (from sequence or structural data) into clusters, groups, families etc., curation of a particular protein or protein family, or any other proteins that have been classified as members of a common group.",
            "exact_synonyms": ["Genes, gene family or system"],
            "narrow_synonyms": ["Gene families", "Protein sequence classification", "Protein families", "Gene family", "Gene system"],
            "text": "Gene and protein families"
          }, {
            "children": [{
              "comment": ["Includes restriction fragment length polymorphisms (RFLP) in a DNA sequence.  An RFLP is defined by the presence or absence of a specific restriction site of a bacterial restriction enzyme.", "Includes microsatellite polymorphism in a DNA sequence.  A microsatellite polymorphism is a very short subsequence that is repeated a variable number of times between individuals. These repeats consist of the nucleotides cytosine and adenosine.", "Includes single nucleotide polymorphisms (SNP) and associated data, for example, the discovery and annotation of SNPs.  A SNP is a DNA sequence variation where a single nucleotide differs between members of a species or paired chromosomes in an individual.", "Includes variable number of tandem repeat (VNTR) polymorphism in a DNA sequence.  VNTRs occur in non-coding regions of DNA and consists sub-sequence that is repeated a multiple (and varied) number of times."],
              "data": {
                "uri": "http://edamontology.org/topic_2885"
              },
              "definition": "DNA polymorphism.",
              "narrow_synonyms": ["VNTR", "Single nucleotide polymorphism", "SNP", "Variable number of tandem repeat polymorphism", "Microsatellites", "snps", "RFLP"],
              "text": "DNA polymorphism"
            }, {
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/topic_3958"
                },
                "definition": "A DNA structural variation, specifically a duplication or deletion event, resulting in sections of the genome to be repeated, or the number of repeats in the genome to vary between individuals.",
                "narrow_synonyms": ["Complex CNV", "CNV deletion", "CNV insertion / amplification", "Copy number variant", "CNV duplication"],
                "text": "Copy number variation"
              }],
              "data": {
                "uri": "http://edamontology.org/topic_3175"
              },
              "definition": "Variation in chromosome structure including microscopic and submicroscopic types of variation such as deletions, duplications, copy-number variants, insertions, inversions and translocations.",
              "exact_synonyms": ["Genomic structural variation", "DNA structural variation"],
              "narrow_synonyms": ["Translocation", "Deletion", "Insertion", "Inversion", "Duplication"],
              "text": "Structural variation"
            }, {
              "data": {
                "uri": "http://edamontology.org/topic_2533"
              },
              "definition": "DNA mutation.",
              "text": "DNA mutation"
            }],
            "data": {
              "uri": "http://edamontology.org/topic_0199"
            },
            "definition": "Stable, naturally occuring mutations in a nucleotide sequence including alleles, naturally occurring mutations such as single base nucleotide substitutions, deletions and insertions, RFLPs and other polymorphisms.",
            "exact_synonyms": ["DNA variation"],
            "narrow_synonyms": ["Genomic variation", "Polymorphism", "Somatic mutations", "Mutation"],
            "text": "Genetic variation"
          }, {
            "data": {
              "uri": "http://edamontology.org/topic_3959"
            },
            "definition": "The branch of genetics concerned with the relationships between chromosomes and cellular behaviour, especially during mitosis and meiosis.",
            "text": "Cytogenetics"
          }],
          "data": {
            "uri": "http://edamontology.org/topic_3321"
          },
          "definition": "The structure and function of genes at a molecular level.",
          "text": "Molecular genetics"
        }, {
          "comment": ["This involves the study of often complex genetic traits underlying diseases involving defects in the immune system. For example, identifying target genes for therapeutic approaches, or genetic variations involved in immunological pathology."],
          "data": {
            "uri": "http://edamontology.org/topic_3930"
          },
          "definition": "A biomedical field that bridges immunology and genetics, to study the genetic basis of the immune system.",
          "exact_synonyms": ["Immungenetics", "Immunology and genetics", "Immune system genetics"],
          "narrow_synonyms": ["Immunogenes"],
          "text": "Immunogenetics"
        }, {
          "children": [{
            "comment": ["Epigenetics concerns the heritable changes in gene expression owing to mechanisms other than DNA sequence variation."],
            "data": {
              "uri": "http://edamontology.org/topic_3173"
            },
            "definition": "The study of the epigenetic modifications of a whole cell, tissue, organism etc.",
            "text": "Epigenomics"
          }, {
            "comment": ["The study of the phenomena whereby the effects of one locus mask the allelic effects of another, such as how dominant alleles mask the effects of the recessive alleles at the same locus."],
            "data": {
              "uri": "http://edamontology.org/topic_3974"
            },
            "definition": "The study of the epigenetic modifications of a whole cell, tissue, organism etc.",
            "exact_synonyms": ["Epistatic interactions", "Epistatic genetic interaction"],
            "text": "Epistasis"
          }],
          "comment": ["This includes sub-topics such as histone modification and DNA methylation (methylation sites and analysis, for example of patterns and profiles of DNA methylation in a population, tissue etc.)"],
          "data": {
            "uri": "http://edamontology.org/topic_3295"
          },
          "definition": "Topic concerning the study of heritable changes, for example in gene expression or phenotype, caused by mechanisms other than changes in the DNA sequence.",
          "narrow_synonyms": ["DNA methylation", "Methylation profiles", "Histone modification"],
          "text": "Epigenetics"
        }],
        "data": {
          "uri": "http://edamontology.org/topic_3053"
        },
        "definition": "The study of genes, genetic variation and heredity in living organisms.",
        "narrow_synonyms": ["Heredity", "Genes"],
        "text": "Genetics"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_2229"
        },
        "definition": "Cells, such as key genes and proteins involved in the cell cycle.",
        "narrow_synonyms": ["Cells", "Cellular processes", "Protein subcellular localization"],
        "text": "Cell biology"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/topic_3576"
          },
          "definition": "Biotechnology applied to the medical sciences and the development of medicines.",
          "narrow_synonyms": ["Pharmaceutical biotechnology"],
          "text": "Medical biotechnology"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3912"
          },
          "definition": "The application of biotechnology to directly manipulate an organism's genes.",
          "exact_synonyms": ["Genetic modification", "Genetic manipulation"],
          "narrow_synonyms": ["Genome editing", "Genome engineering"],
          "text": "Genetic engineering"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3895"
          },
          "definition": "The application of multi-disciplinary science and technology for the construction of artificial biological systems for diverse applications.",
          "narrow_synonyms": ["Biomimeic chemistry"],
          "text": "Synthetic biology"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3398"
          },
          "definition": "The application of biological concepts and methods to the analytical and synthetic methodologies of engineering.",
          "exact_synonyms": ["Biological engineering"],
          "text": "Bioengineering"
        }, {
          "data": {
            "uri": "http://edamontology.org/topic_3368"
          },
          "definition": "Any matter, surface or construct that interacts with a biological system.",
          "text": "Biomaterials"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3939"
          },
          "definition": "Biotechnology approach that seeks to optimize cellular genetic and regulatory processes in order to increase the cells' production of a certain substance.",
          "text": "Metabolic engineering"
        }],
        "data": {
          "uri": "http://edamontology.org/topic_3297"
        },
        "definition": "The exploitation of biological process, structure and function for industrial purposes, for example the genetic manipulation of microorganisms for the antibody production.",
        "narrow_synonyms": ["Applied microbiology"],
        "text": "Biotechnology"
      }],
      "data": {
        "uri": "http://edamontology.org/topic_3070"
      },
      "definition": "The study of life and living organisms, including their morphology, biochemistry, physiology, development, evolution, and so on.",
      "exact_synonyms": ["Biological science"],
      "narrow_synonyms": ["Reproductive biology", "Biological rhythms", "Chronobiology", "Aerobiology", "Cryobiology", "Behavioural biology"],
      "text": "Biology"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/topic_3473"
        },
        "definition": "The discovery of patterns in large data sets and the extraction and trasnsformation of those patterns into a useful format.",
        "narrow_synonyms": ["Pattern recognition"],
        "text": "Data mining"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3332"
        },
        "definition": "Topic concerning the development and application of theory, analytical methods, mathematical models and computational simulation of chemical systems.",
        "text": "Computational chemistry"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3372"
        },
        "definition": "The process that leads from an original formulation of a computing problem to executable programs.",
        "exact_synonyms": ["Software development", "Computer programming"],
        "narrow_synonyms": ["Programming languages", "Algorithms", "Data structures"],
        "text": "Software engineering"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_0218"
        },
        "definition": "The processing and analysis of natural language, such as scientific literature in English, in order to extract data and information, or to enable human-computer interaction.",
        "exact_synonyms": ["NLP"],
        "narrow_synonyms": ["BioNLP", "Text data mining", "Literature mining", "Text analytics", "Text mining"],
        "text": "Natural language processing"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_0092"
        },
        "definition": "Rendering (drawing on a computer screen) or visualisation of molecular sequences, structures or other biomolecular data.",
        "exact_synonyms": ["Data rendering"],
        "text": "Data visualisation"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3474"
        },
        "definition": "A topic concerning the application of artificial intelligence methods to algorithms, in order to create methods that can learn from data in order to generate an ouput, rather than relying on explicitly encoded information only.",
        "narrow_synonyms": ["Knowledge representation", "Supervised learning", "Kernel methods", "Neural networks", "Ensembl learning", "Reinforcement learning", "Active learning", "Unsupervised learning", "Recommender system"],
        "text": "Machine learning"
      }],
      "data": {
        "uri": "http://edamontology.org/topic_3316"
      },
      "definition": "The theory and practical use of computer systems.",
      "narrow_synonyms": ["Cloud computing", "High-performance computing", "HPC", "High performance computing"],
      "text": "Computer science"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/topic_3379"
        },
        "definition": "The testing of new medicines, vaccines or procedures on animals (preclinical) and humans (clinical) prior to their approval by regulatory authorities.",
        "narrow_synonyms": ["Drug trials", "Clinical studies", "Preclinical studies", "Clinical study", "Preclinical study", "Clinical trial"],
        "text": "Preclinical and clinical studies"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3679"
        },
        "definition": "The design of an experiment involving non-human animals.",
        "narrow_synonyms": ["Challenge study"],
        "text": "Animal study"
      }, {
        "data": {
          "uri": "http://edamontology.org/topic_3517"
        },
        "definition": "Genome-wide association study experiments.",
        "exact_synonyms": ["GWAS analysis", "Genome-wide association study", "GWAS"],
        "text": "GWAS study"
      }],
      "data": {
        "uri": "http://edamontology.org/topic_3678"
      },
      "definition": "The design of an experiment intended to test a hypothesis, and describe or explain empirical data obtained under various experimental conditions.",
      "exact_synonyms": ["Design of experiments", "Experimental design", "Studies"],
      "text": "Experimental design and studies"
    }],
    "data": {
      "uri": "http://edamontology.org/topic_0003"
    },
    "definition": "A category denoting a rather broad domain or field of interest, of study, application, work, data, or technology. Topics have no clearly defined borders between each other.",
    "text": "Topic"
  }, {
    "children": [{
      "children": [{
        "data": {
          "uri": "http://edamontology.org/data_3738"
        },
        "definition": "The ratio between regional and local species diversity.",
        "exact_synonyms": ["True beta diversity", "\u03B2-diversity"],
        "text": "Beta diversity data"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_3737"
        },
        "definition": "The mean species diversity in sites or habitats at a local scale.",
        "exact_synonyms": ["\u03B1-diversity"],
        "text": "Alpha diversity data"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_3739"
        },
        "definition": "The total species diversity in a landscape.",
        "exact_synonyms": ["\u0263-diversity"],
        "text": "Gamma diversity data"
      }],
      "data": {
        "uri": "http://edamontology.org/data_3707"
      },
      "definition": "Machine-readable biodiversity data.",
      "exact_synonyms": ["Biodiversity information"],
      "narrow_synonyms": ["OTU table"],
      "text": "Biodiversity data"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/data_2167"
        },
        "definition": "Density plot (of base composition) for a nucleotide sequence.",
        "text": "Nucleic acid density plot"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_2957"
        },
        "definition": "A Hopp and Woods plot of predicted antigenicity of a peptide or protein.",
        "text": "Hopp and Woods plot"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_2160"
        },
        "definition": "A plot of Fickett testcode statistic (identifying protein coding regions) in a nucleotide sequences.",
        "text": "Fickett testcode plot"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_3743"
        },
        "definition": "A plot in which community data (e.g. species abundance data) is summarised.  Similar species and samples are plotted close together, and dissimilar species and samples are plotted placed far apart.",
        "text": "Ordination plot"
      }, {
        "comment": ["Such as generated by the Vienna package."],
        "data": {
          "uri": "http://edamontology.org/data_1595"
        },
        "definition": "Dotplot of RNA base pairing probability matrix.",
        "text": "Base pairing probability matrix dotplot"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_2166"
        },
        "definition": "A plot of character or word composition / frequency of a molecular sequence.",
        "text": "Sequence composition plot"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_1527"
        },
        "definition": "The titration curve of a protein.",
        "text": "Protein titration curve"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_2165"
        },
        "definition": "A plot of pK versus pH for a protein.",
        "text": "Protein ionisation curve"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_3905"
        },
        "definition": "Visualization of distribution of quantitative data, e.g. expression data, by histograms, violin plots and density plots.",
        "exact_synonyms": ["Density plot"],
        "text": "Histogram"
      }, {
        "comment": ["Use this concept for calculated substitution rates, relative site variability, data on sites with biased properties, highly conserved or very poorly conserved sites, regions, blocks etc."],
        "data": {
          "uri": "http://edamontology.org/data_2161"
        },
        "definition": "A plot of sequence similarities identified from word-matching or character comparison.",
        "text": "Sequence similarity plot"
      }],
      "data": {
        "uri": "http://edamontology.org/data_2884"
      },
      "definition": "Biological data that has been plotted as a graph of some type, or plotting instructions for rendering such a graph.",
      "exact_synonyms": ["Graph data"],
      "text": "Plot"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/data_3872"
        },
        "definition": "Static information of a structure molecular system that is needed for a molecular simulation: the list of atoms, their non-bonded parameters for Van der Waals and electrostatic interactions, and the complete connectivity in terms of bonds, angles and dihedrals.",
        "text": "Topology data"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_3870"
        },
        "definition": "Dynamic information of a structure molecular system coming from a molecular simulation: XYZ 3D coordinates (sometimes with their associated velocities) for every atom along time.",
        "text": "Trajectory data"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_3871"
        },
        "definition": "Force field parameters: charges, masses, radii, bond lengths, bond dihedrals, etc. define the structural molecular system, and are essential for the proper description and simulation of a molecular system.",
        "text": "Forcefield parameters"
      }],
      "data": {
        "uri": "http://edamontology.org/data_3869"
      },
      "definition": "Data coming from molecular simulations, computer \"experiments\" on model molecules. Tipically formed by two separated but indivisible pieces of information: topology data (static) and trajectory data (dynamic).",
      "text": "Simulation"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/data_3488"
        },
        "definition": "Spectral information for a molecule from a nuclear magnetic resonance experiment.",
        "exact_synonyms": ["NMR spectra"],
        "has_topic": ["http://edamontology.org/topic_1317"],
        "text": "NMR spectrum"
      }],
      "data": {
        "uri": "http://edamontology.org/data_3483"
      },
      "definition": "The spectrum of frequencies of electromagnetic radiation emitted from a molecule as a result of some spectroscopy experiment.",
      "exact_synonyms": ["Spectra"],
      "text": "Spectrum"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/data_3505"
        },
        "definition": "A list of publications such as scientic papers or books.",
        "text": "Bibliography"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_3779"
        },
        "definition": "A text (such as a scientific article), annotated with notes, data and metadata, such as recognised entities, concepts, and their relations.",
        "text": "Annotated text"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_3779"
          },
          "definition": "A text (such as a scientific article), annotated with notes, data and metadata, such as recognised entities, concepts, and their relations.",
          "text": "Annotated text"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_0971"
          },
          "definition": "A scientific text, typically a full text article from a scientific journal.",
          "narrow_synonyms": ["Scientific article", "Article text"],
          "text": "Article"
        }],
        "data": {
          "uri": "http://edamontology.org/data_3671"
        },
        "definition": "Any free or plain text, typically for human consumption and in English. Can instantiate also as a textual search query.",
        "exact_synonyms": ["Free text"],
        "narrow_synonyms": ["Plain text", "Textual search query"],
        "text": "Text"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_0971"
        },
        "definition": "A scientific text, typically a full text article from a scientific journal.",
        "narrow_synonyms": ["Scientific article", "Article text"],
        "text": "Article"
      }, {
        "comment": ["A text mining abstract will typically include an annotated a list of words or sentences extracted from one or more scientific articles."],
        "data": {
          "uri": "http://edamontology.org/data_0972"
        },
        "definition": "A human-readable collection of information resulting from text mining.",
        "exact_synonyms": ["Text mining output"],
        "text": "Text mining report"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_2849"
        },
        "definition": "An abstract of a scientific article.",
        "text": "Abstract"
      }, {
        "comment": ["A bibliographic reference might include information such as authors, title, journal name, date and (possibly) a link to the abstract or full-text of the article if available."],
        "data": {
          "uri": "http://edamontology.org/data_0970"
        },
        "definition": "Bibliographic data that uniquely identifies a scientific article, book or other published material.",
        "exact_synonyms": ["Reference", "Bibliographic reference"],
        "text": "Citation"
      }],
      "comment": ["This is a broad data type and is used a placeholder for other, more specific types.  It is primarily intended to help navigation of EDAM and would not typically be used for annotation. It includes concepts that are best described as scientific text or closely concerned with or derived from text."],
      "data": {
        "uri": "http://edamontology.org/data_2526"
      },
      "definition": "Data concerning, extracted from, or derived from the analysis of a scientific text (or texts) such as a full text article from a scientific journal.",
      "has_topic": ["http://edamontology.org/topic_3068"],
      "narrow_synonyms": ["Scientific text data", "Article data"],
      "text": "Text data"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/data_1439"
        },
        "definition": "A model of DNA substitution that explains a DNA sequence alignment, derived from phylogenetic tree analysis.",
        "exact_synonyms": ["Substitution model", "Phylogenetic tree report (DNA substitution model)", "Sequence alignment report (DNA substitution model)"],
        "text": "DNA substitution model"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_3241"
        },
        "definition": "Mathematical model of a network, that contains biochemical kinetics.",
        "text": "Kinetic model"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_3949"
          },
          "definition": "A profile HMM is a variant of a Hidden Markov model that is derived specifically from a set of (aligned) biological sequences. Profile HMMs provide the basis for a position-specific scoring system, which can be used to align sequences and search databases for related sequences.",
          "text": "Profile HMM"
        }],
        "data": {
          "uri": "http://edamontology.org/data_1364"
        },
        "definition": "A statistical Markov model of a system which is assumed to be a Markov process with unobserved (hidden) states.  For example, a hidden Markov model representation of a set or alignment of sequences.",
        "exact_synonyms": ["HMM"],
        "text": "Hidden Markov model"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_1347"
        },
        "definition": "Dirichlet distribution used by hidden Markov model analysis programs.",
        "text": "Dirichlet distribution"
      }],
      "data": {
        "uri": "http://edamontology.org/data_0950"
      },
      "definition": "A biological model represented in mathematical terms.",
      "exact_synonyms": ["Biological model"],
      "has_topic": ["http://edamontology.org/topic_3307"],
      "text": "Mathematical model"
    }, {
      "comment": ["Typically formed by two separated but indivisible pieces of information: topology data (static) and trajectory data (dynamic)."],
      "data": {
        "uri": "http://edamontology.org/data_3842"
      },
      "definition": "Data coming from molecular simulations, computer \"experiments\" on model molecules.",
      "has_topic": ["http://edamontology.org/topic_0081"],
      "text": "Molecular simulation data"
    }, {
      "children": [{
        "comment": ["Information might include start and end position in a chromosome sequence, chromosome identifier, name of band and so on."],
        "data": {
          "uri": "http://edamontology.org/data_3236"
        },
        "definition": "The position of a cytogenetic band in a genome.",
        "text": "Cytoband position"
      }],
      "comment": ["This includes positions in genomes based on a reference sequence. A position may be specified for any mappable object, i.e. anything that may have positional information such as a physical position in a chromosome. Data might include sequence region name, strand, coordinate system name, assembly name, start position and end position."],
      "data": {
        "uri": "http://edamontology.org/data_2012"
      },
      "definition": "A position in a map (for example a genetic map), either a single position (point) or a region / interval.",
      "exact_synonyms": ["Locus", "Map position", "Sequence co-ordinates"],
      "text": "Sequence coordinates"
    }, {
      "comment": ["Variations are stored along with a reference genome."],
      "data": {
        "uri": "http://edamontology.org/data_3498"
      },
      "definition": "Data on gene sequence variations resulting large-scale genotyping and DNA sequencing projects.",
      "exact_synonyms": ["Gene sequence variations"],
      "has_topic": ["http://edamontology.org/topic_0199"],
      "text": "Sequence variations"
    }, {
      "children": [{
        "comment": ["A feature key indicates the biological nature of the feature or information about changes to or versions of the sequence."],
        "data": {
          "uri": "http://edamontology.org/data_1020"
        },
        "definition": "The type of a sequence feature, typically a term or accession from the Sequence Ontology, for example an EMBL or Swiss-Prot sequence feature key.",
        "exact_synonyms": ["Sequence feature method", "Sequence feature type"],
        "text": "Sequence feature key"
      }, {
        "comment": ["A feature label identifies a feature of a sequence database entry. When used with the database name and the entry's primary accession number, it is a unique identifier of that feature."],
        "data": {
          "uri": "http://edamontology.org/data_1022"
        },
        "definition": "A name of a sequence feature, e.g. the name of a feature to be displayed to an end-user. Typically an EMBL or Swiss-Prot feature label.",
        "exact_synonyms": ["Sequence feature name"],
        "text": "Sequence feature label"
      }, {
        "comment": ["Feature qualifiers hold information about a feature beyond that provided by the feature key and location."],
        "data": {
          "uri": "http://edamontology.org/data_1021"
        },
        "definition": "Typically one of the EMBL or Swiss-Prot feature qualifiers.",
        "text": "Sequence feature qualifier"
      }, {
        "comment": ["This might be the name and version of a software tool, the name of a database, or 'curated' to indicate a manual annotation (made by a human)."],
        "data": {
          "uri": "http://edamontology.org/data_0856"
        },
        "definition": "How the annotation of a sequence feature (for example in EMBL or Swiss-Prot) was derived.",
        "text": "Sequence feature source"
      }],
      "data": {
        "uri": "http://edamontology.org/data_2914"
      },
      "definition": "Metadata on sequence features.",
      "text": "Sequence features metadata"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/data_3670"
        },
        "definition": "A training course available for use on the Web.",
        "exact_synonyms": ["On-line course"],
        "narrow_synonyms": ["MOOC", "Massive open online course"],
        "text": "Online course"
      }],
      "data": {
        "uri": "http://edamontology.org/data_3669"
      },
      "definition": "Some material that is used for educational (training) purposes.",
      "narrow_synonyms": ["Open educational resource", "OER"],
      "text": "Training material"
    }, {
      "children": [{
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_3738"
          },
          "definition": "The ratio between regional and local species diversity.",
          "exact_synonyms": ["True beta diversity", "\u03B2-diversity"],
          "text": "Beta diversity data"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_3737"
          },
          "definition": "The mean species diversity in sites or habitats at a local scale.",
          "exact_synonyms": ["\u03B1-diversity"],
          "text": "Alpha diversity data"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_3739"
          },
          "definition": "The total species diversity in a landscape.",
          "exact_synonyms": ["\u0263-diversity"],
          "text": "Gamma diversity data"
        }],
        "data": {
          "uri": "http://edamontology.org/data_3707"
        },
        "definition": "Machine-readable biodiversity data.",
        "exact_synonyms": ["Biodiversity information"],
        "narrow_synonyms": ["OTU table"],
        "text": "Biodiversity data"
      }],
      "comment": ["This is a broad data type and is used a placeholder for other, more specific types."],
      "data": {
        "uri": "http://edamontology.org/data_3736"
      },
      "definition": "Data concerning ecology; for example measurements and reports from the study of interactions among organisms and their environment.",
      "text": "Ecological data"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_2019"
      },
      "definition": "Data describing a molecular map (genetic or physical) or a set of such maps, including various attributes of, data extracted from or derived from the analysis of them, but exluding the map(s) themselves. This  includes metadata for map sets that share a common set of features which are mapped.",
      "has_topic": ["http://edamontology.org/topic_0102"],
      "narrow_synonyms": ["Map set data", "Map attribute"],
      "text": "Map data"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/data_3953"
        },
        "definition": "A ranked list of pathways, each associated with z-score, p-value or similar, concerning or derived from the analysis of e.g. a set of genes or proteins.",
        "exact_synonyms": ["Pathway term enrichment report", "Pathway over-representation report", "Pathway enrichment report", "Pathway analysis results", "Pathway report"],
        "has_topic": ["http://edamontology.org/topic_1775"],
        "text": "Pathway overrepresentation data"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_3754"
        },
        "definition": "A ranked list of Gene Ontology concepts, each associated with a p-value, concerning or derived from the analysis of e.g. a set of genes or proteins.",
        "exact_synonyms": ["Gene ontology term enrichment report", "Gene ontology concept over-representation report", "Gene ontology enrichment report", "GO-term enrichment report"],
        "has_topic": ["http://edamontology.org/topic_1775"],
        "text": "GO-term enrichment data"
      }],
      "data": {
        "uri": "http://edamontology.org/data_3753"
      },
      "definition": "A ranked list of categories (usually ontology concepts), each associated with a statistical metric of over-/under-representation within the studied data.",
      "exact_synonyms": ["Over-representation report", "Enrichment report"],
      "narrow_synonyms": ["Functional enrichment report"],
      "text": "Over-representation data"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_1352"
      },
      "definition": "Regular expression pattern.",
      "text": "Regular expression"
    }, {
      "children": [{
        "children": [{
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_3924"
            },
            "definition": "Alignment (superimposition) of DNA tertiary (3D) structures.",
            "exact_synonyms": ["Structure alignment (DNA)"],
            "text": "DNA structure alignment"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1493"
            },
            "definition": "Alignment (superimposition) of RNA tertiary (3D) structures.",
            "exact_synonyms": ["Structure alignment (RNA)"],
            "text": "RNA structure alignment"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1482"
          },
          "definition": "Alignment (superimposition) of nucleic acid tertiary (3D) structures.",
          "exact_synonyms": ["Structure alignment (nucleic acid)"],
          "text": "Nucleic acid structure alignment"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1481"
          },
          "definition": "Alignment (superimposition) of protein tertiary (3D) structures.",
          "exact_synonyms": ["Structure alignment (protein)"],
          "text": "Protein structure alignment"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1479"
          },
          "definition": "Alignment (superimposition) of exactly two molecular tertiary (3D) structures.",
          "exact_synonyms": ["Pair structure alignment"],
          "text": "Structure alignment (pair)"
        }],
        "comment": ["A tertiary structure alignment will include the untransformed coordinates of one macromolecule, followed by the second (or subsequent) structure(s) with all the coordinates transformed (by rotation / translation) to give a superposition."],
        "data": {
          "uri": "http://edamontology.org/data_0886"
        },
        "definition": "Alignment (superimposition) of molecular tertiary (3D) structures.",
        "has_topic": ["http://edamontology.org/topic_0081"],
        "text": "Structure alignment"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_0890"
        },
        "definition": "A 3D profile-3D profile alignment (each profile representing structures or a structure alignment).",
        "exact_synonyms": ["Structural profile alignment"],
        "text": "Structural (3D) profile alignment"
      }, {
        "comment": ["A \"sequence-profile alignment\" is an alignment of one or more molecular sequence(s) to one or more sequence profile(s) (each profile typically representing a sequence alignment).", "This includes reports of hits from a search of a protein secondary or domain database. Data associated with the search or alignment might also be included, e.g. ranked list of best-scoring sequences, a graphical representation of scores etc.", "A \"profile-profile alignment\" is an alignment of two sequence profiles, each profile typically representing a sequence alignment."],
        "data": {
          "uri": "http://edamontology.org/data_0858"
        },
        "definition": "Report on the location of matches (\"hits\") between sequences, sequence profiles, motifs (conserved or functional patterns) and other types of sequence signatures.",
        "narrow_synonyms": ["Sequence profile alignment", "Search results (protein secondary database)", "Sequence motif hits", "Protein secondary database search results", "Profile-profile alignment", "Sequence profile matches", "Sequence motif matches", "Sequence-profile alignment", "Sequence profile hits"],
        "text": "Sequence signature matches"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_0878"
          },
          "definition": "Alignment of the (1D representations of) secondary structure of two or more proteins.",
          "exact_synonyms": ["Secondary structure alignment (protein)"],
          "text": "Protein secondary structure alignment"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_0881"
          },
          "definition": "Alignment of the (1D representations of) secondary structure of two or more RNA molecules.",
          "exact_synonyms": ["Secondary structure alignment (RNA)"],
          "text": "RNA secondary structure alignment"
        }],
        "data": {
          "uri": "http://edamontology.org/data_2366"
        },
        "definition": "Alignment of the (1D representations of) secondary structure of two or more molecules.",
        "text": "Secondary structure alignment"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_0893"
        },
        "definition": "An alignment of molecular sequence to structure (from threading sequence(s) through 3D structure or representation of structure(s)).",
        "text": "Sequence-structure alignment"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_1383"
          },
          "definition": "Alignment of multiple nucleotide sequences.",
          "exact_synonyms": ["Sequence alignment (nucleic acid)"],
          "narrow_synonyms": ["DNA sequence alignment", "RNA sequence alignment"],
          "text": "Nucleic acid sequence alignment"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1381"
          },
          "definition": "Alignment of exactly two molecular sequences.",
          "exact_synonyms": ["Sequence alignment (pair)"],
          "text": "Pair sequence alignment"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1384"
          },
          "definition": "Alignment of multiple protein sequences.",
          "exact_synonyms": ["Sequence alignment (protein)"],
          "text": "Protein sequence alignment"
        }, {
          "comment": ["Hybrid sequence alignments include for example genomic DNA to EST, cDNA or mRNA."],
          "data": {
            "uri": "http://edamontology.org/data_1385"
          },
          "definition": "Alignment of multiple molecular sequences of different types.",
          "exact_synonyms": ["Sequence alignment (hybrid)"],
          "text": "Hybrid sequence alignment"
        }],
        "data": {
          "uri": "http://edamontology.org/data_0863"
        },
        "definition": "Alignment of multiple molecular sequences.",
        "exact_synonyms": ["msa", "Multiple sequence aligment"],
        "has_topic": ["http://edamontology.org/topic_0080"],
        "text": "Sequence alignment"
      }],
      "data": {
        "uri": "http://edamontology.org/data_1916"
      },
      "definition": "An alignment of molecular sequences, structures or profiles derived from them.",
      "text": "Alignment"
    }, {
      "children": [{
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_2992"
          },
          "definition": "An image of protein structure.",
          "exact_synonyms": ["Structure image (protein)"],
          "text": "Protein structure image"
        }, {
          "children": [{
            "comment": ["Useful for highlighting amphipathicity and other properties."],
            "data": {
              "uri": "http://edamontology.org/data_2163"
            },
            "definition": "An image of peptide sequence sequence in a simple 3,4,3,4 repeating pattern that emulates at a simple level the arrangement of residues around an alpha helix.",
            "text": "Helical net"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2162"
            },
            "definition": "An image of peptide sequence sequence looking down the axis of the helix for highlighting amphipathicity and other properties.",
            "text": "Helical wheel"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1709"
          },
          "definition": "Image of protein secondary structure.",
          "text": "Protein secondary structure image"
        }],
        "data": {
          "uri": "http://edamontology.org/data_3153"
        },
        "definition": "An image of a protein.",
        "text": "Protein image"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_1714"
          },
          "definition": "An image of spots from a microarray experiment.",
          "text": "Microarray spots image"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_3807"
          },
          "definition": "Raw DDD movie acquisition from electron microscopy.",
          "has_topic": ["http://edamontology.org/topic_1317"],
          "text": "EM Movie"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_3442"
          },
          "definition": "An imaging technique that uses magnetic fields and radiowaves to form images, typically to investigate the anatomy and physiology of the human body.",
          "exact_synonyms": ["Nuclear magnetic resonance imaging image", "MRT image", "Magnetic resonance imaging image", "NMRI image", "Magnetic resonance tomography image"],
          "has_topic": ["http://edamontology.org/topic_3384"],
          "text": "MRI image"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_0942"
          },
          "definition": "Two-dimensional gel electrophoresis image",
          "has_topic": ["http://edamontology.org/topic_0121"],
          "text": "2D PAGE image"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_3808"
          },
          "definition": "Raw acquistion from electron microscopy or average of an aligned DDD movie.",
          "has_topic": ["http://edamontology.org/topic_1317"],
          "text": "EM Micrograph"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2586"
          },
          "definition": "An image arising from a Northern Blot experiment.",
          "text": "Northern blot image"
        }],
        "data": {
          "uri": "http://edamontology.org/data_3424"
        },
        "definition": "Raw biological or biomedical image generated by some experimental technique.",
        "text": "Raw image"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_1713"
        },
        "definition": "A fate map is a plan of early stage of an embryo such as a blastula, showing areas that are significance to development.",
        "has_topic": ["http://edamontology.org/topic_3065"],
        "text": "Fate map"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_1708"
        },
        "definition": "Image of RNA secondary structure, knots, pseudoknots etc.",
        "text": "RNA secondary structure image"
      }, {
        "children": [{
          "comment": ["The molecular identifier and formula are typically included."],
          "data": {
            "uri": "http://edamontology.org/data_1712"
          },
          "definition": "An image of the structure of a small chemical compound.",
          "exact_synonyms": ["Small molecule structure image"],
          "narrow_synonyms": ["Chemical structure sketch", "Small molecule sketch"],
          "text": "Chemical structure image"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2992"
          },
          "definition": "An image of protein structure.",
          "exact_synonyms": ["Structure image (protein)"],
          "text": "Protein structure image"
        }],
        "data": {
          "uri": "http://edamontology.org/data_1710"
        },
        "definition": "Image of one or more molecular tertiary (3D) structures.",
        "text": "Structure image"
      }, {
        "comment": ["See also 'Phylogenetic tree'"],
        "data": {
          "uri": "http://edamontology.org/data_1707"
        },
        "definition": "An image (for viewing or printing) of a phylogenetic tree including (typically) a plot of rooted or unrooted phylogenies, cladograms, circular trees or phenograms and associated information.",
        "text": "Phylogenetic tree image"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_1711"
        },
        "definition": "Image of two or more aligned molecular sequences possibly annotated with alignment features.",
        "text": "Sequence alignment image"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_3449"
        },
        "definition": "An image from a cell migration track assay.",
        "has_topic": ["http://edamontology.org/topic_2229"],
        "text": "Cell migration track image"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_1636"
        },
        "definition": "A graphical 2D tabular representation of expression data, typically derived from an omics experiment. A heat map is a table where rows and columns correspond to different features and contexts (for example, cells or samples) and the cell colour represents the level of expression of a gene that context.",
        "text": "Heat map"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_2168"
          },
          "definition": "Image of a sequence trace (nucleotide sequence versus probabilities of each of the 4 bases).",
          "text": "Sequence trace image"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1289"
          },
          "definition": "Image of the restriction enzyme cleavage sites (restriction sites) in a nucleic acid sequence.",
          "text": "Restriction map"
        }],
        "data": {
          "uri": "http://edamontology.org/data_2969"
        },
        "definition": "Image of a molecular sequence, possibly with sequence features or properties shown.",
        "text": "Sequence image"
      }],
      "data": {
        "uri": "http://edamontology.org/data_2968"
      },
      "definition": "Data (typically biological or biomedical) that has been rendered into an image, typically for display on screen.",
      "exact_synonyms": ["Image data"],
      "text": "Image"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/data_1265"
        },
        "definition": "A table of base frequencies of a nucleotide sequence.",
        "text": "Base frequencies table"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_1494"
        },
        "definition": "Matrix to transform (rotate/translate) 3D coordinates, typically the transformation necessary to superimpose two molecular structures.",
        "text": "Structural transformation matrix"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_1267"
        },
        "definition": "A table of amino acid frequencies of a protein sequence.",
        "exact_synonyms": ["Sequence composition (amino acid frequencies)"],
        "text": "Amino acid frequencies table"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_1266"
        },
        "definition": "A table of word composition of a nucleotide sequence.",
        "text": "Base word frequencies table"
      }, {
        "comment": ["Consider for example an HMM with two states (AT-rich and GC-rich).  The emission matrix holds the probabilities of choosing each of the four nucleotides (A, C, G and T) in the AT-rich state and in the GC-rich state."],
        "data": {
          "uri": "http://edamontology.org/data_3355"
        },
        "definition": "A HMM emission matrix holds the probabilities of choosing the four nucleotides (A, C, G and T) in each of the states of a HMM.",
        "exact_synonyms": ["HMM emission matrix"],
        "text": "Emission matrix"
      }, {
        "comment": ["Such data are often used for genome rearrangement tools and phylogenetic tree labeling."],
        "data": {
          "uri": "http://edamontology.org/data_3479"
        },
        "definition": "Multiple gene identifiers in a specific order.",
        "text": "Gene order"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_1361"
          },
          "definition": "A profile (typically representing a sequence alignment) that is a simple matrix of nucleotide (or amino acid) counts per position.",
          "exact_synonyms": ["PFM"],
          "text": "Position frequency matrix"
        }, {
          "comment": ["Contributions of individual sequences to the matrix might be uneven (weighted)."],
          "data": {
            "uri": "http://edamontology.org/data_1362"
          },
          "definition": "A profile (typically representing a sequence alignment) that is weighted matrix of nucleotide (or amino acid) counts per position.",
          "exact_synonyms": ["PWM"],
          "text": "Position weight matrix"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1365"
          },
          "definition": "One or more fingerprints (sequence classifiers) as used in the PRINTS database.",
          "text": "Fingerprint"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1363"
          },
          "definition": "A profile (typically representing a sequence alignment) derived from a matrix of nucleotide (or amino acid) counts per position that reflects information content at each position.",
          "exact_synonyms": ["ICM"],
          "text": "Information content matrix"
        }],
        "data": {
          "uri": "http://edamontology.org/data_2854"
        },
        "definition": "A simple matrix of numbers, where each value (or column of values) is derived derived from analysis of the corresponding position in a sequence alignment.",
        "exact_synonyms": ["PSSM"],
        "text": "Position-specific scoring matrix"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_1448"
          },
          "definition": "Matrix of integer or floating point numbers for nucleotide comparison.",
          "exact_synonyms": ["Nucleotide substitution matrix", "Nucleotide comparison matrix"],
          "text": "Comparison matrix (nucleotide)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1449"
          },
          "definition": "Matrix of integer or floating point numbers for amino acid comparison.",
          "exact_synonyms": ["Amino acid comparison matrix", "Amino acid substitution matrix"],
          "text": "Comparison matrix (amino acid)"
        }],
        "comment": ["The comparison matrix might include matrix name, optional comment, height and width (or size) of matrix, an index row/column (of characters) and data rows/columns (of integers or floats)."],
        "data": {
          "uri": "http://edamontology.org/data_0874"
        },
        "definition": "Matrix of integer or floating point numbers for amino acid or nucleotide sequence comparison.",
        "exact_synonyms": ["Substitution matrix"],
        "text": "Comparison matrix"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_1499"
          },
          "definition": "A matrix of 3D-1D scores reflecting the probability of amino acids to occur in different tertiary structural environments.",
          "text": "3D-1D scoring matrix"
        }],
        "data": {
          "uri": "http://edamontology.org/data_0892"
        },
        "definition": "Matrix of values used for scoring sequence-structure compatibility.",
        "text": "Protein sequence-structure scoring matrix"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_1268"
        },
        "definition": "A table of amino acid word composition of a protein sequence.",
        "exact_synonyms": ["Sequence composition (amino acid words)"],
        "text": "Amino acid word frequencies table"
      }, {
        "children": [{
          "comment": ["Methods might perform character compatibility analysis or identify patterns of similarity in an alignment or data matrix."],
          "data": {
            "uri": "http://edamontology.org/data_0870"
          },
          "definition": "A matrix of estimated evolutionary distance between molecular sequences, such as is suitable for phylogenetic tree calculation.",
          "exact_synonyms": ["Phylogenetic distance matrix"],
          "text": "Sequence distance matrix"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2856"
          },
          "definition": "Distances (values representing similarity) between a group of molecular structures.",
          "text": "Structural distance matrix"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1546"
          },
          "definition": "A matrix of distances between amino acid residues (for example the C-alpha atoms) in a protein structure.",
          "text": "Protein distance matrix"
        }],
        "data": {
          "uri": "http://edamontology.org/data_2855"
        },
        "definition": "A matrix of distances between molecular entities, where a value (distance) is (typically) derived from comparison of two entities and reflects their similarity.",
        "text": "Distance matrix"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_1505"
          },
          "definition": "Molecular weights of amino acids.",
          "exact_synonyms": ["Molecular weight (amino acids)"],
          "text": "Amino acid index (molecular weight)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1506"
          },
          "definition": "Hydrophobic, hydrophilic or charge properties of amino acids.",
          "exact_synonyms": ["Hydropathy (amino acids)"],
          "text": "Amino acid index (hydropathy)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1508"
          },
          "definition": "Van der Waals radii of atoms for different amino acid residues.",
          "exact_synonyms": ["van der Waals radii (amino acids)"],
          "text": "Amino acid index (van der Waals radii)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1502"
          },
          "definition": "Chemical classification (small, aliphatic, aromatic, polar, charged etc) of amino acids.",
          "exact_synonyms": ["Chemical classes (amino acids)"],
          "text": "Amino acid index (chemical classes)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1507"
          },
          "definition": "Experimental free energy values for the water-interface and water-octanol transitions for the amino acids.",
          "exact_synonyms": ["White-Wimley data (amino acids)"],
          "text": "Amino acid index (White-Wimley data)"
        }],
        "data": {
          "uri": "http://edamontology.org/data_1501"
        },
        "definition": "A table of 20 numerical values which quantify a property (e.g. physicochemical or biochemical) of the common amino acids.",
        "text": "Amino acid index"
      }, {
        "comment": ["This combines data from all hybridisations."],
        "data": {
          "uri": "http://edamontology.org/data_3112"
        },
        "definition": "The final processed (normalised) data for a set of hybridisations in a microarray experiment.",
        "exact_synonyms": ["Gene expression data matrix", "Normalised microarray data"],
        "text": "Gene expression matrix"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_3917"
        },
        "definition": "A table of unnormalized values representing summarised read counts per genomic region (e.g. gene, transcript, peak).",
        "exact_synonyms": ["Read count matrix"],
        "text": "Count matrix"
      }, {
        "comment": ["Consider for example an HMM with two states (AT-rich and GC-rich).  The transition matrix will hold the probabilities of switching from the AT-rich to the GC-rich state, and vica versa."],
        "data": {
          "uri": "http://edamontology.org/data_3354"
        },
        "definition": "A HMM transition matrix contains the probabilities of switching from one HMM state to another.",
        "exact_synonyms": ["HMM transition matrix"],
        "text": "Transition matrix"
      }],
      "comment": ["This is a broad data type and is used a placeholder for other, more specific types."],
      "data": {
        "uri": "http://edamontology.org/data_2082"
      },
      "definition": "An array of numerical values.",
      "exact_synonyms": ["Array"],
      "text": "Matrix"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_3786"
      },
      "definition": "A structured query, in form of a script, that defines a database search task.",
      "text": "Query script"
    }, {
      "children": [{
        "children": [{
          "children": [{
            "comment": ["Information might include start and end position in a chromosome sequence, chromosome identifier, name of band and so on."],
            "data": {
              "uri": "http://edamontology.org/data_3236"
            },
            "definition": "The position of a cytogenetic band in a genome.",
            "text": "Cytoband position"
          }],
          "comment": ["This includes positions in genomes based on a reference sequence. A position may be specified for any mappable object, i.e. anything that may have positional information such as a physical position in a chromosome. Data might include sequence region name, strand, coordinate system name, assembly name, start position and end position."],
          "data": {
            "uri": "http://edamontology.org/data_2012"
          },
          "definition": "A position in a map (for example a genetic map), either a single position (point) or a region / interval.",
          "exact_synonyms": ["Locus", "Map position", "Sequence co-ordinates"],
          "text": "Sequence coordinates"
        }],
        "data": {
          "uri": "http://edamontology.org/data_1017"
        },
        "definition": "Specification of range(s) of sequence positions.",
        "text": "Sequence range"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_2190"
        },
        "definition": "A fixed-size datum calculated (by using a hash function) for a molecular sequence, typically for purposes of error detection or indexing.",
        "exact_synonyms": ["Hash value", "Hash", "Hash sum", "Hash code"],
        "text": "Sequence checksum"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_1249"
        },
        "definition": "The size (length) of a sequence, subsequence or region in a sequence, or range(s) of lengths.",
        "text": "Sequence length"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_1771"
        },
        "definition": "Information on an molecular sequence version.",
        "exact_synonyms": ["Sequence version information"],
        "text": "Sequence version"
      }, {
        "children": [{
          "children": [{
            "comment": ["Information might include start and end position in a chromosome sequence, chromosome identifier, name of band and so on."],
            "data": {
              "uri": "http://edamontology.org/data_3236"
            },
            "definition": "The position of a cytogenetic band in a genome.",
            "text": "Cytoband position"
          }],
          "comment": ["This includes positions in genomes based on a reference sequence. A position may be specified for any mappable object, i.e. anything that may have positional information such as a physical position in a chromosome. Data might include sequence region name, strand, coordinate system name, assembly name, start position and end position."],
          "data": {
            "uri": "http://edamontology.org/data_2012"
          },
          "definition": "A position in a map (for example a genetic map), either a single position (point) or a region / interval.",
          "exact_synonyms": ["Locus", "Map position", "Sequence co-ordinates"],
          "text": "Sequence coordinates"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1856"
          },
          "definition": "An insertion code (part of the residue number) for an amino acid residue from a PDB file.",
          "text": "PDB insertion code"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2216"
          },
          "definition": "The number of a codon, for instance, at which a mutation is located.",
          "text": "Codon number"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1742"
          },
          "definition": "A residue identifier (a string) from a PDB file.",
          "text": "PDB residue number"
        }],
        "data": {
          "uri": "http://edamontology.org/data_1016"
        },
        "definition": "A position of one or more points (base or residue) in a sequence, or part of such a specification.",
        "text": "Sequence position"
      }],
      "data": {
        "uri": "http://edamontology.org/data_2534"
      },
      "definition": "An attribute of a molecular sequence, possibly in reference to some other sequence.",
      "narrow_synonyms": ["Sequence parameter"],
      "text": "Sequence attribute"
    }, {
      "children": [{
        "comment": ["A codon usage table might include the codon usage table name, optional comments and a table with columns for codons and corresponding codon usage data. A genetic code can be extracted from or represented by a codon usage table."],
        "data": {
          "uri": "http://edamontology.org/data_1597"
        },
        "definition": "Table of codon usage data calculated from one or more nucleic acid sequences.",
        "has_topic": ["http://edamontology.org/topic_0203"],
        "text": "Codon usage table"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_1602"
        },
        "definition": "The differences in codon usage fractions between two codon usage tables.",
        "text": "Codon usage fraction difference"
      }, {
        "comment": ["A genetic code need not include detailed codon usage information."],
        "data": {
          "uri": "http://edamontology.org/data_1598"
        },
        "definition": "A genetic code for an organism.",
        "text": "Genetic code"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_1600"
        },
        "definition": "A plot of the synonymous codon usage calculated for windows over a nucleotide sequence.",
        "exact_synonyms": ["Synonymous codon usage statistic plot"],
        "text": "Codon usage bias plot"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_2865"
        },
        "definition": "A numerical measure of differences in the frequency of occurrence of synonymous codons in DNA sequences.",
        "text": "Codon usage bias"
      }],
      "comment": ["This is a broad data type and is used a placeholder for other, more specific types."],
      "data": {
        "uri": "http://edamontology.org/data_0914"
      },
      "definition": "Data derived from analysis of codon usage (typically a codon usage table) of DNA sequences.",
      "exact_synonyms": ["Codon usage report"],
      "has_topic": ["http://edamontology.org/topic_0203"],
      "text": "Codon usage data"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/data_3724"
        },
        "definition": "Experimental determined parameter for the cultivation of an organism.",
        "exact_synonyms": ["Cultivation conditions"],
        "narrow_synonyms": ["pH value", "Nitrogen source", "Salinity", "Culture media composition", "Carbon source", "Temperature"],
        "text": "Cultivation parameter"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_0940"
        },
        "definition": "Volume map data from electron microscopy.",
        "exact_synonyms": ["3D volume map", "EM volume map", "Electron microscopy volume map"],
        "has_topic": ["http://edamontology.org/topic_1317"],
        "text": "Volume map"
      }, {
        "comment": ["This is the raw data produced by a DNA sequencing machine."],
        "data": {
          "uri": "http://edamontology.org/data_0924"
        },
        "definition": "Fluorescence trace data generated by an automated DNA sequencer, which can be interprted as a molecular sequence (reads), given associated sequencing metadata such as base-call quality scores.",
        "text": "Sequence trace"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_0939"
          },
          "definition": "Protein secondary structure from protein coordinate or circular dichroism (CD) spectroscopic data.",
          "exact_synonyms": ["CD spectrum", "Protein circular dichroism (CD) spectroscopic data"],
          "text": "CD spectra"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_0938"
          },
          "definition": "Nuclear magnetic resonance (NMR) raw data, typically for a protein.",
          "narrow_synonyms": ["Protein NMR data"],
          "text": "Raw NMR data"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_0937"
          },
          "definition": "X-ray crystallography data.",
          "text": "Electron density map"
        }],
        "comment": ["This is a broad data type and is used a placeholder for other, more specific types.  It is primarily intended to help navigation of EDAM and would not typically be used for annotation."],
        "data": {
          "uri": "http://edamontology.org/data_2537"
        },
        "definition": "Raw data from experimental methods for determining protein structure.",
        "text": "Protein structure raw data"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_3722"
        },
        "definition": "Experimentally determined parameter of the physiology of an organism, e.g. substrate spectrum.",
        "text": "Physiology parameter"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_3723"
        },
        "definition": "Experimentally determined parameter of the morphology of an organism, e.g. size & shape.",
        "text": "Morphology parameter"
      }, {
        "comment": ["This is a broad data type and is used a placeholder for other, more specific types.  It is primarily intended to help navigation of EDAM and would not typically be used for annotation."],
        "data": {
          "uri": "http://edamontology.org/data_0905"
        },
        "definition": "Protein-protein interaction data from for example yeast two-hybrid analysis, protein microarrays, immunoaffinity chromatography followed by mass spectrometry, phage display etc.",
        "text": "Protein interaction raw data"
      }, {
        "comment": ["Radiation Hybrid (RH) scores are used in Radiation Hybrid mapping."],
        "data": {
          "uri": "http://edamontology.org/data_0926"
        },
        "definition": "Radiation hybrid scores (RH) scores for one or more markers.",
        "exact_synonyms": ["Radiation Hybrid (RH) scores"],
        "text": "RH scores"
      }, {
        "comment": ["Such data as found in Affymetrix CEL or GPR files."],
        "data": {
          "uri": "http://edamontology.org/data_3110"
        },
        "definition": "Raw data (typically MIAME-compliant) for hybridisations from a microarray experiment.",
        "text": "Raw microarray data"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_0943"
          },
          "definition": "Spectra from mass spectrometry.",
          "exact_synonyms": ["Mass spectrometry spectra"],
          "has_topic": ["http://edamontology.org/topic_0121"],
          "text": "Mass spectrum"
        }, {
          "comment": ["A molecular weight standard fingerprint is standard protonated molecular masses e.g. from trypsin (modified porcine trypsin, Promega) and keratin peptides."],
          "data": {
            "uri": "http://edamontology.org/data_0944"
          },
          "definition": "A set of peptide masses (peptide mass fingerprint) from mass spectrometry.",
          "exact_synonyms": ["Peak list", "Protein fingerprint"],
          "has_topic": ["http://edamontology.org/topic_0121"],
          "narrow_synonyms": ["Molecular weights standard fingerprint"],
          "text": "Peptide mass fingerprint"
        }],
        "data": {
          "uri": "http://edamontology.org/data_2536"
        },
        "definition": "Data concerning a mass spectrometry measurement.",
        "text": "Mass spectrometry data"
      }],
      "comment": ["This is a broad data type and is used a placeholder for other, more specific types. It is primarily intended to help navigation of EDAM and would not typically be used for annotation."],
      "data": {
        "uri": "http://edamontology.org/data_3108"
      },
      "definition": "Raw data such as measurements or other results from laboratory experiments, as generated from laboratory hardware.",
      "exact_synonyms": ["Measurement", "Measured data", "Experimentally measured data", "Measurement data", "Experimental measurement data"],
      "narrow_synonyms": ["Raw experimental data", "Measurement metadata"],
      "text": "Experimental measurement"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_2589"
      },
      "definition": "Raw data on a biological hierarchy, describing the hierarchy proper, hierarchy components and possibly associated annotation.",
      "exact_synonyms": ["Hierarchy annotation"],
      "text": "Hierarchy"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/data_2007"
        },
        "definition": "A word or phrase that can appear in the keywords field (KW line) of entries from the UniProt database.",
        "text": "UniProt keyword"
      }],
      "comment": ["Boolean operators (AND, OR and NOT) and wildcard characters may be allowed."],
      "data": {
        "uri": "http://edamontology.org/data_0968"
      },
      "definition": "Keyword(s) or phrase(s) used (typically) for text-searching purposes.",
      "exact_synonyms": ["Term", "Phrases"],
      "text": "Keyword"
    }, {
      "children": [{
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_1497"
          },
          "definition": "Root-mean-square deviation (RMSD) is calculated to measure the average distance between superimposed macromolecular coordinates.",
          "exact_synonyms": ["RMSD"],
          "text": "Root-mean-square deviation"
        }, {
          "comment": ["A ligand fingerprint is derived from ligand structural data from a Protein DataBank file. It reflects the elements or groups present or absent, covalent bonds and bond orders and the bonded environment in terms of SATIS codes and BLEEP atom types."],
          "data": {
            "uri": "http://edamontology.org/data_1498"
          },
          "definition": "A measure of the similarity between two ligand fingerprints.",
          "text": "Tanimoto similarity score"
        }],
        "data": {
          "uri": "http://edamontology.org/data_0888"
        },
        "definition": "A value representing molecular structure similarity, measured from structure alignment or some other type of structure comparison.",
        "text": "Structure similarity score"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_1412"
          },
          "definition": "Sequence identity is the number (%) of matches (identical characters) in positions from an alignment of two molecular sequences.",
          "text": "Sequence identity"
        }, {
          "children": [{
            "comment": ["Bit scores are normalised with respect to the scoring system and therefore can be used to compare alignment scores from different searches."],
            "data": {
              "uri": "http://edamontology.org/data_2335"
            },
            "definition": "A score derived from the alignment of two sequences, which is then normalised with respect to the scoring system.",
            "text": "Bit score"
          }],
          "comment": ["Data Type is float probably."],
          "data": {
            "uri": "http://edamontology.org/data_1413"
          },
          "definition": "Sequence similarity is the similarity (expressed as a percentage) of two molecular sequences calculated from their alignment, a scoring matrix for scoring characters substitutions and penalties for gap insertion and extension.",
          "text": "Sequence similarity"
        }],
        "data": {
          "uri": "http://edamontology.org/data_0865"
        },
        "definition": "A value representing molecular sequence similarity.",
        "text": "Sequence similarity score"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_1402"
          },
          "definition": "The score (penalty) for a 'mismatch' used in various alignment and sequence database search applications with simple scoring schemes.",
          "text": "Mismatch penalty score"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1403"
          },
          "definition": "This is the threshold drop in score at which extension of word alignment is halted.",
          "text": "Drop off score"
        }, {
          "children": [{
            "children": [{
              "data": {
                "uri": "http://edamontology.org/data_1411"
              },
              "definition": "A number defining the penalty for extending gaps at the termini of an alignment, either from the N/C terminal of protein or 5'/3' terminal of nucleotide sequences.",
              "text": "Terminal gap extension penalty"
            }],
            "data": {
              "uri": "http://edamontology.org/data_1398"
            },
            "definition": "A penalty for extending a gap in an alignment.",
            "text": "Gap extension penalty"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1399"
            },
            "definition": "A penalty for gaps that are close together in an alignment.",
            "text": "Gap separation penalty"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/data_1410"
              },
              "definition": "A number defining the penalty for opening gaps at the termini of an alignment, either from the N/C terminal of protein or 5'/3' terminal of nucleotide sequences.",
              "text": "Terminal gap opening penalty"
            }],
            "data": {
              "uri": "http://edamontology.org/data_1397"
            },
            "definition": "A penalty for opening a gap in an alignment.",
            "text": "Gap opening penalty"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2137"
          },
          "definition": "A penalty for introducing or extending a gap in an alignment.",
          "text": "Gap penalty"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1401"
          },
          "definition": "The score for a 'match' used in various sequence database search applications with simple scoring schemes.",
          "text": "Match reward score"
        }],
        "data": {
          "uri": "http://edamontology.org/data_1394"
        },
        "definition": "A simple floating point number defining the penalty for opening or extending a gap in an alignment.",
        "text": "Alignment score or penalty"
      }, {
        "children": [{
          "comment": ["An expectation value (E-Value) is the expected number of observations which are at least as extreme as observations expected to occur by random chance. The E-value describes the number of hits with a given score or better that are expected to occur at random when searching a database of a particular size. It decreases exponentially with the score (S) of a hit. A low E value indicates a more significant score."],
          "data": {
            "uri": "http://edamontology.org/data_1667"
          },
          "definition": "A simple floating point number defining the lower or upper limit of an expectation value (E-value).",
          "exact_synonyms": ["Expectation value"],
          "text": "E-value"
        }, {
          "comment": ["Q-values are widely used in high-throughput data analysis (e.g. detection of differentially expressed genes from transcriptome data)."],
          "data": {
            "uri": "http://edamontology.org/data_3932"
          },
          "definition": "A score derived from the P-value to ensure correction for multiple tests. The Q-value provides an estimate of the positive False Discovery Rate (pFDR), i.e. the rate of false positives among all the cases reported positive: pFDR = FP / (FP + TP).",
          "exact_synonyms": ["Adjusted P-value", "Padj", "FDR", "pFDR"],
          "text": "Q-value"
        }, {
          "comment": ["A z-value might be specified as a threshold for reporting hits from database searches."],
          "data": {
            "uri": "http://edamontology.org/data_1669"
          },
          "definition": "The P-value is the probability of obtaining by random chance a result that is at least as extreme as an observed result, assuming a NULL hypothesis is true.",
          "text": "P-value"
        }, {
          "comment": ["A z-value might be specified as a threshold for reporting hits from database searches."],
          "data": {
            "uri": "http://edamontology.org/data_1668"
          },
          "definition": "The z-value is the number of standard deviations a data value is above or below a mean value.",
          "text": "Z-value"
        }],
        "data": {
          "uri": "http://edamontology.org/data_0951"
        },
        "definition": "A value representing estimated statistical significance of some observed data; typically sequence database hits.",
        "text": "Statistical estimate score"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_3756"
        },
        "definition": "Score for localization of one or more post-translational modifications in peptide sequence measured by mass spectrometry.",
        "narrow_synonyms": ["PTM localisation", "PTM score", "False localisation rate"],
        "text": "Localisation score"
      }],
      "data": {
        "uri": "http://edamontology.org/data_1772"
      },
      "definition": "A numerical value, that is some type of scored value arising for example from a prediction method.",
      "text": "Score"
    }, {
      "comment": ["This is a broad data type and is used a placeholder for other, more specific types."],
      "data": {
        "uri": "http://edamontology.org/data_3028"
      },
      "definition": "Data concerning the classification, identification and naming of organisms.",
      "exact_synonyms": ["Taxonomic data"],
      "has_topic": ["http://edamontology.org/topic_0084"],
      "text": "Taxonomy"
    }, {
      "children": [{
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_2886"
          },
          "definition": "A protein sequence and associated metadata.",
          "exact_synonyms": ["Sequence record (protein)"],
          "text": "Protein sequence record"
        }],
        "data": {
          "uri": "http://edamontology.org/data_2976"
        },
        "definition": "One or more protein sequences, possibly with associated annotation.",
        "exact_synonyms": ["Amino acid sequences", "Amino acid sequence", "Protein sequences"],
        "text": "Protein sequence"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_2887"
          },
          "definition": "A nucleic acid sequence and associated metadata.",
          "exact_synonyms": ["Nucleotide sequence record", "Sequence record (nucleic acid)"],
          "narrow_synonyms": ["DNA sequence record", "RNA sequence record"],
          "text": "Nucleic acid sequence record"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_3495"
          },
          "definition": "An RNA sequence.",
          "exact_synonyms": ["RNA sequences"],
          "text": "RNA sequence"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_3494"
          },
          "definition": "A DNA sequence.",
          "exact_synonyms": ["DNA sequences"],
          "text": "DNA sequence"
        }],
        "data": {
          "uri": "http://edamontology.org/data_2977"
        },
        "definition": "One or more nucleic acid sequences, possibly with associated annotation.",
        "exact_synonyms": ["Nucleotide sequences", "Nucleotide sequence", "Nucleic acid sequences"],
        "narrow_synonyms": ["DNA sequence"],
        "text": "Nucleic acid sequence"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_2887"
          },
          "definition": "A nucleic acid sequence and associated metadata.",
          "exact_synonyms": ["Nucleotide sequence record", "Sequence record (nucleic acid)"],
          "narrow_synonyms": ["DNA sequence record", "RNA sequence record"],
          "text": "Nucleic acid sequence record"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2886"
          },
          "definition": "A protein sequence and associated metadata.",
          "exact_synonyms": ["Sequence record (protein)"],
          "text": "Protein sequence record"
        }],
        "data": {
          "uri": "http://edamontology.org/data_0849"
        },
        "definition": "A molecular sequence and associated metadata.",
        "text": "Sequence record"
      }],
      "comment": ["This concept is a placeholder of concepts for primary sequence data including raw sequences and sequence records.  It should not normally be used for derivatives such as sequence alignments, motifs or profiles."],
      "data": {
        "uri": "http://edamontology.org/data_2044"
      },
      "definition": "One or more molecular sequences, possibly with associated annotation.",
      "exact_synonyms": ["Sequences"],
      "has_topic": ["http://edamontology.org/topic_0080"],
      "text": "Sequence"
    }, {
      "children": [{
        "comment": ["A \"sequence-profile alignment\" is an alignment of one or more molecular sequence(s) to one or more sequence profile(s) (each profile typically representing a sequence alignment).", "This includes reports of hits from a search of a protein secondary or domain database. Data associated with the search or alignment might also be included, e.g. ranked list of best-scoring sequences, a graphical representation of scores etc.", "A \"profile-profile alignment\" is an alignment of two sequence profiles, each profile typically representing a sequence alignment."],
        "data": {
          "uri": "http://edamontology.org/data_0858"
        },
        "definition": "Report on the location of matches (\"hits\") between sequences, sequence profiles, motifs (conserved or functional patterns) and other types of sequence signatures.",
        "narrow_synonyms": ["Sequence profile alignment", "Search results (protein secondary database)", "Sequence motif hits", "Protein secondary database search results", "Profile-profile alignment", "Sequence profile matches", "Sequence motif matches", "Sequence-profile alignment", "Sequence profile hits"],
        "text": "Sequence signature matches"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_2071"
          },
          "definition": "An amino acid sequence motif.",
          "exact_synonyms": ["Protein sequence motif"],
          "text": "Sequence motif (protein)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2070"
          },
          "definition": "A nucleotide sequence motif.",
          "exact_synonyms": ["Nucleic acid sequence motif"],
          "narrow_synonyms": ["DNA sequence motif", "RNA sequence motif"],
          "text": "Sequence motif (nucleic acid)"
        }],
        "data": {
          "uri": "http://edamontology.org/data_1353"
        },
        "definition": "Any specific or conserved pattern (typically expressed as a regular expression) in a molecular sequence.",
        "has_topic": ["http://edamontology.org/topic_0160"],
        "text": "Sequence motif"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_3949"
          },
          "definition": "A profile HMM is a variant of a Hidden Markov model that is derived specifically from a set of (aligned) biological sequences. Profile HMMs provide the basis for a position-specific scoring system, which can be used to align sequences and search databases for related sequences.",
          "text": "Profile HMM"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_1361"
            },
            "definition": "A profile (typically representing a sequence alignment) that is a simple matrix of nucleotide (or amino acid) counts per position.",
            "exact_synonyms": ["PFM"],
            "text": "Position frequency matrix"
          }, {
            "comment": ["Contributions of individual sequences to the matrix might be uneven (weighted)."],
            "data": {
              "uri": "http://edamontology.org/data_1362"
            },
            "definition": "A profile (typically representing a sequence alignment) that is weighted matrix of nucleotide (or amino acid) counts per position.",
            "exact_synonyms": ["PWM"],
            "text": "Position weight matrix"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1365"
            },
            "definition": "One or more fingerprints (sequence classifiers) as used in the PRINTS database.",
            "text": "Fingerprint"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1363"
            },
            "definition": "A profile (typically representing a sequence alignment) derived from a matrix of nucleotide (or amino acid) counts per position that reflects information content at each position.",
            "exact_synonyms": ["ICM"],
            "text": "Information content matrix"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2854"
          },
          "definition": "A simple matrix of numbers, where each value (or column of values) is derived derived from analysis of the corresponding position in a sequence alignment.",
          "exact_synonyms": ["PSSM"],
          "text": "Position-specific scoring matrix"
        }],
        "data": {
          "uri": "http://edamontology.org/data_1354"
        },
        "definition": "Some type of statistical model representing a (typically multiple) sequence alignment.",
        "has_topic": ["http://edamontology.org/topic_0160"],
        "text": "Sequence profile"
      }],
      "comment": ["This can include metadata about a motif or sequence profile such as its name, length, technical details about the profile construction, and so on."],
      "data": {
        "uri": "http://edamontology.org/data_0860"
      },
      "definition": "Data concering concerning specific or conserved pattern in molecular sequences and the classifiers used for their identification, including sequence motifs, profiles or other diagnostic element.",
      "has_topic": ["http://edamontology.org/topic_0160"],
      "text": "Sequence signature data"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_2042"
      },
      "definition": "Typically a human-readable summary of body of facts or information indicating why a statement is true or valid. This may include a computational prediction, laboratory experiment, literature reference etc.",
      "text": "Evidence"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/data_1444"
        },
        "definition": "Independent contrasts for characters used in a phylogenetic tree, or covariances, regressions and correlations between characters for those contrasts.",
        "exact_synonyms": ["Phylogenetic report (character contrasts)"],
        "text": "Phylogenetic character contrasts"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_1429"
        },
        "definition": "Phylogenetic invariants data for testing alternative tree topologies.",
        "exact_synonyms": ["Phylogenetic report (invariants)"],
        "has_topic": ["http://edamontology.org/topic_0199"],
        "text": "Phylogenetic invariants"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_3272"
          },
          "definition": "A phylogenetic tree that reflects phylogeny of the taxa from which the characters (used in calculating the tree) were sampled.",
          "text": "Species tree"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_3271"
          },
          "definition": "A phylogenetic tree that is an estimate of the character's phylogeny.",
          "text": "Gene tree"
        }],
        "comment": ["A phylogenetic tree is usually constructed from a set of sequences from which an alignment (or data matrix) is calculated. See also 'Phylogenetic tree image'."],
        "data": {
          "uri": "http://edamontology.org/data_0872"
        },
        "definition": "The raw data (not just an image) from which a phylogenetic tree is directly generated or plotted, such as topology, lengths (in time or in expected amounts of variance) and a confidence interval for each length.",
        "exact_synonyms": ["Phylogeny"],
        "has_topic": ["http://edamontology.org/topic_0084"],
        "text": "Phylogenetic tree"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_1428"
        },
        "definition": "One or more cliques of mutually compatible characters that are generated, for example from analysis of discrete character data, and are used to generate a phylogeny.",
        "exact_synonyms": ["Phylogenetic report (cliques)"],
        "text": "Phylogenetic character cliques"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_1442"
        },
        "definition": "Distances, such as Branch Score distance, between two or more phylogenetic trees.",
        "exact_synonyms": ["Phylogenetic tree report (tree distances)"],
        "text": "Phylogenetic tree distances"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_1427"
          },
          "definition": "Character data with discrete states that may be read during phylogenetic tree calculation.",
          "exact_synonyms": ["Discretely coded characters", "Discrete characters", "Phylogenetic discrete states"],
          "text": "Phylogenetic discrete data"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2873"
            },
            "definition": "Gene frequencies data that may be read during phylogenetic tree calculation.",
            "text": "Phylogenetic gene frequencies data"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1426"
          },
          "definition": "Continuous quantitative data that may be read during phylogenetic tree calculation.",
          "exact_synonyms": ["Phylogenetic continuous quantitative characters", "Quantitative traits"],
          "text": "Phylogenetic continuous quantitative data"
        }],
        "comment": ["As defined, this concept would also include molecular sequences, microsatellites, polymorphisms (RAPDs, RFLPs, or AFLPs), restriction sites and fragments"],
        "data": {
          "uri": "http://edamontology.org/data_0871"
        },
        "definition": "Basic character data from which a phylogenetic tree may be generated.",
        "text": "Phylogenetic character data"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_2994"
        },
        "definition": "Weights for sequence positions or characters in phylogenetic analysis where zero is defined as unweighted.",
        "text": "Phylogenetic character weights"
      }],
      "comment": ["This is a broad data type and is used a placeholder for other, more specific types."],
      "data": {
        "uri": "http://edamontology.org/data_2523"
      },
      "definition": "Data concerning phylogeny, typically of molecular sequences, including reports of information concerning or derived from a phylogenetic tree, or from comparing two or more phylogenetic trees.",
      "text": "Phylogenetic data"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/data_0582"
        },
        "definition": "An ontology of biological or bioinformatics concepts and relations, a controlled vocabulary, structured glossary etc.",
        "has_topic": ["http://edamontology.org/topic_0089"],
        "text": "Ontology"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_0966"
          },
          "definition": "A term (name) from an ontology.",
          "exact_synonyms": ["Ontology terms", "Ontology class name"],
          "text": "Ontology term"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1731"
          },
          "definition": "The definition of a concept from an ontology.",
          "exact_synonyms": ["Ontology class definition"],
          "text": "Ontology concept definition"
        }],
        "data": {
          "uri": "http://edamontology.org/data_0967"
        },
        "definition": "Data concerning or derived from a concept from a biological ontology.",
        "exact_synonyms": ["Ontology term metadata", "Ontology class metadata"],
        "text": "Ontology concept data"
      }, {
        "comment": ["This includes any fields from the concept definition such as concept name, definition, comments and so on."],
        "data": {
          "uri": "http://edamontology.org/data_2858"
        },
        "definition": "A concept from a biological ontology.",
        "text": "Ontology concept"
      }],
      "comment": ["This is a broad data type and is used a placeholder for other, more specific types."],
      "data": {
        "uri": "http://edamontology.org/data_2353"
      },
      "definition": "Data concerning or derived from an ontology.",
      "exact_synonyms": ["Ontological data"],
      "has_topic": ["http://edamontology.org/topic_0089"],
      "text": "Ontology data"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/data_3002"
        },
        "definition": "Annotation of one particular positional feature on a biomolecular (typically genome) sequence, suitable for import and display in a genome browser.",
        "exact_synonyms": ["Genome annotation track", "Sequence annotation track", "Genome-browser track", "Genome track", "Genomic track"],
        "text": "Annotation track"
      }, {
        "comment": ["This includes protein sequence feature annotation in any known sequence feature table format and any other report of protein features."],
        "data": {
          "uri": "http://edamontology.org/data_1277"
        },
        "definition": "An informative report on intrinsic positional features of a protein sequence.",
        "exact_synonyms": ["Feature table (protein)", "Protein feature table"],
        "text": "Protein features"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_1270"
        },
        "definition": "Annotation of positional sequence features, organised into a standard feature table.",
        "exact_synonyms": ["Sequence feature table"],
        "text": "Feature table"
      }, {
        "children": [{
          "comment": ["This includes 5'untranslated region (5'UTR), coding sequences (CDS), exons, intervening sequences (intron) and 3'untranslated regions (3'UTR)."],
          "data": {
            "uri": "http://edamontology.org/data_3134"
          },
          "definition": "An informative report on features of a messenger RNA (mRNA) molecules including precursor RNA, primary (unprocessed) transcript and fully processed molecules. This includes reports on a specific gene transcript, clone or EST.",
          "exact_synonyms": ["Transcript (report)", "mRNA (report)", "Clone or EST (report)", "mRNA features", "Gene transcript annotation", "Nucleic acid features (mRNA features)"],
          "text": "Gene transcript report"
        }],
        "comment": ["This includes nucleotide sequence feature annotation in any known sequence feature table format and any other report of nucleic acid features."],
        "data": {
          "uri": "http://edamontology.org/data_1276"
        },
        "definition": "An informative report on intrinsic positional features of a nucleotide sequence, formatted to be machine-readable.",
        "exact_synonyms": ["Nucleic acid feature table", "Feature table (nucleic acid)"],
        "narrow_synonyms": ["Genome features", "Genomic features"],
        "text": "Nucleic acid features"
      }],
      "comment": ["This includes annotation of positional sequence features, organised into a standard feature table, or any other report of sequence features.  General feature reports are a source of sequence feature table information although internal conversion would be required."],
      "data": {
        "uri": "http://edamontology.org/data_1255"
      },
      "definition": "Annotation of positional features of molecular sequence(s), i.e. that can be mapped to position(s) in the sequence.",
      "exact_synonyms": ["Feature record", "General sequence features", "Features", "Sequence features report"],
      "text": "Sequence features"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/data_1714"
        },
        "definition": "An image of spots from a microarray experiment.",
        "text": "Microarray spots image"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_1636"
          },
          "definition": "A graphical 2D tabular representation of expression data, typically derived from an omics experiment. A heat map is a table where rows and columns correspond to different features and contexts (for example, cells or samples) and the cell colour represents the level of expression of a gene that context.",
          "text": "Heat map"
        }],
        "data": {
          "uri": "http://edamontology.org/data_3768"
        },
        "definition": "Groupings of expression profiles according to a clustering algorithm.",
        "narrow_synonyms": ["Clustered gene expression profiles"],
        "text": "Clustered expression profiles"
      }, {
        "children": [{
          "comment": ["This includes tag to gene assignments (tag mapping) of SAGE, MPSS and SBS data. Typically this is the sequencing-based expression profile annotated with gene identifiers.", "SAGE, MPSS and SBS experiments are usually performed to study gene expression.  The sequence tags are typically subsequently annotated (after a database search) with the mRNA (and therefore gene) the tag was extracted from."],
          "data": {
            "uri": "http://edamontology.org/data_2535"
          },
          "definition": "Output from a serial analysis of gene expression (SAGE), massively parallel signature sequencing (MPSS) or sequencing by synthesis (SBS) experiment.  In all cases this is a list of short sequence tags and the number of times it is observed.",
          "exact_synonyms": ["Sequencing-based expression profile"],
          "narrow_synonyms": ["Sequence tag profile (with gene assignment)"],
          "text": "Sequence tag profile"
        }],
        "data": {
          "uri": "http://edamontology.org/data_0928"
        },
        "definition": "Data quantifying the level of expression of (typically) multiple genes, derived for example from microarray experiments.",
        "text": "Gene expression profile"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_2717"
          },
          "definition": "General annotation on an oligonucleotide probe, or a set of probes.",
          "has_topic": ["http://edamontology.org/topic_0632"],
          "narrow_synonyms": ["Oligonucleotide probe sets annotation"],
          "text": "Oligonucleotide probe annotation"
        }],
        "comment": ["This might include gene identifiers, genomic coordinates, probe oligonucleotide sequences etc."],
        "data": {
          "uri": "http://edamontology.org/data_3115"
        },
        "definition": "Annotation on the array itself used in a microarray experiment.",
        "text": "Microarray metadata"
      }, {
        "children": [{
          "comment": ["Such data as found in Affymetrix .CHP files or data from other software such as RMA or dChip."],
          "data": {
            "uri": "http://edamontology.org/data_3111"
          },
          "definition": "Data generated from processing and analysis of probe set data from a microarray experiment.",
          "exact_synonyms": ["Gene expression report", "Gene annotation (expression)", "Microarray probe set data"],
          "has_topic": ["http://edamontology.org/topic_0203"],
          "text": "Processed microarray data"
        }, {
          "comment": ["Such data as found in Affymetrix CEL or GPR files."],
          "data": {
            "uri": "http://edamontology.org/data_3110"
          },
          "definition": "Raw data (typically MIAME-compliant) for hybridisations from a microarray experiment.",
          "text": "Raw microarray data"
        }],
        "data": {
          "uri": "http://edamontology.org/data_3117"
        },
        "definition": "Data concerning the hybridisations measured during a microarray experiment.",
        "text": "Microarray hybridisation data"
      }, {
        "comment": ["This combines data from all hybridisations."],
        "data": {
          "uri": "http://edamontology.org/data_3112"
        },
        "definition": "The final processed (normalised) data for a set of hybridisations in a microarray experiment.",
        "exact_synonyms": ["Gene expression data matrix", "Normalised microarray data"],
        "text": "Gene expression matrix"
      }],
      "data": {
        "uri": "http://edamontology.org/data_2603"
      },
      "definition": "Image, hybridisation or some other data arising from a study of feature/molecule expression, typically profiling or quantification.",
      "has_topic": ["http://edamontology.org/topic_0203"],
      "narrow_synonyms": ["Metabolite expression data", "mRNA profile", "Transcriptome quantification data", "Gene transcription quantification data", "Transcriptome profile", "Protein expression data", "Gene product profile", "RNA-seq data", "Microarray data", "Non-coding RNA profile", "mRNA quantification data", "Gene expression data", "Gene product quantification data", "RNA profile", "Gene transcription profile", "RNA quantification data", "Non-coding RNA quantification data"],
      "text": "Expression data"
    }, {
      "children": [{
        "children": [{
          "children": [{
            "comment": ["Model validation might involve checks for atomic packing, steric clashes, agreement with electron density maps etc."],
            "data": {
              "uri": "http://edamontology.org/data_1539"
            },
            "definition": "Report on the quality of a protein three-dimensional model.",
            "exact_synonyms": ["Protein property (structural quality)", "Protein report (structural quality)", "Protein structure validation report", "Protein structure report (quality evaluation)"],
            "text": "Protein structural quality report"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1537"
          },
          "definition": "A human-readable collection of information about one or more specific protein 3D structure(s) or structural domains.",
          "exact_synonyms": ["Protein structure report (domain)", "Protein report (structure)", "Protein property (structural)", "Protein structure-derived report", "Protein structural property"],
          "text": "Protein structure report"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_1696"
            },
            "definition": "A human-readable collection of information about a specific drug.",
            "exact_synonyms": ["Drug annotation"],
            "has_topic": ["http://edamontology.org/topic_0154"],
            "narrow_synonyms": ["Drug structure relationship map"],
            "text": "Drug report"
          }],
          "data": {
            "uri": "http://edamontology.org/data_0962"
          },
          "definition": "A human-readable collection of information about a specific chemical compound.",
          "exact_synonyms": ["Chemical compound annotation", "Small molecule annotation", "Chemical structure report"],
          "has_topic": ["http://edamontology.org/topic_0154"],
          "text": "Small molecule report"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2313"
          },
          "definition": "A human-readable collection of information about one or more specific carbohydrate 3D structure(s).",
          "text": "Carbohydrate report"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2879"
          },
          "definition": "A human-readable collection of information about one or more specific lipid 3D structure(s).",
          "text": "Lipid report"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_3128"
          },
          "definition": "A human-readable collection of information about regions within a nucleic acid sequence which form secondary or tertiary (3D) structures.",
          "exact_synonyms": ["Nucleic acid features (structure)"],
          "narrow_synonyms": ["d-loop (report)", "Stem loop (report)", "Quadruplexes (report)"],
          "text": "Nucleic acid structure report"
        }],
        "data": {
          "uri": "http://edamontology.org/data_2085"
        },
        "definition": "A human-readable collection of information about one or more molecular tertiary (3D) structures.  It might include annotation on the structure, a computer-generated report of analysis of structural data, and metadata (data about primary data) or any other free (essentially unformatted) text, as distinct from the primary data itself.",
        "exact_synonyms": ["Structure-derived report"],
        "text": "Structure report"
      }, {
        "children": [{
          "comment": ["The report might correlate gene expression or single-nucleotide polymorphisms with drug efficacy or toxicity."],
          "data": {
            "uri": "http://edamontology.org/data_1621"
          },
          "definition": "A human-readable collection of information about the influence of genotype on drug response.",
          "text": "Pharmacogenomic test report"
        }, {
          "comment": ["For example, an informative report on a specific tumor including nature and origin of the sample, anatomic site, organ or tissue, tumor type, including morphology and/or histologic type, and so on."],
          "data": {
            "uri": "http://edamontology.org/data_1622"
          },
          "definition": "A human-readable collection of information about a specific disease.",
          "has_topic": ["http://edamontology.org/topic_0634"],
          "text": "Disease report"
        }],
        "data": {
          "uri": "http://edamontology.org/data_0920"
        },
        "definition": "A human-readable collection of information about the set of genes (or allelic forms) present in an individual, organism or cell and associated with a specific physical characteristic, or a report concerning an organisms traits and phenotypes.",
        "exact_synonyms": ["Genotype/phenotype annotation"],
        "text": "Genotype/phenotype report"
      }, {
        "children": [{
          "children": [{
            "comment": ["Model validation might involve checks for atomic packing, steric clashes, agreement with electron density maps etc."],
            "data": {
              "uri": "http://edamontology.org/data_1539"
            },
            "definition": "Report on the quality of a protein three-dimensional model.",
            "exact_synonyms": ["Protein property (structural quality)", "Protein report (structural quality)", "Protein structure validation report", "Protein structure report (quality evaluation)"],
            "text": "Protein structural quality report"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1537"
          },
          "definition": "A human-readable collection of information about one or more specific protein 3D structure(s) or structural domains.",
          "exact_synonyms": ["Protein structure report (domain)", "Protein report (structure)", "Protein property (structural)", "Protein structure-derived report", "Protein structural property"],
          "text": "Protein structure report"
        }, {
          "comment": ["This includes protein sequence feature annotation in any known sequence feature table format and any other report of protein features."],
          "data": {
            "uri": "http://edamontology.org/data_1277"
          },
          "definition": "An informative report on intrinsic positional features of a protein sequence.",
          "exact_synonyms": ["Feature table (protein)", "Protein feature table"],
          "text": "Protein features"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_0907"
          },
          "definition": "An informative report on a specific protein family or other classification or group of protein sequences or structures.",
          "exact_synonyms": ["Protein family annotation"],
          "has_topic": ["http://edamontology.org/topic_0623"],
          "text": "Protein family report"
        }],
        "data": {
          "uri": "http://edamontology.org/data_0896"
        },
        "definition": "An informative human-readable report about one or more specific protein molecules or protein structural domains, derived from analysis of primary (sequence or structural) data.",
        "exact_synonyms": ["Gene product annotation"],
        "text": "Protein report"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_3861"
        },
        "definition": "A human-readable systematic collection of patient (or population) health information in a digital format.",
        "exact_synonyms": ["Electronic medical record", "EMR", "EHR"],
        "text": "Electronic health record"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_2984"
        },
        "definition": "An informative report concerning or derived from the analysis of a biological pathway or network, such as a map (diagram) or annotation.",
        "has_topic": ["http://edamontology.org/topic_0602"],
        "text": "Pathway or network report"
      }, {
        "comment": ["This can include basic provenance and technical information about the image, scientific annotation and so on."],
        "data": {
          "uri": "http://edamontology.org/data_3546"
        },
        "definition": "Any data concerning a specific biological or biomedical image.",
        "exact_synonyms": ["Image-associated data", "Image-related data"],
        "text": "Image metadata"
      }, {
        "children": [{
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_1260"
            },
            "definition": "A report on ambiguity in molecular sequence(s).",
            "exact_synonyms": ["Sequence property (ambiguity)"],
            "text": "Sequence ambiguity report"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/data_1265"
              },
              "definition": "A table of base frequencies of a nucleotide sequence.",
              "text": "Base frequencies table"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1267"
              },
              "definition": "A table of amino acid frequencies of a protein sequence.",
              "exact_synonyms": ["Sequence composition (amino acid frequencies)"],
              "text": "Amino acid frequencies table"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2167"
              },
              "definition": "Density plot (of base composition) for a nucleotide sequence.",
              "text": "Nucleic acid density plot"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1266"
              },
              "definition": "A table of word composition of a nucleotide sequence.",
              "text": "Base word frequencies table"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1263"
              },
              "definition": "A plot of third base position variability in a nucleotide sequence.",
              "text": "Base position variability plot"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2166"
              },
              "definition": "A plot of character or word composition / frequency of a molecular sequence.",
              "text": "Sequence composition plot"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1268"
              },
              "definition": "A table of amino acid word composition of a protein sequence.",
              "exact_synonyms": ["Sequence composition (amino acid words)"],
              "text": "Amino acid word frequencies table"
            }],
            "data": {
              "uri": "http://edamontology.org/data_1261"
            },
            "definition": "A report (typically a table) on character or word composition / frequency of a molecular sequence(s).",
            "exact_synonyms": ["Sequence composition", "Sequence property (composition)"],
            "text": "Sequence composition report"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1259"
            },
            "definition": "A report on sequence complexity, for example low-complexity or repeat regions in sequences.",
            "exact_synonyms": ["Sequence property (complexity)"],
            "text": "Sequence complexity report"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1254"
          },
          "definition": "An informative report about non-positional sequence features, typically a report on general molecular sequence properties derived from sequence analysis.",
          "exact_synonyms": ["Sequence properties report"],
          "text": "Sequence property"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2168"
            },
            "definition": "Image of a sequence trace (nucleotide sequence versus probabilities of each of the 4 bases).",
            "text": "Sequence trace image"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1289"
            },
            "definition": "Image of the restriction enzyme cleavage sites (restriction sites) in a nucleic acid sequence.",
            "text": "Restriction map"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2969"
          },
          "definition": "Image of a molecular sequence, possibly with sequence features or properties shown.",
          "text": "Sequence image"
        }],
        "data": {
          "uri": "http://edamontology.org/data_2955"
        },
        "definition": "An informative report of information about molecular sequence(s), including basic information (metadata), and reports generated from molecular sequence analysis, including positional features and non-positional properties.",
        "exact_synonyms": ["Sequence-derived report"],
        "text": "Sequence report"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_3718"
          },
          "definition": "Information about the ability of an organism to cause disease in a corresponding host.",
          "exact_synonyms": ["Pathogenicity"],
          "text": "Pathogenicity report"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_3719"
          },
          "definition": "Information about the biosafety classification of an organism according to corresponding law.",
          "exact_synonyms": ["Biosafety level"],
          "text": "Biosafety classification"
        }],
        "data": {
          "uri": "http://edamontology.org/data_3716"
        },
        "definition": "A human-readable collection of information concerning biosafety data.",
        "exact_synonyms": ["Biosafety information"],
        "text": "Biosafety report"
      }, {
        "comment": ["This is a broad data type and is used a placeholder for other, more specific types."],
        "data": {
          "uri": "http://edamontology.org/data_0887"
        },
        "definition": "An informative report of molecular tertiary structure alignment-derived data.",
        "text": "Structure alignment report"
      }, {
        "comment": ["A text mining abstract will typically include an annotated a list of words or sentences extracted from one or more scientific articles."],
        "data": {
          "uri": "http://edamontology.org/data_0972"
        },
        "definition": "A human-readable collection of information resulting from text mining.",
        "exact_synonyms": ["Text mining output"],
        "text": "Text mining report"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_2531"
        },
        "definition": "A human-readable collection of information about about how a scientific experiment or analysis was carried out that results in a specific set of data or results used for further analysis or to test a specific hypothesis.",
        "exact_synonyms": ["Experiment annotation", "Experiment metadata", "Experiment report"],
        "text": "Protocol"
      }, {
        "children": [{
          "comment": ["This might include an overall quality assement of the assembly and summary statistics including counts, average length and number of bases for reads, matches and non-matches, contigs, reads in pairs etc."],
          "data": {
            "uri": "http://edamontology.org/data_3181"
          },
          "definition": "An informative report about a DNA sequence assembly.",
          "exact_synonyms": ["Assembly report"],
          "text": "Sequence assembly report"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_0862"
          },
          "definition": "A dotplot of sequence similarities identified from word-matching or character comparison.",
          "text": "Dotplot"
        }, {
          "comment": ["Use this concept for calculated substitution rates, relative site variability, data on sites with biased properties, highly conserved or very poorly conserved sites, regions, blocks etc."],
          "data": {
            "uri": "http://edamontology.org/data_2161"
          },
          "definition": "A plot of sequence similarities identified from word-matching or character comparison.",
          "text": "Sequence similarity plot"
        }],
        "comment": ["Use this for any computer-generated reports on sequence alignments, and for general information (metadata) on a sequence alignment, such as a description, sequence identifiers and alignment score."],
        "data": {
          "uri": "http://edamontology.org/data_0867"
        },
        "definition": "An informative report of molecular sequence alignment-derived data or metadata.",
        "exact_synonyms": ["Sequence alignment metadata"],
        "text": "Sequence alignment report"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_3558"
        },
        "definition": "A human-readable collection of information concerning a clinical trial.",
        "exact_synonyms": ["Clinical trial information"],
        "text": "Clinical trial report"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_3492"
          },
          "definition": "An informative report about a specific or conserved nucleic acid sequence pattern.",
          "text": "Nucleic acid signature"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1355"
          },
          "definition": "An informative report about a specific or conserved protein sequence pattern.",
          "narrow_synonyms": ["Protein family signature", "Protein site signature", "Protein domain signature", "Protein repeat signature", "InterPro entry", "Protein region signature"],
          "text": "Protein signature"
        }],
        "data": {
          "uri": "http://edamontology.org/data_2762"
        },
        "definition": "An informative report about a specific or conserved pattern in a molecular sequence, such as its context in genes or proteins, its role, origin or method of construction, etc.",
        "exact_synonyms": ["Sequence profile report", "Sequence motif report"],
        "has_topic": ["http://edamontology.org/topic_0160"],
        "text": "Sequence signature report"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_3914"
        },
        "definition": "A human-readable collection of information about about how a scientific experiment or analysis was carried out that results in a specific set of data or results used for further analysis or to test a specific hypothesis.",
        "exact_synonyms": ["QC metrics", "QC report", "Quality control metrics"],
        "text": "Quality control report"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_1596"
          },
          "definition": "A human-readable collection of information about RNA/DNA folding, minimum folding energies for DNA or RNA sequences, energy landscape of RNA mutants etc.",
          "exact_synonyms": ["Nucleic acid report (folding)", "Nucleic acid report (folding model)"],
          "narrow_synonyms": ["RNA secondary structure folding classification", "RNA secondary structure folding probablities"],
          "text": "Nucleic acid folding report"
        }, {
          "comment": ["This includes basic information. e.g. chromosome number, length, karyotype features, chromosome sequence etc."],
          "data": {
            "uri": "http://edamontology.org/data_0919"
          },
          "definition": "A human-readable collection of information about a specific chromosome.",
          "text": "Chromosome report"
        }, {
          "comment": ["This includes any report on a particular locus or gene.  This might include the gene name, description, summary and so on. It can include details about the function of a gene, such as its encoded protein or a functional classification of the gene sequence along according to the encoded protein(s)."],
          "data": {
            "uri": "http://edamontology.org/data_0916"
          },
          "definition": "A report on predicted or actual gene structure, regions which make an RNA product and features such as promoters, coding regions, splice sites etc.",
          "exact_synonyms": ["Gene and transcript structure (report)", "Nucleic acid features (gene and transcript structure)", "Gene features report", "Gene annotation", "Gene structure (repot)", "Gene function (report)"],
          "text": "Gene report"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2354"
            },
            "definition": "A human-readable collection of information about a specific RNA family or other group of classified RNA sequences.",
            "exact_synonyms": ["RNA family annotation"],
            "text": "RNA family report"
          }],
          "comment": ["This includes reports on on gene homologues between species."],
          "data": {
            "uri": "http://edamontology.org/data_3148"
          },
          "definition": "A human-readable collection of information about a particular family of genes, typically a set of genes with similar sequence that originate from duplication of a common ancestor gene, or any other classification of nucleic acid sequences or structures that reflects gene structure.",
          "exact_synonyms": ["Gene annotation (homology)", "Gene annotation (homology information)", "Gene family annotation", "Gene homology (report)", "Homology information"],
          "text": "Gene family report"
        }, {
          "comment": ["This includes linkage disequilibrium; the non-random association of alleles or polymorphisms at two or more loci (not necessarily on the same chromosome)."],
          "data": {
            "uri": "http://edamontology.org/data_0927"
          },
          "definition": "A human-readable collection of information about the linkage of alleles.",
          "exact_synonyms": ["Gene annotation (linkage)"],
          "narrow_synonyms": ["Linkage disequilibrium (report)"],
          "text": "Genetic linkage report"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_3128"
          },
          "definition": "A human-readable collection of information about regions within a nucleic acid sequence which form secondary or tertiary (3D) structures.",
          "exact_synonyms": ["Nucleic acid features (structure)"],
          "narrow_synonyms": ["d-loop (report)", "Stem loop (report)", "Quadruplexes (report)"],
          "text": "Nucleic acid structure report"
        }],
        "data": {
          "uri": "http://edamontology.org/data_2084"
        },
        "definition": "A human-readable collection of information about one or more specific nucleic acid molecules.",
        "text": "Nucleic acid report"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_2711"
          },
          "definition": "A human-readable collection of information concerning a genome as a whole.",
          "text": "Genome report"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_0963"
          },
          "definition": "A human-readable collection of information about a particular strain of organism cell line including plants, virus, fungi and bacteria. The data typically includes strain number, organism type, growth conditions, source and so on.",
          "exact_synonyms": ["Organism strain data", "Cell line annotation"],
          "text": "Cell line report"
        }],
        "data": {
          "uri": "http://edamontology.org/data_2530"
        },
        "definition": "A human-readable collection of information about a specific organism.",
        "exact_synonyms": ["Organism annotation"],
        "text": "Organism report"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_3567"
        },
        "definition": "A report about a biosample.",
        "exact_synonyms": ["Biosample report"],
        "text": "Reference sample report"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_3721"
          },
          "definition": "A report about any kind of isolation source of biological material e.g. blood, water, soil.",
          "text": "Isolation source"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_3720"
          },
          "definition": "A report about localisation of the isolaton of biological material e.g. country or coordinates.",
          "text": "Geographic location"
        }],
        "data": {
          "uri": "http://edamontology.org/data_3717"
        },
        "definition": "A report about any kind of isolation of biological material.",
        "narrow_synonyms": ["Isolation source", "Geographic location"],
        "text": "Isolation report"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_0956"
        },
        "definition": "A human-readable collection of information concerning an analysis of an index of biological data.",
        "exact_synonyms": ["Database index annotation"],
        "has_topic": ["http://edamontology.org/topic_3489"],
        "text": "Data index report"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_2223"
          },
          "definition": "Data concerning a biological ontology.",
          "has_topic": ["http://edamontology.org/topic_0089"],
          "text": "Ontology metadata"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_3106"
          },
          "definition": "Metadata concerning the software, hardware or other aspects of a computer system.",
          "text": "System metadata"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_0960"
          },
          "definition": "Textual metadata on a software author or end-user, for example a person or other software.",
          "text": "User metadata"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_0949"
          },
          "definition": "Basic information, annotation or documentation concerning a workflow (but not the workflow itself).",
          "text": "Workflow metadata"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2193"
          },
          "definition": "Basic information on any arbitrary database entry.",
          "text": "Database entry metadata"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_0958"
          },
          "definition": "Basic information about one or more bioinformatics applications or packages, such as name, type, description, or other documentation.",
          "text": "Tool metadata"
        }, {
          "comment": ["This might include compound and dose in a dose response experiment."],
          "data": {
            "uri": "http://edamontology.org/data_3113"
          },
          "definition": "Annotation on a biological sample, for example experimental factors and their values.",
          "text": "Sample annotation"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_0957"
          },
          "definition": "Basic information on bioinformatics database(s) or other data sources such as name, type, description, URL etc.",
          "text": "Database metadata"
        }],
        "comment": ["This is a broad data type and is used a placeholder for other, more specific types."],
        "data": {
          "uri": "http://edamontology.org/data_2337"
        },
        "definition": "Data concerning or describing some core computational resource, as distinct from primary data.  This includes metadata on the origin, source, history, ownership or location of some thing.",
        "exact_synonyms": ["Provenance metadata"],
        "text": "Resource metadata"
      }],
      "comment": ["You can use this term by default for any textual report, in case you can't find another, more specific term. Reports may be generated automatically or collated by hand and can include metadata on the origin, source, history, ownership or location of some thing."],
      "data": {
        "uri": "http://edamontology.org/data_2048"
      },
      "definition": "A human-readable collection of information including annotation on a biological entity or phenomena, computer-generated reports of analysis of primary data (e.g. sequence or structural), and metadata (data about primary data) or any other free (essentially unformatted) text, as distinct from the primary data itself.",
      "exact_synonyms": ["Record", "Document"],
      "text": "Report"
    }, {
      "children": [{
        "children": [{
          "comment": ["A MIRIAM URI consists of the URI of the MIRIAM data type (PubMed, UniProt etc) followed by the identifier of an element of that data type, for example PMID for a publication or an accession number for a GO term."],
          "data": {
            "uri": "http://edamontology.org/data_1164"
          },
          "definition": "The URI (URL or URN) of a data entity from the MIRIAM database.",
          "exact_synonyms": ["identifiers.org synonym"],
          "is_identifier_of": ["http://edamontology.org/data_0957"],
          "text": "MIRIAM URI"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1052"
          },
          "definition": "A Uniform Resource Locator (URL).",
          "text": "URL"
        }, {
          "children": [{
            "comment": ["LSIDs provide a standard way to locate and describe data. An LSID is represented as a Uniform Resource Name (URN) with the following format: URN:LSID:<Authority>:<Namespace>:<ObjectID>[:<Version>]"],
            "data": {
              "uri": "http://edamontology.org/data_1055"
            },
            "definition": "A Life Science Identifier (LSID) - a unique identifier of some data.",
            "exact_synonyms": ["Life Science Identifier"],
            "text": "LSID"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1053"
          },
          "definition": "A Uniform Resource Name (URN).",
          "text": "URN"
        }],
        "data": {
          "uri": "http://edamontology.org/data_1047"
        },
        "definition": "A string of characters that name or otherwise identify a resource on the Internet.",
        "exact_synonyms": ["URIs"],
        "text": "URI"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_1804"
          },
          "definition": "Gene identifier from Sol Genomics Network.",
          "text": "Gene ID (SGN)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2344"
          },
          "definition": "Identifier of a pathway from the NCI-Nature pathway database.",
          "text": "Pathway ID (NCI-Nature)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1066"
          },
          "definition": "Identifier of a molecular sequence alignment, for example a record from an alignment database.",
          "is_identifier_of": ["http://edamontology.org/data_0863"],
          "text": "Sequence alignment ID"
        }, {
          "children": [{
            "comment": ["A sunid uniquely identifies an entry in the SCOP hierarchy, including leaves (the SCOP domains) and higher level nodes including entries corresponding to the protein level."],
            "data": {
              "uri": "http://edamontology.org/data_1042"
            },
            "definition": "Unique identifier (number) of an entry in the SCOP hierarchy, for example 33229.",
            "exact_synonyms": ["SCOP unique identifier", "sunid"],
            "text": "SCOP sunid"
          }, {
            "comment": ["An scss includes the class (alphabetical), fold, superfamily and family (all numerical) to which a given domain belongs."],
            "data": {
              "uri": "http://edamontology.org/data_1041"
            },
            "definition": "A SCOP concise classification string (sccs) is a compact representation of a SCOP domain classification.",
            "text": "SCOP concise classification string (sccs)"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1039"
          },
          "definition": "Identifier of a protein domain (or other node) from the SCOP database.",
          "text": "SCOP domain identifier"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2654"
          },
          "definition": "Identifier of a target protein from the Therapeutic Target Database (TTD).",
          "text": "Target ID (TTD)"
        }, {
          "comment": ["These identifiers are unique within the cPath database, however, they are not stable between releases."],
          "data": {
            "uri": "http://edamontology.org/data_2637"
          },
          "definition": "A unique identifier for pathways, reactions, complexes and small molecules from the cPath (Pathway Commons) database.",
          "text": "cPath ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2716"
          },
          "definition": "Identifier of a predicted transcription factor from the DBD database.",
          "text": "DBD ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1124"
          },
          "definition": "Accession number of an entry from the TreeFam database.",
          "text": "TreeFam accession number"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2793"
          },
          "definition": "Identifier of an entry from the SISYPHUS database of tertiary structure alignments.",
          "text": "SISYPHUS ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2398"
          },
          "definition": "Unique identifier for a protein from the Ensembl database.",
          "exact_synonyms": ["Protein ID (Ensembl)", "Ensembl ID (protein)"],
          "text": "Ensembl protein ID"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2609"
            },
            "definition": "Unique identifier of a drug from the KEGG Drug database.",
            "text": "Drug ID (KEGG)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2613"
            },
            "definition": "Unique identifier of a glycan ligand from the KEGG GLYCAN database (a subset of KEGG LIGAND).",
            "text": "KEGG Glycan ID"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2608"
            },
            "definition": "Identifier of a biological reaction from the KEGG reactions database.",
            "text": "Reaction ID (KEGG)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2605"
            },
            "definition": "Unique identifier of a chemical compound from the KEGG database.",
            "exact_synonyms": ["KEGG compound ID", "KEGG compound identifier"],
            "text": "Compound ID (KEGG)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2102"
            },
            "definition": "A three-letter code used in the KEGG databases to uniquely identify organisms.",
            "text": "KEGG organism code"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2343"
            },
            "definition": "Identifier of a pathway from the KEGG pathway database.",
            "exact_synonyms": ["KEGG pathway ID"],
            "text": "Pathway ID (KEGG)"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1154"
          },
          "definition": "Unique identifier of an object from one of the KEGG databases (excluding the GENES division).",
          "text": "KEGG object identifier"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1032"
          },
          "definition": "Identifier of a gene from DictyBase.",
          "text": "Gene ID (DictyBase)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2752"
          },
          "definition": "Identifier of an entry from the GlycosciencesDB database.",
          "text": "GlycoMap ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1151"
          },
          "definition": "Identifier of an entry from the HGVbase database.",
          "text": "HGVbase ID"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2705"
            },
            "definition": "An identifier of a 'cellular component' concept from the Gene Ontology.",
            "exact_synonyms": ["GO concept identifier (cellular compartment)"],
            "text": "GO concept ID (cellular component)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2582"
            },
            "definition": "An identifier of a 'biological process' concept from the the Gene Ontology.",
            "text": "GO concept ID (biological process)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2583"
            },
            "definition": "An identifier of a 'molecular function' concept from the the Gene Ontology.",
            "text": "GO concept ID (molecular function)"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1176"
          },
          "definition": "An identifier of a concept from The Gene Ontology.",
          "exact_synonyms": ["GO concept identifier"],
          "text": "GO concept ID"
        }, {
          "comment": ["A MIRIAM URI consists of the URI of the MIRIAM data type (PubMed, UniProt etc) followed by the identifier of an element of that data type, for example PMID for a publication or an accession number for a GO term."],
          "data": {
            "uri": "http://edamontology.org/data_1164"
          },
          "definition": "The URI (URL or URN) of a data entity from the MIRIAM database.",
          "exact_synonyms": ["identifiers.org synonym"],
          "is_identifier_of": ["http://edamontology.org/data_0957"],
          "text": "MIRIAM URI"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1148"
          },
          "definition": "Identifier of an entry from the GermOnline database.",
          "text": "GermOnline ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2837"
          },
          "definition": "Identifier of a pathway from the BioSystems pathway database.",
          "text": "Pathway ID (BioSystems)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2580"
          },
          "definition": "Unique identifier of a monomer from the BindingDB database.",
          "text": "BindingDB Monomer ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1119"
          },
          "definition": "Unique identifier or name of a profile from the JASPAR database.",
          "text": "JASPAR profile ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1179"
          },
          "definition": "A stable unique identifier for each taxon (for a species, a family, an order, or any other group in the NCBI taxonomy database.",
          "exact_synonyms": ["NCBI tax ID", "NCBI taxonomy identifier"],
          "text": "NCBI taxonomy ID"
        }, {
          "comment": ["Nucleotide sequence version contains two letters followed by six digits, a dot, and a version number (or for older nucleotide sequence records, the format is one letter followed by five digits, a dot, and a version number). Protein sequence version contains three letters followed by five digits, a dot, and a version number."],
          "data": {
            "uri": "http://edamontology.org/data_2315"
          },
          "definition": "An identifier assigned to sequence records processed by NCBI, made of the accession number of the database record followed by a dot and a version number.",
          "exact_synonyms": ["NCBI accession.version", "accession.version"],
          "text": "NCBI version"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2780"
          },
          "definition": "A stock number from The Arabidopsis information resource (TAIR).",
          "text": "Stock number (TAIR)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1188"
          },
          "definition": "Digital Object Identifier (DOI) of a published article.",
          "exact_synonyms": ["Digital Object Identifier"],
          "text": "DOI"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2609"
          },
          "definition": "Unique identifier of a drug from the KEGG Drug database.",
          "text": "Drug ID (KEGG)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1185"
          },
          "definition": "An identifier of a concept from the MGED ontology.",
          "text": "MGED concept ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2631"
          },
          "definition": "An identifier of a mobile genetic element from the Aclame database.",
          "text": "ACLAME ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2651"
          },
          "definition": "Identifier of a disease from the pharmacogenetics and pharmacogenomics knowledge base (PharmGKB).",
          "text": "Disease ID (PharmGKB)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2646"
          },
          "definition": "Identifier of a small molecular from the ChEMBL database.",
          "exact_synonyms": ["ChEMBL ID"],
          "text": "Compound ID (ChEMBL)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2725"
          },
          "definition": "Unique identifier for a gene transcript from the Ensembl database.",
          "exact_synonyms": ["Transcript ID (Ensembl)"],
          "text": "Ensembl transcript ID"
        }, {
          "comment": ["OBO file for regular expression."],
          "data": {
            "uri": "http://edamontology.org/data_2614"
          },
          "definition": "A unique identifier of a family from the transport classification database (TCDB) of membrane transport proteins.",
          "exact_synonyms": ["TC number"],
          "text": "TCDB ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2657"
          },
          "definition": "A unique identifier of a neuron from the NeuroMorpho database.",
          "text": "NeuroMorpho ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2721"
          },
          "definition": "Identifier of an dinucleotide property from the DiProDB database.",
          "text": "DiProDB ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2626"
          },
          "definition": "Identifier of a peptide from the PeptideAtlas peptide databases.",
          "text": "PeptideAtlas ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1886"
          },
          "definition": "The blattner identifier for a gene.",
          "text": "Blattner number"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1171"
          },
          "definition": "Unique identifier of an entry from the BioModel database.",
          "text": "BioModel ID"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2398"
            },
            "definition": "Unique identifier for a protein from the Ensembl database.",
            "exact_synonyms": ["Protein ID (Ensembl)", "Ensembl ID (protein)"],
            "text": "Ensembl protein ID"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2725"
            },
            "definition": "Unique identifier for a gene transcript from the Ensembl database.",
            "exact_synonyms": ["Transcript ID (Ensembl)"],
            "text": "Ensembl transcript ID"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1033"
            },
            "definition": "Unique identifier for a gene (or other feature) from the Ensembl database.",
            "exact_synonyms": ["Gene ID (Ensembl)"],
            "text": "Ensembl gene ID"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_3270"
            },
            "definition": "Unique identifier for a gene tree from the Ensembl database.",
            "exact_synonyms": ["Ensembl ID (gene tree)"],
            "text": "Ensembl gene tree ID"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2610"
          },
          "definition": "Identifier of an entry (exon, gene, transcript or protein) from the Ensembl database.",
          "exact_synonyms": ["Ensembl IDs"],
          "text": "Ensembl ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2629"
          },
          "definition": "Unique identifier of a peptidase enzyme from the MEROPS database.",
          "exact_synonyms": ["MEROPS ID"],
          "text": "Enzyme ID (MEROPS)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2644"
          },
          "definition": "Identifier of an enzyme-catalysed reaction from the Rhea database.",
          "text": "Reaction ID (Rhea)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2802"
          },
          "definition": "Unique identifier for a protein from the EcID database.",
          "text": "Protein ID (EcID)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2783"
          },
          "definition": "Accession number of an entry (family) from the PANTHER database.",
          "exact_synonyms": ["Panther family ID"],
          "text": "Protein family ID (PANTHER)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2643"
          },
          "definition": "Identifier for a gene from the Zebrafish information network genome (ZFIN) database.",
          "text": "Gene ID (ZFIN)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2380"
          },
          "definition": "A unique identifier of an item from the CABRI database.",
          "text": "CABRI accession"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2114"
          },
          "definition": "Protein identifier used by WormBase database.",
          "text": "WormBase wormpep ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1033"
          },
          "definition": "Unique identifier for a gene (or other feature) from the Ensembl database.",
          "exact_synonyms": ["Gene ID (Ensembl)"],
          "text": "Ensembl gene ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2386"
          },
          "definition": "Identifier of an entry (promoter) from the EPD database.",
          "exact_synonyms": ["EPD identifier"],
          "text": "EPD ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2835"
          },
          "definition": "Identifier for a gene from the VBASE2 database.",
          "exact_synonyms": ["VBASE2 ID"],
          "text": "Gene ID (VBASE2)"
        }, {
          "children": [{
            "comment": ["Secondary identifier are used to handle entries that were merged with or split from other entries in the database."],
            "data": {
              "uri": "http://edamontology.org/data_2174"
            },
            "definition": "Secondary identifier of an object from the FlyBase database.",
            "text": "FlyBase secondary identifier"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2112"
            },
            "definition": "Primary identifier of an object from the FlyBase database.",
            "text": "FlyBase primary identifier"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1089"
          },
          "definition": "Identifier of an object from the FlyBase database.",
          "text": "FlyBase ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1106"
          },
          "definition": "Identifier of a dbSNP database entry.",
          "exact_synonyms": ["dbSNP identifier"],
          "text": "dbSNP ID"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2106"
            },
            "definition": "Identifier of a biological reaction from the BioCyc reactions database.",
            "text": "Reaction ID (BioCyc)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2107"
            },
            "definition": "Identifier of an enzyme from the BioCyc enzymes database.",
            "exact_synonyms": ["BioCyc enzyme ID"],
            "text": "Enzyme ID (BioCyc)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1157"
            },
            "definition": "Identifier of an pathway from the BioCyc biological pathways database.",
            "exact_synonyms": ["BioCyc pathway ID"],
            "text": "Pathway ID (BioCyc)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2105"
            },
            "definition": "Identifier of a compound from the BioCyc chemical compounds database.",
            "exact_synonyms": ["BioCyc compound ID", "BioCyc compound identifier"],
            "text": "Compound ID (BioCyc)"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2104"
          },
          "definition": "Identifier of an object from one of the BioCyc databases.",
          "text": "BioCyc ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2774"
          },
          "definition": "A unique identifier of gene assigned by the J. Craig Venter Institute (JCVI).",
          "text": "Gene ID (JCVI)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1136"
          },
          "definition": "Unique identifier of an entry from the PIRSF database.",
          "text": "PIRSF ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2714"
          },
          "definition": "Unique identifier of a position-specific scoring matrix from the CDD database.",
          "text": "CDD PSSM-ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1184"
          },
          "definition": "An identifier of a concept from the ChEBI ontology.",
          "text": "ChEBI concept ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1181"
          },
          "definition": "An identifier of a concept from the UMLS vocabulary.",
          "text": "UMLS concept ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2798"
          },
          "definition": "Identifier of an EST sequence from the MaizeDB database.",
          "text": "MaizeDB ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2797"
          },
          "definition": "Unique identifier for a ligand-gated ion channel protein from the LGICdb database.",
          "exact_synonyms": ["LGICdb ID"],
          "text": "Protein ID (LGICdb)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1104"
          },
          "definition": "A unique identifier of an entry (gene cluster) from the NCBI UniGene database.",
          "exact_synonyms": ["UniGene ID", "UniGene cluster ID", "UniGene identifier"],
          "text": "Sequence cluster ID (UniGene)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2668"
          },
          "definition": "Unique identifier of an entry from the iRefIndex database of protein-protein interactions.",
          "text": "iRefIndex ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1174"
          },
          "definition": "Identifier of an entry from the ChEBI database.",
          "exact_synonyms": ["ChEBI IDs", "ChEBI identifier"],
          "text": "ChEBI ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2302"
          },
          "definition": "Unique identifier of an entry from the STRING database of protein-protein interactions.",
          "text": "STRING ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2619"
          },
          "definition": "Identifier of a protein modification catalogued in the RESID database.",
          "text": "RESID ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1903"
          },
          "definition": "Identifier of locus from DictyBase (Dictyostelium discoideum).",
          "text": "Locus ID (DictyBase)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2345"
          },
          "definition": "Identifier of a pathway from the ConsensusPathDB pathway database.",
          "text": "Pathway ID (ConsensusPathDB)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2709"
          },
          "definition": "An identifier of a gene expression profile from the CleanEx database.",
          "text": "CleanEx entry name"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2613"
          },
          "definition": "Unique identifier of a glycan ligand from the KEGG GLYCAN database (a subset of KEGG LIGAND).",
          "text": "KEGG Glycan ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1105"
          },
          "definition": "Identifier of a dbEST database entry.",
          "exact_synonyms": ["dbEST ID"],
          "text": "dbEST accession"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1796"
          },
          "definition": "Gene identifier from FlyBase database.",
          "text": "Gene ID (FlyBase)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_3769"
          },
          "definition": "An identifier of a concept from the BRENDA ontology.",
          "text": "BRENDA ontology concept ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2786"
          },
          "definition": "An identifier of a genome project assigned by NCBI.",
          "text": "NCBI Genome Project ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1034"
          },
          "definition": "Identifier of an entry from the SGD database.",
          "exact_synonyms": ["SGD identifier"],
          "text": "Gene ID (SGD)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2393"
          },
          "definition": "Identifier of an entry from the Rouge or HUGE databases.",
          "text": "mFLJ/mKIAA number"
        }, {
          "comment": ["This concept refers to identifiers used by the databases collated in CPDB; CPDB identifiers are not independently defined."],
          "data": {
            "uri": "http://edamontology.org/data_1160"
          },
          "definition": "Identifier of an entry from the CPDB (ConsensusPathDB) biological pathways database, which is an identifier from an external database integrated into CPDB.",
          "exact_synonyms": ["CPDB ID"],
          "text": "Pathway ID (CPDB)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2744"
          },
          "definition": "Identifier of a locus from the PseudoCAP database.",
          "text": "Locus ID (PseudoCAP)"
        }, {
          "comment": ["The use of Medline UI has been replaced by the PubMed unique identifier."],
          "data": {
            "uri": "http://edamontology.org/data_1189"
          },
          "definition": "Medline UI (unique identifier) of an article.",
          "exact_synonyms": ["Medline unique identifier"],
          "text": "Medline UI"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_3021"
          },
          "definition": "Accession number of a UniProt (protein sequence) database entry.",
          "exact_synonyms": ["UniProt accession number", "UniProtKB accession", "UniProtKB accession number", "UniProt entry accession"],
          "narrow_synonyms": ["Swiss-Prot entry accession", "TrEMBL entry accession"],
          "text": "UniProt accession"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1794"
          },
          "definition": "Identifier of a gene from PlasmoDB Plasmodium Genome Resource.",
          "text": "Gene ID (PlasmoDB)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1158"
          },
          "definition": "Identifier of an entry from the INOH database.",
          "exact_synonyms": ["INOH identifier"],
          "text": "Pathway ID (INOH)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1895"
          },
          "definition": "Locus identifier for Arabidopsis Genome Initiative (TAIR, TIGR and MIPS databases)",
          "exact_synonyms": ["Arabidopsis gene loci number", "AGI ID", "AGI identifier", "AGI locus code"],
          "text": "Locus ID (AGI)"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2651"
            },
            "definition": "Identifier of a disease from the pharmacogenetics and pharmacogenomics knowledge base (PharmGKB).",
            "text": "Disease ID (PharmGKB)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2650"
            },
            "definition": "Identifier of a pathway from the pharmacogenetics and pharmacogenomics knowledge base (PharmGKB).",
            "text": "Pathway ID (PharmGKB)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2652"
            },
            "definition": "Identifier of a drug from the pharmacogenetics and pharmacogenomics knowledge base (PharmGKB).",
            "text": "Drug ID (PharmGKB)"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2649"
          },
          "definition": "Identifier of an entry from the pharmacogenetics and pharmacogenomics knowledge base (PharmGKB).",
          "text": "PharmGKB ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2713"
          },
          "definition": "Unique identifier for a protein complex from the CORUM database.",
          "exact_synonyms": ["CORUM complex ID"],
          "text": "Protein ID (CORUM)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2669"
          },
          "definition": "Unique identifier of an entry from the ModelDB database.",
          "text": "ModelDB ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2662"
          },
          "definition": "Unique identifier of a toxin from the Toxin and Toxin Target Database (T3DB) database.",
          "text": "T3DB ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2641"
          },
          "definition": "Identifier of an enzyme reaction mechanism from the MACie database.",
          "exact_synonyms": ["MACie entry number"],
          "text": "Reaction ID (MACie)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2794"
          },
          "definition": "Accession of an open reading frame (catalogued in a database).",
          "text": "ORF ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2781"
          },
          "definition": "Identifier of an entry from the RNA editing database (REDIdb).",
          "text": "REDIdb ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2392"
          },
          "definition": "Accession number of a UniParc (protein sequence) database entry.",
          "exact_synonyms": ["UniParc ID", "UPI"],
          "text": "UniParc accession"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1036"
          },
          "definition": "Identifier of an entry from the TIGR database.",
          "text": "TIGR identifier"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1159"
          },
          "definition": "Identifier of an entry from the PATIKA database.",
          "exact_synonyms": ["PATIKA ID"],
          "text": "Pathway ID (PATIKA)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_3103"
          },
          "definition": "Unique identifier of a drug conforming to the Anatomical Therapeutic Chemical (ATC) Classification System, a drug classification system controlled by the WHO Collaborating Centre for Drug Statistics Methodology (WHOCC).",
          "text": "ATC code"
        }, {
          "comment": ["This qualifier consists of a stable ID portion (3+5 format with 3 position letters and 5 numbers) plus a version number after the decimal point. When the protein sequence encoded by the CDS changes, only the version number of the /protein_id value is incremented; the stable part of the /protein_id remains unchanged and as a result will permanently be associated with a given protein; this qualifier is valid only on CDS features which translate into a valid protein."],
          "data": {
            "uri": "http://edamontology.org/data_3029"
          },
          "definition": "EMBL/GENBANK/DDBJ coding feature protein identifier, issued by International collaborators.",
          "text": "Protein ID (EMBL/GenBank/DDBJ)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1135"
          },
          "definition": "Unique identifier of an entry from the Gene3D database.",
          "text": "Gene3D ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2389"
          },
          "definition": "Identifier of an entry from the UniSTS database.",
          "text": "UniSTS accession"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2384"
          },
          "definition": "Identifier of a protein entry catalogued in the International Protein Index (IPI) database.",
          "text": "IPI protein ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1113"
          },
          "definition": "Unique identifier of an entry from the COG database.",
          "exact_synonyms": ["COG ID"],
          "text": "Sequence cluster ID (COG)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1901"
          },
          "definition": "Identifier for loci from SGD (Saccharomyces Genome Database).",
          "exact_synonyms": ["SGDID"],
          "text": "Locus ID (SGD)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_3022"
          },
          "definition": "Identifier of a genetic code in the NCBI list of genetic codes.",
          "text": "NCBI genetic code ID"
        }, {
          "children": [{
            "children": [{
              "data": {
                "uri": "http://edamontology.org/data_2701"
              },
              "definition": "A code number identifying a family from the CATH database.",
              "text": "CATH node ID (family)"
            }],
            "data": {
              "uri": "http://edamontology.org/data_1043"
            },
            "definition": "A code number identifying a node from the CATH database.",
            "exact_synonyms": ["CATH node identifier", "CATH code"],
            "text": "CATH node ID"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1040"
            },
            "definition": "Identifier of a protein domain from CATH.",
            "exact_synonyms": ["CATH domain identifier"],
            "text": "CATH domain ID"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2700"
          },
          "definition": "Identifier of a protein domain (or other node) from the CATH database.",
          "text": "CATH identifier"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_3952"
          },
          "definition": "Identifier of a pathway from the WikiPathways pathway database.",
          "exact_synonyms": ["WikiPathways pathway ID", "WikiPathways ID"],
          "text": "Pathway ID (WikiPathways)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2758"
          },
          "definition": "Accession number of a Pfam clan.",
          "text": "Pfam clan ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2620"
          },
          "definition": "Identifier of an entry from the RGD database.",
          "text": "RGD ID"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_1134"
            },
            "definition": "Secondary accession number of an InterPro entry.",
            "exact_synonyms": ["InterPro secondary accession number"],
            "is_identifier_of": ["http://edamontology.org/data_1355"],
            "text": "InterPro secondary accession"
          }],
          "comment": ["Every InterPro entry has a unique accession number to provide a persistent citation of database records."],
          "data": {
            "uri": "http://edamontology.org/data_1133"
          },
          "definition": "Primary accession number of an InterPro entry.",
          "exact_synonyms": ["InterPro primary accession", "InterPro primary accession number"],
          "is_identifier_of": ["http://edamontology.org/data_1355"],
          "text": "InterPro accession"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1004"
          },
          "definition": "Gmelin registry number of a chemical compound.",
          "exact_synonyms": ["Gmelin chemical registry number"],
          "text": "Chemical registry number (Gmelin)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2588"
          },
          "definition": "Unique identifier of a blot from a Northern Blot from the BlotBase database.",
          "text": "BlotBase blot ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2653"
          },
          "definition": "Identifier of a drug from the Therapeutic Target Database (TTD).",
          "text": "Drug ID (TTD)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_3274"
          },
          "definition": "Identifier of an object from the MGI database.",
          "text": "MGI accession"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1902"
          },
          "definition": "Identifier of loci from Maize Mapping Project.",
          "text": "Locus ID (MMP)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1118"
          },
          "definition": "Unique identifier or name of a HMMER hidden Markov model.",
          "is_identifier_of": ["http://edamontology.org/data_1364"],
          "text": "HMMER hidden Markov model ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1100"
          },
          "definition": "An identifier of PIR sequence database entry.",
          "exact_synonyms": ["PIR ID", "PIR accession number"],
          "text": "PIR identifier"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1143"
          },
          "definition": "Identifier of an entry from the TRANSFAC database.",
          "text": "TRANSFAC accession number"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1167"
          },
          "definition": "Unique identifier of a Taverna workflow.",
          "text": "Taverna workflow ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1805"
          },
          "definition": "Gene identifier used by WormBase database.",
          "text": "Gene ID (WormBase)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1141"
          },
          "definition": "Accession number of an entry (family) from the TIGRFam database.",
          "exact_synonyms": ["TIGRFam accession number"],
          "text": "TIGRFam ID"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_1034"
            },
            "definition": "Identifier of an entry from the SGD database.",
            "exact_synonyms": ["SGD identifier"],
            "text": "Gene ID (SGD)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1901"
            },
            "definition": "Identifier for loci from SGD (Saccharomyces Genome Database).",
            "exact_synonyms": ["SGDID"],
            "text": "Locus ID (SGD)"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2632"
          },
          "definition": "Identifier of an entry from the Saccharomyces genome database (SGD).",
          "text": "SGD ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1900"
          },
          "definition": "Identifier for loci from NCBI database.",
          "exact_synonyms": ["Locus ID (NCBI)"],
          "text": "NCBI locus tag"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1146"
          },
          "definition": "Identifier of an entry from the EMDB electron microscopy database.",
          "text": "EMDB ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1907"
          },
          "definition": "Identifier of a gene from the KOME database.",
          "text": "Gene ID (KOME)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2800"
          },
          "definition": "An identifier of a disease from the Orpha database.",
          "is_identifier_of": ["http://edamontology.org/data_1622"],
          "text": "Orpha number"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2617"
          },
          "definition": "Unique identifier of a protein listed in the UCSD-Nature Signaling Gateway Molecule Pages database.",
          "text": "Signaling Gateway protein ID"
        }, {
          "children": [{
            "comment": ["Nucleotide sequence GI number is shown in the VERSION field of the database record. Protein sequence GI number is shown in the CDS/db_xref field of a nucleotide database record, and the VERSION field of a protein database record."],
            "data": {
              "uri": "http://edamontology.org/data_2327"
            },
            "definition": "A unique identifier assigned to NCBI protein sequence records.",
            "exact_synonyms": ["protein gi number", "protein gi"],
            "text": "GI number (protein)"
          }],
          "comment": ["Nucleotide sequence GI number is shown in the VERSION field of the database record. Protein sequence GI number is shown in the CDS/db_xref field of a nucleotide database record, and the VERSION field of a protein database record."],
          "data": {
            "uri": "http://edamontology.org/data_2314"
          },
          "definition": "A series of digits that are assigned consecutively to each sequence record processed by NCBI. The GI number bears no resemblance to the Accession number of the sequence record.",
          "exact_synonyms": ["NCBI GI number"],
          "text": "GI number"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1802"
          },
          "definition": "Gene identifier from Gramene database.",
          "text": "Gene ID (Gramene)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2374"
          },
          "definition": "Unique identifier of a spot from a two-dimensional (protein) gel in the SWISS-2DPAGE database.",
          "text": "Spot serial number"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1002"
          },
          "definition": "CAS registry number of a chemical compound; a unique numerical identifier of chemicals in the scientific literature, as assigned by the Chemical Abstracts Service.",
          "exact_synonyms": ["Chemical registry number (CAS)", "CAS chemical registry number"],
          "text": "CAS number"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_3757"
          },
          "definition": "Identifier of a protein modification catalogued in the Unimod database.",
          "text": "Unimod ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2650"
          },
          "definition": "Identifier of a pathway from the pharmacogenetics and pharmacogenomics knowledge base (PharmGKB).",
          "text": "Pathway ID (PharmGKB)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1180"
          },
          "definition": "An identifier of a concept from the Plant Ontology (PO).",
          "text": "Plant Ontology concept ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2635"
          },
          "definition": "Identifier of a metabolite from the 3DMET database.",
          "exact_synonyms": ["3DMET ID"],
          "text": "Compound ID (3DMET)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1129"
          },
          "definition": "Accession number of an entry from the BIND database.",
          "text": "BIND accession number"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2106"
          },
          "definition": "Identifier of a biological reaction from the BioCyc reactions database.",
          "text": "Reaction ID (BioCyc)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1177"
          },
          "definition": "An identifier of a concept from the MeSH vocabulary.",
          "text": "MeSH concept ID"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2621"
            },
            "definition": "Identifier of a protein sequence from the TAIR database.",
            "text": "TAIR accession (protein)"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/data_2388"
              },
              "definition": "Identifier of an Arabidopsis thaliana gene from the TAIR database.",
              "text": "TAIR accession (At gene)"
            }],
            "data": {
              "uri": "http://edamontology.org/data_1037"
            },
            "definition": "Identifier of an gene from the TAIR database.",
            "text": "TAIR accession (gene)"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2387"
          },
          "definition": "Identifier of an entry from the TAIR database.",
          "text": "TAIR accession"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2666"
          },
          "definition": "Identifier of a conserved domain from the Conserved Domain Database.",
          "text": "CDD ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2742"
          },
          "definition": "Identifier of a transcription factor from the AraC-XylS database.",
          "text": "AraC-XylS ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2634"
          },
          "definition": "The International Standard Book Number (ISBN) is for identifying printed books.",
          "text": "ISBN"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2390"
          },
          "definition": "Identifier of an entry from the UNITE database.",
          "text": "UNITE accession"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1147"
          },
          "definition": "Accession number of an entry from the GEO database.",
          "text": "GEO accession number"
        }, {
          "comment": ["This is the identifier used internally by MIRIAM for a data type."],
          "data": {
            "uri": "http://edamontology.org/data_1162"
          },
          "definition": "Unique identifier of a MIRIAM data resource.",
          "is_identifier_of": ["http://edamontology.org/data_0957"],
          "text": "MIRIAM identifier"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2916"
            },
            "definition": "An identifier of an entry from the DDBJ sequence database.",
            "exact_synonyms": ["DDBJ identifier", "DDBJ accession number", "DDBJ ID"],
            "text": "DDBJ accession"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2290"
            },
            "definition": "An accession number of an entry from the EMBL sequence database.",
            "exact_synonyms": ["EMBL ID", "EMBL accession number", "EMBL identifier"],
            "text": "EMBL accession"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/data_1105"
              },
              "definition": "Identifier of a dbEST database entry.",
              "exact_synonyms": ["dbEST ID"],
              "text": "dbEST accession"
            }],
            "data": {
              "uri": "http://edamontology.org/data_2292"
            },
            "definition": "Accession number of an entry from the GenBank sequence database.",
            "exact_synonyms": ["GenBank ID", "GenBank accession number", "GenBank identifier"],
            "text": "GenBank accession"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1103"
          },
          "definition": "Identifier of a (nucleic acid) entry from the EMBL/GenBank/DDBJ databases.",
          "text": "EMBL/GenBank/DDBJ ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2343"
          },
          "definition": "Identifier of a pathway from the KEGG pathway database.",
          "exact_synonyms": ["KEGG pathway ID"],
          "text": "Pathway ID (KEGG)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1178"
          },
          "definition": "An identifier of a concept from the HGNC controlled vocabulary.",
          "text": "HGNC concept ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1138"
          },
          "definition": "Accession number of a Pfam entry.",
          "text": "Pfam accession number"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2773"
          },
          "definition": "Identifier of a human major histocompatibility complex (HLA) or other protein from the IMGT/HLA database.",
          "text": "IMGT/HLA ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1898"
          },
          "definition": "Identifier for loci from CGD (Candida Genome Database).",
          "exact_synonyms": ["CGDID", "CGD locus identifier"],
          "text": "Locus ID (CGD)"
        }, {
          "comment": ["The ontology is provided as two components, the service ontology and the domain ontology. The domain ontology acts provides concepts for core bioinformatics data types and their relations. The service ontology describes the physical and operational features of web services."],
          "data": {
            "uri": "http://edamontology.org/data_1186"
          },
          "definition": "An identifier of a concept from the myGrid ontology.",
          "text": "myGrid concept ID"
        }, {
          "comment": ["Classifies anatomical entities according to their shared characteristics (genus) and distinguishing characteristics (differentia). Specifies the part-whole and spatial relationships of the entities, morphological transformation of the entities during prenatal development and the postnatal life cycle and principles, rules and definitions according to which classes and relationships in the other three components of FMA are represented."],
          "data": {
            "uri": "http://edamontology.org/data_1182"
          },
          "definition": "An identifier of a concept from Foundational Model of Anatomy.",
          "text": "FMA concept ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2616"
          },
          "definition": "Unique identifier of an entry from the DIP database of protein-protein interactions.",
          "text": "DIP ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2107"
          },
          "definition": "Identifier of an enzyme from the BioCyc enzymes database.",
          "exact_synonyms": ["BioCyc enzyme ID"],
          "text": "Enzyme ID (BioCyc)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2789"
          },
          "definition": "Unique identifier for a membrane protein from the TopDB database.",
          "exact_synonyms": ["TopDB ID"],
          "text": "Protein ID (TopDB)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1803"
          },
          "definition": "Gene identifier from Virginia Bioinformatics Institute microbial database.",
          "text": "Gene ID (Virginia microbial)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1140"
          },
          "definition": "Unique identifier (number) of a hidden Markov model from the Superfamily database.",
          "text": "Superfamily hidden Markov model number"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2625"
          },
          "definition": "Identifier of an entry from the LIPID MAPS database.",
          "exact_synonyms": ["LM ID"],
          "text": "LIPID MAPS ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2383"
          },
          "definition": "Identifier of an entry from the EGA database.",
          "text": "EGA accession"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2836"
          },
          "definition": "A unique identifier for a virus from the DPVweb database.",
          "exact_synonyms": ["DPVweb virus ID"],
          "text": "DPVweb ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2356"
          },
          "definition": "Stable accession number of an entry (RNA family) from the RFAM database.",
          "text": "RFAM accession"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2804"
          },
          "definition": "Unique identifier for a cone snail toxin protein from the ConoServer database.",
          "text": "Protein ID (ConoServer)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2746"
          },
          "definition": "Unique identifier of a monosaccharide from the MonosaccharideDB database.",
          "text": "MonosaccharideDB ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2660"
          },
          "definition": "Identifier of an entry from the BioNumbers database of key numbers and associated data in molecular biology.",
          "text": "BioNumbers ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2325"
          },
          "definition": "Identifier of an enzyme from the REBASE enzymes database.",
          "text": "REBASE enzyme number"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1137"
          },
          "definition": "The unique identifier of an entry in the PRINTS database.",
          "text": "PRINTS code"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2719"
          },
          "definition": "Identifier of an oligonucleotide probe from the dbProbe database.",
          "text": "dbProbe ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_3270"
          },
          "definition": "Unique identifier for a gene tree from the Ensembl database.",
          "exact_synonyms": ["Ensembl ID (gene tree)"],
          "text": "Ensembl gene tree ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1885"
          },
          "definition": "Identifier of a gene from the GeneFarm database.",
          "text": "Gene ID (GeneFarm)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1873"
          },
          "definition": "A unique identifier for an organism used in the iHOP database.",
          "text": "iHOP organism ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2209"
          },
          "definition": "A unique identifier of a specific mutation catalogued in a database.",
          "text": "Mutation ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2739"
          },
          "definition": "A unique identifier of gene in the Genolist database.",
          "text": "Gene ID (Genolist)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1123"
          },
          "definition": "Accession number of an entry from the TreeBASE database.",
          "text": "TreeBASE study accession number"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2636"
          },
          "definition": "A unique identifier of an interaction from the MatrixDB database.",
          "text": "MatrixDB interaction ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2611"
          },
          "definition": "An identifier of a disease from the International Classification of Diseases (ICD) database.",
          "is_identifier_of": ["http://edamontology.org/data_1622"],
          "text": "ICD identifier"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2738"
          },
          "definition": "A unique identifier of gene in the Xenbase database.",
          "text": "Gene ID (Xenbase)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_3265"
          },
          "definition": "Identifier of a HGMD database entry.",
          "exact_synonyms": ["HGMD identifier"],
          "text": "HGMD ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2615"
          },
          "definition": "Unique identifier of an entry from the MINT database of protein-protein interactions.",
          "text": "MINT ID"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2370"
            },
            "definition": "Identifier of a polyA signal from the ASTD database.",
            "text": "ASTD ID (polya)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2369"
            },
            "definition": "Identifier of an intron from the ASTD database.",
            "text": "ASTD ID (intron)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2368"
            },
            "definition": "Identifier of an exon from the ASTD database.",
            "text": "ASTD ID (exon)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2371"
            },
            "definition": "Identifier of a transcription start site from the ASTD database.",
            "text": "ASTD ID (tss)"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2367"
          },
          "definition": "Identifier of an object from the ASTD database.",
          "text": "ASTD ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1183"
          },
          "definition": "An identifier of a concept from the EMAP mouse ontology.",
          "text": "EMAP concept ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1157"
          },
          "definition": "Identifier of an pathway from the BioCyc biological pathways database.",
          "exact_synonyms": ["BioCyc pathway ID"],
          "text": "Pathway ID (BioCyc)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2285"
          },
          "definition": "Identifier for genetic elements in MIPS database.",
          "exact_synonyms": ["MIPS genetic element identifier"],
          "text": "Gene ID (MIPS)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2805"
          },
          "definition": "Identifier of a GeneSNP database entry.",
          "text": "GeneSNP ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1173"
          },
          "definition": "Identifier of an entry from the ChemSpider database.",
          "text": "ChemSpider ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2772"
          },
          "definition": "Identifier of a antibody from the HPA database.",
          "text": "HPA antibody id"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1155"
          },
          "definition": "Identifier of an entry from the Reactome database.",
          "exact_synonyms": ["Reactome ID"],
          "text": "Pathway ID (reactome)"
        }, {
          "comment": ["Could list (or reference) other taxa here from https://www.phenoscape.org/wiki/Taxonomic_Rank_Vocabulary."],
          "data": {
            "uri": "http://edamontology.org/data_2784"
          },
          "definition": "A unique identifier for a virus from the RNAVirusDB database.",
          "text": "RNAVirusDB ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2741"
          },
          "definition": "Identifier of an entry (promoter) from the ABS database.",
          "exact_synonyms": ["ABS identifier"],
          "text": "ABS ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2593"
          },
          "definition": "A unique identifier for an organism used in the BRENDA database.",
          "text": "BRENDA organism ID"
        }, {
          "comment": ["ProDom is a protein domain family database."],
          "data": {
            "uri": "http://edamontology.org/data_1142"
          },
          "definition": "A ProDom domain family accession number.",
          "text": "ProDom accession number"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2745"
          },
          "definition": "Identifier of a locus from the UTR database.",
          "text": "Locus ID (UTR)"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2348"
            },
            "definition": "Unique identifier of an entry from the UniRef90 database.",
            "exact_synonyms": ["UniRef90 entry accession", "UniRef90 cluster id"],
            "text": "Sequence cluster ID (UniRef90)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2349"
            },
            "definition": "Unique identifier of an entry from the UniRef50 database.",
            "exact_synonyms": ["UniRef50 cluster id", "UniRef50 entry accession"],
            "text": "Sequence cluster ID (UniRef50)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2347"
            },
            "definition": "Unique identifier of an entry from the UniRef100 database.",
            "exact_synonyms": ["UniRef100 entry accession", "UniRef100 cluster id"],
            "text": "Sequence cluster ID (UniRef100)"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2346"
          },
          "definition": "Unique identifier of an entry from the UniRef database.",
          "exact_synonyms": ["UniRef cluster id", "UniRef entry accession"],
          "text": "Sequence cluster ID (UniRef)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2659"
          },
          "definition": "Identifier of a pathway from the Small Molecule Pathway Database (SMPDB).",
          "text": "Pathway ID (SMPDB)"
        }, {
          "comment": ["A unisequence is a single sequence assembled from ESTs."],
          "data": {
            "uri": "http://edamontology.org/data_2730"
          },
          "definition": "Identifier of a unisequence from the COGEME database.",
          "text": "COGEME unisequence ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1161"
          },
          "definition": "Identifier of a biological pathway from the Panther Pathways database.",
          "exact_synonyms": ["Panther Pathways ID"],
          "text": "Pathway ID (Panther)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2664"
          },
          "definition": "Identifier of an entry from the GlycomeDB database.",
          "text": "GlycomeDB ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1187"
          },
          "definition": "PubMed unique identifier of an article.",
          "exact_synonyms": ["PMID"],
          "text": "PubMed ID"
        }, {
          "comment": ["A PDB identification code which consists of 4 characters, the first of which is a digit in the range 0 - 9; the remaining 3 are alpha-numeric, and letters are upper case only. (source: https://cdn.rcsb.org/wwpdb/docs/documentation/file-format/PDB_format_1996.pdf)"],
          "data": {
            "uri": "http://edamontology.org/data_1127"
          },
          "definition": "An identifier of an entry from the PDB database.",
          "exact_synonyms": ["PDB identifier", "PDBID"],
          "text": "PDB ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1904"
          },
          "definition": "Identifier of a locus from EntrezGene database.",
          "text": "Locus ID (EntrezGene)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1175"
          },
          "definition": "An identifier of a concept from the BioPax ontology.",
          "text": "BioPax concept ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2771"
          },
          "definition": "A unique identifier of gene cluster in the H-InvDB database.",
          "text": "HIX ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2766"
          },
          "definition": "Name of a protein family from the HAMAP database.",
          "text": "HAMAP ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2652"
          },
          "definition": "Identifier of a drug from the pharmacogenetics and pharmacogenomics knowledge base (PharmGKB).",
          "text": "Drug ID (PharmGKB)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2702"
          },
          "definition": "Identifier of an enzyme from the CAZy enzymes database.",
          "exact_synonyms": ["CAZy ID"],
          "text": "Enzyme ID (CAZy)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2658"
          },
          "definition": "Identifier of a chemical from the ChemIDplus database.",
          "exact_synonyms": ["ChemIDplus ID"],
          "text": "Compound ID (ChemIDplus)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2799"
          },
          "definition": "A unique identifier of gene in the MfunGD database.",
          "text": "Gene ID (MfunGD)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2776"
          },
          "definition": "Identifier of a physical entity from the ConsensusPathDB database.",
          "text": "ConsensusPathDB entity ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_3264"
          },
          "definition": "Identifier of a COSMIC database entry.",
          "exact_synonyms": ["COSMIC identifier"],
          "text": "COSMIC ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2326"
          },
          "definition": "Unique identifier of a drug from the DrugBank database.",
          "text": "DrugBank ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2578"
          },
          "definition": "Unique identifier of a toxin from the ArachnoServer database.",
          "text": "ArachnoServer ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2759"
          },
          "definition": "Identifier for a gene from the VectorBase database.",
          "exact_synonyms": ["VectorBase ID"],
          "text": "Gene ID (VectorBase)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2704"
          },
          "definition": "A unique identifier assigned by the I.M.A.G.E. consortium to a clone (cloned molecular sequence).",
          "exact_synonyms": ["I.M.A.G.E. cloneID", "IMAGE cloneID"],
          "text": "Clone ID (IMAGE)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2645"
          },
          "definition": "Identifier of a biological pathway from the Unipathway database.",
          "exact_synonyms": ["upaid"],
          "text": "Pathway ID (Unipathway)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2665"
          },
          "definition": "Identifier of an entry from the LipidBank database.",
          "text": "LipidBank ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2647"
          },
          "definition": "Unique identifier of an entry from the Ligand-gated ion channel (LGICdb) database.",
          "text": "LGICdb identifier"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2723"
          },
          "definition": "Unique identifier for a protein from the DisProt database.",
          "exact_synonyms": ["DisProt ID"],
          "text": "Protein ID (DisProt)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2220"
          },
          "definition": "Unique identifier of a sequence cluster from the SYSTERS database.",
          "exact_synonyms": ["SYSTERS cluster ID"],
          "text": "Sequence cluster ID (SYSTERS)"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2297"
            },
            "definition": "Identifier of an E. coli K-12 gene from EcoGene Database.",
            "exact_synonyms": ["ECK accession", "E. coli K-12 gene identifier"],
            "text": "Gene ID (ECK)"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1795"
          },
          "definition": "Identifier of a gene from EcoGene Database.",
          "exact_synonyms": ["EcoGene Accession", "EcoGene ID"],
          "text": "Gene ID (EcoGene)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2787"
          },
          "definition": "A unique identifier of a whole genome assigned by the NCBI.",
          "text": "NCBI genome accession"
        }, {
          "comment": ["There are canonical and taxon-specific forms of RNAcentral ID. Canonical form e.g. urs_9or10digits identifies an RNA sequence (within the RNA central database) which may appear in multiple sequences. Taxon-specific form identifies a sequence in the specific taxon (e.g. urs_9or10digits_taxonID)."],
          "data": {
            "uri": "http://edamontology.org/data_3856"
          },
          "definition": "Identifier of an entry from the RNA central database of annotated human miRNAs.",
          "text": "RNA central ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1027"
          },
          "definition": "An NCBI unique identifier of a gene.",
          "exact_synonyms": ["NCBI geneid", "NCBI gene ID", "Gene identifier (NCBI)", "Gene identifier (Entrez)", "Entrez gene ID"],
          "text": "Gene ID (NCBI)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2612"
          },
          "definition": "Unique identifier of a sequence cluster from the CluSTr database.",
          "exact_synonyms": ["CluSTr cluster ID", "CluSTr ID"],
          "text": "Sequence cluster ID (CluSTr)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2778"
          },
          "definition": "The number of a strain of algae and protozoa from the CCAP database.",
          "text": "CCAP strain number"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2756"
          },
          "definition": "Identifier of a membrane transport proteins from the transport classification database (TCDB).",
          "text": "TCID"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2648"
            },
            "definition": "Identifier of a biological reaction (kinetics entry) from the SABIO-RK reactions database.",
            "text": "Reaction kinetics ID (SABIO-RK)"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2309"
          },
          "definition": "Identifier of a biological reaction from the SABIO-RK reactions database.",
          "text": "Reaction ID (SABIO-RK)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1905"
          },
          "definition": "Identifier of locus from MaizeGDB (Maize genome database).",
          "text": "Locus ID (MaizeGDB)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1891"
          },
          "definition": "A unique identifier of a protein or gene used in the iHOP database.",
          "text": "iHOP symbol"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2670"
          },
          "definition": "Identifier of a signaling pathway from the Database of Quantitative Cellular Signaling (DQCS).",
          "text": "Pathway ID (DQCS)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1128"
          },
          "definition": "Identifier of an entry from the AAindex database.",
          "text": "AAindex ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2751"
          },
          "definition": "An identifier of a particular genome.",
          "text": "GenomeReviews ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2105"
          },
          "definition": "Identifier of a compound from the BioCyc chemical compounds database.",
          "exact_synonyms": ["BioCyc compound ID", "BioCyc compound identifier"],
          "text": "Compound ID (BioCyc)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2622"
          },
          "definition": "Identifier of a small molecule metabolite from the Human Metabolome Database (HMDB).",
          "exact_synonyms": ["HMDB ID"],
          "text": "Compound ID (HMDB)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1908"
          },
          "definition": "Identifier of a locus from the Tropgene database.",
          "text": "Locus ID (Tropgene)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1149"
          },
          "definition": "Identifier of an entry from the EMAGE database.",
          "text": "EMAGE ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2375"
          },
          "definition": "Unique identifier of a spot from a two-dimensional (protein) gel from a HSC-2DPAGE database.",
          "text": "Spot ID (HSC-2DPAGE)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2729"
          },
          "definition": "Identifier of an EST sequence from the COGEME database.",
          "text": "COGEME EST ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2628"
          },
          "definition": "A unique identifier of an interaction from the BioGRID database.",
          "text": "BioGRID interaction ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2715"
          },
          "definition": "Unique identifier for a protein from the CuticleDB database.",
          "exact_synonyms": ["CuticleDB ID"],
          "text": "Protein ID (CuticleDB)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2391"
          },
          "definition": "Identifier of an entry from the UTR database.",
          "text": "UTR accession"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1139"
          },
          "definition": "Accession number of an entry from the SMART database.",
          "text": "SMART accession number"
        }, {
          "comment": ["This can be name of a gene, the ID of a TFBS, or genomic coordinates in form \"chr:start..end\"."],
          "data": {
            "uri": "http://edamontology.org/data_2736"
          },
          "definition": "A feature identifier as used in the SwissRegulon database.",
          "text": "Sequence feature ID (SwissRegulon)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2656"
          },
          "definition": "A unique identifier of a neuron from the NeuronDB database.",
          "text": "NeuronDB ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2591"
          },
          "definition": "Identifier of an entry from the Brite database of biological hierarchies.",
          "text": "Brite hierarchy ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1011"
          },
          "definition": "An Enzyme Commission (EC) number of an enzyme.",
          "exact_synonyms": ["EC code", "EC", "Enzyme Commission number"],
          "text": "EC number"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2642"
          },
          "definition": "Identifier for a gene from the miRBase database.",
          "exact_synonyms": ["miRNA identifier", "miRNA ID", "miRNA name"],
          "text": "Gene ID (miRBase)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1896"
          },
          "definition": "Identifier for loci from ASPGD (Aspergillus Genome Database).",
          "text": "Locus ID (ASPGD)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2796"
          },
          "definition": "Identifier of an entry from the GlycosciencesDB database.",
          "text": "Linucs ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1003"
          },
          "definition": "Beilstein registry number of a chemical compound.",
          "exact_synonyms": ["Beilstein chemical registry number"],
          "text": "Chemical registry number (Beilstein)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2667"
          },
          "definition": "An identifier of an entry from the MMDB database.",
          "exact_synonyms": ["MMDB accession"],
          "text": "MMDB ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2731"
          },
          "definition": "Accession number of an entry (family) from the TIGRFam database.",
          "exact_synonyms": ["GeneFarm family ID"],
          "text": "Protein family ID (GeneFarm)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1899"
          },
          "definition": "Locus identifier for Comprehensive Microbial Resource at the J. Craig Venter Institute.",
          "text": "Locus ID (CMR)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2298"
          },
          "definition": "Identifier for a gene approved by the HUGO Gene Nomenclature Committee.",
          "exact_synonyms": ["HGNC ID"],
          "text": "Gene ID (HGNC)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2792"
          },
          "definition": "Unique identifier for a peroxidase protein from the PeroxiBase database.",
          "exact_synonyms": ["PeroxiBase ID"],
          "text": "Protein ID (PeroxiBase)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1130"
          },
          "definition": "Accession number of an entry from the IntAct database.",
          "text": "IntAct accession number"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2770"
          },
          "definition": "Identifier of an RNA transcript from the H-InvDB database.",
          "text": "HIT ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1031"
          },
          "definition": "Identifier of a gene or feature from the CGD database.",
          "exact_synonyms": ["CGD ID"],
          "text": "Gene ID (CGD)"
        }, {
          "comment": ["A FIG ID consists of four parts: a prefix, genome id, locus type and id number."],
          "data": {
            "uri": "http://edamontology.org/data_2737"
          },
          "definition": "A unique identifier of gene in the NMPDR database.",
          "text": "FIG ID"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2293"
            },
            "definition": "Secondary (internal) identifier of a Gramene database entry.",
            "exact_synonyms": ["Gramene internal ID", "Gramene secondary ID", "Gramene internal identifier"],
            "text": "Gramene secondary identifier"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1102"
            },
            "definition": "Primary identifier of a Gramene database entry.",
            "exact_synonyms": ["Gramene primary ID"],
            "text": "Gramene primary identifier"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2915"
          },
          "definition": "Identifier of a Gramene database entry.",
          "text": "Gramene identifier"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1035"
          },
          "definition": "Identifier of a gene from the GeneDB database.",
          "exact_synonyms": ["GeneDB identifier"],
          "text": "Gene ID (GeneDB)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1897"
          },
          "definition": "Identifier for loci from Magnaporthe grisea Database at the Broad Institute.",
          "text": "Locus ID (MGG)"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_1172"
            },
            "definition": "Chemical structure specified in PubChem Compound Identification (CID), a non-zero integer identifier for a unique chemical structure.",
            "exact_synonyms": ["PubChem compound accession identifier"],
            "text": "PubChem CID"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2638"
            },
            "definition": "Identifier of an assay from the PubChem database.",
            "text": "PubChem bioassay ID"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2639"
          },
          "definition": "Identifier of an entry from the PubChem database.",
          "exact_synonyms": ["PubChem identifier"],
          "text": "PubChem ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1153"
          },
          "definition": "Identifier of an entry from the OMIM database.",
          "text": "OMIM ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_3238"
          },
          "definition": "Cell type ontology concept ID.",
          "exact_synonyms": ["CL ID"],
          "text": "Cell type ontology ID"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2803"
            },
            "definition": "A unique identifier of a cDNA molecule catalogued in the RefSeq database.",
            "text": "Clone ID (RefSeq)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2385"
            },
            "definition": "Accession number of a protein from the RefSeq database.",
            "exact_synonyms": ["RefSeq protein ID"],
            "text": "RefSeq accession (protein)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1027"
            },
            "definition": "An NCBI unique identifier of a gene.",
            "exact_synonyms": ["NCBI geneid", "NCBI gene ID", "Gene identifier (NCBI)", "Gene identifier (Entrez)", "Entrez gene ID"],
            "text": "Gene ID (NCBI)"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1098"
          },
          "definition": "Accession number of a RefSeq database entry.",
          "exact_synonyms": ["RefSeq ID"],
          "text": "RefSeq accession"
        }],
        "data": {
          "uri": "http://edamontology.org/data_2091"
        },
        "definition": "A persistent (stable) and unique identifier, typically identifying an object (entry) from a database.",
        "text": "Accession"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_1066"
          },
          "definition": "Identifier of a molecular sequence alignment, for example a record from an alignment database.",
          "is_identifier_of": ["http://edamontology.org/data_0863"],
          "text": "Sequence alignment ID"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2791"
            },
            "definition": "Name of a reference map gel from the SWISS-2DPAGE database.",
            "text": "Reference map name (SWISS-2DPAGE)"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2790"
          },
          "definition": "Identifier of a two-dimensional (protein) gel.",
          "exact_synonyms": ["Gel identifier"],
          "text": "Gel ID"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_1106"
            },
            "definition": "Identifier of a dbSNP database entry.",
            "exact_synonyms": ["dbSNP identifier"],
            "text": "dbSNP ID"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_3265"
            },
            "definition": "Identifier of a HGMD database entry.",
            "exact_synonyms": ["HGMD identifier"],
            "text": "HGMD ID"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2805"
            },
            "definition": "Identifier of a GeneSNP database entry.",
            "text": "GeneSNP ID"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_3264"
            },
            "definition": "Identifier of a COSMIC database entry.",
            "exact_synonyms": ["COSMIC identifier"],
            "text": "COSMIC ID"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2294"
          },
          "definition": "An identifier of an entry from a database of molecular sequence variation.",
          "text": "Sequence variation ID"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_1119"
            },
            "definition": "Unique identifier or name of a profile from the JASPAR database.",
            "text": "JASPAR profile ID"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2714"
            },
            "definition": "Unique identifier of a position-specific scoring matrix from the CDD database.",
            "text": "CDD PSSM-ID"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1118"
            },
            "definition": "Unique identifier or name of a HMMER hidden Markov model.",
            "is_identifier_of": ["http://edamontology.org/data_1364"],
            "text": "HMMER hidden Markov model ID"
          }],
          "comment": ["A sequence profile typically represents a sequence alignment."],
          "data": {
            "uri": "http://edamontology.org/data_1115"
          },
          "definition": "Identifier of a sequence profile.",
          "is_identifier_of": ["http://edamontology.org/data_1354"],
          "text": "Sequence profile ID"
        }, {
          "children": [{
            "children": [{
              "comment": ["A PDB identification code which consists of 4 characters, the first of which is a digit in the range 0 - 9; the remaining 3 are alpha-numeric, and letters are upper case only. (source: https://cdn.rcsb.org/wwpdb/docs/documentation/file-format/PDB_format_1996.pdf)"],
              "data": {
                "uri": "http://edamontology.org/data_1127"
              },
              "definition": "An identifier of an entry from the PDB database.",
              "exact_synonyms": ["PDB identifier", "PDBID"],
              "text": "PDB ID"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2667"
              },
              "definition": "An identifier of an entry from the MMDB database.",
              "exact_synonyms": ["MMDB accession"],
              "text": "MMDB ID"
            }],
            "data": {
              "uri": "http://edamontology.org/data_1070"
            },
            "definition": "A unique and persistent identifier of a molecular tertiary structure, typically an entry from a structure database.",
            "text": "Structure ID"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1759"
            },
            "definition": "Identifier of a model structure from a PDB file.",
            "exact_synonyms": ["Model number"],
            "text": "PDB model number"
          }],
          "data": {
            "uri": "http://edamontology.org/data_3035"
          },
          "definition": "An identifier of a molecular tertiary structure, typically an entry from a structure database.",
          "is_identifier_of": ["http://edamontology.org/data_0883"],
          "text": "Structure identifier"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_1116"
            },
            "definition": "Identifier of an entry from the ELMdb database of protein functional sites.",
            "text": "ELM ID"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1117"
            },
            "definition": "Accession number of an entry from the Prosite database.",
            "exact_synonyms": ["Prosite ID"],
            "text": "Prosite accession number"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2761"
            },
            "definition": "Identifier of an entry from the UTRSite database of regulatory motifs in eukaryotic UTRs.",
            "text": "UTRSite ID"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1114"
          },
          "definition": "Identifier of a sequence motif, for example an entry from a motif database.",
          "is_identifier_of": ["http://edamontology.org/data_1353"],
          "text": "Sequence motif identifier"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_1167"
            },
            "definition": "Unique identifier of a Taverna workflow.",
            "text": "Taverna workflow ID"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1083"
          },
          "definition": "Identifier of a biological or biomedical workflow, typically from a database of workflows.",
          "text": "Workflow ID"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2668"
            },
            "definition": "Unique identifier of an entry from the iRefIndex database of protein-protein interactions.",
            "text": "iRefIndex ID"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2302"
            },
            "definition": "Unique identifier of an entry from the STRING database of protein-protein interactions.",
            "text": "STRING ID"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1129"
            },
            "definition": "Accession number of an entry from the BIND database.",
            "text": "BIND accession number"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2616"
            },
            "definition": "Unique identifier of an entry from the DIP database of protein-protein interactions.",
            "text": "DIP ID"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2636"
            },
            "definition": "A unique identifier of an interaction from the MatrixDB database.",
            "text": "MatrixDB interaction ID"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2615"
            },
            "definition": "Unique identifier of an entry from the MINT database of protein-protein interactions.",
            "text": "MINT ID"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2628"
            },
            "definition": "A unique identifier of an interaction from the BioGRID database.",
            "text": "BioGRID interaction ID"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1130"
            },
            "definition": "Accession number of an entry from the IntAct database.",
            "text": "IntAct accession number"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1074"
          },
          "definition": "Identifier of a report of protein interactions from a protein interaction database (typically).",
          "is_identifier_of": ["http://edamontology.org/data_0906"],
          "text": "Protein interaction ID"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2374"
            },
            "definition": "Unique identifier of a spot from a two-dimensional (protein) gel in the SWISS-2DPAGE database.",
            "text": "Spot serial number"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2375"
            },
            "definition": "Unique identifier of a spot from a two-dimensional (protein) gel from a HSC-2DPAGE database.",
            "text": "Spot ID (HSC-2DPAGE)"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2373"
          },
          "definition": "Unique identifier of a spot from a two-dimensional (protein) gel.",
          "text": "Spot ID"
        }, {
          "children": [{
            "children": [{
              "data": {
                "uri": "http://edamontology.org/data_1026"
              },
              "definition": "The short name of a gene; a single word that does not contain white space characters. It is typically derived from the gene name.",
              "text": "Gene symbol"
            }],
            "data": {
              "uri": "http://edamontology.org/data_2299"
            },
            "definition": "The name of a gene, (typically) assigned by a person and/or according to a naming scheme. It may contain white space characters and is typically more intuitive and readable than a gene symbol. It (typically) may be used to identify similar genes in different species and to derive a gene symbol.",
            "narrow_synonyms": ["Allele name"],
            "text": "Gene name"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/data_1804"
              },
              "definition": "Gene identifier from Sol Genomics Network.",
              "text": "Gene ID (SGN)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1032"
              },
              "definition": "Identifier of a gene from DictyBase.",
              "text": "Gene ID (DictyBase)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1886"
              },
              "definition": "The blattner identifier for a gene.",
              "text": "Blattner number"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2643"
              },
              "definition": "Identifier for a gene from the Zebrafish information network genome (ZFIN) database.",
              "text": "Gene ID (ZFIN)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1033"
              },
              "definition": "Unique identifier for a gene (or other feature) from the Ensembl database.",
              "exact_synonyms": ["Gene ID (Ensembl)"],
              "text": "Ensembl gene ID"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2835"
              },
              "definition": "Identifier for a gene from the VBASE2 database.",
              "exact_synonyms": ["VBASE2 ID"],
              "text": "Gene ID (VBASE2)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2774"
              },
              "definition": "A unique identifier of gene assigned by the J. Craig Venter Institute (JCVI).",
              "text": "Gene ID (JCVI)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1796"
              },
              "definition": "Gene identifier from FlyBase database.",
              "text": "Gene ID (FlyBase)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1034"
              },
              "definition": "Identifier of an entry from the SGD database.",
              "exact_synonyms": ["SGD identifier"],
              "text": "Gene ID (SGD)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2393"
              },
              "definition": "Identifier of an entry from the Rouge or HUGE databases.",
              "text": "mFLJ/mKIAA number"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1794"
              },
              "definition": "Identifier of a gene from PlasmoDB Plasmodium Genome Resource.",
              "text": "Gene ID (PlasmoDB)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1036"
              },
              "definition": "Identifier of an entry from the TIGR database.",
              "text": "TIGR identifier"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1805"
              },
              "definition": "Gene identifier used by WormBase database.",
              "text": "Gene ID (WormBase)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1907"
              },
              "definition": "Identifier of a gene from the KOME database.",
              "text": "Gene ID (KOME)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1802"
              },
              "definition": "Gene identifier from Gramene database.",
              "text": "Gene ID (Gramene)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1803"
              },
              "definition": "Gene identifier from Virginia Bioinformatics Institute microbial database.",
              "text": "Gene ID (Virginia microbial)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1885"
              },
              "definition": "Identifier of a gene from the GeneFarm database.",
              "text": "Gene ID (GeneFarm)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2739"
              },
              "definition": "A unique identifier of gene in the Genolist database.",
              "text": "Gene ID (Genolist)"
            }, {
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/data_2388"
                },
                "definition": "Identifier of an Arabidopsis thaliana gene from the TAIR database.",
                "text": "TAIR accession (At gene)"
              }],
              "data": {
                "uri": "http://edamontology.org/data_1037"
              },
              "definition": "Identifier of an gene from the TAIR database.",
              "text": "TAIR accession (gene)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2738"
              },
              "definition": "A unique identifier of gene in the Xenbase database.",
              "text": "Gene ID (Xenbase)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2285"
              },
              "definition": "Identifier for genetic elements in MIPS database.",
              "exact_synonyms": ["MIPS genetic element identifier"],
              "text": "Gene ID (MIPS)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2771"
              },
              "definition": "A unique identifier of gene cluster in the H-InvDB database.",
              "text": "HIX ID"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2799"
              },
              "definition": "A unique identifier of gene in the MfunGD database.",
              "text": "Gene ID (MfunGD)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2759"
              },
              "definition": "Identifier for a gene from the VectorBase database.",
              "exact_synonyms": ["VectorBase ID"],
              "text": "Gene ID (VectorBase)"
            }, {
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/data_2297"
                },
                "definition": "Identifier of an E. coli K-12 gene from EcoGene Database.",
                "exact_synonyms": ["ECK accession", "E. coli K-12 gene identifier"],
                "text": "Gene ID (ECK)"
              }],
              "data": {
                "uri": "http://edamontology.org/data_1795"
              },
              "definition": "Identifier of a gene from EcoGene Database.",
              "exact_synonyms": ["EcoGene Accession", "EcoGene ID"],
              "text": "Gene ID (EcoGene)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1027"
              },
              "definition": "An NCBI unique identifier of a gene.",
              "exact_synonyms": ["NCBI geneid", "NCBI gene ID", "Gene identifier (NCBI)", "Gene identifier (Entrez)", "Entrez gene ID"],
              "text": "Gene ID (NCBI)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1891"
              },
              "definition": "A unique identifier of a protein or gene used in the iHOP database.",
              "text": "iHOP symbol"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2642"
              },
              "definition": "Identifier for a gene from the miRBase database.",
              "exact_synonyms": ["miRNA identifier", "miRNA ID", "miRNA name"],
              "text": "Gene ID (miRBase)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2298"
              },
              "definition": "Identifier for a gene approved by the HUGO Gene Nomenclature Committee.",
              "exact_synonyms": ["HGNC ID"],
              "text": "Gene ID (HGNC)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1031"
              },
              "definition": "Identifier of a gene or feature from the CGD database.",
              "exact_synonyms": ["CGD ID"],
              "text": "Gene ID (CGD)"
            }, {
              "comment": ["A FIG ID consists of four parts: a prefix, genome id, locus type and id number."],
              "data": {
                "uri": "http://edamontology.org/data_2737"
              },
              "definition": "A unique identifier of gene in the NMPDR database.",
              "text": "FIG ID"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1035"
              },
              "definition": "Identifier of a gene from the GeneDB database.",
              "exact_synonyms": ["GeneDB identifier"],
              "text": "Gene ID (GeneDB)"
            }],
            "data": {
              "uri": "http://edamontology.org/data_2295"
            },
            "definition": "A unique (and typically persistent) identifier of a gene in a database, that is (typically) different to the gene name/symbol.",
            "exact_synonyms": ["Gene code", "Gene accession"],
            "text": "Gene ID"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1025"
          },
          "definition": "An identifier of a gene, such as a name/symbol or a unique identifier of a gene in a database.",
          "is_identifier_of": ["http://edamontology.org/data_0916"],
          "text": "Gene identifier"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2383"
            },
            "definition": "Identifier of an entry from the EGA database.",
            "text": "EGA accession"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2382"
          },
          "definition": "Identifier of an entry from a database of genotype experiment metadata.",
          "is_identifier_of": ["http://edamontology.org/data_2531"],
          "text": "Genotype experiment ID"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2386"
            },
            "definition": "Identifier of an entry (promoter) from the EPD database.",
            "exact_synonyms": ["EPD identifier"],
            "text": "EPD ID"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2741"
            },
            "definition": "Identifier of an entry (promoter) from the ABS database.",
            "exact_synonyms": ["ABS identifier"],
            "text": "ABS ID"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2727"
          },
          "definition": "An identifier of a promoter of a gene that is catalogued in a database.",
          "text": "Promoter ID"
        }, {
          "children": [{
            "children": [{
              "comment": ["See for example http://www.ebi.ac.uk/Tools/webservices/help/matrix."],
              "data": {
                "uri": "http://edamontology.org/data_1126"
              },
              "definition": "Unique name or identifier of a comparison matrix.",
              "exact_synonyms": ["Substitution matrix name"],
              "is_identifier_of": ["http://edamontology.org/data_0874"],
              "text": "Comparison matrix name"
            }],
            "data": {
              "uri": "http://edamontology.org/data_1069"
            },
            "definition": "An identifier of a comparison matrix.",
            "exact_synonyms": ["Substitution matrix identifier"],
            "is_identifier_of": ["http://edamontology.org/data_0874"],
            "text": "Comparison matrix identifier"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/data_1128"
              },
              "definition": "Identifier of an entry from the AAindex database.",
              "text": "AAindex ID"
            }],
            "data": {
              "uri": "http://edamontology.org/data_1073"
            },
            "definition": "Identifier of an index of amino acid physicochemical and biochemical property data.",
            "is_identifier_of": ["http://edamontology.org/data_1501"],
            "text": "Amino acid index ID"
          }],
          "data": {
            "uri": "http://edamontology.org/data_3036"
          },
          "definition": "An identifier of an array of numerical values, such as a comparison matrix.",
          "is_identifier_of": ["http://edamontology.org/data_2082"],
          "text": "Matrix identifier"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_1146"
            },
            "definition": "Identifier of an entry from the EMDB electron microscopy database.",
            "text": "EMDB ID"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1079"
          },
          "definition": "Identifier of an entry from a database of electron microscopy data.",
          "is_identifier_of": ["http://edamontology.org/data_3805"],
          "text": "Electron microscopy model ID"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2780"
            },
            "definition": "A stock number from The Arabidopsis information resource (TAIR).",
            "text": "Stock number (TAIR)"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2779"
          },
          "definition": "An identifier of stock from a catalogue of biological resources.",
          "text": "Stock number"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_3022"
            },
            "definition": "Identifier of a genetic code in the NCBI list of genetic codes.",
            "text": "NCBI genetic code ID"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2128"
            },
            "definition": "Informal name for a genetic code, typically an organism name.",
            "text": "Genetic code name"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2127"
          },
          "definition": "An identifier of a genetic code.",
          "is_identifier_of": ["http://edamontology.org/data_1598"],
          "text": "Genetic code identifier"
        }, {
          "children": [{
            "children": [{
              "data": {
                "uri": "http://edamontology.org/data_1748"
              },
              "definition": "Identifier (a string) of a specific atom from a PDB file for a molecular structure.",
              "text": "PDB atom name"
            }],
            "data": {
              "uri": "http://edamontology.org/data_1757"
            },
            "definition": "Name of an atom.",
            "text": "Atom name"
          }],
          "data": {
            "uri": "http://edamontology.org/data_0983"
          },
          "definition": "Identifier (e.g. character symbol) of a specific atom.",
          "exact_synonyms": ["Atom identifier"],
          "text": "Atom ID"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2597"
            },
            "definition": "The name of a catalogue of biological resources from the CABRI database.",
            "text": "CABRI catalogue name"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2596"
          },
          "definition": "An identifier of a catalogue of biological resources.",
          "exact_synonyms": ["Catalogue identifier"],
          "text": "Catalogue ID"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2634"
            },
            "definition": "The International Standard Book Number (ISBN) is for identifying printed books.",
            "text": "ISBN"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2633"
          },
          "definition": "Unique identifier of a book.",
          "text": "Book ID"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_1061"
            },
            "definition": "Name of a QSAR descriptor.",
            "is_identifier_of": ["http://edamontology.org/data_0847"],
            "text": "QSAR descriptor name"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2110"
          },
          "definition": "Identifier of a molecular property.",
          "is_identifier_of": ["http://edamontology.org/data_2087"],
          "text": "Molecular property identifier"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_3266"
            },
            "definition": "Unique identifier of sequence assembly.",
            "narrow_synonyms": ["Sequence assembly version"],
            "text": "Sequence assembly ID"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/data_1104"
              },
              "definition": "A unique identifier of an entry (gene cluster) from the NCBI UniGene database.",
              "exact_synonyms": ["UniGene ID", "UniGene cluster ID", "UniGene identifier"],
              "text": "Sequence cluster ID (UniGene)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1113"
              },
              "definition": "Unique identifier of an entry from the COG database.",
              "exact_synonyms": ["COG ID"],
              "text": "Sequence cluster ID (COG)"
            }, {
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/data_2348"
                },
                "definition": "Unique identifier of an entry from the UniRef90 database.",
                "exact_synonyms": ["UniRef90 entry accession", "UniRef90 cluster id"],
                "text": "Sequence cluster ID (UniRef90)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2349"
                },
                "definition": "Unique identifier of an entry from the UniRef50 database.",
                "exact_synonyms": ["UniRef50 cluster id", "UniRef50 entry accession"],
                "text": "Sequence cluster ID (UniRef50)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2347"
                },
                "definition": "Unique identifier of an entry from the UniRef100 database.",
                "exact_synonyms": ["UniRef100 entry accession", "UniRef100 cluster id"],
                "text": "Sequence cluster ID (UniRef100)"
              }],
              "data": {
                "uri": "http://edamontology.org/data_2346"
              },
              "definition": "Unique identifier of an entry from the UniRef database.",
              "exact_synonyms": ["UniRef cluster id", "UniRef entry accession"],
              "text": "Sequence cluster ID (UniRef)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2220"
              },
              "definition": "Unique identifier of a sequence cluster from the SYSTERS database.",
              "exact_synonyms": ["SYSTERS cluster ID"],
              "text": "Sequence cluster ID (SYSTERS)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2612"
              },
              "definition": "Unique identifier of a sequence cluster from the CluSTr database.",
              "exact_synonyms": ["CluSTr cluster ID", "CluSTr ID"],
              "text": "Sequence cluster ID (CluSTr)"
            }],
            "data": {
              "uri": "http://edamontology.org/data_1112"
            },
            "definition": "An identifier of a cluster of molecular sequence(s).",
            "is_identifier_of": ["http://edamontology.org/data_1235"],
            "text": "Sequence cluster ID"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1064"
          },
          "definition": "An identifier of a set of molecular sequence(s).",
          "is_identifier_of": ["http://edamontology.org/data_0850"],
          "text": "Sequence set ID"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_1151"
            },
            "definition": "Identifier of an entry from the HGVbase database.",
            "text": "HGVbase ID"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1153"
            },
            "definition": "Identifier of an entry from the OMIM database.",
            "text": "OMIM ID"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1081"
          },
          "definition": "Identifier of an entry from a database of genotypes and phenotypes.",
          "is_identifier_of": ["http://edamontology.org/data_0920"],
          "text": "Genotype and phenotype annotation ID"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_1903"
            },
            "definition": "Identifier of locus from DictyBase (Dictyostelium discoideum).",
            "text": "Locus ID (DictyBase)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2744"
            },
            "definition": "Identifier of a locus from the PseudoCAP database.",
            "text": "Locus ID (PseudoCAP)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1895"
            },
            "definition": "Locus identifier for Arabidopsis Genome Initiative (TAIR, TIGR and MIPS databases)",
            "exact_synonyms": ["Arabidopsis gene loci number", "AGI ID", "AGI identifier", "AGI locus code"],
            "text": "Locus ID (AGI)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2794"
            },
            "definition": "Accession of an open reading frame (catalogued in a database).",
            "text": "ORF ID"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1901"
            },
            "definition": "Identifier for loci from SGD (Saccharomyces Genome Database).",
            "exact_synonyms": ["SGDID"],
            "text": "Locus ID (SGD)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1902"
            },
            "definition": "Identifier of loci from Maize Mapping Project.",
            "text": "Locus ID (MMP)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1900"
            },
            "definition": "Identifier for loci from NCBI database.",
            "exact_synonyms": ["Locus ID (NCBI)"],
            "text": "NCBI locus tag"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1898"
            },
            "definition": "Identifier for loci from CGD (Candida Genome Database).",
            "exact_synonyms": ["CGDID", "CGD locus identifier"],
            "text": "Locus ID (CGD)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2745"
            },
            "definition": "Identifier of a locus from the UTR database.",
            "text": "Locus ID (UTR)"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/data_1804"
              },
              "definition": "Gene identifier from Sol Genomics Network.",
              "text": "Gene ID (SGN)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1032"
              },
              "definition": "Identifier of a gene from DictyBase.",
              "text": "Gene ID (DictyBase)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1886"
              },
              "definition": "The blattner identifier for a gene.",
              "text": "Blattner number"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2643"
              },
              "definition": "Identifier for a gene from the Zebrafish information network genome (ZFIN) database.",
              "text": "Gene ID (ZFIN)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1033"
              },
              "definition": "Unique identifier for a gene (or other feature) from the Ensembl database.",
              "exact_synonyms": ["Gene ID (Ensembl)"],
              "text": "Ensembl gene ID"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2835"
              },
              "definition": "Identifier for a gene from the VBASE2 database.",
              "exact_synonyms": ["VBASE2 ID"],
              "text": "Gene ID (VBASE2)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2774"
              },
              "definition": "A unique identifier of gene assigned by the J. Craig Venter Institute (JCVI).",
              "text": "Gene ID (JCVI)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1796"
              },
              "definition": "Gene identifier from FlyBase database.",
              "text": "Gene ID (FlyBase)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1034"
              },
              "definition": "Identifier of an entry from the SGD database.",
              "exact_synonyms": ["SGD identifier"],
              "text": "Gene ID (SGD)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2393"
              },
              "definition": "Identifier of an entry from the Rouge or HUGE databases.",
              "text": "mFLJ/mKIAA number"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1794"
              },
              "definition": "Identifier of a gene from PlasmoDB Plasmodium Genome Resource.",
              "text": "Gene ID (PlasmoDB)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1036"
              },
              "definition": "Identifier of an entry from the TIGR database.",
              "text": "TIGR identifier"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1805"
              },
              "definition": "Gene identifier used by WormBase database.",
              "text": "Gene ID (WormBase)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1907"
              },
              "definition": "Identifier of a gene from the KOME database.",
              "text": "Gene ID (KOME)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1802"
              },
              "definition": "Gene identifier from Gramene database.",
              "text": "Gene ID (Gramene)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1803"
              },
              "definition": "Gene identifier from Virginia Bioinformatics Institute microbial database.",
              "text": "Gene ID (Virginia microbial)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1885"
              },
              "definition": "Identifier of a gene from the GeneFarm database.",
              "text": "Gene ID (GeneFarm)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2739"
              },
              "definition": "A unique identifier of gene in the Genolist database.",
              "text": "Gene ID (Genolist)"
            }, {
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/data_2388"
                },
                "definition": "Identifier of an Arabidopsis thaliana gene from the TAIR database.",
                "text": "TAIR accession (At gene)"
              }],
              "data": {
                "uri": "http://edamontology.org/data_1037"
              },
              "definition": "Identifier of an gene from the TAIR database.",
              "text": "TAIR accession (gene)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2738"
              },
              "definition": "A unique identifier of gene in the Xenbase database.",
              "text": "Gene ID (Xenbase)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2285"
              },
              "definition": "Identifier for genetic elements in MIPS database.",
              "exact_synonyms": ["MIPS genetic element identifier"],
              "text": "Gene ID (MIPS)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2771"
              },
              "definition": "A unique identifier of gene cluster in the H-InvDB database.",
              "text": "HIX ID"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2799"
              },
              "definition": "A unique identifier of gene in the MfunGD database.",
              "text": "Gene ID (MfunGD)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2759"
              },
              "definition": "Identifier for a gene from the VectorBase database.",
              "exact_synonyms": ["VectorBase ID"],
              "text": "Gene ID (VectorBase)"
            }, {
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/data_2297"
                },
                "definition": "Identifier of an E. coli K-12 gene from EcoGene Database.",
                "exact_synonyms": ["ECK accession", "E. coli K-12 gene identifier"],
                "text": "Gene ID (ECK)"
              }],
              "data": {
                "uri": "http://edamontology.org/data_1795"
              },
              "definition": "Identifier of a gene from EcoGene Database.",
              "exact_synonyms": ["EcoGene Accession", "EcoGene ID"],
              "text": "Gene ID (EcoGene)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1027"
              },
              "definition": "An NCBI unique identifier of a gene.",
              "exact_synonyms": ["NCBI geneid", "NCBI gene ID", "Gene identifier (NCBI)", "Gene identifier (Entrez)", "Entrez gene ID"],
              "text": "Gene ID (NCBI)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1891"
              },
              "definition": "A unique identifier of a protein or gene used in the iHOP database.",
              "text": "iHOP symbol"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2642"
              },
              "definition": "Identifier for a gene from the miRBase database.",
              "exact_synonyms": ["miRNA identifier", "miRNA ID", "miRNA name"],
              "text": "Gene ID (miRBase)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2298"
              },
              "definition": "Identifier for a gene approved by the HUGO Gene Nomenclature Committee.",
              "exact_synonyms": ["HGNC ID"],
              "text": "Gene ID (HGNC)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1031"
              },
              "definition": "Identifier of a gene or feature from the CGD database.",
              "exact_synonyms": ["CGD ID"],
              "text": "Gene ID (CGD)"
            }, {
              "comment": ["A FIG ID consists of four parts: a prefix, genome id, locus type and id number."],
              "data": {
                "uri": "http://edamontology.org/data_2737"
              },
              "definition": "A unique identifier of gene in the NMPDR database.",
              "text": "FIG ID"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1035"
              },
              "definition": "Identifier of a gene from the GeneDB database.",
              "exact_synonyms": ["GeneDB identifier"],
              "text": "Gene ID (GeneDB)"
            }],
            "data": {
              "uri": "http://edamontology.org/data_2295"
            },
            "definition": "A unique (and typically persistent) identifier of a gene in a database, that is (typically) different to the gene name/symbol.",
            "exact_synonyms": ["Gene code", "Gene accession"],
            "text": "Gene ID"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1904"
            },
            "definition": "Identifier of a locus from EntrezGene database.",
            "text": "Locus ID (EntrezGene)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1905"
            },
            "definition": "Identifier of locus from MaizeGDB (Maize genome database).",
            "text": "Locus ID (MaizeGDB)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1908"
            },
            "definition": "Identifier of a locus from the Tropgene database.",
            "text": "Locus ID (Tropgene)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1896"
            },
            "definition": "Identifier for loci from ASPGD (Aspergillus Genome Database).",
            "text": "Locus ID (ASPGD)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1899"
            },
            "definition": "Locus identifier for Comprehensive Microbial Resource at the J. Craig Venter Institute.",
            "text": "Locus ID (CMR)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1897"
            },
            "definition": "Identifier for loci from Magnaporthe grisea Database at the Broad Institute.",
            "text": "Locus ID (MGG)"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1893"
          },
          "definition": "A unique name or other identifier of a genetic locus, typically conforming to a scheme that names loci (such as predicted genes) depending on their position in a molecular sequence, for example a completely sequenced genome or chromosome.",
          "exact_synonyms": ["Locus name", "Locus identifier"],
          "is_identifier_of": ["http://edamontology.org/data_2012"],
          "text": "Locus ID"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_1188"
            },
            "definition": "Digital Object Identifier (DOI) of a published article.",
            "exact_synonyms": ["Digital Object Identifier"],
            "text": "DOI"
          }, {
            "comment": ["The use of Medline UI has been replaced by the PubMed unique identifier."],
            "data": {
              "uri": "http://edamontology.org/data_1189"
            },
            "definition": "Medline UI (unique identifier) of an article.",
            "exact_synonyms": ["Medline unique identifier"],
            "text": "Medline UI"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1187"
            },
            "definition": "PubMed unique identifier of an article.",
            "exact_synonyms": ["PMID"],
            "text": "PubMed ID"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1088"
          },
          "definition": "Unique identifier of a scientific article.",
          "exact_synonyms": ["Article identifier"],
          "is_identifier_of": ["http://edamontology.org/data_0971"],
          "text": "Article ID"
        }, {
          "children": [{
            "children": [{
              "comment": ["OBO file for regular expression."],
              "data": {
                "uri": "http://edamontology.org/data_2614"
              },
              "definition": "A unique identifier of a family from the transport classification database (TCDB) of membrane transport proteins.",
              "exact_synonyms": ["TC number"],
              "text": "TCDB ID"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2783"
              },
              "definition": "Accession number of an entry (family) from the PANTHER database.",
              "exact_synonyms": ["Panther family ID"],
              "text": "Protein family ID (PANTHER)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1136"
              },
              "definition": "Unique identifier of an entry from the PIRSF database.",
              "text": "PIRSF ID"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1135"
              },
              "definition": "Unique identifier of an entry from the Gene3D database.",
              "text": "Gene3D ID"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2758"
              },
              "definition": "Accession number of a Pfam clan.",
              "text": "Pfam clan ID"
            }, {
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/data_1134"
                },
                "definition": "Secondary accession number of an InterPro entry.",
                "exact_synonyms": ["InterPro secondary accession number"],
                "is_identifier_of": ["http://edamontology.org/data_1355"],
                "text": "InterPro secondary accession"
              }],
              "comment": ["Every InterPro entry has a unique accession number to provide a persistent citation of database records."],
              "data": {
                "uri": "http://edamontology.org/data_1133"
              },
              "definition": "Primary accession number of an InterPro entry.",
              "exact_synonyms": ["InterPro primary accession", "InterPro primary accession number"],
              "is_identifier_of": ["http://edamontology.org/data_1355"],
              "text": "InterPro accession"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1141"
              },
              "definition": "Accession number of an entry (family) from the TIGRFam database.",
              "exact_synonyms": ["TIGRFam accession number"],
              "text": "TIGRFam ID"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1138"
              },
              "definition": "Accession number of a Pfam entry.",
              "text": "Pfam accession number"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1140"
              },
              "definition": "Unique identifier (number) of a hidden Markov model from the Superfamily database.",
              "text": "Superfamily hidden Markov model number"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1137"
              },
              "definition": "The unique identifier of an entry in the PRINTS database.",
              "text": "PRINTS code"
            }, {
              "comment": ["ProDom is a protein domain family database."],
              "data": {
                "uri": "http://edamontology.org/data_1142"
              },
              "definition": "A ProDom domain family accession number.",
              "text": "ProDom accession number"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2766"
              },
              "definition": "Name of a protein family from the HAMAP database.",
              "text": "HAMAP ID"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1139"
              },
              "definition": "Accession number of an entry from the SMART database.",
              "text": "SMART accession number"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2731"
              },
              "definition": "Accession number of an entry (family) from the TIGRFam database.",
              "exact_synonyms": ["GeneFarm family ID"],
              "text": "Protein family ID (GeneFarm)"
            }],
            "data": {
              "uri": "http://edamontology.org/data_2910"
            },
            "definition": "Accession of a protein family (that is deposited in a database).",
            "text": "Protein family accession"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/data_2782"
              },
              "definition": "Name of a domain from the SMART database.",
              "text": "SMART domain name"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1132"
              },
              "definition": "Name of an InterPro entry, usually indicating the type of protein matches for that entry.",
              "is_identifier_of": ["http://edamontology.org/data_1355"],
              "text": "InterPro entry name"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2757"
              },
              "definition": "Name of a domain from the Pfam database.",
              "text": "Pfam domain name"
            }],
            "data": {
              "uri": "http://edamontology.org/data_1131"
            },
            "definition": "Name of a protein family.",
            "text": "Protein family name"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1075"
          },
          "definition": "Identifier of a protein family.",
          "exact_synonyms": ["Protein secondary database record identifier"],
          "is_identifier_of": ["http://edamontology.org/data_0907"],
          "text": "Protein family identifier"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2904"
            },
            "definition": "An accession of a map of a molecular sequence (deposited in a database).",
            "text": "Map accession"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2117"
          },
          "definition": "An identifier of a map of a molecular sequence.",
          "is_identifier_of": ["http://edamontology.org/data_1274"],
          "text": "Map identifier"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2793"
            },
            "definition": "Identifier of an entry from the SISYPHUS database of tertiary structure alignments.",
            "text": "SISYPHUS ID"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1072"
          },
          "definition": "Identifier of an entry from a database of tertiary structure alignments.",
          "is_identifier_of": ["http://edamontology.org/data_0886"],
          "text": "Structure alignment ID"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2606"
            },
            "definition": "Name (not necessarily stable) an entry (RNA family) from the RFAM database.",
            "text": "RFAM name"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2356"
            },
            "definition": "Stable accession number of an entry (RNA family) from the RFAM database.",
            "text": "RFAM accession"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2355"
          },
          "definition": "Identifier of an RNA family, typically an entry from a RNA sequence classification database.",
          "is_identifier_of": ["http://edamontology.org/data_2354"],
          "text": "RNA family identifier"
        }, {
          "children": [{
            "children": [{
              "data": {
                "uri": "http://edamontology.org/data_2344"
              },
              "definition": "Identifier of a pathway from the NCI-Nature pathway database.",
              "text": "Pathway ID (NCI-Nature)"
            }, {
              "comment": ["These identifiers are unique within the cPath database, however, they are not stable between releases."],
              "data": {
                "uri": "http://edamontology.org/data_2637"
              },
              "definition": "A unique identifier for pathways, reactions, complexes and small molecules from the cPath (Pathway Commons) database.",
              "text": "cPath ID"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2837"
              },
              "definition": "Identifier of a pathway from the BioSystems pathway database.",
              "text": "Pathway ID (BioSystems)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2345"
              },
              "definition": "Identifier of a pathway from the ConsensusPathDB pathway database.",
              "text": "Pathway ID (ConsensusPathDB)"
            }, {
              "comment": ["This concept refers to identifiers used by the databases collated in CPDB; CPDB identifiers are not independently defined."],
              "data": {
                "uri": "http://edamontology.org/data_1160"
              },
              "definition": "Identifier of an entry from the CPDB (ConsensusPathDB) biological pathways database, which is an identifier from an external database integrated into CPDB.",
              "exact_synonyms": ["CPDB ID"],
              "text": "Pathway ID (CPDB)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1158"
              },
              "definition": "Identifier of an entry from the INOH database.",
              "exact_synonyms": ["INOH identifier"],
              "text": "Pathway ID (INOH)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1159"
              },
              "definition": "Identifier of an entry from the PATIKA database.",
              "exact_synonyms": ["PATIKA ID"],
              "text": "Pathway ID (PATIKA)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_3952"
              },
              "definition": "Identifier of a pathway from the WikiPathways pathway database.",
              "exact_synonyms": ["WikiPathways pathway ID", "WikiPathways ID"],
              "text": "Pathway ID (WikiPathways)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2650"
              },
              "definition": "Identifier of a pathway from the pharmacogenetics and pharmacogenomics knowledge base (PharmGKB).",
              "text": "Pathway ID (PharmGKB)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2343"
              },
              "definition": "Identifier of a pathway from the KEGG pathway database.",
              "exact_synonyms": ["KEGG pathway ID"],
              "text": "Pathway ID (KEGG)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1157"
              },
              "definition": "Identifier of an pathway from the BioCyc biological pathways database.",
              "exact_synonyms": ["BioCyc pathway ID"],
              "text": "Pathway ID (BioCyc)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1155"
              },
              "definition": "Identifier of an entry from the Reactome database.",
              "exact_synonyms": ["Reactome ID"],
              "text": "Pathway ID (reactome)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2659"
              },
              "definition": "Identifier of a pathway from the Small Molecule Pathway Database (SMPDB).",
              "text": "Pathway ID (SMPDB)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1161"
              },
              "definition": "Identifier of a biological pathway from the Panther Pathways database.",
              "exact_synonyms": ["Panther Pathways ID"],
              "text": "Pathway ID (Panther)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2645"
              },
              "definition": "Identifier of a biological pathway from the Unipathway database.",
              "exact_synonyms": ["upaid"],
              "text": "Pathway ID (Unipathway)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2670"
              },
              "definition": "Identifier of a signaling pathway from the Database of Quantitative Cellular Signaling (DQCS).",
              "text": "Pathway ID (DQCS)"
            }],
            "data": {
              "uri": "http://edamontology.org/data_2365"
            },
            "definition": "A persistent, unique identifier of a biological pathway or network (typically a database entry).",
            "text": "Pathway or network accession"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2342"
            },
            "definition": "The name of a biological pathway or network.",
            "text": "Pathway or network name"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1082"
          },
          "definition": "Identifier of an entry from a database of biological pathways or networks.",
          "is_identifier_of": ["http://edamontology.org/data_2600"],
          "text": "Pathway or network identifier"
        }, {
          "children": [{
            "children": [{
              "data": {
                "uri": "http://edamontology.org/data_1179"
              },
              "definition": "A stable unique identifier for each taxon (for a species, a family, an order, or any other group in the NCBI taxonomy database.",
              "exact_synonyms": ["NCBI tax ID", "NCBI taxonomy identifier"],
              "text": "NCBI taxonomy ID"
            }, {
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/data_2778"
                },
                "definition": "The number of a strain of algae and protozoa from the CCAP database.",
                "text": "CCAP strain number"
              }],
              "data": {
                "uri": "http://edamontology.org/data_2912"
              },
              "definition": "Identifier of a strain of an organism variant, typically a plant, virus or bacterium.",
              "is_identifier_of": ["http://edamontology.org/data_0963"],
              "text": "Strain accession"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1873"
              },
              "definition": "A unique identifier for an organism used in the iHOP database.",
              "text": "iHOP organism ID"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2593"
              },
              "definition": "A unique identifier for an organism used in the BRENDA database.",
              "text": "BRENDA organism ID"
            }, {
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/data_2836"
                },
                "definition": "A unique identifier for a virus from the DPVweb database.",
                "exact_synonyms": ["DPVweb virus ID"],
                "text": "DPVweb ID"
              }, {
                "comment": ["Could list (or reference) other taxa here from https://www.phenoscape.org/wiki/Taxonomic_Rank_Vocabulary."],
                "data": {
                  "uri": "http://edamontology.org/data_2784"
                },
                "definition": "A unique identifier for a virus from the RNAVirusDB database.",
                "text": "RNAVirusDB ID"
              }],
              "data": {
                "uri": "http://edamontology.org/data_2785"
              },
              "definition": "An accession of annotation on a (group of) viruses (catalogued in a database).",
              "text": "Virus ID"
            }],
            "data": {
              "uri": "http://edamontology.org/data_2908"
            },
            "definition": "An accession of annotation on a (group of) organisms (catalogued in a database).",
            "text": "Organism accession"
          }, {
            "children": [{
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/data_2836"
                },
                "definition": "A unique identifier for a virus from the DPVweb database.",
                "exact_synonyms": ["DPVweb virus ID"],
                "text": "DPVweb ID"
              }, {
                "comment": ["Could list (or reference) other taxa here from https://www.phenoscape.org/wiki/Taxonomic_Rank_Vocabulary."],
                "data": {
                  "uri": "http://edamontology.org/data_2784"
                },
                "definition": "A unique identifier for a virus from the RNAVirusDB database.",
                "text": "RNAVirusDB ID"
              }],
              "data": {
                "uri": "http://edamontology.org/data_2785"
              },
              "definition": "An accession of annotation on a (group of) viruses (catalogued in a database).",
              "text": "Virus ID"
            }],
            "data": {
              "uri": "http://edamontology.org/data_2913"
            },
            "definition": "An accession of annotation on a (group of) viruses (catalogued in a database).",
            "text": "Virus identifier"
          }, {
            "children": [{
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/data_2778"
                },
                "definition": "The number of a strain of algae and protozoa from the CCAP database.",
                "text": "CCAP strain number"
              }],
              "data": {
                "uri": "http://edamontology.org/data_2912"
              },
              "definition": "Identifier of a strain of an organism variant, typically a plant, virus or bacterium.",
              "is_identifier_of": ["http://edamontology.org/data_0963"],
              "text": "Strain accession"
            }, {
              "children": [{
                "children": [{
                  "data": {
                    "uri": "http://edamontology.org/data_2320"
                  },
                  "definition": "The name of a cell line.",
                  "text": "Cell line name (assonant)"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_2319"
                  },
                  "definition": "The name of a cell line.",
                  "text": "Cell line name (no punctuation)"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_2317"
                  },
                  "definition": "The name of a cell line.",
                  "text": "Cell line name (exact)"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_2318"
                  },
                  "definition": "The name of a cell line.",
                  "text": "Cell line name (truncated)"
                }],
                "data": {
                  "uri": "http://edamontology.org/data_2316"
                },
                "definition": "The name of a cell line.",
                "text": "Cell line name"
              }],
              "data": {
                "uri": "http://edamontology.org/data_1046"
              },
              "definition": "The name of a strain of an organism variant, typically a plant, virus or bacterium.",
              "text": "Strain name"
            }],
            "data": {
              "uri": "http://edamontology.org/data_2379"
            },
            "definition": "Identifier of a strain of an organism variant, typically a plant, virus or bacterium.",
            "text": "Strain identifier"
          }, {
            "children": [{
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/data_2595"
                },
                "definition": "The name of a taxon using the controlled vocabulary of the UTRdb database.",
                "text": "UTRdb taxon"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_1044"
                },
                "definition": "The name of a biological kingdom (Bacteria, Archaea, or Eukaryotes).",
                "text": "Kingdom name"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_1870"
                },
                "definition": "The name of a genus of organism.",
                "text": "Genus name"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_1045"
                },
                "definition": "The name of a species (typically a taxonomic group) of organism.",
                "exact_synonyms": ["Organism species"],
                "text": "Species name"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_1875"
                },
                "definition": "The name of a taxon from the NCBI taxonomy database.",
                "text": "NCBI taxon"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2594"
                },
                "definition": "The name of a taxon using the controlled vocabulary of the UniGene database.",
                "exact_synonyms": ["UniGene organism abbreviation"],
                "text": "UniGene taxon"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2732"
                },
                "definition": "The name of a family of organism.",
                "text": "Family name"
              }],
              "comment": ["For a complete list of taxonomic ranks see https://www.phenoscape.org/wiki/Taxonomic_Rank_Vocabulary."],
              "data": {
                "uri": "http://edamontology.org/data_1868"
              },
              "definition": "The name of a group of organisms belonging to the same taxonomic rank.",
              "exact_synonyms": ["Taxonomic rank", "Taxonomy rank"],
              "text": "Taxon"
            }, {
              "comment": ["Name components correspond to levels in a taxonomic hierarchy (e.g. 'Genus', 'Species', etc.) Meta information such as a reference where the name was defined and a date might be included."],
              "data": {
                "uri": "http://edamontology.org/data_1872"
              },
              "definition": "The full name for a group of organisms, reflecting their biological classification and (usually) conforming to a standard nomenclature.",
              "exact_synonyms": ["Taxonomic name", "Taxonomic information"],
              "text": "Taxonomic classification"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2102"
              },
              "definition": "A three-letter code used in the KEGG databases to uniquely identify organisms.",
              "text": "KEGG organism code"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1874"
              },
              "definition": "Common name for an organism as used in the GenBank database.",
              "text": "Genbank common name"
            }, {
              "children": [{
                "children": [{
                  "data": {
                    "uri": "http://edamontology.org/data_2320"
                  },
                  "definition": "The name of a cell line.",
                  "text": "Cell line name (assonant)"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_2319"
                  },
                  "definition": "The name of a cell line.",
                  "text": "Cell line name (no punctuation)"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_2317"
                  },
                  "definition": "The name of a cell line.",
                  "text": "Cell line name (exact)"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_2318"
                  },
                  "definition": "The name of a cell line.",
                  "text": "Cell line name (truncated)"
                }],
                "data": {
                  "uri": "http://edamontology.org/data_2316"
                },
                "definition": "The name of a cell line.",
                "text": "Cell line name"
              }],
              "data": {
                "uri": "http://edamontology.org/data_1046"
              },
              "definition": "The name of a strain of an organism variant, typically a plant, virus or bacterium.",
              "text": "Strain name"
            }],
            "data": {
              "uri": "http://edamontology.org/data_2909"
            },
            "definition": "The name of an organism (or group of organisms).",
            "text": "Organism name"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1869"
          },
          "definition": "A unique identifier of a (group of) organisms.",
          "is_identifier_of": ["http://edamontology.org/data_2530"],
          "text": "Organism identifier"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2644"
            },
            "definition": "Identifier of an enzyme-catalysed reaction from the Rhea database.",
            "text": "Reaction ID (Rhea)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2641"
            },
            "definition": "Identifier of an enzyme reaction mechanism from the MACie database.",
            "exact_synonyms": ["MACie entry number"],
            "text": "Reaction ID (MACie)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2608"
            },
            "definition": "Identifier of a biological reaction from the KEGG reactions database.",
            "text": "Reaction ID (KEGG)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2106"
            },
            "definition": "Identifier of a biological reaction from the BioCyc reactions database.",
            "text": "Reaction ID (BioCyc)"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/data_2648"
              },
              "definition": "Identifier of a biological reaction (kinetics entry) from the SABIO-RK reactions database.",
              "text": "Reaction kinetics ID (SABIO-RK)"
            }],
            "data": {
              "uri": "http://edamontology.org/data_2309"
            },
            "definition": "Identifier of a biological reaction from the SABIO-RK reactions database.",
            "text": "Reaction ID (SABIO-RK)"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2108"
          },
          "definition": "Identifier of a biological reaction from a database.",
          "is_identifier_of": ["http://edamontology.org/data_2978"],
          "text": "Reaction ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2098"
          },
          "definition": "An identifier of a submitted job.",
          "text": "Job identifier"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_1023"
            },
            "definition": "The name of a sequence feature-containing entity adhering to the standard feature naming scheme used by all EMBOSS applications.",
            "exact_synonyms": ["UFO"],
            "text": "EMBOSS Uniform Feature Object"
          }, {
            "children": [{
              "comment": ["This can be name of a gene, the ID of a TFBS, or genomic coordinates in form \"chr:start..end\"."],
              "data": {
                "uri": "http://edamontology.org/data_2736"
              },
              "definition": "A feature identifier as used in the SwissRegulon database.",
              "text": "Sequence feature ID (SwissRegulon)"
            }],
            "data": {
              "uri": "http://edamontology.org/data_1015"
            },
            "definition": "A unique identifier of molecular sequence feature, for example an ID of a feature that is unique within the scope of the GFF file.",
            "text": "Sequence feature ID"
          }, {
            "comment": ["A feature label identifies a feature of a sequence database entry. When used with the database name and the entry's primary accession number, it is a unique identifier of that feature."],
            "data": {
              "uri": "http://edamontology.org/data_1022"
            },
            "definition": "A name of a sequence feature, e.g. the name of a feature to be displayed to an end-user. Typically an EMBL or Swiss-Prot feature label.",
            "exact_synonyms": ["Sequence feature name"],
            "text": "Sequence feature label"
          }],
          "data": {
            "uri": "http://edamontology.org/data_3034"
          },
          "definition": "Name or other identifier of molecular sequence feature(s).",
          "is_identifier_of": ["http://edamontology.org/data_1255"],
          "text": "Sequence feature identifier"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2638"
          },
          "definition": "Identifier of an assay from the PubChem database.",
          "text": "PubChem bioassay ID"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_1148"
            },
            "definition": "Identifier of an entry from the GermOnline database.",
            "text": "GermOnline ID"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2709"
            },
            "definition": "An identifier of a gene expression profile from the CleanEx database.",
            "text": "CleanEx entry name"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1147"
            },
            "definition": "Accession number of an entry from the GEO database.",
            "text": "GEO accession number"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1149"
            },
            "definition": "Identifier of an entry from the EMAGE database.",
            "text": "EMAGE ID"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1080"
          },
          "definition": "Accession of a report of gene expression (e.g. a gene expression profile) from a database.",
          "exact_synonyms": ["Gene expression profile identifier"],
          "is_identifier_of": ["http://edamontology.org/data_3111"],
          "text": "Gene expression report ID"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_3759"
            },
            "definition": "Identifier for mass spectrometry proteomics data in the proteomexchange.org repository.",
            "text": "ProteomeXchange ID"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1144"
            },
            "definition": "Accession number of an entry from the ArrayExpress database.",
            "exact_synonyms": ["ArrayExpress experiment ID"],
            "text": "ArrayExpress accession number"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2710"
            },
            "definition": "An identifier of (typically a list of) gene expression experiments catalogued in the CleanEx database.",
            "text": "CleanEx dataset code"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1145"
            },
            "definition": "PRIDE experiment accession number.",
            "text": "PRIDE experiment accession number"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_3568"
            },
            "definition": "Accession number of an entry from the Gene Expression Atlas.",
            "text": "Gene Expression Atlas Experiment ID"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1078"
          },
          "definition": "Identifier of an entry from a database of microarray data.",
          "is_identifier_of": ["http://edamontology.org/data_2531"],
          "text": "Experiment annotation ID"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2209"
            },
            "definition": "A unique identifier of a specific mutation catalogued in a database.",
            "text": "Mutation ID"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2538"
          },
          "definition": "An identifier of a mutation.",
          "text": "Mutation identifier"
        }, {
          "children": [{
            "children": [{
              "data": {
                "uri": "http://edamontology.org/data_2786"
              },
              "definition": "An identifier of a genome project assigned by NCBI.",
              "text": "NCBI Genome Project ID"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2787"
              },
              "definition": "A unique identifier of a whole genome assigned by the NCBI.",
              "text": "NCBI genome accession"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2751"
              },
              "definition": "An identifier of a particular genome.",
              "text": "GenomeReviews ID"
            }],
            "data": {
              "uri": "http://edamontology.org/data_2903"
            },
            "definition": "An accession of a particular genome (in a database).",
            "text": "Genome accession"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2340"
            },
            "definition": "An identifier of a build of a particular genome.",
            "text": "Genome build identifier"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2749"
          },
          "definition": "An identifier of a particular genome.",
          "text": "Genome identifier"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2588"
            },
            "definition": "Unique identifier of a blot from a Northern Blot from the BlotBase database.",
            "text": "BlotBase blot ID"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2587"
          },
          "definition": "Unique identifier of a blot from a Northern Blot.",
          "text": "Blot ID"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_1124"
            },
            "definition": "Accession number of an entry from the TreeFam database.",
            "text": "TreeFam accession number"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_3270"
            },
            "definition": "Unique identifier for a gene tree from the Ensembl database.",
            "exact_synonyms": ["Ensembl ID (gene tree)"],
            "text": "Ensembl gene tree ID"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1123"
            },
            "definition": "Accession number of an entry from the TreeBASE database.",
            "text": "TreeBASE study accession number"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1068"
          },
          "definition": "Identifier of a phylogenetic tree for example from a phylogenetic tree database.",
          "is_identifier_of": ["http://edamontology.org/data_0872"],
          "text": "Phylogenetic tree ID"
        }, {
          "children": [{
            "children": [{
              "data": {
                "uri": "http://edamontology.org/data_2716"
              },
              "definition": "Identifier of a predicted transcription factor from the DBD database.",
              "text": "DBD ID"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1143"
              },
              "definition": "Identifier of an entry from the TRANSFAC database.",
              "text": "TRANSFAC accession number"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2742"
              },
              "definition": "Identifier of a transcription factor from the AraC-XylS database.",
              "text": "AraC-XylS ID"
            }],
            "data": {
              "uri": "http://edamontology.org/data_2911"
            },
            "definition": "Accession of an entry from a database of transcription factors or binding sites.",
            "text": "Transcription factor accession"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2755"
            },
            "definition": "The name of a transcription factor.",
            "text": "Transcription factor name"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1077"
          },
          "definition": "Identifier of a transcription factor (or a TF binding site).",
          "text": "Transcription factor identifier"
        }, {
          "children": [{
            "children": [{
              "children": [{
                "comment": ["The primary name of a MIRIAM data type is taken from a controlled vocabulary."],
                "data": {
                  "uri": "http://edamontology.org/data_1165"
                },
                "definition": "The primary name of a data type from the MIRIAM database.",
                "text": "MIRIAM data type primary name"
              }, {
                "comment": ["A synonymous name for a MIRIAM data type taken from a controlled vocabulary."],
                "data": {
                  "uri": "http://edamontology.org/data_1166"
                },
                "definition": "A synonymous name of a data type from the MIRIAM database.",
                "text": "MIRIAM data type synonymous name"
              }],
              "data": {
                "uri": "http://edamontology.org/data_1163"
              },
              "definition": "The name of a data type from the MIRIAM database.",
              "is_identifier_of": ["http://edamontology.org/data_0957"],
              "text": "MIRIAM data type name"
            }],
            "data": {
              "uri": "http://edamontology.org/data_2253"
            },
            "definition": "The name of a data type.",
            "text": "Data resource definition name"
          }, {
            "children": [{
              "comment": ["A MIRIAM URI consists of the URI of the MIRIAM data type (PubMed, UniProt etc) followed by the identifier of an element of that data type, for example PMID for a publication or an accession number for a GO term."],
              "data": {
                "uri": "http://edamontology.org/data_1164"
              },
              "definition": "The URI (URL or URN) of a data entity from the MIRIAM database.",
              "exact_synonyms": ["identifiers.org synonym"],
              "is_identifier_of": ["http://edamontology.org/data_0957"],
              "text": "MIRIAM URI"
            }, {
              "comment": ["This is the identifier used internally by MIRIAM for a data type."],
              "data": {
                "uri": "http://edamontology.org/data_1162"
              },
              "definition": "Unique identifier of a MIRIAM data resource.",
              "is_identifier_of": ["http://edamontology.org/data_0957"],
              "text": "MIRIAM identifier"
            }],
            "data": {
              "uri": "http://edamontology.org/data_2902"
            },
            "definition": "Accession of a data definition (catalogued in a database).",
            "text": "Data resource definition accession"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1084"
          },
          "definition": "Identifier of a data type definition from some provider.",
          "exact_synonyms": ["Data resource definition identifier"],
          "text": "Data resource definition ID"
        }, {
          "children": [{
            "children": [{
              "data": {
                "uri": "http://edamontology.org/data_2254"
              },
              "definition": "Name of an OBO file format such as OBO-XML, plain and so on.",
              "text": "OBO file format name"
            }],
            "data": {
              "uri": "http://edamontology.org/data_2129"
            },
            "definition": "Name of a file format such as HTML, PNG, PDF, EMBL, GenBank and so on.",
            "text": "File format name"
          }],
          "data": {
            "uri": "http://edamontology.org/data_3358"
          },
          "definition": "An identifier of a data format.",
          "text": "Format identifier"
        }, {
          "children": [{
            "children": [{
              "data": {
                "uri": "http://edamontology.org/data_2651"
              },
              "definition": "Identifier of a disease from the pharmacogenetics and pharmacogenomics knowledge base (PharmGKB).",
              "text": "Disease ID (PharmGKB)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2800"
              },
              "definition": "An identifier of a disease from the Orpha database.",
              "is_identifier_of": ["http://edamontology.org/data_1622"],
              "text": "Orpha number"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2611"
              },
              "definition": "An identifier of a disease from the International Classification of Diseases (ICD) database.",
              "is_identifier_of": ["http://edamontology.org/data_1622"],
              "text": "ICD identifier"
            }],
            "data": {
              "uri": "http://edamontology.org/data_1150"
            },
            "definition": "Accession number of an entry from a database of disease.",
            "text": "Disease ID"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_3668"
            },
            "definition": "The name of some disease.",
            "text": "Disease name"
          }],
          "data": {
            "uri": "http://edamontology.org/data_3667"
          },
          "definition": "Identifier of an entry from a database of disease.",
          "is_identifier_of": ["http://edamontology.org/data_1622"],
          "text": "Disease identifier"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_1128"
            },
            "definition": "Identifier of an entry from the AAindex database.",
            "text": "AAindex ID"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1073"
          },
          "definition": "Identifier of an index of amino acid physicochemical and biochemical property data.",
          "is_identifier_of": ["http://edamontology.org/data_1501"],
          "text": "Amino acid index ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1071"
          },
          "definition": "Identifier or name of a structural (3D) profile or template (representing a structure or structure alignment).",
          "exact_synonyms": ["Structural profile identifier"],
          "is_identifier_of": ["http://edamontology.org/data_0889"],
          "text": "Structural (3D) profile ID"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2892"
            },
            "definition": "The name of a type or group of cells.",
            "text": "Cell type name"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/data_2657"
              },
              "definition": "A unique identifier of a neuron from the NeuroMorpho database.",
              "text": "NeuroMorpho ID"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2656"
              },
              "definition": "A unique identifier of a neuron from the NeuronDB database.",
              "text": "NeuronDB ID"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_3238"
              },
              "definition": "Cell type ontology concept ID.",
              "exact_synonyms": ["CL ID"],
              "text": "Cell type ontology ID"
            }],
            "data": {
              "uri": "http://edamontology.org/data_2893"
            },
            "definition": "Accession of a type or group of cells (catalogued in a database).",
            "exact_synonyms": ["Cell type ID"],
            "text": "Cell type accession"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2655"
          },
          "definition": "A unique identifier of a type or group of cells.",
          "text": "Cell type identifier"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_1170"
            },
            "definition": "Name of a biological (mathematical) model.",
            "text": "Biological model name"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/data_1171"
              },
              "definition": "Unique identifier of an entry from the BioModel database.",
              "text": "BioModel ID"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2669"
              },
              "definition": "Unique identifier of an entry from the ModelDB database.",
              "text": "ModelDB ID"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2591"
              },
              "definition": "Identifier of an entry from the Brite database of biological hierarchies.",
              "text": "Brite hierarchy ID"
            }],
            "data": {
              "uri": "http://edamontology.org/data_2891"
            },
            "definition": "Accession of a mathematical model, typically an entry from a database.",
            "text": "Biological model accession"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1085"
          },
          "definition": "Identifier of a mathematical model, typically an entry from a database.",
          "exact_synonyms": ["Biological model identifier"],
          "is_identifier_of": ["http://edamontology.org/data_0950"],
          "text": "Biological model ID"
        }, {
          "children": [{
            "children": [{
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/data_2654"
                },
                "definition": "Identifier of a target protein from the Therapeutic Target Database (TTD).",
                "text": "Target ID (TTD)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2398"
                },
                "definition": "Unique identifier for a protein from the Ensembl database.",
                "exact_synonyms": ["Protein ID (Ensembl)", "Ensembl ID (protein)"],
                "text": "Ensembl protein ID"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2802"
                },
                "definition": "Unique identifier for a protein from the EcID database.",
                "text": "Protein ID (EcID)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2114"
                },
                "definition": "Protein identifier used by WormBase database.",
                "text": "WormBase wormpep ID"
              }, {
                "children": [{
                  "data": {
                    "uri": "http://edamontology.org/data_2716"
                  },
                  "definition": "Identifier of a predicted transcription factor from the DBD database.",
                  "text": "DBD ID"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_1143"
                  },
                  "definition": "Identifier of an entry from the TRANSFAC database.",
                  "text": "TRANSFAC accession number"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_2742"
                  },
                  "definition": "Identifier of a transcription factor from the AraC-XylS database.",
                  "text": "AraC-XylS ID"
                }],
                "data": {
                  "uri": "http://edamontology.org/data_2911"
                },
                "definition": "Accession of an entry from a database of transcription factors or binding sites.",
                "text": "Transcription factor accession"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2797"
                },
                "definition": "Unique identifier for a ligand-gated ion channel protein from the LGICdb database.",
                "exact_synonyms": ["LGICdb ID"],
                "text": "Protein ID (LGICdb)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2713"
                },
                "definition": "Unique identifier for a protein complex from the CORUM database.",
                "exact_synonyms": ["CORUM complex ID"],
                "text": "Protein ID (CORUM)"
              }, {
                "comment": ["This qualifier consists of a stable ID portion (3+5 format with 3 position letters and 5 numbers) plus a version number after the decimal point. When the protein sequence encoded by the CDS changes, only the version number of the /protein_id value is incremented; the stable part of the /protein_id remains unchanged and as a result will permanently be associated with a given protein; this qualifier is valid only on CDS features which translate into a valid protein."],
                "data": {
                  "uri": "http://edamontology.org/data_3029"
                },
                "definition": "EMBL/GENBANK/DDBJ coding feature protein identifier, issued by International collaborators.",
                "text": "Protein ID (EMBL/GenBank/DDBJ)"
              }, {
                "children": [{
                  "data": {
                    "uri": "http://edamontology.org/data_2629"
                  },
                  "definition": "Unique identifier of a peptidase enzyme from the MEROPS database.",
                  "exact_synonyms": ["MEROPS ID"],
                  "text": "Enzyme ID (MEROPS)"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_2107"
                  },
                  "definition": "Identifier of an enzyme from the BioCyc enzymes database.",
                  "exact_synonyms": ["BioCyc enzyme ID"],
                  "text": "Enzyme ID (BioCyc)"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_2325"
                  },
                  "definition": "Identifier of an enzyme from the REBASE enzymes database.",
                  "text": "REBASE enzyme number"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_2702"
                  },
                  "definition": "Identifier of an enzyme from the CAZy enzymes database.",
                  "exact_synonyms": ["CAZy ID"],
                  "text": "Enzyme ID (CAZy)"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_1011"
                  },
                  "definition": "An Enzyme Commission (EC) number of an enzyme.",
                  "exact_synonyms": ["EC code", "EC", "Enzyme Commission number"],
                  "text": "EC number"
                }],
                "data": {
                  "uri": "http://edamontology.org/data_2321"
                },
                "definition": "A unique, persistent identifier of an enzyme.",
                "exact_synonyms": ["Enzyme accession"],
                "text": "Enzyme ID"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2617"
                },
                "definition": "Unique identifier of a protein listed in the UCSD-Nature Signaling Gateway Molecule Pages database.",
                "text": "Signaling Gateway protein ID"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2773"
                },
                "definition": "Identifier of a human major histocompatibility complex (HLA) or other protein from the IMGT/HLA database.",
                "text": "IMGT/HLA ID"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2789"
                },
                "definition": "Unique identifier for a membrane protein from the TopDB database.",
                "exact_synonyms": ["TopDB ID"],
                "text": "Protein ID (TopDB)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2804"
                },
                "definition": "Unique identifier for a cone snail toxin protein from the ConoServer database.",
                "text": "Protein ID (ConoServer)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2772"
                },
                "definition": "Identifier of a antibody from the HPA database.",
                "text": "HPA antibody id"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2647"
                },
                "definition": "Unique identifier of an entry from the Ligand-gated ion channel (LGICdb) database.",
                "text": "LGICdb identifier"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2723"
                },
                "definition": "Unique identifier for a protein from the DisProt database.",
                "exact_synonyms": ["DisProt ID"],
                "text": "Protein ID (DisProt)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2756"
                },
                "definition": "Identifier of a membrane transport proteins from the transport classification database (TCDB).",
                "text": "TCID"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_1891"
                },
                "definition": "A unique identifier of a protein or gene used in the iHOP database.",
                "text": "iHOP symbol"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2715"
                },
                "definition": "Unique identifier for a protein from the CuticleDB database.",
                "exact_synonyms": ["CuticleDB ID"],
                "text": "Protein ID (CuticleDB)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2792"
                },
                "definition": "Unique identifier for a peroxidase protein from the PeroxiBase database.",
                "exact_synonyms": ["PeroxiBase ID"],
                "text": "Protein ID (PeroxiBase)"
              }],
              "data": {
                "uri": "http://edamontology.org/data_2907"
              },
              "definition": "Accession of a protein deposited in a database.",
              "exact_synonyms": ["Protein accessions"],
              "text": "Protein accession"
            }, {
              "children": [{
                "children": [{
                  "data": {
                    "uri": "http://edamontology.org/data_2716"
                  },
                  "definition": "Identifier of a predicted transcription factor from the DBD database.",
                  "text": "DBD ID"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_1143"
                  },
                  "definition": "Identifier of an entry from the TRANSFAC database.",
                  "text": "TRANSFAC accession number"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_2742"
                  },
                  "definition": "Identifier of a transcription factor from the AraC-XylS database.",
                  "text": "AraC-XylS ID"
                }],
                "data": {
                  "uri": "http://edamontology.org/data_2911"
                },
                "definition": "Accession of an entry from a database of transcription factors or binding sites.",
                "text": "Transcription factor accession"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2755"
                },
                "definition": "The name of a transcription factor.",
                "text": "Transcription factor name"
              }],
              "data": {
                "uri": "http://edamontology.org/data_1077"
              },
              "definition": "Identifier of a transcription factor (or a TF binding site).",
              "text": "Transcription factor identifier"
            }, {
              "children": [{
                "children": [{
                  "data": {
                    "uri": "http://edamontology.org/data_1013"
                  },
                  "definition": "Name of a restriction enzyme.",
                  "text": "Restriction enzyme name"
                }],
                "data": {
                  "uri": "http://edamontology.org/data_1012"
                },
                "definition": "Name of an enzyme.",
                "text": "Enzyme name"
              }, {
                "children": [{
                  "data": {
                    "uri": "http://edamontology.org/data_2629"
                  },
                  "definition": "Unique identifier of a peptidase enzyme from the MEROPS database.",
                  "exact_synonyms": ["MEROPS ID"],
                  "text": "Enzyme ID (MEROPS)"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_2107"
                  },
                  "definition": "Identifier of an enzyme from the BioCyc enzymes database.",
                  "exact_synonyms": ["BioCyc enzyme ID"],
                  "text": "Enzyme ID (BioCyc)"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_2325"
                  },
                  "definition": "Identifier of an enzyme from the REBASE enzymes database.",
                  "text": "REBASE enzyme number"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_2702"
                  },
                  "definition": "Identifier of an enzyme from the CAZy enzymes database.",
                  "exact_synonyms": ["CAZy ID"],
                  "text": "Enzyme ID (CAZy)"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_1011"
                  },
                  "definition": "An Enzyme Commission (EC) number of an enzyme.",
                  "exact_synonyms": ["EC code", "EC", "Enzyme Commission number"],
                  "text": "EC number"
                }],
                "data": {
                  "uri": "http://edamontology.org/data_2321"
                },
                "definition": "A unique, persistent identifier of an enzyme.",
                "exact_synonyms": ["Enzyme accession"],
                "text": "Enzyme ID"
              }],
              "data": {
                "uri": "http://edamontology.org/data_1010"
              },
              "definition": "Name or other identifier of an enzyme or record from a database of enzymes.",
              "text": "Enzyme identifier"
            }, {
              "children": [{
                "children": [{
                  "data": {
                    "uri": "http://edamontology.org/data_1013"
                  },
                  "definition": "Name of a restriction enzyme.",
                  "text": "Restriction enzyme name"
                }],
                "data": {
                  "uri": "http://edamontology.org/data_1012"
                },
                "definition": "Name of an enzyme.",
                "text": "Enzyme name"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2755"
                },
                "definition": "The name of a transcription factor.",
                "text": "Transcription factor name"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2775"
                },
                "definition": "The name of a kinase protein.",
                "text": "Kinase name"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2764"
                },
                "definition": "Official name of a protein as used in the UniProt database.",
                "text": "Protein name (UniProt)"
              }],
              "data": {
                "uri": "http://edamontology.org/data_1009"
              },
              "definition": "Name of a protein.",
              "text": "Protein name"
            }],
            "data": {
              "uri": "http://edamontology.org/data_0989"
            },
            "definition": "Identifier of a protein.",
            "is_identifier_of": ["http://edamontology.org/data_0896"],
            "text": "Protein identifier"
          }, {
            "children": [{
              "children": [{
                "comment": ["This is the recommended chemical name for use for example in database annotation."],
                "data": {
                  "uri": "http://edamontology.org/data_0997"
                },
                "definition": "Unique name from Chemical Entities of Biological Interest (ChEBI) of a chemical compound.",
                "exact_synonyms": ["ChEBI chemical name"],
                "text": "Chemical name (ChEBI)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2899"
                },
                "definition": "Common name of a drug.",
                "text": "Drug name"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_0998"
                },
                "definition": "IUPAC recommended name of a chemical compound.",
                "exact_synonyms": ["IUPAC chemical name"],
                "text": "Chemical name (IUPAC)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_1000"
                },
                "definition": "Brand name of a chemical compound.",
                "exact_synonyms": ["Brand chemical name"],
                "text": "Chemical name (brand)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_0999"
                },
                "definition": "International Non-proprietary Name (INN or 'generic name') of a chemical compound, assigned by the World Health Organisation (WHO).",
                "exact_synonyms": ["INN chemical name"],
                "text": "Chemical name (INN)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_1001"
                },
                "definition": "Synonymous name of a chemical compound.",
                "exact_synonyms": ["Synonymous chemical name"],
                "text": "Chemical name (synonymous)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_1007"
                },
                "definition": "String of one or more ASCII characters representing a nucleotide.",
                "text": "Nucleotide code"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_1005"
                },
                "definition": "3-letter code word for a ligand (HET group) from a PDB file, for example ATP.",
                "exact_synonyms": ["Short ligand name", "Component identifier code"],
                "text": "HET group name"
              }],
              "data": {
                "uri": "http://edamontology.org/data_0990"
              },
              "definition": "Unique name of a chemical compound.",
              "exact_synonyms": ["Chemical name"],
              "text": "Compound name"
            }, {
              "children": [{
                "children": [{
                  "data": {
                    "uri": "http://edamontology.org/data_1013"
                  },
                  "definition": "Name of a restriction enzyme.",
                  "text": "Restriction enzyme name"
                }],
                "data": {
                  "uri": "http://edamontology.org/data_1012"
                },
                "definition": "Name of an enzyme.",
                "text": "Enzyme name"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2755"
                },
                "definition": "The name of a transcription factor.",
                "text": "Transcription factor name"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2775"
                },
                "definition": "The name of a kinase protein.",
                "text": "Kinase name"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2764"
                },
                "definition": "Official name of a protein as used in the UniProt database.",
                "text": "Protein name (UniProt)"
              }],
              "data": {
                "uri": "http://edamontology.org/data_1009"
              },
              "definition": "Name of a protein.",
              "text": "Protein name"
            }, {
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/data_2706"
                },
                "definition": "Name of a chromosome as used in the BioCyc database.",
                "text": "Chromosome name (BioCyc)"
              }],
              "data": {
                "uri": "http://edamontology.org/data_0987"
              },
              "definition": "Name of a chromosome.",
              "is_identifier_of": ["http://edamontology.org/data_0919"],
              "text": "Chromosome name"
            }],
            "data": {
              "uri": "http://edamontology.org/data_0984"
            },
            "definition": "Name of a specific molecule.",
            "text": "Molecule name"
          }, {
            "children": [{
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/data_2580"
                },
                "definition": "Unique identifier of a monomer from the BindingDB database.",
                "text": "BindingDB Monomer ID"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2646"
                },
                "definition": "Identifier of a small molecular from the ChEMBL database.",
                "exact_synonyms": ["ChEMBL ID"],
                "text": "Compound ID (ChEMBL)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_1174"
                },
                "definition": "Identifier of an entry from the ChEBI database.",
                "exact_synonyms": ["ChEBI IDs", "ChEBI identifier"],
                "text": "ChEBI ID"
              }, {
                "children": [{
                  "data": {
                    "uri": "http://edamontology.org/data_1004"
                  },
                  "definition": "Gmelin registry number of a chemical compound.",
                  "exact_synonyms": ["Gmelin chemical registry number"],
                  "text": "Chemical registry number (Gmelin)"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_1002"
                  },
                  "definition": "CAS registry number of a chemical compound; a unique numerical identifier of chemicals in the scientific literature, as assigned by the Chemical Abstracts Service.",
                  "exact_synonyms": ["Chemical registry number (CAS)", "CAS chemical registry number"],
                  "text": "CAS number"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_1003"
                  },
                  "definition": "Beilstein registry number of a chemical compound.",
                  "exact_synonyms": ["Beilstein chemical registry number"],
                  "text": "Chemical registry number (Beilstein)"
                }],
                "data": {
                  "uri": "http://edamontology.org/data_0991"
                },
                "definition": "Unique registry number of a chemical compound.",
                "text": "Chemical registry number"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_1172"
                },
                "definition": "Chemical structure specified in PubChem Compound Identification (CID), a non-zero integer identifier for a unique chemical structure.",
                "exact_synonyms": ["PubChem compound accession identifier"],
                "text": "PubChem CID"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2635"
                },
                "definition": "Identifier of a metabolite from the 3DMET database.",
                "exact_synonyms": ["3DMET ID"],
                "text": "Compound ID (3DMET)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2605"
                },
                "definition": "Unique identifier of a chemical compound from the KEGG database.",
                "exact_synonyms": ["KEGG compound ID", "KEGG compound identifier"],
                "text": "Compound ID (KEGG)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_1173"
                },
                "definition": "Identifier of an entry from the ChemSpider database.",
                "text": "ChemSpider ID"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2658"
                },
                "definition": "Identifier of a chemical from the ChemIDplus database.",
                "exact_synonyms": ["ChemIDplus ID"],
                "text": "Compound ID (ChemIDplus)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2105"
                },
                "definition": "Identifier of a compound from the BioCyc chemical compounds database.",
                "exact_synonyms": ["BioCyc compound ID", "BioCyc compound identifier"],
                "text": "Compound ID (BioCyc)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2622"
                },
                "definition": "Identifier of a small molecule metabolite from the Human Metabolome Database (HMDB).",
                "exact_synonyms": ["HMDB ID"],
                "text": "Compound ID (HMDB)"
              }],
              "data": {
                "uri": "http://edamontology.org/data_2894"
              },
              "definition": "Accession of an entry from a database of chemicals.",
              "exact_synonyms": ["Chemical compound accession", "Small molecule accession"],
              "text": "Compound accession"
            }, {
              "children": [{
                "children": [{
                  "data": {
                    "uri": "http://edamontology.org/data_2609"
                  },
                  "definition": "Unique identifier of a drug from the KEGG Drug database.",
                  "text": "Drug ID (KEGG)"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_3103"
                  },
                  "definition": "Unique identifier of a drug conforming to the Anatomical Therapeutic Chemical (ATC) Classification System, a drug classification system controlled by the WHO Collaborating Centre for Drug Statistics Methodology (WHOCC).",
                  "text": "ATC code"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_2653"
                  },
                  "definition": "Identifier of a drug from the Therapeutic Target Database (TTD).",
                  "text": "Drug ID (TTD)"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_1002"
                  },
                  "definition": "CAS registry number of a chemical compound; a unique numerical identifier of chemicals in the scientific literature, as assigned by the Chemical Abstracts Service.",
                  "exact_synonyms": ["Chemical registry number (CAS)", "CAS chemical registry number"],
                  "text": "CAS number"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_2652"
                  },
                  "definition": "Identifier of a drug from the pharmacogenetics and pharmacogenomics knowledge base (PharmGKB).",
                  "text": "Drug ID (PharmGKB)"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_2326"
                  },
                  "definition": "Unique identifier of a drug from the DrugBank database.",
                  "text": "DrugBank ID"
                }],
                "data": {
                  "uri": "http://edamontology.org/data_2895"
                },
                "definition": "Accession of a drug.",
                "text": "Drug accession"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2899"
                },
                "definition": "Common name of a drug.",
                "text": "Drug name"
              }],
              "data": {
                "uri": "http://edamontology.org/data_0993"
              },
              "definition": "Identifier of a drug.",
              "is_identifier_of": ["http://edamontology.org/data_2851"],
              "text": "Drug identifier"
            }, {
              "children": [{
                "comment": ["This is the recommended chemical name for use for example in database annotation."],
                "data": {
                  "uri": "http://edamontology.org/data_0997"
                },
                "definition": "Unique name from Chemical Entities of Biological Interest (ChEBI) of a chemical compound.",
                "exact_synonyms": ["ChEBI chemical name"],
                "text": "Chemical name (ChEBI)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2899"
                },
                "definition": "Common name of a drug.",
                "text": "Drug name"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_0998"
                },
                "definition": "IUPAC recommended name of a chemical compound.",
                "exact_synonyms": ["IUPAC chemical name"],
                "text": "Chemical name (IUPAC)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_1000"
                },
                "definition": "Brand name of a chemical compound.",
                "exact_synonyms": ["Brand chemical name"],
                "text": "Chemical name (brand)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_0999"
                },
                "definition": "International Non-proprietary Name (INN or 'generic name') of a chemical compound, assigned by the World Health Organisation (WHO).",
                "exact_synonyms": ["INN chemical name"],
                "text": "Chemical name (INN)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_1001"
                },
                "definition": "Synonymous name of a chemical compound.",
                "exact_synonyms": ["Synonymous chemical name"],
                "text": "Chemical name (synonymous)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_1007"
                },
                "definition": "String of one or more ASCII characters representing a nucleotide.",
                "text": "Nucleotide code"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_1005"
                },
                "definition": "3-letter code word for a ligand (HET group) from a PDB file, for example ATP.",
                "exact_synonyms": ["Short ligand name", "Component identifier code"],
                "text": "HET group name"
              }],
              "data": {
                "uri": "http://edamontology.org/data_0990"
              },
              "definition": "Unique name of a chemical compound.",
              "exact_synonyms": ["Chemical name"],
              "text": "Compound name"
            }, {
              "children": [{
                "children": [{
                  "data": {
                    "uri": "http://edamontology.org/data_2563"
                  },
                  "definition": "Single letter amino acid identifier, e.g. G.",
                  "text": "Amino acid name (single letter)"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_2565"
                  },
                  "definition": "Full name of an amino acid, e.g. Glycine.",
                  "text": "Amino acid name (full name)"
                }, {
                  "children": [{
                    "data": {
                      "uri": "http://edamontology.org/data_1758"
                    },
                    "definition": "Three-letter amino acid residue names as used in PDB files.",
                    "text": "PDB residue name"
                  }],
                  "data": {
                    "uri": "http://edamontology.org/data_2564"
                  },
                  "definition": "Three letter amino acid identifier, e.g. GLY.",
                  "text": "Amino acid name (three letter)"
                }],
                "data": {
                  "uri": "http://edamontology.org/data_1006"
                },
                "definition": "String of one or more ASCII characters representing an amino acid.",
                "text": "Amino acid name"
              }],
              "data": {
                "uri": "http://edamontology.org/data_0994"
              },
              "definition": "Identifier of an amino acid.",
              "exact_synonyms": ["Residue identifier"],
              "is_identifier_of": ["http://edamontology.org/data_2016"],
              "text": "Amino acid identifier"
            }, {
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/data_1007"
                },
                "definition": "String of one or more ASCII characters representing a nucleotide.",
                "text": "Nucleotide code"
              }],
              "data": {
                "uri": "http://edamontology.org/data_0995"
              },
              "definition": "Name or other identifier of a nucleotide.",
              "text": "Nucleotide identifier"
            }, {
              "children": [{
                "children": [{
                  "data": {
                    "uri": "http://edamontology.org/data_2752"
                  },
                  "definition": "Identifier of an entry from the GlycosciencesDB database.",
                  "text": "GlycoMap ID"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_2613"
                  },
                  "definition": "Unique identifier of a glycan ligand from the KEGG GLYCAN database (a subset of KEGG LIGAND).",
                  "text": "KEGG Glycan ID"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_2664"
                  },
                  "definition": "Identifier of an entry from the GlycomeDB database.",
                  "text": "GlycomeDB ID"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_2796"
                  },
                  "definition": "Identifier of an entry from the GlycosciencesDB database.",
                  "text": "Linucs ID"
                }],
                "data": {
                  "uri": "http://edamontology.org/data_2900"
                },
                "definition": "Accession of an entry from a database of carbohydrates.",
                "text": "Carbohydrate accession"
              }],
              "data": {
                "uri": "http://edamontology.org/data_2663"
              },
              "definition": "Identifier of a carbohydrate.",
              "is_identifier_of": ["http://edamontology.org/data_1462", "http://edamontology.org/data_2313"],
              "text": "Carbohydrate identifier"
            }, {
              "children": [{
                "children": [{
                  "data": {
                    "uri": "http://edamontology.org/data_2746"
                  },
                  "definition": "Unique identifier of a monosaccharide from the MonosaccharideDB database.",
                  "text": "MonosaccharideDB ID"
                }],
                "data": {
                  "uri": "http://edamontology.org/data_2898"
                },
                "definition": "Accession of a monosaccharide (catalogued in a database).",
                "text": "Monosaccharide accession"
              }],
              "data": {
                "uri": "http://edamontology.org/data_0996"
              },
              "definition": "Identifier of a monosaccharide.",
              "text": "Monosaccharide identifier"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_3104"
              },
              "definition": "A unique, unambiguous, alphanumeric identifier of a chemical substance as catalogued by the Substance Registration System of the Food and Drug Administration (FDA).",
              "exact_synonyms": ["Unique Ingredient Identifier"],
              "text": "UNII"
            }, {
              "children": [{
                "children": [{
                  "data": {
                    "uri": "http://edamontology.org/data_2662"
                  },
                  "definition": "Unique identifier of a toxin from the Toxin and Toxin Target Database (T3DB) database.",
                  "text": "T3DB ID"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_2578"
                  },
                  "definition": "Unique identifier of a toxin from the ArachnoServer database.",
                  "text": "ArachnoServer ID"
                }],
                "data": {
                  "uri": "http://edamontology.org/data_2897"
                },
                "definition": "Accession of a toxin (catalogued in a database).",
                "text": "Toxin accession"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2896"
                },
                "definition": "Name of a toxin.",
                "text": "Toxin name"
              }],
              "data": {
                "uri": "http://edamontology.org/data_2576"
              },
              "definition": "Identifier of a toxin.",
              "is_identifier_of": ["http://edamontology.org/data_2852"],
              "text": "Toxin identifier"
            }],
            "data": {
              "uri": "http://edamontology.org/data_1086"
            },
            "definition": "Identifier of an entry from a database of chemicals.",
            "exact_synonyms": ["Compound ID", "Small molecule identifier", "Chemical compound identifier"],
            "is_identifier_of": ["http://edamontology.org/data_0962"],
            "text": "Compound identifier"
          }, {
            "children": [{
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/data_2626"
                },
                "definition": "Identifier of a peptide from the PeptideAtlas peptide databases.",
                "text": "PeptideAtlas ID"
              }],
              "data": {
                "uri": "http://edamontology.org/data_2906"
              },
              "definition": "Accession of a peptide deposited in a database.",
              "text": "Peptide ID"
            }, {
              "comment": ["This is typically a character (for the chain) appended to a PDB identifier, e.g. 1cukA"],
              "data": {
                "uri": "http://edamontology.org/data_1008"
              },
              "definition": "Identifier of a polypeptide chain from a protein.",
              "exact_synonyms": ["Polypeptide chain identifier", "Protein chain identifier", "Chain identifier", "PDB chain identifier", "PDB strand id"],
              "is_identifier_of": ["http://edamontology.org/data_1467"],
              "text": "Polypeptide chain ID"
            }],
            "data": {
              "uri": "http://edamontology.org/data_0988"
            },
            "definition": "Identifier of a peptide chain.",
            "text": "Peptide identifier"
          }, {
            "children": [{
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/data_2580"
                },
                "definition": "Unique identifier of a monomer from the BindingDB database.",
                "text": "BindingDB Monomer ID"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2646"
                },
                "definition": "Identifier of a small molecular from the ChEMBL database.",
                "exact_synonyms": ["ChEMBL ID"],
                "text": "Compound ID (ChEMBL)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_1174"
                },
                "definition": "Identifier of an entry from the ChEBI database.",
                "exact_synonyms": ["ChEBI IDs", "ChEBI identifier"],
                "text": "ChEBI ID"
              }, {
                "children": [{
                  "data": {
                    "uri": "http://edamontology.org/data_1004"
                  },
                  "definition": "Gmelin registry number of a chemical compound.",
                  "exact_synonyms": ["Gmelin chemical registry number"],
                  "text": "Chemical registry number (Gmelin)"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_1002"
                  },
                  "definition": "CAS registry number of a chemical compound; a unique numerical identifier of chemicals in the scientific literature, as assigned by the Chemical Abstracts Service.",
                  "exact_synonyms": ["Chemical registry number (CAS)", "CAS chemical registry number"],
                  "text": "CAS number"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_1003"
                  },
                  "definition": "Beilstein registry number of a chemical compound.",
                  "exact_synonyms": ["Beilstein chemical registry number"],
                  "text": "Chemical registry number (Beilstein)"
                }],
                "data": {
                  "uri": "http://edamontology.org/data_0991"
                },
                "definition": "Unique registry number of a chemical compound.",
                "text": "Chemical registry number"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_1172"
                },
                "definition": "Chemical structure specified in PubChem Compound Identification (CID), a non-zero integer identifier for a unique chemical structure.",
                "exact_synonyms": ["PubChem compound accession identifier"],
                "text": "PubChem CID"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2635"
                },
                "definition": "Identifier of a metabolite from the 3DMET database.",
                "exact_synonyms": ["3DMET ID"],
                "text": "Compound ID (3DMET)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2605"
                },
                "definition": "Unique identifier of a chemical compound from the KEGG database.",
                "exact_synonyms": ["KEGG compound ID", "KEGG compound identifier"],
                "text": "Compound ID (KEGG)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_1173"
                },
                "definition": "Identifier of an entry from the ChemSpider database.",
                "text": "ChemSpider ID"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2658"
                },
                "definition": "Identifier of a chemical from the ChemIDplus database.",
                "exact_synonyms": ["ChemIDplus ID"],
                "text": "Compound ID (ChemIDplus)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2105"
                },
                "definition": "Identifier of a compound from the BioCyc chemical compounds database.",
                "exact_synonyms": ["BioCyc compound ID", "BioCyc compound identifier"],
                "text": "Compound ID (BioCyc)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2622"
                },
                "definition": "Identifier of a small molecule metabolite from the Human Metabolome Database (HMDB).",
                "exact_synonyms": ["HMDB ID"],
                "text": "Compound ID (HMDB)"
              }],
              "data": {
                "uri": "http://edamontology.org/data_2894"
              },
              "definition": "Accession of an entry from a database of chemicals.",
              "exact_synonyms": ["Chemical compound accession", "Small molecule accession"],
              "text": "Compound accession"
            }, {
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/data_2721"
                },
                "definition": "Identifier of an dinucleotide property from the DiProDB database.",
                "text": "DiProDB ID"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2719"
                },
                "definition": "Identifier of an oligonucleotide probe from the dbProbe database.",
                "text": "dbProbe ID"
              }],
              "data": {
                "uri": "http://edamontology.org/data_2718"
              },
              "definition": "Identifier of an oligonucleotide from a database.",
              "text": "Oligonucleotide ID"
            }, {
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/data_2654"
                },
                "definition": "Identifier of a target protein from the Therapeutic Target Database (TTD).",
                "text": "Target ID (TTD)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2398"
                },
                "definition": "Unique identifier for a protein from the Ensembl database.",
                "exact_synonyms": ["Protein ID (Ensembl)", "Ensembl ID (protein)"],
                "text": "Ensembl protein ID"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2802"
                },
                "definition": "Unique identifier for a protein from the EcID database.",
                "text": "Protein ID (EcID)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2114"
                },
                "definition": "Protein identifier used by WormBase database.",
                "text": "WormBase wormpep ID"
              }, {
                "children": [{
                  "data": {
                    "uri": "http://edamontology.org/data_2716"
                  },
                  "definition": "Identifier of a predicted transcription factor from the DBD database.",
                  "text": "DBD ID"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_1143"
                  },
                  "definition": "Identifier of an entry from the TRANSFAC database.",
                  "text": "TRANSFAC accession number"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_2742"
                  },
                  "definition": "Identifier of a transcription factor from the AraC-XylS database.",
                  "text": "AraC-XylS ID"
                }],
                "data": {
                  "uri": "http://edamontology.org/data_2911"
                },
                "definition": "Accession of an entry from a database of transcription factors or binding sites.",
                "text": "Transcription factor accession"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2797"
                },
                "definition": "Unique identifier for a ligand-gated ion channel protein from the LGICdb database.",
                "exact_synonyms": ["LGICdb ID"],
                "text": "Protein ID (LGICdb)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2713"
                },
                "definition": "Unique identifier for a protein complex from the CORUM database.",
                "exact_synonyms": ["CORUM complex ID"],
                "text": "Protein ID (CORUM)"
              }, {
                "comment": ["This qualifier consists of a stable ID portion (3+5 format with 3 position letters and 5 numbers) plus a version number after the decimal point. When the protein sequence encoded by the CDS changes, only the version number of the /protein_id value is incremented; the stable part of the /protein_id remains unchanged and as a result will permanently be associated with a given protein; this qualifier is valid only on CDS features which translate into a valid protein."],
                "data": {
                  "uri": "http://edamontology.org/data_3029"
                },
                "definition": "EMBL/GENBANK/DDBJ coding feature protein identifier, issued by International collaborators.",
                "text": "Protein ID (EMBL/GenBank/DDBJ)"
              }, {
                "children": [{
                  "data": {
                    "uri": "http://edamontology.org/data_2629"
                  },
                  "definition": "Unique identifier of a peptidase enzyme from the MEROPS database.",
                  "exact_synonyms": ["MEROPS ID"],
                  "text": "Enzyme ID (MEROPS)"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_2107"
                  },
                  "definition": "Identifier of an enzyme from the BioCyc enzymes database.",
                  "exact_synonyms": ["BioCyc enzyme ID"],
                  "text": "Enzyme ID (BioCyc)"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_2325"
                  },
                  "definition": "Identifier of an enzyme from the REBASE enzymes database.",
                  "text": "REBASE enzyme number"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_2702"
                  },
                  "definition": "Identifier of an enzyme from the CAZy enzymes database.",
                  "exact_synonyms": ["CAZy ID"],
                  "text": "Enzyme ID (CAZy)"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_1011"
                  },
                  "definition": "An Enzyme Commission (EC) number of an enzyme.",
                  "exact_synonyms": ["EC code", "EC", "Enzyme Commission number"],
                  "text": "EC number"
                }],
                "data": {
                  "uri": "http://edamontology.org/data_2321"
                },
                "definition": "A unique, persistent identifier of an enzyme.",
                "exact_synonyms": ["Enzyme accession"],
                "text": "Enzyme ID"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2617"
                },
                "definition": "Unique identifier of a protein listed in the UCSD-Nature Signaling Gateway Molecule Pages database.",
                "text": "Signaling Gateway protein ID"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2773"
                },
                "definition": "Identifier of a human major histocompatibility complex (HLA) or other protein from the IMGT/HLA database.",
                "text": "IMGT/HLA ID"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2789"
                },
                "definition": "Unique identifier for a membrane protein from the TopDB database.",
                "exact_synonyms": ["TopDB ID"],
                "text": "Protein ID (TopDB)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2804"
                },
                "definition": "Unique identifier for a cone snail toxin protein from the ConoServer database.",
                "text": "Protein ID (ConoServer)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2772"
                },
                "definition": "Identifier of a antibody from the HPA database.",
                "text": "HPA antibody id"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2647"
                },
                "definition": "Unique identifier of an entry from the Ligand-gated ion channel (LGICdb) database.",
                "text": "LGICdb identifier"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2723"
                },
                "definition": "Unique identifier for a protein from the DisProt database.",
                "exact_synonyms": ["DisProt ID"],
                "text": "Protein ID (DisProt)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2756"
                },
                "definition": "Identifier of a membrane transport proteins from the transport classification database (TCDB).",
                "text": "TCID"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_1891"
                },
                "definition": "A unique identifier of a protein or gene used in the iHOP database.",
                "text": "iHOP symbol"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2715"
                },
                "definition": "Unique identifier for a protein from the CuticleDB database.",
                "exact_synonyms": ["CuticleDB ID"],
                "text": "Protein ID (CuticleDB)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2792"
                },
                "definition": "Unique identifier for a peroxidase protein from the PeroxiBase database.",
                "exact_synonyms": ["PeroxiBase ID"],
                "text": "Protein ID (PeroxiBase)"
              }],
              "data": {
                "uri": "http://edamontology.org/data_2907"
              },
              "definition": "Accession of a protein deposited in a database.",
              "exact_synonyms": ["Protein accessions"],
              "text": "Protein accession"
            }, {
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/data_2625"
                },
                "definition": "Identifier of an entry from the LIPID MAPS database.",
                "exact_synonyms": ["LM ID"],
                "text": "LIPID MAPS ID"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2665"
                },
                "definition": "Identifier of an entry from the LipidBank database.",
                "text": "LipidBank ID"
              }],
              "data": {
                "uri": "http://edamontology.org/data_2905"
              },
              "definition": "Accession of an entry from a database of lipids.",
              "text": "Lipid accession"
            }, {
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/data_2752"
                },
                "definition": "Identifier of an entry from the GlycosciencesDB database.",
                "text": "GlycoMap ID"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2613"
                },
                "definition": "Unique identifier of a glycan ligand from the KEGG GLYCAN database (a subset of KEGG LIGAND).",
                "text": "KEGG Glycan ID"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2664"
                },
                "definition": "Identifier of an entry from the GlycomeDB database.",
                "text": "GlycomeDB ID"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2796"
                },
                "definition": "Identifier of an entry from the GlycosciencesDB database.",
                "text": "Linucs ID"
              }],
              "data": {
                "uri": "http://edamontology.org/data_2900"
              },
              "definition": "Accession of an entry from a database of carbohydrates.",
              "text": "Carbohydrate accession"
            }, {
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/data_2626"
                },
                "definition": "Identifier of a peptide from the PeptideAtlas peptide databases.",
                "text": "PeptideAtlas ID"
              }],
              "data": {
                "uri": "http://edamontology.org/data_2906"
              },
              "definition": "Accession of a peptide deposited in a database.",
              "text": "Peptide ID"
            }, {
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/data_2725"
                },
                "definition": "Unique identifier for a gene transcript from the Ensembl database.",
                "exact_synonyms": ["Transcript ID (Ensembl)"],
                "text": "Ensembl transcript ID"
              }, {
                "children": [{
                  "data": {
                    "uri": "http://edamontology.org/data_2803"
                  },
                  "definition": "A unique identifier of a cDNA molecule catalogued in the RefSeq database.",
                  "text": "Clone ID (RefSeq)"
                }, {
                  "children": [{
                    "data": {
                      "uri": "http://edamontology.org/data_2798"
                    },
                    "definition": "Identifier of an EST sequence from the MaizeDB database.",
                    "text": "MaizeDB ID"
                  }, {
                    "data": {
                      "uri": "http://edamontology.org/data_1105"
                    },
                    "definition": "Identifier of a dbEST database entry.",
                    "exact_synonyms": ["dbEST ID"],
                    "text": "dbEST accession"
                  }, {
                    "comment": ["A unisequence is a single sequence assembled from ESTs."],
                    "data": {
                      "uri": "http://edamontology.org/data_2730"
                    },
                    "definition": "Identifier of a unisequence from the COGEME database.",
                    "text": "COGEME unisequence ID"
                  }, {
                    "data": {
                      "uri": "http://edamontology.org/data_2729"
                    },
                    "definition": "Identifier of an EST sequence from the COGEME database.",
                    "text": "COGEME EST ID"
                  }],
                  "data": {
                    "uri": "http://edamontology.org/data_2728"
                  },
                  "definition": "Identifier of an EST sequence.",
                  "text": "EST accession"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_2704"
                  },
                  "definition": "A unique identifier assigned by the I.M.A.G.E. consortium to a clone (cloned molecular sequence).",
                  "exact_synonyms": ["I.M.A.G.E. cloneID", "IMAGE cloneID"],
                  "text": "Clone ID (IMAGE)"
                }],
                "data": {
                  "uri": "http://edamontology.org/data_1855"
                },
                "definition": "An identifier of a clone (cloned molecular sequence) from a database.",
                "text": "Clone ID"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2770"
                },
                "definition": "Identifier of an RNA transcript from the H-InvDB database.",
                "text": "HIT ID"
              }],
              "data": {
                "uri": "http://edamontology.org/data_2769"
              },
              "definition": "Identifier of a RNA transcript.",
              "is_identifier_of": ["http://edamontology.org/data_1276"],
              "text": "Transcript ID"
            }],
            "data": {
              "uri": "http://edamontology.org/data_2901"
            },
            "definition": "Accession of a specific molecule (catalogued in a database).",
            "text": "Molecule accession"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/data_2208"
              },
              "definition": "An identifier of a plasmid in a database.",
              "text": "Plasmid identifier"
            }, {
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/data_2721"
                },
                "definition": "Identifier of an dinucleotide property from the DiProDB database.",
                "text": "DiProDB ID"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2719"
                },
                "definition": "Identifier of an oligonucleotide probe from the dbProbe database.",
                "text": "dbProbe ID"
              }],
              "data": {
                "uri": "http://edamontology.org/data_2718"
              },
              "definition": "Identifier of an oligonucleotide from a database.",
              "text": "Oligonucleotide ID"
            }, {
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/data_2725"
                },
                "definition": "Unique identifier for a gene transcript from the Ensembl database.",
                "exact_synonyms": ["Transcript ID (Ensembl)"],
                "text": "Ensembl transcript ID"
              }, {
                "children": [{
                  "data": {
                    "uri": "http://edamontology.org/data_2803"
                  },
                  "definition": "A unique identifier of a cDNA molecule catalogued in the RefSeq database.",
                  "text": "Clone ID (RefSeq)"
                }, {
                  "children": [{
                    "data": {
                      "uri": "http://edamontology.org/data_2798"
                    },
                    "definition": "Identifier of an EST sequence from the MaizeDB database.",
                    "text": "MaizeDB ID"
                  }, {
                    "data": {
                      "uri": "http://edamontology.org/data_1105"
                    },
                    "definition": "Identifier of a dbEST database entry.",
                    "exact_synonyms": ["dbEST ID"],
                    "text": "dbEST accession"
                  }, {
                    "comment": ["A unisequence is a single sequence assembled from ESTs."],
                    "data": {
                      "uri": "http://edamontology.org/data_2730"
                    },
                    "definition": "Identifier of a unisequence from the COGEME database.",
                    "text": "COGEME unisequence ID"
                  }, {
                    "data": {
                      "uri": "http://edamontology.org/data_2729"
                    },
                    "definition": "Identifier of an EST sequence from the COGEME database.",
                    "text": "COGEME EST ID"
                  }],
                  "data": {
                    "uri": "http://edamontology.org/data_2728"
                  },
                  "definition": "Identifier of an EST sequence.",
                  "text": "EST accession"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_2704"
                  },
                  "definition": "A unique identifier assigned by the I.M.A.G.E. consortium to a clone (cloned molecular sequence).",
                  "exact_synonyms": ["I.M.A.G.E. cloneID", "IMAGE cloneID"],
                  "text": "Clone ID (IMAGE)"
                }],
                "data": {
                  "uri": "http://edamontology.org/data_1855"
                },
                "definition": "An identifier of a clone (cloned molecular sequence) from a database.",
                "text": "Clone ID"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2770"
                },
                "definition": "Identifier of an RNA transcript from the H-InvDB database.",
                "text": "HIT ID"
              }],
              "data": {
                "uri": "http://edamontology.org/data_2769"
              },
              "definition": "Identifier of a RNA transcript.",
              "is_identifier_of": ["http://edamontology.org/data_1276"],
              "text": "Transcript ID"
            }, {
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/data_2706"
                },
                "definition": "Name of a chromosome as used in the BioCyc database.",
                "text": "Chromosome name (BioCyc)"
              }],
              "data": {
                "uri": "http://edamontology.org/data_0987"
              },
              "definition": "Name of a chromosome.",
              "is_identifier_of": ["http://edamontology.org/data_0919"],
              "text": "Chromosome name"
            }],
            "data": {
              "uri": "http://edamontology.org/data_2119"
            },
            "definition": "Name or other identifier of a nucleic acid molecule.",
            "is_identifier_of": ["http://edamontology.org/data_2084"],
            "text": "Nucleic acid identifier"
          }, {
            "children": [{
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/data_2625"
                },
                "definition": "Identifier of an entry from the LIPID MAPS database.",
                "exact_synonyms": ["LM ID"],
                "text": "LIPID MAPS ID"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2665"
                },
                "definition": "Identifier of an entry from the LipidBank database.",
                "text": "LipidBank ID"
              }],
              "data": {
                "uri": "http://edamontology.org/data_2905"
              },
              "definition": "Accession of an entry from a database of lipids.",
              "text": "Lipid accession"
            }],
            "data": {
              "uri": "http://edamontology.org/data_2812"
            },
            "definition": "Identifier of a lipid.",
            "is_identifier_of": ["http://edamontology.org/data_2879", "http://edamontology.org/data_2850"],
            "text": "Lipid identifier"
          }],
          "data": {
            "uri": "http://edamontology.org/data_0982"
          },
          "definition": "Name or other identifier of a molecule.",
          "text": "Molecule identifier"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_3273"
          },
          "definition": "Name or other identifier of an entry from a biosample database.",
          "exact_synonyms": ["Sample accession"],
          "is_identifier_of": ["http://edamontology.org/data_3113"],
          "text": "Sample ID"
        }, {
          "children": [{
            "children": [{
              "comment": ["A sunid uniquely identifies an entry in the SCOP hierarchy, including leaves (the SCOP domains) and higher level nodes including entries corresponding to the protein level."],
              "data": {
                "uri": "http://edamontology.org/data_1042"
              },
              "definition": "Unique identifier (number) of an entry in the SCOP hierarchy, for example 33229.",
              "exact_synonyms": ["SCOP unique identifier", "sunid"],
              "text": "SCOP sunid"
            }, {
              "comment": ["An scss includes the class (alphabetical), fold, superfamily and family (all numerical) to which a given domain belongs."],
              "data": {
                "uri": "http://edamontology.org/data_1041"
              },
              "definition": "A SCOP concise classification string (sccs) is a compact representation of a SCOP domain classification.",
              "text": "SCOP concise classification string (sccs)"
            }],
            "data": {
              "uri": "http://edamontology.org/data_1039"
            },
            "definition": "Identifier of a protein domain (or other node) from the SCOP database.",
            "text": "SCOP domain identifier"
          }, {
            "children": [{
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/data_2701"
                },
                "definition": "A code number identifying a family from the CATH database.",
                "text": "CATH node ID (family)"
              }],
              "data": {
                "uri": "http://edamontology.org/data_1043"
              },
              "definition": "A code number identifying a node from the CATH database.",
              "exact_synonyms": ["CATH node identifier", "CATH code"],
              "text": "CATH node ID"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1040"
              },
              "definition": "Identifier of a protein domain from CATH.",
              "exact_synonyms": ["CATH domain identifier"],
              "text": "CATH domain ID"
            }],
            "data": {
              "uri": "http://edamontology.org/data_2700"
            },
            "definition": "Identifier of a protein domain (or other node) from the CATH database.",
            "text": "CATH identifier"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2666"
            },
            "definition": "Identifier of a conserved domain from the Conserved Domain Database.",
            "text": "CDD ID"
          }],
          "comment": ["This is typically a character or string concatenated with a PDB identifier and a chain identifier."],
          "data": {
            "uri": "http://edamontology.org/data_1038"
          },
          "definition": "Identifier of a protein structural domain.",
          "is_identifier_of": ["http://edamontology.org/data_1468"],
          "text": "Protein domain ID"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2631"
            },
            "definition": "An identifier of a mobile genetic element from the Aclame database.",
            "text": "ACLAME ID"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2630"
          },
          "definition": "An identifier of a mobile genetic element.",
          "text": "Mobile genetic element ID"
        }, {
          "children": [{
            "children": [{
              "comment": ["Signature methods from http://www.ebi.ac.uk/Tools/InterProScan/help.html#results include BlastProDom, FPrintScan, HMMPIR, HMMPfam, HMMSmart, HMMTigr, ProfileScan, ScanRegExp, SuperFamily and HAMAP."],
              "data": {
                "uri": "http://edamontology.org/data_1191"
              },
              "definition": "The unique name of a signature (sequence classifier) method.",
              "text": "Tool name (signature)"
            }, {
              "comment": ["This includes 'fasta3', 'fastx3', 'fasty3', 'fastf3', 'fasts3' and 'ssearch'."],
              "data": {
                "uri": "http://edamontology.org/data_1193"
              },
              "definition": "The name of a FASTA tool.",
              "text": "Tool name (FASTA)"
            }, {
              "comment": ["This include 'blastn', 'blastp', 'blastx', 'tblastn' and 'tblastx'."],
              "data": {
                "uri": "http://edamontology.org/data_1192"
              },
              "definition": "The name of a BLAST tool.",
              "exact_synonyms": ["BLAST name"],
              "text": "Tool name (BLAST)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1194"
              },
              "definition": "The name of an EMBOSS application.",
              "text": "Tool name (EMBOSS)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1195"
              },
              "definition": "The name of an EMBASSY package.",
              "text": "Tool name (EMBASSY package)"
            }],
            "data": {
              "uri": "http://edamontology.org/data_1190"
            },
            "definition": "The name of a computer package, application, method or function.",
            "text": "Tool name"
          }],
          "data": {
            "uri": "http://edamontology.org/data_0977"
          },
          "definition": "An identifier of a bioinformatics tool, e.g. an application or web service.",
          "text": "Tool identifier"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2619"
            },
            "definition": "Identifier of a protein modification catalogued in the RESID database.",
            "text": "RESID ID"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_3757"
            },
            "definition": "Identifier of a protein modification catalogued in the Unimod database.",
            "text": "Unimod ID"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2618"
          },
          "definition": "Identifier of a protein modification catalogued in a database.",
          "text": "Protein modification ID"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2794"
            },
            "definition": "Accession of an open reading frame (catalogued in a database).",
            "text": "ORF ID"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1807"
            },
            "definition": "The name of an open reading frame attributed by a sequencing project.",
            "text": "ORF name"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2795"
          },
          "definition": "An identifier of an open reading frame.",
          "text": "ORF identifier"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_1056"
            },
            "definition": "The name of a biological or bioinformatics database.",
            "text": "Database name"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1048"
          },
          "definition": "An identifier of a biological or bioinformatics database.",
          "exact_synonyms": ["Database identifier"],
          "is_identifier_of": ["http://edamontology.org/data_0957"],
          "text": "Database ID"
        }, {
          "children": [{
            "children": [{
              "children": [{
                "comment": ["Nucleotide sequence version contains two letters followed by six digits, a dot, and a version number (or for older nucleotide sequence records, the format is one letter followed by five digits, a dot, and a version number). Protein sequence version contains three letters followed by five digits, a dot, and a version number."],
                "data": {
                  "uri": "http://edamontology.org/data_2315"
                },
                "definition": "An identifier assigned to sequence records processed by NCBI, made of the accession number of the database record followed by a dot and a version number.",
                "exact_synonyms": ["NCBI accession.version", "accession.version"],
                "text": "NCBI version"
              }, {
                "children": [{
                  "comment": ["Nucleotide sequence GI number is shown in the VERSION field of the database record. Protein sequence GI number is shown in the CDS/db_xref field of a nucleotide database record, and the VERSION field of a protein database record."],
                  "data": {
                    "uri": "http://edamontology.org/data_2327"
                  },
                  "definition": "A unique identifier assigned to NCBI protein sequence records.",
                  "exact_synonyms": ["protein gi number", "protein gi"],
                  "text": "GI number (protein)"
                }],
                "comment": ["Nucleotide sequence GI number is shown in the VERSION field of the database record. Protein sequence GI number is shown in the CDS/db_xref field of a nucleotide database record, and the VERSION field of a protein database record."],
                "data": {
                  "uri": "http://edamontology.org/data_2314"
                },
                "definition": "A series of digits that are assigned consecutively to each sequence record processed by NCBI. The GI number bears no resemblance to the Accession number of the sequence record.",
                "exact_synonyms": ["NCBI GI number"],
                "text": "GI number"
              }, {
                "children": [{
                  "data": {
                    "uri": "http://edamontology.org/data_2803"
                  },
                  "definition": "A unique identifier of a cDNA molecule catalogued in the RefSeq database.",
                  "text": "Clone ID (RefSeq)"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_2385"
                  },
                  "definition": "Accession number of a protein from the RefSeq database.",
                  "exact_synonyms": ["RefSeq protein ID"],
                  "text": "RefSeq accession (protein)"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_1027"
                  },
                  "definition": "An NCBI unique identifier of a gene.",
                  "exact_synonyms": ["NCBI geneid", "NCBI gene ID", "Gene identifier (NCBI)", "Gene identifier (Entrez)", "Entrez gene ID"],
                  "text": "Gene ID (NCBI)"
                }],
                "data": {
                  "uri": "http://edamontology.org/data_1098"
                },
                "definition": "Accession number of a RefSeq database entry.",
                "exact_synonyms": ["RefSeq ID"],
                "text": "RefSeq accession"
              }],
              "data": {
                "uri": "http://edamontology.org/data_2362"
              },
              "definition": "Accession number of a nucleotide or protein sequence database entry.",
              "is_identifier_of": ["http://edamontology.org/data_0849"],
              "text": "Sequence accession (hybrid)"
            }, {
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/data_2781"
                },
                "definition": "Identifier of an entry from the RNA editing database (REDIdb).",
                "text": "REDIdb ID"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2389"
                },
                "definition": "Identifier of an entry from the UniSTS database.",
                "text": "UniSTS accession"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2390"
                },
                "definition": "Identifier of an entry from the UNITE database.",
                "text": "UNITE accession"
              }, {
                "children": [{
                  "data": {
                    "uri": "http://edamontology.org/data_2916"
                  },
                  "definition": "An identifier of an entry from the DDBJ sequence database.",
                  "exact_synonyms": ["DDBJ identifier", "DDBJ accession number", "DDBJ ID"],
                  "text": "DDBJ accession"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_2290"
                  },
                  "definition": "An accession number of an entry from the EMBL sequence database.",
                  "exact_synonyms": ["EMBL ID", "EMBL accession number", "EMBL identifier"],
                  "text": "EMBL accession"
                }, {
                  "children": [{
                    "data": {
                      "uri": "http://edamontology.org/data_1105"
                    },
                    "definition": "Identifier of a dbEST database entry.",
                    "exact_synonyms": ["dbEST ID"],
                    "text": "dbEST accession"
                  }],
                  "data": {
                    "uri": "http://edamontology.org/data_2292"
                  },
                  "definition": "Accession number of an entry from the GenBank sequence database.",
                  "exact_synonyms": ["GenBank ID", "GenBank accession number", "GenBank identifier"],
                  "text": "GenBank accession"
                }],
                "data": {
                  "uri": "http://edamontology.org/data_1103"
                },
                "definition": "Identifier of a (nucleic acid) entry from the EMBL/GenBank/DDBJ databases.",
                "text": "EMBL/GenBank/DDBJ ID"
              }, {
                "children": [{
                  "data": {
                    "uri": "http://edamontology.org/data_2370"
                  },
                  "definition": "Identifier of a polyA signal from the ASTD database.",
                  "text": "ASTD ID (polya)"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_2369"
                  },
                  "definition": "Identifier of an intron from the ASTD database.",
                  "text": "ASTD ID (intron)"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_2368"
                  },
                  "definition": "Identifier of an exon from the ASTD database.",
                  "text": "ASTD ID (exon)"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_2371"
                  },
                  "definition": "Identifier of a transcription start site from the ASTD database.",
                  "text": "ASTD ID (tss)"
                }],
                "data": {
                  "uri": "http://edamontology.org/data_2367"
                },
                "definition": "Identifier of an object from the ASTD database.",
                "text": "ASTD ID"
              }, {
                "comment": ["There are canonical and taxon-specific forms of RNAcentral ID. Canonical form e.g. urs_9or10digits identifies an RNA sequence (within the RNA central database) which may appear in multiple sequences. Taxon-specific form identifies a sequence in the specific taxon (e.g. urs_9or10digits_taxonID)."],
                "data": {
                  "uri": "http://edamontology.org/data_3856"
                },
                "definition": "Identifier of an entry from the RNA central database of annotated human miRNAs.",
                "text": "RNA central ID"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2391"
                },
                "definition": "Identifier of an entry from the UTR database.",
                "text": "UTR accession"
              }],
              "data": {
                "uri": "http://edamontology.org/data_1097"
              },
              "definition": "Accession number of a nucleotide sequence database entry.",
              "exact_synonyms": ["Nucleotide sequence accession number"],
              "is_identifier_of": ["http://edamontology.org/data_2977"],
              "text": "Sequence accession (nucleic acid)"
            }, {
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/data_3021"
                },
                "definition": "Accession number of a UniProt (protein sequence) database entry.",
                "exact_synonyms": ["UniProt accession number", "UniProtKB accession", "UniProtKB accession number", "UniProt entry accession"],
                "narrow_synonyms": ["Swiss-Prot entry accession", "TrEMBL entry accession"],
                "text": "UniProt accession"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2392"
                },
                "definition": "Accession number of a UniParc (protein sequence) database entry.",
                "exact_synonyms": ["UniParc ID", "UPI"],
                "text": "UniParc accession"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2384"
                },
                "definition": "Identifier of a protein entry catalogued in the International Protein Index (IPI) database.",
                "text": "IPI protein ID"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_1100"
                },
                "definition": "An identifier of PIR sequence database entry.",
                "exact_synonyms": ["PIR ID", "PIR accession number"],
                "text": "PIR identifier"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2621"
                },
                "definition": "Identifier of a protein sequence from the TAIR database.",
                "text": "TAIR accession (protein)"
              }, {
                "children": [{
                  "data": {
                    "uri": "http://edamontology.org/data_2293"
                  },
                  "definition": "Secondary (internal) identifier of a Gramene database entry.",
                  "exact_synonyms": ["Gramene internal ID", "Gramene secondary ID", "Gramene internal identifier"],
                  "text": "Gramene secondary identifier"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/data_1102"
                  },
                  "definition": "Primary identifier of a Gramene database entry.",
                  "exact_synonyms": ["Gramene primary ID"],
                  "text": "Gramene primary identifier"
                }],
                "data": {
                  "uri": "http://edamontology.org/data_2915"
                },
                "definition": "Identifier of a Gramene database entry.",
                "text": "Gramene identifier"
              }],
              "data": {
                "uri": "http://edamontology.org/data_1096"
              },
              "definition": "Accession number of a protein sequence database entry.",
              "exact_synonyms": ["Protein sequence accession number"],
              "is_identifier_of": ["http://edamontology.org/data_2976"],
              "text": "Sequence accession (protein)"
            }],
            "data": {
              "uri": "http://edamontology.org/data_1093"
            },
            "definition": "A persistent, unique identifier of a molecular sequence database entry.",
            "exact_synonyms": ["Sequence accession number"],
            "text": "Sequence accession"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/data_2291"
              },
              "definition": "An identifier of a polypeptide in the UniProt database.",
              "exact_synonyms": ["UniProtKB identifier", "UniProt identifier", "UniProt entry name", "UniProtKB entry name"],
              "is_identifier_of": ["http://edamontology.org/data_0849"],
              "text": "UniProt ID"
            }],
            "data": {
              "uri": "http://edamontology.org/data_2154"
            },
            "definition": "Any arbitrary name of a molecular sequence.",
            "text": "Sequence name"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1095"
            },
            "definition": "The name of a sequence-based entity adhering to the standard sequence naming scheme used by all EMBOSS applications.",
            "exact_synonyms": ["EMBOSS USA"],
            "text": "EMBOSS Uniform Sequence Address"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1063"
          },
          "definition": "An identifier of molecular sequence(s) or entries from a molecular sequence database.",
          "is_identifier_of": ["http://edamontology.org/data_2044"],
          "text": "Sequence identifier"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2339"
            },
            "definition": "The name of a concept in an ontology.",
            "text": "Ontology concept name"
          }, {
            "children": [{
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/data_2705"
                },
                "definition": "An identifier of a 'cellular component' concept from the Gene Ontology.",
                "exact_synonyms": ["GO concept identifier (cellular compartment)"],
                "text": "GO concept ID (cellular component)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2582"
                },
                "definition": "An identifier of a 'biological process' concept from the the Gene Ontology.",
                "text": "GO concept ID (biological process)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2583"
                },
                "definition": "An identifier of a 'molecular function' concept from the the Gene Ontology.",
                "text": "GO concept ID (molecular function)"
              }],
              "data": {
                "uri": "http://edamontology.org/data_1176"
              },
              "definition": "An identifier of a concept from The Gene Ontology.",
              "exact_synonyms": ["GO concept identifier"],
              "text": "GO concept ID"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1179"
              },
              "definition": "A stable unique identifier for each taxon (for a species, a family, an order, or any other group in the NCBI taxonomy database.",
              "exact_synonyms": ["NCBI tax ID", "NCBI taxonomy identifier"],
              "text": "NCBI taxonomy ID"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1185"
              },
              "definition": "An identifier of a concept from the MGED ontology.",
              "text": "MGED concept ID"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1184"
              },
              "definition": "An identifier of a concept from the ChEBI ontology.",
              "text": "ChEBI concept ID"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1181"
              },
              "definition": "An identifier of a concept from the UMLS vocabulary.",
              "text": "UMLS concept ID"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_3769"
              },
              "definition": "An identifier of a concept from the BRENDA ontology.",
              "text": "BRENDA ontology concept ID"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1180"
              },
              "definition": "An identifier of a concept from the Plant Ontology (PO).",
              "text": "Plant Ontology concept ID"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1177"
              },
              "definition": "An identifier of a concept from the MeSH vocabulary.",
              "text": "MeSH concept ID"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1178"
              },
              "definition": "An identifier of a concept from the HGNC controlled vocabulary.",
              "text": "HGNC concept ID"
            }, {
              "comment": ["The ontology is provided as two components, the service ontology and the domain ontology. The domain ontology acts provides concepts for core bioinformatics data types and their relations. The service ontology describes the physical and operational features of web services."],
              "data": {
                "uri": "http://edamontology.org/data_1186"
              },
              "definition": "An identifier of a concept from the myGrid ontology.",
              "text": "myGrid concept ID"
            }, {
              "comment": ["Classifies anatomical entities according to their shared characteristics (genus) and distinguishing characteristics (differentia). Specifies the part-whole and spatial relationships of the entities, morphological transformation of the entities during prenatal development and the postnatal life cycle and principles, rules and definitions according to which classes and relationships in the other three components of FMA are represented."],
              "data": {
                "uri": "http://edamontology.org/data_1182"
              },
              "definition": "An identifier of a concept from Foundational Model of Anatomy.",
              "text": "FMA concept ID"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1183"
              },
              "definition": "An identifier of a concept from the EMAP mouse ontology.",
              "text": "EMAP concept ID"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1175"
              },
              "definition": "An identifier of a concept from the BioPax ontology.",
              "text": "BioPax concept ID"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_3238"
              },
              "definition": "Cell type ontology concept ID.",
              "exact_synonyms": ["CL ID"],
              "text": "Cell type ontology ID"
            }],
            "data": {
              "uri": "http://edamontology.org/data_1087"
            },
            "definition": "A unique (typically numerical) identifier of a concept in an ontology of biological or bioinformatics concepts and relations.",
            "text": "Ontology concept ID"
          }],
          "data": {
            "uri": "http://edamontology.org/data_3025"
          },
          "definition": "Identifier of a concept in an ontology of biological or bioinformatics concepts and relations.",
          "is_identifier_of": ["http://edamontology.org/data_2858"],
          "text": "Ontology concept identifier"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_1051"
            },
            "definition": "Name of an ontology of biological or bioinformatics concepts and relations.",
            "is_identifier_of": ["http://edamontology.org/data_0582"],
            "text": "Ontology name"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2338"
          },
          "definition": "Any arbitrary identifier of an ontology.",
          "is_identifier_of": ["http://edamontology.org/data_0582"],
          "text": "Ontology identifier"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_1076"
            },
            "definition": "Unique name of a codon usage table.",
            "is_identifier_of": ["http://edamontology.org/data_1598", "http://edamontology.org/data_1597"],
            "text": "Codon usage table name"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2111"
          },
          "definition": "Identifier of a codon usage table, for example a genetic code.",
          "exact_synonyms": ["Codon usage table identifier"],
          "is_identifier_of": ["http://edamontology.org/data_1597", "http://edamontology.org/data_1598"],
          "text": "Codon usage table ID"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_1692"
            },
            "definition": "The name of a person.",
            "text": "Person name"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/data_1690"
              },
              "definition": "A password on a computer system.",
              "text": "Password"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1691"
              },
              "definition": "A valid email address of an end-user.",
              "text": "Email address"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1689"
              },
              "definition": "A username on a computer system.",
              "text": "Username"
            }],
            "data": {
              "uri": "http://edamontology.org/data_2101"
            },
            "definition": "An identifier of a software end-user (typically a person).",
            "text": "User ID"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/data_1882"
              },
              "definition": "An identifier representing an author in the DragonDB database.",
              "text": "DragonDB author identifier"
            }],
            "data": {
              "uri": "http://edamontology.org/data_1881"
            },
            "definition": "Information on the authors of a published work.",
            "text": "Author ID"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2118"
          },
          "definition": "An identifier of a software end-user (typically a person).",
          "text": "Person identifier"
        }],
        "comment": ["This concept exists only to assist EDAM maintenance and navigation in graphical browsers.  It does not add semantic information.  This branch provides an alternative organisation of the concepts nested under 'Accession' and 'Name'. All concepts under here are already included under 'Accession' or 'Name'."],
        "data": {
          "uri": "http://edamontology.org/data_0976"
        },
        "definition": "An identifier that identifies a particular type of data.",
        "exact_synonyms": ["Identifier (typed)"],
        "text": "Identifier (by type of data)"
      }, {
        "children": [{
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_1091"
            },
            "definition": "Name of an object from the WormBase database, usually a human-readable name.",
            "text": "WormBase name"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2114"
            },
            "definition": "Protein identifier used by WormBase database.",
            "text": "WormBase wormpep ID"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1805"
            },
            "definition": "Gene identifier used by WormBase database.",
            "text": "Gene ID (WormBase)"
          }, {
            "comment": ["A WormBase class describes the type of object such as 'sequence' or 'protein'."],
            "data": {
              "uri": "http://edamontology.org/data_1092"
            },
            "definition": "Class of an object from the WormBase database.",
            "text": "WormBase class"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2113"
          },
          "definition": "Identifier of an object from the WormBase database.",
          "text": "WormBase identifier"
        }, {
          "comment": ["These identifiers are unique within the cPath database, however, they are not stable between releases."],
          "data": {
            "uri": "http://edamontology.org/data_2637"
          },
          "definition": "A unique identifier for pathways, reactions, complexes and small molecules from the cPath (Pathway Commons) database.",
          "text": "cPath ID"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2609"
            },
            "definition": "Unique identifier of a drug from the KEGG Drug database.",
            "text": "Drug ID (KEGG)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2613"
            },
            "definition": "Unique identifier of a glycan ligand from the KEGG GLYCAN database (a subset of KEGG LIGAND).",
            "text": "KEGG Glycan ID"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2608"
            },
            "definition": "Identifier of a biological reaction from the KEGG reactions database.",
            "text": "Reaction ID (KEGG)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2605"
            },
            "definition": "Unique identifier of a chemical compound from the KEGG database.",
            "exact_synonyms": ["KEGG compound ID", "KEGG compound identifier"],
            "text": "Compound ID (KEGG)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2102"
            },
            "definition": "A three-letter code used in the KEGG databases to uniquely identify organisms.",
            "text": "KEGG organism code"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2343"
            },
            "definition": "Identifier of a pathway from the KEGG pathway database.",
            "exact_synonyms": ["KEGG pathway ID"],
            "text": "Pathway ID (KEGG)"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1154"
          },
          "definition": "Unique identifier of an object from one of the KEGG databases (excluding the GENES division).",
          "text": "KEGG object identifier"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2777"
            },
            "definition": "Name of a physical entity from the ConsensusPathDB database.",
            "text": "ConsensusPathDB entity name"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2345"
            },
            "definition": "Identifier of a pathway from the ConsensusPathDB pathway database.",
            "text": "Pathway ID (ConsensusPathDB)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2776"
            },
            "definition": "Identifier of a physical entity from the ConsensusPathDB database.",
            "text": "ConsensusPathDB entity ID"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2917"
          },
          "definition": "An identifier of an entity from the ConsensusPathDB database.",
          "text": "ConsensusPathDB identifier"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2398"
            },
            "definition": "Unique identifier for a protein from the Ensembl database.",
            "exact_synonyms": ["Protein ID (Ensembl)", "Ensembl ID (protein)"],
            "text": "Ensembl protein ID"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2725"
            },
            "definition": "Unique identifier for a gene transcript from the Ensembl database.",
            "exact_synonyms": ["Transcript ID (Ensembl)"],
            "text": "Ensembl transcript ID"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1033"
            },
            "definition": "Unique identifier for a gene (or other feature) from the Ensembl database.",
            "exact_synonyms": ["Gene ID (Ensembl)"],
            "text": "Ensembl gene ID"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_3270"
            },
            "definition": "Unique identifier for a gene tree from the Ensembl database.",
            "exact_synonyms": ["Ensembl ID (gene tree)"],
            "text": "Ensembl gene tree ID"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2610"
          },
          "definition": "Identifier of an entry (exon, gene, transcript or protein) from the Ensembl database.",
          "exact_synonyms": ["Ensembl IDs"],
          "text": "Ensembl ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2380"
          },
          "definition": "A unique identifier of an item from the CABRI database.",
          "text": "CABRI accession"
        }, {
          "children": [{
            "comment": ["Secondary identifier are used to handle entries that were merged with or split from other entries in the database."],
            "data": {
              "uri": "http://edamontology.org/data_2174"
            },
            "definition": "Secondary identifier of an object from the FlyBase database.",
            "text": "FlyBase secondary identifier"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2112"
            },
            "definition": "Primary identifier of an object from the FlyBase database.",
            "text": "FlyBase primary identifier"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1089"
          },
          "definition": "Identifier of an object from the FlyBase database.",
          "text": "FlyBase ID"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2106"
            },
            "definition": "Identifier of a biological reaction from the BioCyc reactions database.",
            "text": "Reaction ID (BioCyc)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2107"
            },
            "definition": "Identifier of an enzyme from the BioCyc enzymes database.",
            "exact_synonyms": ["BioCyc enzyme ID"],
            "text": "Enzyme ID (BioCyc)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1157"
            },
            "definition": "Identifier of an pathway from the BioCyc biological pathways database.",
            "exact_synonyms": ["BioCyc pathway ID"],
            "text": "Pathway ID (BioCyc)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2105"
            },
            "definition": "Identifier of a compound from the BioCyc chemical compounds database.",
            "exact_synonyms": ["BioCyc compound ID", "BioCyc compound identifier"],
            "text": "Compound ID (BioCyc)"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2104"
          },
          "definition": "Identifier of an object from one of the BioCyc databases.",
          "text": "BioCyc ID"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2651"
            },
            "definition": "Identifier of a disease from the pharmacogenetics and pharmacogenomics knowledge base (PharmGKB).",
            "text": "Disease ID (PharmGKB)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2650"
            },
            "definition": "Identifier of a pathway from the pharmacogenetics and pharmacogenomics knowledge base (PharmGKB).",
            "text": "Pathway ID (PharmGKB)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2652"
            },
            "definition": "Identifier of a drug from the pharmacogenetics and pharmacogenomics knowledge base (PharmGKB).",
            "text": "Drug ID (PharmGKB)"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2649"
          },
          "definition": "Identifier of an entry from the pharmacogenetics and pharmacogenomics knowledge base (PharmGKB).",
          "text": "PharmGKB ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1036"
          },
          "definition": "Identifier of an entry from the TIGR database.",
          "text": "TIGR identifier"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_3952"
          },
          "definition": "Identifier of a pathway from the WikiPathways pathway database.",
          "exact_synonyms": ["WikiPathways pathway ID", "WikiPathways ID"],
          "text": "Pathway ID (WikiPathways)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2620"
          },
          "definition": "Identifier of an entry from the RGD database.",
          "text": "RGD ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_3274"
          },
          "definition": "Identifier of an object from the MGI database.",
          "text": "MGI accession"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_1034"
            },
            "definition": "Identifier of an entry from the SGD database.",
            "exact_synonyms": ["SGD identifier"],
            "text": "Gene ID (SGD)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1901"
            },
            "definition": "Identifier for loci from SGD (Saccharomyces Genome Database).",
            "exact_synonyms": ["SGDID"],
            "text": "Locus ID (SGD)"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2632"
          },
          "definition": "Identifier of an entry from the Saccharomyces genome database (SGD).",
          "text": "SGD ID"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2621"
            },
            "definition": "Identifier of a protein sequence from the TAIR database.",
            "text": "TAIR accession (protein)"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/data_2388"
              },
              "definition": "Identifier of an Arabidopsis thaliana gene from the TAIR database.",
              "text": "TAIR accession (At gene)"
            }],
            "data": {
              "uri": "http://edamontology.org/data_1037"
            },
            "definition": "Identifier of an gene from the TAIR database.",
            "text": "TAIR accession (gene)"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2387"
          },
          "definition": "Identifier of an entry from the TAIR database.",
          "text": "TAIR accession"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2370"
            },
            "definition": "Identifier of a polyA signal from the ASTD database.",
            "text": "ASTD ID (polya)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2369"
            },
            "definition": "Identifier of an intron from the ASTD database.",
            "text": "ASTD ID (intron)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2368"
            },
            "definition": "Identifier of an exon from the ASTD database.",
            "text": "ASTD ID (exon)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2371"
            },
            "definition": "Identifier of a transcription start site from the ASTD database.",
            "text": "ASTD ID (tss)"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2367"
          },
          "definition": "Identifier of an object from the ASTD database.",
          "text": "ASTD ID"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1891"
          },
          "definition": "A unique identifier of a protein or gene used in the iHOP database.",
          "text": "iHOP symbol"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_1172"
            },
            "definition": "Chemical structure specified in PubChem Compound Identification (CID), a non-zero integer identifier for a unique chemical structure.",
            "exact_synonyms": ["PubChem compound accession identifier"],
            "text": "PubChem CID"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2638"
            },
            "definition": "Identifier of an assay from the PubChem database.",
            "text": "PubChem bioassay ID"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2639"
          },
          "definition": "Identifier of an entry from the PubChem database.",
          "exact_synonyms": ["PubChem identifier"],
          "text": "PubChem ID"
        }],
        "comment": ["This branch provides an alternative organisation of the concepts nested under 'Accession' and 'Name'. All concepts under here are already included under 'Accession' or 'Name'."],
        "data": {
          "uri": "http://edamontology.org/data_2109"
        },
        "definition": "An identifier that is re-used for data objects of fundamentally different types (typically served from a single database).",
        "text": "Identifier (hybrid)"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_2131"
          },
          "definition": "Name of a computer operating system such as Linux, PC or Mac.",
          "text": "Operating system name"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2597"
          },
          "definition": "The name of a catalogue of biological resources from the CABRI database.",
          "text": "CABRI catalogue name"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1091"
          },
          "definition": "Name of an object from the WormBase database, usually a human-readable name.",
          "text": "WormBase name"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_3275"
          },
          "definition": "Name of a phenotype.",
          "exact_synonyms": ["Phenotypes", "Phenotype"],
          "text": "Phenotype name"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_1058"
            },
            "definition": "The name of a file (of any type) with restricted possible values.",
            "text": "Enumerated file name"
          }, {
            "comment": ["A file base name is the file name stripped of its directory specification and extension."],
            "data": {
              "uri": "http://edamontology.org/data_1060"
            },
            "definition": "The base name of a file.",
            "text": "File base name"
          }, {
            "comment": ["A file extension is the characters appearing after the final '.' in the file name."],
            "data": {
              "uri": "http://edamontology.org/data_1059"
            },
            "definition": "The extension of a file name.",
            "text": "File name extension"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1050"
          },
          "definition": "The name (or part of a name) of a file (of any type).",
          "text": "File name"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1023"
          },
          "definition": "The name of a sequence feature-containing entity adhering to the standard feature naming scheme used by all EMBOSS applications.",
          "exact_synonyms": ["UFO"],
          "text": "EMBOSS Uniform Feature Object"
        }, {
          "children": [{
            "children": [{
              "comment": ["The primary name of a MIRIAM data type is taken from a controlled vocabulary."],
              "data": {
                "uri": "http://edamontology.org/data_1165"
              },
              "definition": "The primary name of a data type from the MIRIAM database.",
              "text": "MIRIAM data type primary name"
            }, {
              "comment": ["A synonymous name for a MIRIAM data type taken from a controlled vocabulary."],
              "data": {
                "uri": "http://edamontology.org/data_1166"
              },
              "definition": "A synonymous name of a data type from the MIRIAM database.",
              "text": "MIRIAM data type synonymous name"
            }],
            "data": {
              "uri": "http://edamontology.org/data_1163"
            },
            "definition": "The name of a data type from the MIRIAM database.",
            "is_identifier_of": ["http://edamontology.org/data_0957"],
            "text": "MIRIAM data type name"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2253"
          },
          "definition": "The name of a data type.",
          "text": "Data resource definition name"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2254"
            },
            "definition": "Name of an OBO file format such as OBO-XML, plain and so on.",
            "text": "OBO file format name"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2129"
          },
          "definition": "Name of a file format such as HTML, PNG, PDF, EMBL, GenBank and so on.",
          "text": "File format name"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1056"
          },
          "definition": "The name of a biological or bioinformatics database.",
          "text": "Database name"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2339"
          },
          "definition": "The name of a concept in an ontology.",
          "text": "Ontology concept name"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2777"
          },
          "definition": "Name of a physical entity from the ConsensusPathDB database.",
          "text": "ConsensusPathDB entity name"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1061"
          },
          "definition": "Name of a QSAR descriptor.",
          "is_identifier_of": ["http://edamontology.org/data_0847"],
          "text": "QSAR descriptor name"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2606"
          },
          "definition": "Name (not necessarily stable) an entry (RNA family) from the RFAM database.",
          "text": "RFAM name"
        }, {
          "children": [{
            "children": [{
              "comment": ["This is the recommended chemical name for use for example in database annotation."],
              "data": {
                "uri": "http://edamontology.org/data_0997"
              },
              "definition": "Unique name from Chemical Entities of Biological Interest (ChEBI) of a chemical compound.",
              "exact_synonyms": ["ChEBI chemical name"],
              "text": "Chemical name (ChEBI)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2899"
              },
              "definition": "Common name of a drug.",
              "text": "Drug name"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_0998"
              },
              "definition": "IUPAC recommended name of a chemical compound.",
              "exact_synonyms": ["IUPAC chemical name"],
              "text": "Chemical name (IUPAC)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1000"
              },
              "definition": "Brand name of a chemical compound.",
              "exact_synonyms": ["Brand chemical name"],
              "text": "Chemical name (brand)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_0999"
              },
              "definition": "International Non-proprietary Name (INN or 'generic name') of a chemical compound, assigned by the World Health Organisation (WHO).",
              "exact_synonyms": ["INN chemical name"],
              "text": "Chemical name (INN)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1001"
              },
              "definition": "Synonymous name of a chemical compound.",
              "exact_synonyms": ["Synonymous chemical name"],
              "text": "Chemical name (synonymous)"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1007"
              },
              "definition": "String of one or more ASCII characters representing a nucleotide.",
              "text": "Nucleotide code"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1005"
              },
              "definition": "3-letter code word for a ligand (HET group) from a PDB file, for example ATP.",
              "exact_synonyms": ["Short ligand name", "Component identifier code"],
              "text": "HET group name"
            }],
            "data": {
              "uri": "http://edamontology.org/data_0990"
            },
            "definition": "Unique name of a chemical compound.",
            "exact_synonyms": ["Chemical name"],
            "text": "Compound name"
          }, {
            "children": [{
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/data_1013"
                },
                "definition": "Name of a restriction enzyme.",
                "text": "Restriction enzyme name"
              }],
              "data": {
                "uri": "http://edamontology.org/data_1012"
              },
              "definition": "Name of an enzyme.",
              "text": "Enzyme name"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2755"
              },
              "definition": "The name of a transcription factor.",
              "text": "Transcription factor name"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2775"
              },
              "definition": "The name of a kinase protein.",
              "text": "Kinase name"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2764"
              },
              "definition": "Official name of a protein as used in the UniProt database.",
              "text": "Protein name (UniProt)"
            }],
            "data": {
              "uri": "http://edamontology.org/data_1009"
            },
            "definition": "Name of a protein.",
            "text": "Protein name"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/data_2706"
              },
              "definition": "Name of a chromosome as used in the BioCyc database.",
              "text": "Chromosome name (BioCyc)"
            }],
            "data": {
              "uri": "http://edamontology.org/data_0987"
            },
            "definition": "Name of a chromosome.",
            "is_identifier_of": ["http://edamontology.org/data_0919"],
            "text": "Chromosome name"
          }],
          "data": {
            "uri": "http://edamontology.org/data_0984"
          },
          "definition": "Name of a specific molecule.",
          "text": "Molecule name"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_1748"
            },
            "definition": "Identifier (a string) of a specific atom from a PDB file for a molecular structure.",
            "text": "PDB atom name"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1757"
          },
          "definition": "Name of an atom.",
          "text": "Atom name"
        }, {
          "comment": ["A feature label identifies a feature of a sequence database entry. When used with the database name and the entry's primary accession number, it is a unique identifier of that feature."],
          "data": {
            "uri": "http://edamontology.org/data_1022"
          },
          "definition": "A name of a sequence feature, e.g. the name of a feature to be displayed to an end-user. Typically an EMBL or Swiss-Prot feature label.",
          "exact_synonyms": ["Sequence feature name"],
          "text": "Sequence feature label"
        }, {
          "children": [{
            "children": [{
              "data": {
                "uri": "http://edamontology.org/data_2595"
              },
              "definition": "The name of a taxon using the controlled vocabulary of the UTRdb database.",
              "text": "UTRdb taxon"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1044"
              },
              "definition": "The name of a biological kingdom (Bacteria, Archaea, or Eukaryotes).",
              "text": "Kingdom name"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1870"
              },
              "definition": "The name of a genus of organism.",
              "text": "Genus name"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1045"
              },
              "definition": "The name of a species (typically a taxonomic group) of organism.",
              "exact_synonyms": ["Organism species"],
              "text": "Species name"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_1875"
              },
              "definition": "The name of a taxon from the NCBI taxonomy database.",
              "text": "NCBI taxon"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2594"
              },
              "definition": "The name of a taxon using the controlled vocabulary of the UniGene database.",
              "exact_synonyms": ["UniGene organism abbreviation"],
              "text": "UniGene taxon"
            }, {
              "data": {
                "uri": "http://edamontology.org/data_2732"
              },
              "definition": "The name of a family of organism.",
              "text": "Family name"
            }],
            "comment": ["For a complete list of taxonomic ranks see https://www.phenoscape.org/wiki/Taxonomic_Rank_Vocabulary."],
            "data": {
              "uri": "http://edamontology.org/data_1868"
            },
            "definition": "The name of a group of organisms belonging to the same taxonomic rank.",
            "exact_synonyms": ["Taxonomic rank", "Taxonomy rank"],
            "text": "Taxon"
          }, {
            "comment": ["Name components correspond to levels in a taxonomic hierarchy (e.g. 'Genus', 'Species', etc.) Meta information such as a reference where the name was defined and a date might be included."],
            "data": {
              "uri": "http://edamontology.org/data_1872"
            },
            "definition": "The full name for a group of organisms, reflecting their biological classification and (usually) conforming to a standard nomenclature.",
            "exact_synonyms": ["Taxonomic name", "Taxonomic information"],
            "text": "Taxonomic classification"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2102"
            },
            "definition": "A three-letter code used in the KEGG databases to uniquely identify organisms.",
            "text": "KEGG organism code"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1874"
            },
            "definition": "Common name for an organism as used in the GenBank database.",
            "text": "Genbank common name"
          }, {
            "children": [{
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/data_2320"
                },
                "definition": "The name of a cell line.",
                "text": "Cell line name (assonant)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2319"
                },
                "definition": "The name of a cell line.",
                "text": "Cell line name (no punctuation)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2317"
                },
                "definition": "The name of a cell line.",
                "text": "Cell line name (exact)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/data_2318"
                },
                "definition": "The name of a cell line.",
                "text": "Cell line name (truncated)"
              }],
              "data": {
                "uri": "http://edamontology.org/data_2316"
              },
              "definition": "The name of a cell line.",
              "text": "Cell line name"
            }],
            "data": {
              "uri": "http://edamontology.org/data_1046"
            },
            "definition": "The name of a strain of an organism variant, typically a plant, virus or bacterium.",
            "text": "Strain name"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2909"
          },
          "definition": "The name of an organism (or group of organisms).",
          "text": "Organism name"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_1026"
            },
            "definition": "The short name of a gene; a single word that does not contain white space characters. It is typically derived from the gene name.",
            "text": "Gene symbol"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2299"
          },
          "definition": "The name of a gene, (typically) assigned by a person and/or according to a naming scheme. It may contain white space characters and is typically more intuitive and readable than a gene symbol. It (typically) may be used to identify similar genes in different species and to derive a gene symbol.",
          "narrow_synonyms": ["Allele name"],
          "text": "Gene name"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2782"
            },
            "definition": "Name of a domain from the SMART database.",
            "text": "SMART domain name"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1132"
            },
            "definition": "Name of an InterPro entry, usually indicating the type of protein matches for that entry.",
            "is_identifier_of": ["http://edamontology.org/data_1355"],
            "text": "InterPro entry name"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2757"
            },
            "definition": "Name of a domain from the Pfam database.",
            "text": "Pfam domain name"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1131"
          },
          "definition": "Name of a protein family.",
          "text": "Protein family name"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1076"
          },
          "definition": "Unique name of a codon usage table.",
          "is_identifier_of": ["http://edamontology.org/data_1598", "http://edamontology.org/data_1597"],
          "text": "Codon usage table name"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1867"
          },
          "definition": "The name of a protein fold.",
          "text": "Protein fold name"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1807"
          },
          "definition": "The name of an open reading frame attributed by a sequencing project.",
          "text": "ORF name"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2791"
          },
          "definition": "Name of a reference map gel from the SWISS-2DPAGE database.",
          "text": "Reference map name (SWISS-2DPAGE)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1051"
          },
          "definition": "Name of an ontology of biological or bioinformatics concepts and relations.",
          "is_identifier_of": ["http://edamontology.org/data_0582"],
          "text": "Ontology name"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1170"
          },
          "definition": "Name of a biological (mathematical) model.",
          "text": "Biological model name"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_3735"
            },
            "definition": "A number corresponding to the number of an analysis performed by a sequencing machine.  For example, if it's the 13th analysis, the run is 13.",
            "text": "Run number"
          }, {
            "comment": ["A flow cell is used to immobilise, amplify and sequence millions of molecules at once.  In Illumina machines, a flowcell is composed of  8 \"lanes\" which allows 8 experiments in a single analysis."],
            "data": {
              "uri": "http://edamontology.org/data_3733"
            },
            "definition": "An identifier of a flow cell of a sequencing machine.",
            "text": "Flow cell identifier"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_3734"
            },
            "definition": "An identifier of a lane within a flow cell of a sequencing machine, within which millions of sequences are immobilised, amplified and sequenced.",
            "text": "Lane identifier"
          }],
          "data": {
            "uri": "http://edamontology.org/data_3732"
          },
          "definition": "Data concerning a sequencing experiment, that may be specified as an input to some tool.",
          "text": "Sequencing metadata name"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2291"
            },
            "definition": "An identifier of a polypeptide in the UniProt database.",
            "exact_synonyms": ["UniProtKB identifier", "UniProt identifier", "UniProt entry name", "UniProtKB entry name"],
            "is_identifier_of": ["http://edamontology.org/data_0849"],
            "text": "UniProt ID"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2154"
          },
          "definition": "Any arbitrary name of a molecular sequence.",
          "text": "Sequence name"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2133"
          },
          "definition": "A logical operator such as OR, AND, XOR, and NOT.",
          "text": "Logical operator"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_3668"
          },
          "definition": "The name of some disease.",
          "text": "Disease name"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2128"
          },
          "definition": "Informal name for a genetic code, typically an organism name.",
          "text": "Genetic code name"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2892"
          },
          "definition": "The name of a type or group of cells.",
          "text": "Cell type name"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1049"
          },
          "definition": "The name of a directory.",
          "text": "Directory name"
        }, {
          "comment": ["See for example http://www.ebi.ac.uk/Tools/webservices/help/matrix."],
          "data": {
            "uri": "http://edamontology.org/data_1126"
          },
          "definition": "Unique name or identifier of a comparison matrix.",
          "exact_synonyms": ["Substitution matrix name"],
          "is_identifier_of": ["http://edamontology.org/data_0874"],
          "text": "Comparison matrix name"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2896"
          },
          "definition": "Name of a toxin.",
          "text": "Toxin name"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1095"
          },
          "definition": "The name of a sequence-based entity adhering to the standard sequence naming scheme used by all EMBOSS applications.",
          "exact_synonyms": ["EMBOSS USA"],
          "text": "EMBOSS Uniform Sequence Address"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2219"
          },
          "definition": "The name of a field in a database.",
          "text": "Database field name"
        }],
        "data": {
          "uri": "http://edamontology.org/data_2099"
        },
        "definition": "A name of a thing, which need not necessarily uniquely identify it.",
        "exact_synonyms": ["Symbolic name"],
        "text": "Name"
      }],
      "data": {
        "uri": "http://edamontology.org/data_0842"
      },
      "definition": "A text token, number or something else which identifies an entity, but which may not be persistent (stable) or unique (the same identifier may identify multiple things).",
      "exact_synonyms": ["ID"],
      "is_identifier_of": ["http://edamontology.org/data_0006"],
      "narrow_synonyms": [{
        "@id": "dc:identifier"
      }],
      "text": "Identifier"
    }, {
      "children": [{
        "comment": ["The score list includes the alignment score, percentage of the query sequence matched, length of the database sequence entry in this alignment, identifier of the database sequence entry, excerpt of the database sequence entry description etc."],
        "data": {
          "uri": "http://edamontology.org/data_0857"
        },
        "definition": "A report of sequence hits and associated data from searching a database of sequences (for example a BLAST search). This will typically include a list of scores (often with statistical evaluation) and a set of alignments for the hits.",
        "exact_synonyms": ["Sequence database search results", "Sequence search hits", "Database hits (sequence)", "Sequence database hits", ""],
        "text": "Sequence search results"
      }],
      "data": {
        "uri": "http://edamontology.org/data_2080"
      },
      "definition": "A report of hits from searching a database of some type.",
      "exact_synonyms": ["Search results", "Database hits"],
      "text": "Database search results"
    }, {
      "children": [{
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_0910"
          },
          "definition": "Km is the concentration (usually in Molar units) of substrate that leads to half-maximal velocity of an enzyme-catalysed reaction.",
          "text": "Km"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2025"
          },
          "definition": "A plot giving an approximation of the kinetics of an enzyme-catalysed reaction, assuming simple kinetics (i.e. no intermediate or product inhibition, allostericity or cooperativity). It plots initial reaction rate to the substrate concentration (S) from which the maximum rate (vmax) is apparent.",
          "text": "Michaelis Menten plot"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2026"
          },
          "definition": "A plot based on the Michaelis Menten equation of enzyme kinetics plotting the ratio of the initial substrate concentration (S) against the reaction velocity (v).",
          "text": "Hanes Woolf plot"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_0909"
          },
          "definition": "The maximum initial velocity or rate of a reaction. It is the limiting velocity as substrate concentrations get very large.",
          "text": "Vmax"
        }],
        "comment": ["This is a broad data type and is used a placeholder for other, more specific types."],
        "data": {
          "uri": "http://edamontology.org/data_2024"
        },
        "definition": "Data concerning chemical reaction(s) catalysed by enzyme(s).",
        "text": "Enzyme kinetics data"
      }],
      "comment": ["This is a broad data type and is used a placeholder for other, more specific types."],
      "data": {
        "uri": "http://edamontology.org/data_2978"
      },
      "definition": "Data concerning a biochemical reaction, typically data and more general annotation on the kinetics of enzyme-catalysed reaction.",
      "exact_synonyms": ["Enzyme kinetics annotation", "Reaction annotation"],
      "text": "Reaction data"
    }, {
      "children": [{
        "children": [{
          "comment": ["The radiation method can break very closely linked markers providing a more detailed map.  Most genetic markers and subsequences may be located to a defined map position and with a more precise estimates of distance than a linkage map."],
          "data": {
            "uri": "http://edamontology.org/data_2870"
          },
          "definition": "A map showing distance between genetic markers estimated by radiation-induced breaks in a chromosome.",
          "exact_synonyms": ["RH map"],
          "text": "Radiation hybrid map"
        }, {
          "children": [{
            "comment": ["A cytogenetic map is built from a set of mutant cell lines with sub-chromosomal deletions and a reference wild-type line ('genome deletion panel'). The panel is used to map markers onto the genome by comparing mutant to wild-type banding patterns. Markers are linked (occur in the same deleted region) if they share the same banding pattern (presence or absence) as the deletion panel."],
            "data": {
              "uri": "http://edamontology.org/data_1859"
            },
            "definition": "A cytogenetic map showing chromosome banding patterns in mutant cell lines relative to the wild type.",
            "exact_synonyms": ["Deletion-based cytogenetic map"],
            "text": "Deletion map"
          }],
          "comment": ["This is the lowest-resolution physical map and can provide only rough estimates of physical (base pair) distances.  Like a genetic map, they are limited to genetic markers of traits observable only in whole organisms."],
          "data": {
            "uri": "http://edamontology.org/data_1283"
          },
          "definition": "A map showing banding patterns derived from direct observation of a stained chromosome.",
          "exact_synonyms": ["Cytogenic map", "Cytologic map", "Chromosome map"],
          "text": "Cytogenetic map"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_1286"
            },
            "definition": "Sequence map of a plasmid (circular DNA).",
            "text": "Plasmid map"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1285"
            },
            "definition": "Sequence map of a single gene annotated with genetic features such as introns, exons, untranslated regions, polyA signals, promoters, enhancers and (possibly) mutations defining alleles of a gene.",
            "text": "Gene map"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1288"
            },
            "definition": "Sequence map of a whole genome.",
            "text": "Genome map"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1289"
            },
            "definition": "Image of the restriction enzyme cleavage sites (restriction sites) in a nucleic acid sequence.",
            "text": "Restriction map"
          }],
          "comment": ["A sequence map typically includes annotation on significant subsequences such as contigs, haplotypes and genes. The contigs shown will (typically) be a set of small overlapping clones representing a complete chromosomal segment."],
          "data": {
            "uri": "http://edamontology.org/data_1279"
          },
          "definition": "A map of genetic markers in a contiguous, assembled genomic sequence, with the sizes and separation of markers measured in base pairs.",
          "text": "Sequence map"
        }],
        "comment": ["Distance in a physical map is measured in base pairs. A physical map might be ordered relative to a reference map (typically a genetic map) in the process of genome sequencing."],
        "data": {
          "uri": "http://edamontology.org/data_1280"
        },
        "definition": "A map of DNA (linear or circular) annotated with physical features or landmarks such as restriction sites, cloned DNA fragments, genes or genetic markers, along with the physical distances between them.",
        "text": "Physical map"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_1863"
          },
          "definition": "A map of haplotypes in a genome or other sequence, describing common patterns of genetic variation.",
          "text": "Haplotype map"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1284"
          },
          "definition": "A gene map showing distances between loci based on relative cotransduction frequencies.",
          "text": "DNA transduction map"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1860"
          },
          "definition": "A genetic map which shows the approximate location of quantitative trait loci (QTL) between two or more markers.",
          "exact_synonyms": ["Quantitative trait locus map"],
          "text": "QTL map"
        }],
        "comment": ["A genetic (linkage) map indicates the proximity of two genes on a chromosome, whether two genes are linked and the frequency they are transmitted together to an offspring. They are limited to genetic markers of traits observable only in whole organisms."],
        "data": {
          "uri": "http://edamontology.org/data_1278"
        },
        "definition": "A map showing the relative positions of genetic markers in a nucleic acid sequence, based on estimation of non-physical distance such as recombination frequencies.",
        "exact_synonyms": ["Linkage map"],
        "text": "Genetic map"
      }],
      "data": {
        "uri": "http://edamontology.org/data_1274"
      },
      "definition": "A map of (typically one) DNA sequence annotated with positional or non-positional features.",
      "exact_synonyms": ["DNA map"],
      "has_topic": ["http://edamontology.org/topic_0102"],
      "text": "Map"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_0889"
      },
      "definition": "Some type of structural (3D) profile or template (representing a structure or structure alignment).",
      "exact_synonyms": ["3D profile", "Structural (3D) profile"],
      "has_topic": ["http://edamontology.org/topic_0081"],
      "text": "Structural profile"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_2600"
      },
      "definition": "Primary data about a specific biological pathway or network (the nodes and connections within the pathway or network).",
      "exact_synonyms": ["Pathway", "Network"],
      "has_topic": ["http://edamontology.org/topic_0602"],
      "text": "Pathway or network"
    }, {
      "children": [{
        "comment": ["Many sequence alignment tasks involving many or very large sequences rely on a precomputed index of the sequence to accelerate the alignment."],
        "data": {
          "uri": "http://edamontology.org/data_3210"
        },
        "definition": "An index of a genome sequence.",
        "text": "Genome index"
      }],
      "data": {
        "uri": "http://edamontology.org/data_0955"
      },
      "definition": "An index of data of biological relevance.",
      "has_topic": ["http://edamontology.org/topic_3489"],
      "text": "Data index"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/data_3805"
        },
        "definition": "Structural 3D model (volume map) from electron microscopy.",
        "has_topic": ["http://edamontology.org/topic_1317"],
        "text": "3D EM Map"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_3806"
        },
        "definition": "Annotation on a structural 3D EM Map from electron microscopy. This might include one or several locations in the map of the known features of a particular macromolecule.",
        "has_topic": ["http://edamontology.org/topic_1317"],
        "text": "3D EM Mask"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_2852"
          },
          "definition": "3D coordinate and associated data for the (3D) structure of a toxin.",
          "text": "Toxin structure"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2851"
          },
          "definition": "3D coordinate and associated data for the (3D) structure of a drug.",
          "text": "Drug structure"
        }],
        "data": {
          "uri": "http://edamontology.org/data_1463"
        },
        "definition": "3D coordinate and associated data for the (3D) structure of a small molecule, such as any common chemical compound.",
        "has_topic": ["http://edamontology.org/topic_0154"],
        "text": "Small molecule structure"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_2878"
          },
          "definition": "3D coordinate and associated data for a protein (3D) structural motif; any group of contiguous or non-contiguous amino acid residues but typically those forming a feature with a structural or functional role.",
          "text": "Protein structural motif"
        }, {
          "comment": ["This is a broad data type and is used a placeholder for other, more specific types.  It is primarily intended to help navigation of EDAM and would not typically be used for annotation."],
          "data": {
            "uri": "http://edamontology.org/data_1755"
          },
          "definition": "Data on a single atom from a protein structure.",
          "exact_synonyms": ["Atom data"],
          "text": "Protein atom"
        }, {
          "comment": ["C-beta atoms from amino acid side-chains may be included."],
          "data": {
            "uri": "http://edamontology.org/data_1470"
          },
          "definition": "3D coordinate and associated data for a protein tertiary (3D) structure (typically C-alpha atoms only).",
          "exact_synonyms": ["Protein structure (C-alpha atoms)"],
          "text": "C-alpha trace"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2877"
          },
          "definition": "3D coordinate and associated data for a multi-protein complex; two or more polypeptides chains in a stable, functional association with one another.",
          "text": "Protein complex"
        }, {
          "comment": ["This is a broad data type and is used a placeholder for other, more specific types.  It is primarily intended to help navigation of EDAM and would not typically be used for annotation."],
          "data": {
            "uri": "http://edamontology.org/data_1756"
          },
          "definition": "Data on a single amino acid residue position in a protein structure.",
          "exact_synonyms": ["Residue"],
          "text": "Protein residue"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1467"
          },
          "definition": "3D coordinate and associated data for the tertiary (3D) structure of a polypeptide chain.",
          "text": "Protein chain"
        }, {
          "comment": ["This includes interactions of proteins with atoms, ions and small molecules or macromolecules such as nucleic acids or other polypeptides.  For stable inter-polypeptide interactions use 'Protein complex' instead."],
          "data": {
            "uri": "http://edamontology.org/data_1461"
          },
          "definition": "The structure of a protein in complex with a ligand, typically a small molecule such as an enzyme substrate or cofactor, but possibly another macromolecule.",
          "text": "Protein-ligand complex"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1468"
          },
          "definition": "3D coordinate and associated data for the tertiary (3D) structure of a protein domain.",
          "has_topic": ["http://edamontology.org/topic_0736"],
          "text": "Protein domain"
        }],
        "data": {
          "uri": "http://edamontology.org/data_1460"
        },
        "definition": "3D coordinate and associated data for a protein tertiary (3D) structure, or part of a structure, possibly in complex with other molecules.",
        "exact_synonyms": ["Protein structures"],
        "has_topic": ["http://edamontology.org/topic_2814"],
        "text": "Protein structure"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_1462"
        },
        "definition": "3D coordinate and associated data for a carbohydrate (3D) structure.",
        "has_topic": ["http://edamontology.org/topic_0152", "http://edamontology.org/topic_0153"],
        "text": "Carbohydrate structure"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_2850"
        },
        "definition": "3D coordinate and associated data for a lipid structure.",
        "text": "Lipid structure"
      }, {
        "children": [{
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_1466"
            },
            "definition": "3D coordinate and associated data for a tRNA tertiary (3D) structure, including tmRNA, snoRNAs etc.",
            "text": "tRNA structure"
          }, {
            "comment": ["This includes thermodynamically stable or evolutionarily conserved structures such as knots, pseudoknots etc."],
            "data": {
              "uri": "http://edamontology.org/data_0880"
            },
            "definition": "An informative report of secondary structure (predicted or real) of an RNA molecule.",
            "exact_synonyms": ["Secondary structure (RNA)"],
            "has_topic": ["http://edamontology.org/topic_0097"],
            "text": "RNA secondary structure"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1465"
          },
          "definition": "3D coordinate and associated data for an RNA tertiary (3D) structure.",
          "has_topic": ["http://edamontology.org/topic_0097"],
          "text": "RNA structure"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1464"
          },
          "definition": "3D coordinate and associated data for a DNA tertiary (3D) structure.",
          "text": "DNA structure"
        }],
        "data": {
          "uri": "http://edamontology.org/data_1459"
        },
        "definition": "3D coordinate and associated data for a nucleic acid tertiary (3D) structure.",
        "has_topic": ["http://edamontology.org/topic_0097"],
        "text": "Nucleic acid structure"
      }],
      "comment": ["The coordinate data may be predicted or real."],
      "data": {
        "uri": "http://edamontology.org/data_0883"
      },
      "definition": "3D coordinate and associated data for a macromolecular tertiary (3D) structure or part of a structure.",
      "exact_synonyms": ["Coordinate model", "Structure data"],
      "has_topic": ["http://edamontology.org/topic_0081"],
      "text": "Structure"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/data_3509"
        },
        "definition": "A mapping of supplied textual terms or phrases to ontology concepts (URIs).",
        "text": "Ontology mapping"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_1883"
        },
        "definition": "A URI along with annotation describing the data found at the address.",
        "text": "Annotated URI"
      }, {
        "comment": ["The cross-mapping is typically a table where each row is an accession number and each column is a database being cross-referenced. The cells give the accession number or identifier of the corresponding entry in a database. If a cell in the table is not filled then no mapping could be found for the database. Additional information might be given on version, date etc."],
        "data": {
          "uri": "http://edamontology.org/data_0954"
        },
        "definition": "A mapping of the accession numbers (or other database identifier) of entries between (typically) two biological or biomedical databases.",
        "text": "Database cross-mapping"
      }, {
        "data": {
          "uri": "http://edamontology.org/data_2872"
        },
        "definition": "A simple list of data identifiers (such as database accessions), possibly with additional basic information on the addressed data.",
        "text": "ID list"
      }],
      "comment": ["A list of database accessions or identifiers are usually included."],
      "data": {
        "uri": "http://edamontology.org/data_2093"
      },
      "definition": "Reference to a dataset (or a cross-reference between two datasets), typically one or more entries in a biological database or ontology.",
      "text": "Data reference"
    }, {
      "children": [{
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_3451"
          },
          "definition": "Rate of association of a protein with another protein or some other molecule.",
          "exact_synonyms": ["kon"],
          "text": "Rate of association"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_1526"
            },
            "definition": "Data on the stability, intrinsic disorder or globularity of a protein sequence.",
            "exact_synonyms": ["Protein globularity data"],
            "text": "Protein globularity"
          }, {
            "comment": ["Hydrophobic moment is a peptides hydrophobicity measured for different angles of rotation."],
            "data": {
              "uri": "http://edamontology.org/data_1522"
            },
            "definition": "A protein sequence with annotation on hydrophobic or hydrophilic / charged regions, hydrophobicity plot etc.",
            "text": "Protein sequence hydropathy plot"
          }, {
            "comment": ["Hydrophobic moment is a peptides hydrophobicity measured for different angles of rotation."],
            "data": {
              "uri": "http://edamontology.org/data_1520"
            },
            "definition": "Report on the hydrophobic moment of a polypeptide sequence.",
            "text": "Peptide hydrophobic moment"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1525"
            },
            "definition": "Data on the crystallizability of a protein sequence.",
            "exact_synonyms": ["Protein crystallizability data"],
            "text": "Protein crystallizability"
          }, {
            "comment": ["The aliphatic index is the relative protein volume occupied by aliphatic side chains."],
            "data": {
              "uri": "http://edamontology.org/data_1521"
            },
            "definition": "The aliphatic index of a protein.",
            "text": "Protein aliphatic index"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1524"
            },
            "definition": "The solubility or atomic solvation energy of a protein sequence or structure.",
            "exact_synonyms": ["Protein solubility data"],
            "text": "Protein solubility"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2970"
          },
          "definition": "A report on protein properties concerning hydropathy.",
          "exact_synonyms": ["Protein hydropathy report"],
          "text": "Protein hydropathy data"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1529"
          },
          "definition": "The pKa value of a protein.",
          "text": "Protein pKa value"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1530"
          },
          "definition": "The hydrogen exchange rate of a protein.",
          "text": "Protein hydrogen exchange rate"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1532"
          },
          "definition": "The optical density of a protein.",
          "text": "Protein optical density"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2956"
          },
          "definition": "Data concerning the properties or features of one or more protein secondary structures.",
          "text": "Protein secondary structure"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1528"
          },
          "definition": "The isoelectric point of one proteins.",
          "text": "Protein isoelectric point"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_3743"
          },
          "definition": "A plot in which community data (e.g. species abundance data) is summarised.  Similar species and samples are plotted close together, and dissimilar species and samples are plotted placed far apart.",
          "text": "Ordination plot"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2957"
            },
            "definition": "A Hopp and Woods plot of predicted antigenicity of a peptide or protein.",
            "text": "Hopp and Woods plot"
          }],
          "comment": ["This includes data on peptide ligands that elicit an immune response (immunogens), allergic cross-reactivity, predicted antigenicity (Hopp and Woods plot) etc. These data are useful in the development of peptide-specific antibodies or multi-epitope vaccines. Methods might use sequence data (for example motifs) and / or structural data."],
          "data": {
            "uri": "http://edamontology.org/data_1534"
          },
          "definition": "An report on allergenicity / immunogenicity of peptides and proteins.",
          "exact_synonyms": ["Peptide immunogenicity", "Peptide immunogenicity report"],
          "text": "Peptide immunogenicity data"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_1544"
            },
            "definition": "Phi/psi angle data or a Ramachandran plot of a protein structure.",
            "text": "Ramachandran plot"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2991"
          },
          "definition": "Geometry data for a protein structure, for example bond lengths, bond angles, torsion angles, chiralities, planaraties etc.",
          "exact_synonyms": ["Torsion angle data"],
          "text": "Protein geometry data"
        }, {
          "comment": ["This concept covers definitions of the protein surface, interior and interfaces, accessible and buried residues, surface accessible pockets, interior inaccessible cavities etc."],
          "data": {
            "uri": "http://edamontology.org/data_1542"
          },
          "definition": "Data on the solvent accessible or buried surface area of a protein structure.",
          "text": "Protein solvent accessibility"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1523"
          },
          "definition": "A plot of the mean charge of the amino acids within a window of specified length as the window is moved along a protein sequence.",
          "text": "Protein charge plot"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1545"
          },
          "definition": "Data on the net charge distribution (dipole moment) of a protein structure.",
          "text": "Protein dipole moment"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1527"
          },
          "definition": "The titration curve of a protein.",
          "text": "Protein titration curve"
        }, {
          "comment": ["The report might include associated data such as frequency of peptide fragment molecular weights."],
          "data": {
            "uri": "http://edamontology.org/data_1519"
          },
          "definition": "List of molecular weight(s) of one or more proteins or peptides, for example cut by proteolytic enzymes or reagents.",
          "text": "Peptide molecular weights"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_0945"
          },
          "definition": "Protein or peptide identifications with evidence supporting the identifications, for example from comparing a peptide mass fingerprint (from mass spectrometry) to a sequence database, or  the set of typical spectra one obtains when running a protein through a mass spectrometer.",
          "exact_synonyms": ["'Protein identification'", "Peptide spectrum match"],
          "has_topic": ["http://edamontology.org/topic_0121"],
          "text": "Peptide identification"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_1548"
            },
            "definition": "Report on clusters of contacting residues in protein structures such as a key structural residue network.",
            "text": "Protein residue 3D cluster"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1549"
            },
            "definition": "Patterns of hydrogen bonding in protein structures.",
            "text": "Protein hydrogen bonds"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1546"
            },
            "definition": "A matrix of distances between amino acid residues (for example the C-alpha atoms) in a protein structure.",
            "text": "Protein distance matrix"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1566"
            },
            "definition": "An informative report on protein-ligand (small molecule) interaction(s).",
            "narrow_synonyms": ["Protein-drug interaction report"],
            "text": "Protein-ligand interaction report"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1547"
            },
            "definition": "An amino acid residue contact map for a protein structure.",
            "text": "Protein contact map"
          }],
          "data": {
            "uri": "http://edamontology.org/data_0906"
          },
          "definition": "Data concerning the interactions (predicted or known) within or between a protein, structural domain or part of a protein. This includes intra- and inter-residue contacts and distances, as well as interactions with other proteins and non-protein entities such as nucleic acid, metal atoms, water, ions etc.",
          "exact_synonyms": ["Protein interaction record", "Protein interaction report", "Protein-protein interaction data", "Protein report (interaction)"],
          "has_topic": ["http://edamontology.org/topic_0128"],
          "narrow_synonyms": ["Atom interaction data", "Protein non-covalent interactions report", "Residue interaction data"],
          "text": "Protein interaction data"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1531"
          },
          "definition": "The extinction coefficient of a protein.",
          "text": "Protein extinction coefficient"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2165"
          },
          "definition": "A plot of pK versus pH for a protein.",
          "text": "Protein ionisation curve"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_0910"
            },
            "definition": "Km is the concentration (usually in Molar units) of substrate that leads to half-maximal velocity of an enzyme-catalysed reaction.",
            "text": "Km"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2025"
            },
            "definition": "A plot giving an approximation of the kinetics of an enzyme-catalysed reaction, assuming simple kinetics (i.e. no intermediate or product inhibition, allostericity or cooperativity). It plots initial reaction rate to the substrate concentration (S) from which the maximum rate (vmax) is apparent.",
            "text": "Michaelis Menten plot"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2026"
            },
            "definition": "A plot based on the Michaelis Menten equation of enzyme kinetics plotting the ratio of the initial substrate concentration (S) against the reaction velocity (v).",
            "text": "Hanes Woolf plot"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_0909"
            },
            "definition": "The maximum initial velocity or rate of a reaction. It is the limiting velocity as substrate concentrations get very large.",
            "text": "Vmax"
          }],
          "comment": ["This is a broad data type and is used a placeholder for other, more specific types."],
          "data": {
            "uri": "http://edamontology.org/data_2024"
          },
          "definition": "Data concerning chemical reaction(s) catalysed by enzyme(s).",
          "text": "Enzyme kinetics data"
        }],
        "comment": ["This is a broad data type and is used a placeholder for other, more specific types.  Data may be based on analysis of nucleic acid sequence or structural data, for example reports on the surface properties (shape, hydropathy, electrostatic patches etc) of a protein structure, protein flexibility or motion, and protein architecture (spatial arrangement of secondary structure)."],
        "data": {
          "uri": "http://edamontology.org/data_0897"
        },
        "definition": "A report of primarily non-positional data describing intrinsic physical, chemical or other properties of a protein molecule or model.",
        "exact_synonyms": ["Protein physicochemical property", "Protein properties"],
        "narrow_synonyms": ["Protein sequence statistics"],
        "text": "Protein property"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_0945"
          },
          "definition": "Protein or peptide identifications with evidence supporting the identifications, for example from comparing a peptide mass fingerprint (from mass spectrometry) to a sequence database, or  the set of typical spectra one obtains when running a protein through a mass spectrometer.",
          "exact_synonyms": ["'Protein identification'", "Peptide spectrum match"],
          "has_topic": ["http://edamontology.org/topic_0121"],
          "text": "Peptide identification"
        }, {
          "comment": ["A molecular weight standard fingerprint is standard protonated molecular masses e.g. from trypsin (modified porcine trypsin, Promega) and keratin peptides."],
          "data": {
            "uri": "http://edamontology.org/data_0944"
          },
          "definition": "A set of peptide masses (peptide mass fingerprint) from mass spectrometry.",
          "exact_synonyms": ["Peak list", "Protein fingerprint"],
          "has_topic": ["http://edamontology.org/topic_0121"],
          "narrow_synonyms": ["Molecular weights standard fingerprint"],
          "text": "Peptide mass fingerprint"
        }],
        "data": {
          "uri": "http://edamontology.org/data_2979"
        },
        "definition": "Data concerning small peptides.",
        "exact_synonyms": ["Peptide data"],
        "text": "Peptide property"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_1503"
          },
          "definition": "Statistical protein contact potentials.",
          "exact_synonyms": ["Contact potentials (amino acid pair-wise)"],
          "text": "Amino acid pair-wise contact potentials"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1449"
          },
          "definition": "Matrix of integer or floating point numbers for amino acid comparison.",
          "exact_synonyms": ["Amino acid comparison matrix", "Amino acid substitution matrix"],
          "text": "Comparison matrix (amino acid)"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_1505"
            },
            "definition": "Molecular weights of amino acids.",
            "exact_synonyms": ["Molecular weight (amino acids)"],
            "text": "Amino acid index (molecular weight)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1506"
            },
            "definition": "Hydrophobic, hydrophilic or charge properties of amino acids.",
            "exact_synonyms": ["Hydropathy (amino acids)"],
            "text": "Amino acid index (hydropathy)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1508"
            },
            "definition": "Van der Waals radii of atoms for different amino acid residues.",
            "exact_synonyms": ["van der Waals radii (amino acids)"],
            "text": "Amino acid index (van der Waals radii)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1502"
            },
            "definition": "Chemical classification (small, aliphatic, aromatic, polar, charged etc) of amino acids.",
            "exact_synonyms": ["Chemical classes (amino acids)"],
            "text": "Amino acid index (chemical classes)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1507"
            },
            "definition": "Experimental free energy values for the water-interface and water-octanol transitions for the amino acids.",
            "exact_synonyms": ["White-Wimley data (amino acids)"],
            "text": "Amino acid index (White-Wimley data)"
          }],
          "data": {
            "uri": "http://edamontology.org/data_1501"
          },
          "definition": "A table of 20 numerical values which quantify a property (e.g. physicochemical or biochemical) of the common amino acids.",
          "text": "Amino acid index"
        }],
        "data": {
          "uri": "http://edamontology.org/data_2016"
        },
        "definition": "Data concerning the intrinsic physical (e.g. structural) or chemical properties of one, more or all amino acids.",
        "exact_synonyms": ["Amino acid data"],
        "text": "Amino acid property"
      }, {
        "children": [{
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2720"
            },
            "definition": "Physicochemical property data for one or more dinucleotides.",
            "text": "Dinucleotide property"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1589"
            },
            "definition": "DNA base pair twist angle data.",
            "text": "DNA base pair twist angle data"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1590"
            },
            "definition": "DNA base trimer roll angles data.",
            "text": "DNA base trimer roll angles data"
          }, {
            "comment": ["Such as generated by the Vienna package."],
            "data": {
              "uri": "http://edamontology.org/data_1595"
            },
            "definition": "Dotplot of RNA base pairing probability matrix.",
            "text": "Base pairing probability matrix dotplot"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1588"
            },
            "definition": "DNA base pair stacking energies data.",
            "text": "DNA base pair stacking energies data"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2088"
          },
          "definition": "Structural data for DNA base pairs or runs of bases, such as energy or angle data.",
          "text": "DNA base structural data"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_1585"
            },
            "definition": "Entropy of hybridised or double stranded nucleic acid (DNA or RNA/DNA).",
            "text": "Nucleic acid entropy"
          }, {
            "comment": ["A melting (stability) profile calculated the free energy required to unwind and separate the nucleic acid strands, plotted for sliding windows over a sequence."],
            "data": {
              "uri": "http://edamontology.org/data_1583"
            },
            "definition": "Data on the dissociation characteristics of a double-stranded nucleic acid molecule (DNA or a DNA/RNA hybrid) during heating.",
            "exact_synonyms": ["Nucleic acid stability profile"],
            "narrow_synonyms": ["Melting map", "Nucleic acid melting curve"],
            "text": "Nucleic acid melting profile"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1584"
            },
            "definition": "Enthalpy of hybridised or double stranded nucleic acid (DNA or RNA/DNA).",
            "text": "Nucleic acid enthalpy"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_2139"
            },
            "definition": "A temperature concerning nucleic acid denaturation, typically the temperature at which the two strands of a hybridised or double stranded nucleic acid (DNA or RNA/DNA) molecule separate.",
            "exact_synonyms": ["Melting temperature"],
            "text": "Nucleic acid melting temperature"
          }],
          "data": {
            "uri": "http://edamontology.org/data_2985"
          },
          "definition": "A thermodynamic or kinetic property of a nucleic acid molecule.",
          "exact_synonyms": ["Nucleic acid property (thermodynamic or kinetic)", "Nucleic acid thermodynamic property"],
          "text": "Nucleic acid thermodynamic data"
        }],
        "comment": ["This is a broad data type and is used a placeholder for other, more specific types."],
        "data": {
          "uri": "http://edamontology.org/data_0912"
        },
        "definition": "A report of primarily non-positional data describing intrinsic physical, chemical or other properties of a nucleic acid molecule.",
        "exact_synonyms": ["Nucleic acid physicochemical property"],
        "narrow_synonyms": ["Nucleic acid property (structural)", "GC-content", "Nucleic acid structural property"],
        "text": "Nucleic acid property"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_2753"
          },
          "definition": "A conformational energy map of the glycosidic linkages in a carbohydrate molecule.",
          "text": "Carbohydrate conformational map"
        }],
        "data": {
          "uri": "http://edamontology.org/data_3425"
        },
        "definition": "Data concerning the intrinsic physical (e.g. structural) or chemical properties of one, more or all carbohydrates.",
        "exact_synonyms": ["Carbohydrate data"],
        "text": "Carbohydrate property"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_0845"
          },
          "definition": "Net charge of a molecule.",
          "text": "Molecular charge"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_1205"
            },
            "definition": "A QSAR molecular descriptor.",
            "exact_synonyms": ["QSAR molecular descriptor"],
            "text": "QSAR descriptor (molecular)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1203"
            },
            "definition": "A QSAR geometrical descriptor.",
            "exact_synonyms": ["QSAR geometrical descriptor"],
            "text": "QSAR descriptor (geometrical)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1204"
            },
            "definition": "A QSAR topological descriptor.",
            "exact_synonyms": ["QSAR topological descriptor"],
            "text": "QSAR descriptor (topological)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1202"
            },
            "definition": "A QSAR electronic descriptor.",
            "exact_synonyms": ["QSAR electronic descriptor"],
            "text": "QSAR descriptor (electronic)"
          }, {
            "data": {
              "uri": "http://edamontology.org/data_1201"
            },
            "definition": "A QSAR constitutional descriptor.",
            "exact_synonyms": ["QSAR constitutional descriptor"],
            "text": "QSAR descriptor (constitutional)"
          }],
          "comment": ["QSAR descriptors have numeric values that quantify chemical information encoded in a symbolic representation of a molecule. They are used in quantitative structure activity relationship (QSAR) applications. Many subtypes of individual descriptors (not included in EDAM) cover various types of protein properties."],
          "data": {
            "uri": "http://edamontology.org/data_0847"
          },
          "definition": "A QSAR quantitative descriptor (name-value pair) of chemical structure.",
          "text": "QSAR descriptor"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_2140"
          },
          "definition": "The concentration of a chemical compound.",
          "text": "Concentration"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/data_2301"
            },
            "definition": "A specification of a chemical structure in SMILES format.",
            "text": "SMILES string"
          }],
          "data": {
            "uri": "http://edamontology.org/data_0846"
          },
          "definition": "A specification of a chemical structure.",
          "exact_synonyms": ["Chemical structure specification"],
          "text": "Chemical formula"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_0844"
          },
          "definition": "Mass of a molecule.",
          "text": "Molecular mass"
        }],
        "data": {
          "uri": "http://edamontology.org/data_2050"
        },
        "definition": "General data for a molecule.",
        "exact_synonyms": ["General molecular property"],
        "text": "Molecular property (general)"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_1858"
          },
          "definition": "Isotropic B factor (atomic displacement parameter) for an atom from a PDB file.",
          "text": "Isotropic B factor"
        }, {
          "comment": ["The sum of the occupancies of all the atom types at a site should not normally significantly exceed 1.0."],
          "data": {
            "uri": "http://edamontology.org/data_1857"
          },
          "definition": "The fraction of an atom type present at a site in a molecular structure.",
          "text": "Atomic occupancy"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1743"
          },
          "definition": "Cartesian coordinate of an atom (in a molecular structure).",
          "exact_synonyms": ["Cartesian coordinate"],
          "text": "Atomic coordinate"
        }],
        "data": {
          "uri": "http://edamontology.org/data_1917"
        },
        "definition": "Data for an atom (in a molecular structure).",
        "exact_synonyms": ["General atomic property"],
        "text": "Atomic property"
      }],
      "data": {
        "uri": "http://edamontology.org/data_2087"
      },
      "definition": "A report on the physical (e.g. structural) or chemical properties of molecules, or parts of a molecule.",
      "exact_synonyms": ["Physicochemical property"],
      "text": "Molecular property"
    }, {
      "children": [{
        "children": [{
          "comment": ["The sequences are typically related, for example a family of sequences."],
          "data": {
            "uri": "http://edamontology.org/data_1246"
          },
          "definition": "A cluster of nucleotide sequences.",
          "exact_synonyms": ["Nucleotide sequence cluster"],
          "text": "Sequence cluster (nucleic acid)"
        }, {
          "comment": ["The sequences are typically related, for example a family of sequences."],
          "data": {
            "uri": "http://edamontology.org/data_1245"
          },
          "definition": "A cluster of protein sequences.",
          "exact_synonyms": ["Protein sequence cluster"],
          "text": "Sequence cluster (protein)"
        }],
        "comment": ["The cluster might include sequences identifiers, short descriptions, alignment and summary information."],
        "data": {
          "uri": "http://edamontology.org/data_1235"
        },
        "definition": "A set of sequences that have been clustered or otherwise classified as belonging to a group including (typically) sequence cluster information.",
        "has_topic": ["http://edamontology.org/topic_0623"],
        "text": "Sequence cluster"
      }, {
        "children": [{
          "comment": ["Typically, an assembly is a collection of contigs (for example ESTs and genomic DNA fragments) that are ordered, aligned and merged. Annotation of the assembled sequence might be included."],
          "data": {
            "uri": "http://edamontology.org/data_0925"
          },
          "definition": "An assembly of fragments of a (typically genomic) DNA sequence.",
          "exact_synonyms": ["Contigs", "SO:0000353"],
          "narrow_synonyms": ["SO:0001248"],
          "text": "Sequence assembly"
        }, {
          "comment": ["The sequences are typically related, for example a family of sequences."],
          "data": {
            "uri": "http://edamontology.org/data_1246"
          },
          "definition": "A cluster of nucleotide sequences.",
          "exact_synonyms": ["Nucleotide sequence cluster"],
          "text": "Sequence cluster (nucleic acid)"
        }, {
          "comment": ["This is the raw data produced by a DNA sequencing machine."],
          "data": {
            "uri": "http://edamontology.org/data_0924"
          },
          "definition": "Fluorescence trace data generated by an automated DNA sequencer, which can be interprted as a molecular sequence (reads), given associated sequencing metadata such as base-call quality scores.",
          "text": "Sequence trace"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1240"
          },
          "definition": "Oligonucleotide primer(s) for PCR and DNA amplification, for example a minimal primer set.",
          "text": "PCR primers"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1239"
          },
          "definition": "Restriction digest fragments from digesting a nucleotide sequence with restriction sites using a restriction endonuclease.",
          "text": "Restriction digest"
        }],
        "data": {
          "uri": "http://edamontology.org/data_1234"
        },
        "definition": "Any collection of multiple nucleotide sequences and associated metadata that do not (typically) correspond to common sequence database records or database entries.",
        "text": "Sequence set (nucleic acid)"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/data_1262"
          },
          "definition": "A report on peptide fragments of certain molecular weight(s) in one or more protein sequences.",
          "text": "Peptide molecular weight hits"
        }, {
          "comment": ["The sequences are typically related, for example a family of sequences."],
          "data": {
            "uri": "http://edamontology.org/data_1245"
          },
          "definition": "A cluster of protein sequences.",
          "exact_synonyms": ["Protein sequence cluster"],
          "text": "Sequence cluster (protein)"
        }, {
          "data": {
            "uri": "http://edamontology.org/data_1238"
          },
          "definition": "A protein sequence cleaved into peptide fragments (by enzymatic or chemical cleavage) with fragment masses.",
          "has_topic": ["http://edamontology.org/topic_0121"],
          "text": "Proteolytic digest"
        }],
        "data": {
          "uri": "http://edamontology.org/data_1233"
        },
        "definition": "Any collection of multiple protein sequences and associated metadata that do not (typically) correspond to common sequence database records or database entries.",
        "text": "Sequence set (protein)"
      }],
      "comment": ["This concept may be used for arbitrary sequence sets and associated data arising from processing.", "An example is an alignment reference; one or a set of reference molecular sequences, structures, or profiles used for alignment of genomic, transcriptomic, or proteomic experimental data."],
      "data": {
        "uri": "http://edamontology.org/data_0850"
      },
      "definition": "A collection of one or typically multiple molecular sequences (which can include derived data or metadata) that do not (typically) correspond to molecular sequence database records or entries and which (typically) are derived from some analytical method.",
      "narrow_synonyms": ["Alignment reference"],
      "text": "Sequence set"
    }],
    "data": {
      "uri": "http://edamontology.org/data_0006"
    },
    "definition": "Information, represented in an information artefact (data record) that is 'understandable' by dedicated computational tools that can use the data as input or produce it as output.",
    "exact_synonyms": ["Data record"],
    "narrow_synonyms": ["Data set", "Datum"],
    "text": "Data"
  }, {
    "children": [{
      "children": [{
        "children": [{
          "data": {
            "uri": "http://edamontology.org/operation_2510"
          },
          "definition": "Back-translate a protein sequence into DNA.",
          "has_topic": ["http://edamontology.org/topic_0108"],
          "text": "DNA back-translation"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0372"
          },
          "definition": "Transcribe a nucleotide sequence into mRNA sequence(s).",
          "has_topic": ["http://edamontology.org/topic_0203"],
          "text": "DNA transcription"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0371"
          },
          "definition": "Translate a DNA sequence into protein.",
          "has_topic": ["http://edamontology.org/topic_0108"],
          "text": "DNA translation"
        }],
        "data": {
          "uri": "http://edamontology.org/operation_0233"
        },
        "definition": "Convert a molecular sequence from one type to another.",
        "text": "Sequence conversion"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_3267"
        },
        "definition": "Convert one set of sequence coordinates to another, e.g. convert coordinates of one assembly to another, cDNA to genomic, CDS to genomic, protein translation to genomic etc.",
        "has_input": ["http://edamontology.org/data_2012"],
        "has_output": ["http://edamontology.org/data_2012"],
        "text": "Sequence coordinate conversion"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_0260"
        },
        "definition": "Convert a molecular sequence alignment from one type to another (for example amino acid to coding nucleotide sequence).",
        "text": "Sequence alignment conversion"
      }],
      "data": {
        "uri": "http://edamontology.org/operation_3434"
      },
      "definition": "Convert a data set from one form to another.",
      "text": "Conversion"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/operation_3731"
        },
        "definition": "The comparison of samples from a metagenomics study, for example, by comparison of metagenome shotgun reads or assembled contig sequences, by comparison of functional profiles, or some other method.",
        "text": "Sample comparison"
      }, {
        "children": [{
          "comment": ["Methods typically test for topological similarity between trees using for example a congruence index."],
          "data": {
            "uri": "http://edamontology.org/operation_0555"
          },
          "definition": "Compare two or more phylogenetic trees to produce a consensus tree.",
          "exact_synonyms": ["Phylogenetic tree generation (consensus)", "Phylogenetic tree construction (consensus)"],
          "text": "Consensus tree construction"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0556"
          },
          "definition": "Compare two or more phylogenetic trees to detect subtrees or supertrees.",
          "exact_synonyms": ["Phylogenetic sub/super tree detection"],
          "narrow_synonyms": ["Supertree construction", "Subtree construction"],
          "text": "Phylogenetic sub/super tree construction"
        }, {
          "comment": ["Methods typically test for topological similarity between trees using for example a congruence index."],
          "data": {
            "uri": "http://edamontology.org/operation_3947"
          },
          "definition": "Mapping between gene tree nodes and species tree nodes or branches, to analyse and account for possible differences between gene histories and species histories, explaining this in terms of gene-scale events such as duplication, loss, transfer etc.",
          "exact_synonyms": ["Gene tree / species tree reconciliation"],
          "text": "Phylogenetic tree reconciliation"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0557"
          },
          "definition": "Compare two or more phylogenetic trees to calculate distances between trees.",
          "has_output": ["http://edamontology.org/data_1442"],
          "text": "Phylogenetic tree distances calculation"
        }],
        "comment": ["For example, to produce a consensus tree, subtrees, supertrees, calculate distances between trees or test topological similarity between trees (e.g. a congruence index) etc."],
        "data": {
          "uri": "http://edamontology.org/operation_0325"
        },
        "definition": "Compare two or more phylogenetic trees.",
        "text": "Phylogenetic tree comparison"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/operation_0360"
          },
          "definition": "Search a database of molecular structure and retrieve structures that are similar to a query structure.",
          "exact_synonyms": ["Structure retrieval by structure", "Structure database search (by structure)"],
          "text": "Structural similarity search"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3564"
          },
          "definition": "Identify and remove redudancy from a set of small molecule structures.",
          "text": "Chemical redundancy removal"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_2518"
          },
          "definition": "Compare nucleic acid tertiary structures.",
          "exact_synonyms": ["Structure comparison (nucleic acid)"],
          "text": "Nucleic acid structure comparison"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3666"
          },
          "definition": "Compare two or more molecular surfaces.",
          "text": "Molecular surface comparison"
        }, {
          "children": [{
            "comment": ["This includes methods that use an existing alignment."],
            "data": {
              "uri": "http://edamontology.org/operation_0504"
            },
            "definition": "Align (superimpose) more than two molecular tertiary structures.",
            "exact_synonyms": ["Structure alignment (multiple)"],
            "narrow_synonyms": ["Multiple protein structure alignment"],
            "text": "Multiple structure alignment"
          }, {
            "comment": ["Local alignment methods identify regions of local similarity, common substructures etc."],
            "data": {
              "uri": "http://edamontology.org/operation_0509"
            },
            "definition": "Locally align (superimpose) two or more molecular tertiary structures.",
            "exact_synonyms": ["Structure alignment (local)"],
            "narrow_synonyms": ["Local protein structure alignment"],
            "text": "Local structure alignment"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0503"
            },
            "definition": "Align (superimpose) exactly two molecular tertiary structures.",
            "exact_synonyms": ["Structure alignment (pairwise)"],
            "narrow_synonyms": ["Pairwise protein structure alignment"],
            "text": "Pairwise structure alignment"
          }, {
            "comment": ["Global alignment methods identify similarity across the entire structures."],
            "data": {
              "uri": "http://edamontology.org/operation_0510"
            },
            "definition": "Globally align (superimpose) two or more molecular tertiary structures.",
            "exact_synonyms": ["Structure alignment (global)"],
            "narrow_synonyms": ["Global protein structure alignment"],
            "text": "Global structure alignment"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_0295"
          },
          "definition": "Align (superimpose) molecular tertiary structures.",
          "exact_synonyms": ["Structural alignment"],
          "has_output": ["http://edamontology.org/data_0886"],
          "narrow_synonyms": ["3D profile-to-3D profile alignment", "Structural profile alignment", "3D profile alignment"],
          "text": "Structure alignment"
        }, {
          "comment": ["Methods might identify structural neighbors, find structural similarities or define a structural core."],
          "data": {
            "uri": "http://edamontology.org/operation_2487"
          },
          "definition": "Compare protein tertiary structures.",
          "exact_synonyms": ["Structure comparison (protein)"],
          "has_input": ["http://edamontology.org/data_1460"],
          "text": "Protein structure comparison"
        }],
        "data": {
          "uri": "http://edamontology.org/operation_2483"
        },
        "definition": "Compare two or more molecular tertiary structures.",
        "has_topic": ["http://edamontology.org/topic_0081"],
        "text": "Structure comparison"
      }, {
        "comment": ["See also 'Sequence profile alignment'."],
        "data": {
          "uri": "http://edamontology.org/operation_0259"
        },
        "definition": "Compare (typically by aligning) two molecular sequence alignments.",
        "text": "Sequence alignment comparison"
      }, {
        "comment": ["The mapping can be achieved by comparing identifier values or some other means, e.g. exact matches to a provided sequence."],
        "data": {
          "uri": "http://edamontology.org/operation_3282"
        },
        "definition": "Map data identifiers to one another for example to establish a link between two biological databases for the purposes of data integration.",
        "exact_synonyms": ["Accession mapping", "Identifier mapping"],
        "text": "ID mapping"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/operation_0240"
          },
          "definition": "Find motifs shared by molecular sequences.",
          "has_output": ["http://edamontology.org/data_0858"],
          "has_topic": ["http://edamontology.org/topic_0160"],
          "text": "Sequence motif comparison"
        }, {
          "children": [{
            "comment": ["Methods include sequence alignment (if related sequences are available) and word-based sequence comparison."],
            "data": {
              "uri": "http://edamontology.org/operation_0265"
            },
            "definition": "Detect frameshifts in DNA sequences, including frameshift sites and signals, and frameshift errors from sequencing projects.",
            "has_topic": ["http://edamontology.org/topic_3168"],
            "narrow_synonyms": ["Frameshift error detection"],
            "text": "Frameshift detection"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_3195"
          },
          "definition": "Detect errors in DNA sequences generated from sequencing projects).",
          "exact_synonyms": ["Short read error correction", "Short-read error correction"],
          "has_topic": ["http://edamontology.org/topic_3168"],
          "text": "Sequencing error detection"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0290"
          },
          "definition": "Compare two or more molecular sequences, identify and remove redundant sequences based on some criteria.",
          "has_output": ["http://edamontology.org/data_2044"],
          "text": "Sequence redundancy removal"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3209"
          },
          "definition": "Compare the sequence or features of two or more genomes, for example, to find matching regions.",
          "exact_synonyms": ["Genomic region matching"],
          "text": "Genome comparison"
        }, {
          "children": [{
            "comment": ["Dot plots are useful when having not too many (e.g. 20) data points for each category. Example: draw a dotplot of sequence similarities identified from word-matching or character comparison."],
            "data": {
              "uri": "http://edamontology.org/operation_0490"
            },
            "definition": "Render a representation of a distribution that consists of group of data points plotted on a simple scale.",
            "exact_synonyms": ["Categorical plot plotting", "Dotplot plotting"],
            "has_output": ["http://edamontology.org/data_0862"],
            "text": "Dot plot plotting"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_0288"
          },
          "definition": "Find exact character or word matches between molecular sequences without full sequence alignment.",
          "text": "Sequence word comparison"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0346"
          },
          "definition": "Search a sequence database and retrieve sequences that are similar to a query sequence.",
          "narrow_synonyms": ["Structure database search (by sequence)", "Sequence database search (by sequence)"],
          "text": "Sequence similarity search"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0289"
          },
          "definition": "Calculate a sequence distance matrix or otherwise estimate genetic distances between molecular sequences.",
          "exact_synonyms": ["Sequence distance calculation", "Phylogenetic distance matrix generation", "Sequence distance matrix construction"],
          "has_output": ["http://edamontology.org/data_0870"],
          "has_topic": ["http://edamontology.org/topic_0084"],
          "text": "Sequence distance matrix generation"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_2233"
          },
          "definition": "Identify a representative sequence from a set of sequences, typically using scores from pair-wise alignment or other comparison of the sequences.",
          "text": "Representative sequence identification"
        }, {
          "children": [{
            "comment": ["A sequence profile typically represents a sequence alignment. Methods might perform one-to-one, one-to-many or many-to-many comparisons."],
            "data": {
              "uri": "http://edamontology.org/operation_0300"
            },
            "definition": "Align molecular sequence(s) to sequence profile(s), or profiles to other profiles.  A profile typically represents a sequence alignment.",
            "has_input": ["http://edamontology.org/data_1354"],
            "has_topic": ["http://edamontology.org/topic_0160"],
            "narrow_synonyms": ["Profile-profile alignment", "Sequence-to-profile alignment", "Sequence-profile alignment", "Profile-to-profile alignment"],
            "text": "Sequence profile alignment"
          }, {
            "comment": ["This is supposed to give a more biologically meaningful alignment than standard alignments."],
            "data": {
              "uri": "http://edamontology.org/operation_0499"
            },
            "definition": "Align multiple sequences using relative gap costs calculated from neighbors in a supplied phylogenetic tree.",
            "exact_synonyms": ["Multiple sequence alignment construction (phylogenetic tree-based)", "Multiple sequence alignment (phylogenetic tree-based)", "Phylogenetic tree-based multiple sequence alignment construction", "Sequence alignment (phylogenetic tree-based)", "Sequence alignment generation (phylogenetic tree-based)"],
            "has_topic": ["http://edamontology.org/topic_0084"],
            "text": "Tree-based sequence alignment"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0294"
            },
            "definition": "Align molecular sequences using sequence and structural information.",
            "exact_synonyms": ["Sequence alignment (structure-based)"],
            "text": "Structure-based sequence alignment"
          }, {
            "comment": ["Methods might perform one-to-one, one-to-many or many-to-many comparisons."],
            "data": {
              "uri": "http://edamontology.org/operation_0491"
            },
            "definition": "Align exactly two molecular sequences.",
            "exact_synonyms": ["Pairwise alignment"],
            "has_output": ["http://edamontology.org/data_1381"],
            "text": "Pairwise sequence alignment"
          }, {
            "comment": ["This includes methods that use an existing alignment, for example to incorporate sequences into an alignment, or combine several multiple alignments into a single, improved alignment."],
            "data": {
              "uri": "http://edamontology.org/operation_0492"
            },
            "definition": "Align more than two molecular sequences.",
            "exact_synonyms": ["Multiple alignment"],
            "text": "Multiple sequence alignment"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3182"
            },
            "definition": "Align two or more (tpyically huge) molecular sequences that represent genomes.",
            "exact_synonyms": ["Whole genome alignment", "Genome alignment construction"],
            "text": "Genome alignment"
          }, {
            "comment": ["Local alignment methods identify regions of local similarity."],
            "data": {
              "uri": "http://edamontology.org/operation_0495"
            },
            "definition": "Locally align two or more molecular sequences.",
            "exact_synonyms": ["Local sequence alignment", "Sequence alignment (local)"],
            "narrow_synonyms": ["Smith-Waterman"],
            "text": "Local alignment"
          }, {
            "comment": ["Global alignment methods identify similarity across the entire length of the sequences."],
            "data": {
              "uri": "http://edamontology.org/operation_0496"
            },
            "definition": "Globally align two or more molecular sequences.",
            "exact_synonyms": ["Global sequence alignment", "Sequence alignment (global)"],
            "text": "Global alignment"
          }],
          "comment": ["See also \"Read mapping\""],
          "data": {
            "uri": "http://edamontology.org/operation_0292"
          },
          "definition": "Align (identify equivalent sites within) molecular sequences.",
          "exact_synonyms": ["Sequence alignment construction", "Sequence alignment generation"],
          "has_output": ["http://edamontology.org/data_0863"],
          "narrow_synonyms": ["Consensus-based sequence alignment", "Constrained sequence alignment", "Sequence alignment (constrained)", "Multiple sequence alignment (constrained)"],
          "text": "Sequence alignment"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_3459"
            },
            "definition": "Clustering of molecular sequences on the basis of their function, typically using information from an ontology of gene function, or some other measure of functional phenotype.",
            "exact_synonyms": ["Functional sequence clustering"],
            "has_topic": ["http://edamontology.org/topic_1775"],
            "text": "Functional clustering"
          }],
          "comment": ["The clusters may be output or used internally for some other purpose."],
          "data": {
            "uri": "http://edamontology.org/operation_0291"
          },
          "definition": "Build clusters of similar sequences, typically using scores from pair-wise alignment or other comparison of the sequences.",
          "exact_synonyms": ["Sequence cluster construction", "Sequence cluster generation"],
          "has_output": ["http://edamontology.org/data_1235"],
          "text": "Sequence clustering"
        }],
        "data": {
          "uri": "http://edamontology.org/operation_2451"
        },
        "definition": "Compare two or more molecular sequences.",
        "has_input": ["http://edamontology.org/data_2044"],
        "has_output": ["http://edamontology.org/data_2955"],
        "text": "Sequence comparison"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/operation_1778"
          },
          "definition": "Compare the functional properties of two or more proteins.",
          "has_topic": ["http://edamontology.org/topic_1775"],
          "text": "Protein function comparison"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3741"
          },
          "definition": "The analysis, using proteomics techniques, to identify proteins whose encoding genes are differentially expressed under a given experimental setup.",
          "exact_synonyms": ["Differential protein expression analysis"],
          "text": "Differential protein expression profiling"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_2929"
            },
            "definition": "Calculate the molecular weight of a protein (or fragments) and compare it to another protein or reference data. Generally used for protein identification.",
            "exact_synonyms": ["Peptide mass fingerprinting", "PMF", "Protein fingerprinting"],
            "text": "Protein fragment weight comparison"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_2930"
          },
          "definition": "Compare the physicochemical properties of two or more proteins (or reference data).",
          "has_output": ["http://edamontology.org/data_0897"],
          "text": "Protein property comparison"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_2474"
          },
          "definition": "Compare the architecture of two or more protein structures.",
          "text": "Protein architecture comparison"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_2488"
          },
          "definition": "Compare protein secondary structures.",
          "exact_synonyms": ["Secondary structure comparison (protein)", "Protein secondary structure"],
          "narrow_synonyms": ["Protein secondary structure alignment"],
          "text": "Protein secondary structure comparison"
        }, {
          "children": [{
            "comment": ["Use this concept for methods that evaluate sequence-structure compatibility by assessing residue interactions in 3D. Methods might perform one-to-one, one-to-many or many-to-many comparisons."],
            "data": {
              "uri": "http://edamontology.org/operation_0302"
            },
            "definition": "Align molecular sequence to structure in 3D space (threading).",
            "exact_synonyms": ["Sequence-structure alignment"],
            "has_input": ["http://edamontology.org/data_1460"],
            "has_output": ["http://edamontology.org/data_0893"],
            "narrow_synonyms": ["Sequence-3D profile alignment", "Sequence-to-3D-profile alignment"],
            "text": "Protein threading"
          }],
          "comment": ["Methods use some type of mapping between sequence and fold, for example secondary structure prediction and alignment, profile comparison, sequence properties, homologous sequence search, kernel machines etc. Domains and folds might be taken from SCOP or CATH."],
          "data": {
            "uri": "http://edamontology.org/operation_0303"
          },
          "definition": "Recognize (predict and identify) known protein structural domains or folds in protein sequence(s) which (typically) are not accompanied by any significant sequence similarity to know structures.",
          "exact_synonyms": ["Protein fold recognition", "Fold prediction", "Protein domain prediction", "Domain prediction", "Protein fold prediction"],
          "text": "Fold recognition"
        }, {
          "comment": ["Methods might identify structural neighbors, find structural similarities or define a structural core."],
          "data": {
            "uri": "http://edamontology.org/operation_2487"
          },
          "definition": "Compare protein tertiary structures.",
          "exact_synonyms": ["Structure comparison (protein)"],
          "has_input": ["http://edamontology.org/data_1460"],
          "text": "Protein structure comparison"
        }],
        "data": {
          "uri": "http://edamontology.org/operation_2997"
        },
        "definition": "Compare two or more proteins (or some aspect) to identify similarities.",
        "text": "Protein comparison"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_3561"
        },
        "definition": "Compare the models or schemas used by two or more databases, or any other general comparison of databases rather than a detailed comparison of the entries themselves.",
        "narrow_synonyms": ["Data model comparison", "Schema comparison"],
        "text": "Database comparison"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/operation_3278"
          },
          "definition": "Calculate similarity between 2 or more documents.",
          "text": "Document similarity calculation"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3279"
          },
          "definition": "Cluster (group) documents on the basis of their calculated similarity.",
          "text": "Document clustering"
        }],
        "data": {
          "uri": "http://edamontology.org/operation_3437"
        },
        "definition": "Compare two or more scientific articles.",
        "has_topic": ["http://edamontology.org/topic_3068"],
        "text": "Article comparison"
      }, {
        "children": [{
          "comment": ["Genomic elements that might be compared include genes, indels, single nucleotide polymorphisms (SNPs), retrotransposons, tandem repeats and so on."],
          "data": {
            "uri": "http://edamontology.org/operation_3194"
          },
          "definition": "Compare the features of two genome sequences.",
          "text": "Genome feature comparison"
        }],
        "data": {
          "uri": "http://edamontology.org/operation_0256"
        },
        "definition": "Compare the feature tables of two or more molecular sequences.",
        "exact_synonyms": ["Feature table comparison", "Feature comparison"],
        "has_input": ["http://edamontology.org/data_1270", "http://edamontology.org/data_0849"],
        "has_topic": ["http://edamontology.org/topic_0160"],
        "text": "Sequence feature comparison"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_3352"
        },
        "definition": "Compare two or more ontologies, e.g. identify differences.",
        "text": "Ontology comparison"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/operation_0285"
          },
          "definition": "Compare two or more codon usage tables.",
          "text": "Codon usage table comparison"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_2518"
          },
          "definition": "Compare nucleic acid tertiary structures.",
          "exact_synonyms": ["Structure comparison (nucleic acid)"],
          "text": "Nucleic acid structure comparison"
        }],
        "data": {
          "uri": "http://edamontology.org/operation_2998"
        },
        "definition": "Compare two or more nucleic acids to identify similarities.",
        "text": "Nucleic acid comparison"
      }],
      "data": {
        "uri": "http://edamontology.org/operation_2424"
      },
      "definition": "Compare two or more things to identify similarities.",
      "text": "Comparison"
    }, {
      "children": [{
        "comment": ["The mapping can be achieved by comparing identifier values or some other means, e.g. exact matches to a provided sequence."],
        "data": {
          "uri": "http://edamontology.org/operation_3282"
        },
        "definition": "Map data identifiers to one another for example to establish a link between two biological databases for the purposes of data integration.",
        "exact_synonyms": ["Accession mapping", "Identifier mapping"],
        "text": "ID mapping"
      }, {
        "comment": ["Epitope mapping is commonly done during vaccine design."],
        "data": {
          "uri": "http://edamontology.org/operation_0416"
        },
        "definition": "Predict antigenic determinant sites (epitopes) in protein sequences.",
        "exact_synonyms": ["Antibody epitope prediction", "Epitope prediction"],
        "has_topic": ["http://edamontology.org/topic_0804"],
        "narrow_synonyms": ["T cell epitope prediction", "Epitope mapping (MHC Class II)", "T cell epitope mapping", "B cell epitope prediction", "Epitope mapping (MHC Class I)", "B cell epitope mapping"],
        "text": "Epitope mapping"
      }, {
        "children": [{
          "children": [{
            "comment": ["An STS is a short subsequence of known sequence and location that occurs only once in the chromosome or genome that is being mapped. Sources of STSs include 1. expressed sequence tags (ESTs), simple sequence length polymorphisms (SSLPs), and random genomic sequences from cloned genomic DNA or database sequences."],
            "data": {
              "uri": "http://edamontology.org/operation_2871"
            },
            "definition": "Generate a physical DNA map (sequence map) from analysis of sequence tagged sites (STS).",
            "exact_synonyms": ["Sequence mapping"],
            "has_output": ["http://edamontology.org/data_1279"],
            "text": "Sequence tagged site (STS) mapping"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0485"
            },
            "definition": "Generate a physical (radiation hybrid) map of genetic markers in a DNA sequence using provided radiation hybrid (RH) scores for one or more markers.",
            "has_output": ["http://edamontology.org/data_2870"],
            "text": "Radiation Hybrid Mapping"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/operation_3199"
              },
              "definition": "A varient of oligonucleotide mapping where a read is mapped to two separate locations because of possible structural variation.",
              "exact_synonyms": ["Split-read mapping"],
              "text": "Split read mapping"
            }],
            "comment": ["The purpose of read mapping is to identify the location of sequenced fragments within a reference genome and assumes that there is, in fact, at least local similarity between the fragment and reference sequences."],
            "data": {
              "uri": "http://edamontology.org/operation_3198"
            },
            "definition": "Align short oligonucleotide sequences (reads) to a larger (genomic) sequence.",
            "exact_synonyms": ["Short read alignment", "Oligonucleotide alignment", "Short oligonucleotide alignment", "Oligonucleotide mapping", "Oligonucleotide alignment generation", "Read alignment", "Short sequence read mapping", "Short read mapping", "Oligonucleotide alignment construction"],
            "text": "Read mapping"
          }, {
            "comment": ["Bisulfite mapping follows high-throughput sequencing of DNA which has undergone bisulfite treatment followed by PCR amplification; unmethylated cytosines are specifically converted to thymine, allowing the methylation status of cytosine in the DNA to be detected."],
            "data": {
              "uri": "http://edamontology.org/operation_3186"
            },
            "definition": "The mapping of methylation sites in a DNA (genome) sequence.  Typically, the mapping of high-throughput bisulfite reads to the reference genome.",
            "exact_synonyms": ["Bisulfite sequence alignment", "Bisulfite sequence mapping", "Bisulfite read mapping"],
            "text": "Bisulfite mapping"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_2944"
          },
          "definition": "Generate a physical (sequence) map of a DNA sequence showing the physical distance (base pairs) between features or landmarks such as restriction sites, cloned DNA fragments, genes and other genetic markers.",
          "exact_synonyms": ["Physical cartography"],
          "has_output": ["http://edamontology.org/data_1280"],
          "has_topic": ["http://edamontology.org/topic_0102"],
          "text": "Physical mapping"
        }, {
          "children": [{
            "comment": ["Haplotype inference can help in population genetic studies and the identification of complex disease genes, , and is typically based on aligned single nucleotide polymorphism (SNP) fragments. Haplotype comparison is a useful way to characterize the genetic variation between individuals. An individual's haplotype describes which nucleotide base occurs at each position for a set of common SNPs. Tools might use combinatorial functions (for example parsimony) or a likelihood function or model with optimisation such as minimum error correction (MEC) model, expectation-maximisation algorithm (EM), genetic algorithm or Markov chain Monte Carlo (MCMC)."],
            "data": {
              "uri": "http://edamontology.org/operation_0487"
            },
            "definition": "Infer haplotypes, either alleles at multiple loci that are transmitted together on the same chromosome, or a set of single nucleotide polymorphisms (SNPs) on a single chromatid that are statistically associated.",
            "exact_synonyms": ["Haplotype reconstruction", "Haplotype map generation", "Haplotype inference"],
            "has_output": ["http://edamontology.org/data_1863"],
            "text": "Haplotype mapping"
          }],
          "comment": ["Mapping involves ordering genetic loci along a chromosome and estimating the physical distance between loci. A genetic map shows the relative (not physical) position of known genes and genetic markers.", "This includes mapping of the genetic architecture of dynamic complex traits (functional mapping), e.g. by characterisation of the underlying quantitative trait loci (QTLs) or nucleotides (QTNs)."],
          "data": {
            "uri": "http://edamontology.org/operation_0282"
          },
          "definition": "Generate a genetic (linkage) map of a DNA sequence (typically a chromosome) showing the relative positions of genetic markers based on estimation of non-physical distances.",
          "exact_synonyms": ["Genetic cartography", "Genetic map construction", "Functional mapping", "Genetic map generation", "Linkage mapping"],
          "has_output": ["http://edamontology.org/data_1278"],
          "narrow_synonyms": ["QTL mapping"],
          "text": "Genetic mapping"
        }, {
          "comment": ["Sequence tag mapping assigns experimentally obtained sequence tags to known transcripts or annotate potential virtual sequence tags in a genome."],
          "data": {
            "uri": "http://edamontology.org/operation_0527"
          },
          "definition": "Make sequence tag to gene assignments (tag mapping) of SAGE, MPSS and SBS data.",
          "exact_synonyms": ["Tag to gene assignment"],
          "text": "Sequence tag mapping"
        }],
        "data": {
          "uri": "http://edamontology.org/operation_2520"
        },
        "definition": "Generate a map of a DNA sequence annotated with positional or non-positional features of some type.",
        "has_output": ["http://edamontology.org/data_1274"],
        "has_topic": ["http://edamontology.org/topic_0102", "http://edamontology.org/topic_0196"],
        "text": "DNA mapping"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_3561"
        },
        "definition": "Compare the models or schemas used by two or more databases, or any other general comparison of databases rather than a detailed comparison of the entries themselves.",
        "narrow_synonyms": ["Data model comparison", "Schema comparison"],
        "text": "Database comparison"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_0533"
        },
        "definition": "Map an expression profile to known biological pathways, for example, to identify or reconstruct a pathway.",
        "exact_synonyms": ["Pathway mapping"],
        "has_output": ["http://edamontology.org/data_2984"],
        "narrow_synonyms": ["Gene-to-pathway mapping", "Gene expression profile pathway mapping", "Gene to pathway mapping"],
        "text": "Expression profile pathway mapping"
      }, {
        "comment": ["An adhesin is a cell-surface component that facilitate the adherence of a microorganism to a cell or surface. They are important virulence factors during establishment of infection and thus are targetted during vaccine development approaches that seek to block adhesin function and prevent adherence to host cell."],
        "data": {
          "uri": "http://edamontology.org/operation_3968"
        },
        "definition": "Predict adhesins in protein sequences.",
        "has_topic": ["http://edamontology.org/topic_0804"],
        "text": "Adhesin prediction"
      }],
      "data": {
        "uri": "http://edamontology.org/operation_2429"
      },
      "definition": "Map properties to positions on an biological entity (typically a molecular sequence or structure), or assemble such an entity from constituent parts.",
      "exact_synonyms": ["Cartography"],
      "text": "Mapping"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/operation_0558"
        },
        "definition": "Annotate a phylogenetic tree with terms from a controlled vocabulary.",
        "text": "Phylogenetic tree annotation"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_3778"
        },
        "definition": "Text annotation is the operation of adding notes, data and metadata, recognised entities and concepts, and their relations to a text (such as a scientific article).",
        "has_input": ["http://edamontology.org/data_3671"],
        "has_output": ["http://edamontology.org/data_3779"],
        "has_topic": ["http://edamontology.org/topic_3068"],
        "narrow_synonyms": ["Article annotation", "Literature annotation"],
        "text": "Text annotation"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_3553"
        },
        "definition": "Annotate an image of some sort, typically with terms from a controlled vocabulary.",
        "text": "Image annotation"
      }, {
        "comment": ["Sequence tag mapping assigns experimentally obtained sequence tags to known transcripts or annotate potential virtual sequence tags in a genome."],
        "data": {
          "uri": "http://edamontology.org/operation_0527"
        },
        "definition": "Make sequence tag to gene assignments (tag mapping) of SAGE, MPSS and SBS data.",
        "exact_synonyms": ["Tag to gene assignment"],
        "text": "Sequence tag mapping"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/operation_3661"
          },
          "definition": "Predict the effect or function of an individual single nucleotide polymorphism (SNP).",
          "text": "SNP annotation"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0362"
          },
          "definition": "Annotate a genome sequence with terms from a controlled vocabulary.",
          "narrow_synonyms": ["Structural genome annotation", "Metagenome annotation", "Functional genome annotation"],
          "text": "Genome annotation"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3672"
          },
          "definition": "Annotate one or more sequences with functional information, such as cellular processes or metaobolic pathways, by reference to a controlled vocabulary - invariably the Gene Ontology (GO).",
          "exact_synonyms": ["Sequence functional annotation"],
          "text": "Gene functional annotation"
        }],
        "data": {
          "uri": "http://edamontology.org/operation_0361"
        },
        "definition": "Annotate a molecular sequence record with terms from a controlled vocabulary.",
        "has_input": ["http://edamontology.org/data_0849"],
        "has_output": ["http://edamontology.org/data_0849"],
        "text": "Sequence annotation"
      }],
      "comment": ["This is a broad concept and is used a placeholder for other, more specific concepts."],
      "data": {
        "uri": "http://edamontology.org/operation_0226"
      },
      "definition": "Annotate an entity (typically a biological or biomedical database entity) with terms from a controlled vocabulary.",
      "has_input": ["http://edamontology.org/data_0582"],
      "has_topic": ["http://edamontology.org/topic_0089"],
      "text": "Annotation"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/operation_2415"
        },
        "definition": "Analyse, simulate or predict protein folding, typically by processing sequence and / or structural data.  For example, predict sites of nucleation or stabilisation key to protein folding.",
        "exact_synonyms": ["Protein folding modelling"],
        "has_output": ["http://edamontology.org/data_1537"],
        "has_topic": ["http://edamontology.org/topic_0130"],
        "narrow_synonyms": ["Protein folding site prediction", "Protein folding simulation"],
        "text": "Protein folding analysis"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/operation_0481"
          },
          "definition": "Model loop conformation in protein structures.",
          "exact_synonyms": ["Protein modelling (loops)", "Protein loop modelling"],
          "text": "Loop modelling"
        }, {
          "comment": ["This includes rotamer likelihood prediction: the prediction of rotamer likelihoods for all 20 amino acid types at each position in a protein structure, where output typically includes, for each residue position, the likelihoods for the 20 amino acid types with estimated reliability of the 20 likelihoods.", "Methods might use a residue rotamer library.", "Antibody optimisation is to optimize the antibody-interacting surface of the antigen (epitope).  Antigen optimisation is to optimize the antigen-interacting surface of the antibody (paratope). Antigen resurfacing is to resurface the antigen by varying the sequence of non-epitope regions."],
          "data": {
            "uri": "http://edamontology.org/operation_0480"
          },
          "definition": "Model, analyse or edit amino acid side chain conformation in protein structure, optimize side-chain packing, hydrogen bonding etc.",
          "exact_synonyms": ["Protein modelling (side chains)"],
          "narrow_synonyms": ["Antigen resurfacing", "Antibody optimisation", "Rotamer likelihood prediction", "Antigen optimisation"],
          "text": "Side chain modelling"
        }, {
          "comment": ["Methods might require a preliminary C(alpha) trace.", "Scaffold selection, scaffold search, epitope grafting and design optimization are stages of backbone modelling done during rational vaccine design."],
          "data": {
            "uri": "http://edamontology.org/operation_0479"
          },
          "definition": "Model protein backbone conformation.",
          "exact_synonyms": ["Protein modelling (backbone)"],
          "narrow_synonyms": ["Epitope grafting", "Scaffold selection", "Scaffold search", "Design optimization"],
          "text": "Backbone modelling"
        }],
        "comment": ["The model might be of a whole, part or aspect of protein structure. Molecular modelling methods might use sequence-structure alignment, structural templates, molecular dynamics, energy minimisation etc."],
        "data": {
          "uri": "http://edamontology.org/operation_0477"
        },
        "definition": "Build a three-dimensional protein model based on known (for example homologs) structures.",
        "exact_synonyms": ["Comparative modelling", "Homology modelling", "Protein structure comparative modelling", "Homology structure modelling"],
        "has_topic": ["http://edamontology.org/topic_2275"],
        "text": "Protein modelling"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_3946"
        },
        "definition": "The development and use of mathematical models and systems analysis for the description of ecological processes, and applications such as the sustainable management of resources.",
        "has_output": ["http://edamontology.org/data_1439"],
        "has_topic": ["http://edamontology.org/topic_0084"],
        "text": "Ecological modelling"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_3893"
        },
        "definition": "Obtain force field parameters (charge, bonds, dihedrals, etc.) from a molecule, to be used in molecular simulations",
        "exact_synonyms": ["Molecule parameterization", "Ligand parameterization"],
        "has_output": ["http://edamontology.org/data_1439"],
        "has_topic": ["http://edamontology.org/topic_0084"],
        "text": "Forcefield parameterisation"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_0550"
        },
        "definition": "Identify a plausible model of DNA substitution that explains a molecular (DNA or protein) sequence alignment.",
        "exact_synonyms": ["Nucleotide substitution modelling"],
        "has_output": ["http://edamontology.org/data_1439"],
        "has_topic": ["http://edamontology.org/topic_0084"],
        "text": "DNA substitution modelling"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_3566"
        },
        "definition": "Simulate gene expression data, e.g. for purposes of benchmarking.",
        "text": "Simulated gene expression data generation"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_0279"
        },
        "definition": "Analyse some aspect of RNA/DNA folding, typically by processing sequence and/or structural data.  For example, compute folding energies such as minimum folding energies for DNA or RNA sequences or energy landscape of RNA mutants.",
        "exact_synonyms": ["Nucleic acid folding", "Nucleic acid folding modelling", "Nucleic acid folding prediction"],
        "has_output": ["http://edamontology.org/data_1596"],
        "narrow_synonyms": ["Nucleic acid folding energy calculation"],
        "text": "Nucleic acid folding analysis"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_2476"
        },
        "definition": "The simulation of molecular (typically protein) conformation using a computational model of physical forces and computer simulation.",
        "exact_synonyms": ["Molecular dynamics simulation"],
        "has_output": ["http://edamontology.org/data_0883"],
        "has_topic": ["http://edamontology.org/topic_0176", "http://edamontology.org/topic_0082"],
        "narrow_synonyms": ["Protein dynamics"],
        "text": "Molecular dynamics"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/operation_0264"
          },
          "definition": "Predict splicing alternatives or transcript isoforms from analysis of sequence data.",
          "exact_synonyms": ["Splice transcript prediction", "Alternative splicing detection", "Differential splicing analysis", "Alternative splicing analysis"],
          "has_topic": ["http://edamontology.org/topic_0114"],
          "text": "Alternative splicing prediction"
        }, {
          "comment": ["Methods might require a pre-mRNA or genomic DNA sequence."],
          "data": {
            "uri": "http://edamontology.org/operation_0433"
          },
          "definition": "Identify, predict or analyse splice sites in nucleotide sequences.",
          "exact_synonyms": ["Splice prediction"],
          "has_topic": ["http://edamontology.org/topic_0114"],
          "text": "Splice site prediction"
        }],
        "data": {
          "uri": "http://edamontology.org/operation_2499"
        },
        "definition": "Predict, analyse, characterize or model splice sites, splicing events and so on, typically by comparing multiple nucleic acid sequences.",
        "exact_synonyms": ["Splicing model analysis"],
        "has_topic": ["http://edamontology.org/topic_0114"],
        "text": "Splicing analysis"
      }],
      "data": {
        "uri": "http://edamontology.org/operation_2426"
      },
      "definition": "Model or simulate some biological entity or system, typically using mathematical techniques including  dynamical systems, statistical models, differential equations, and game theoretic models.",
      "has_topic": ["http://edamontology.org/topic_2275"],
      "narrow_synonyms": ["Mathematical modelling"],
      "text": "Modelling and simulation"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/operation_0309"
        },
        "definition": "Predict and/or optimize oligonucleotide probes for DNA microarrays, for example for transcription profiling of genes, or for genomes and gene families.",
        "exact_synonyms": ["Microarray probe prediction"],
        "has_input": ["http://edamontology.org/data_2977"],
        "has_output": ["http://edamontology.org/data_2717"],
        "has_topic": ["http://edamontology.org/topic_0203", "http://edamontology.org/topic_0632"],
        "text": "Microarray probe design"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_4008"
        },
        "definition": "Design new protein molecules with specific structural or functional properties.",
        "narrow_synonyms": ["Rational protein design", "Protein redesign", "de novo protein design"],
        "text": "Protein design"
      }, {
        "children": [{
          "comment": ["Virtual screening is widely used for lead identification, lead optimization, and scaffold hopping during drug design and discovery."],
          "data": {
            "uri": "http://edamontology.org/operation_3938"
          },
          "definition": "Virtual screening is used in drug discovery to identify potential drug compounds.  It involves searching libraries of small molecules in order to identify those molecules which are most likely to bind to a drug target (typically a protein receptor or enzyme).",
          "has_output": ["http://edamontology.org/data_1461"],
          "has_topic": ["http://edamontology.org/topic_0128"],
          "narrow_synonyms": ["Structured-based virtual screening", "Ligand-based screening", "Virtual ligand screening", "Ligand-based virtual screening", "Structure-based screening"],
          "text": "Virtual screening"
        }],
        "comment": ["Small molecule design can involve assessment of target druggability and flexibility, molecular docking, in silico fragment screening, molecular dynamics, and homology modeling.", "There are two broad categories of small molecule design techniques when applied to the design of drugs: ligand-based drug design (e.g. ligand similarity) and structure-based drug design (ligand docking) methods. Ligand similarity methods exploit structural similarities to known active ligands, whereas ligand docking methods use the 3D structure of a target protein to predict the binding modes and affinities of ligands to it."],
        "data": {
          "uri": "http://edamontology.org/operation_4009"
        },
        "definition": "The design of small molecules with specific biological activity, such as inhibitors or modulators for proteins that are of therapeutic interest.  This can involve the modification of individual atoms, the addition or removal of molecular fragments, and the use reaction-based design to explore tractable synthesis options for the small molecule.",
        "narrow_synonyms": ["Structure-based small molecule design", "Structure-based drug design", "Ligand-based drug design", "Drug design"],
        "text": "Small molecule design"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/operation_3795"
          },
          "definition": "A technique whereby molecules with desired properties and function are isolated from libraries of random molecules, through iterative cycles of selection, amplification, and mutagenesis.",
          "text": "In vitro selection"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_0309"
            },
            "definition": "Predict and/or optimize oligonucleotide probes for DNA microarrays, for example for transcription profiling of genes, or for genomes and gene families.",
            "exact_synonyms": ["Microarray probe prediction"],
            "has_input": ["http://edamontology.org/data_2977"],
            "has_output": ["http://edamontology.org/data_2717"],
            "has_topic": ["http://edamontology.org/topic_0203", "http://edamontology.org/topic_0632"],
            "text": "Microarray probe design"
          }, {
            "comment": ["This includes predicting primers based on gene structure, promoters, exon-exon junctions, predicting primers that are conserved across multiple genomes or species, primers for for gene transcription profiling,  for genotyping polymorphisms, for example single nucleotide polymorphisms (SNPs),  for large scale sequencing, or for methylation PCRs.", "Primer design involves predicting or selecting primers that are specific to a provided PCR template. Primers can be designed with certain properties such as size of product desired, primer size etc. The output might be a minimal or overlapping primer set."],
            "data": {
              "uri": "http://edamontology.org/operation_0308"
            },
            "definition": "Design or predict oligonucleotide primers for PCR and DNA amplification etc.",
            "exact_synonyms": ["PCR primer prediction", "Primer design"],
            "has_input": ["http://edamontology.org/data_2977"],
            "has_output": ["http://edamontology.org/data_1240"],
            "has_topic": ["http://edamontology.org/topic_0632"],
            "narrow_synonyms": ["PCR primer design (for gene transcription profiling)", "PCR primer design (for methylation PCRs)", "PCR primer design (for large scale sequencing)", "PCR primer design (for conserved primers)", "PCR primer design (for genotyping polymorphisms)", "Primer quality estimation", "PCR primer design (based on gene structure)"],
            "text": "PCR primer design"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_2419"
          },
          "definition": "Predict oligonucleotide primers or probes.",
          "exact_synonyms": ["Primer and probe prediction"],
          "has_topic": ["http://edamontology.org/topic_0632"],
          "text": "Primer and probe design"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0483"
          },
          "definition": "Predict or optimise RNA sequences (sequence pools) with likely secondary and tertiary structure for in vitro selection.",
          "exact_synonyms": ["Structured RNA prediction and optimisation", "Nucleic acid folding family identification"],
          "has_output": ["http://edamontology.org/data_1234"],
          "text": "RNA inverse folding"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0560"
          },
          "definition": "Predict or optimise DNA to elicit (via DNA vaccination) an immunological response.",
          "has_topic": ["http://edamontology.org/topic_0804"],
          "text": "DNA vaccine design"
        }],
        "data": {
          "uri": "http://edamontology.org/operation_3095"
        },
        "definition": "Design (or predict) nucleic acid sequences with specific chemical or physical properties.",
        "narrow_synonyms": ["Gene design"],
        "text": "Nucleic acid design"
      }],
      "data": {
        "uri": "http://edamontology.org/operation_2430"
      },
      "definition": "Design a biological entity (typically a molecular sequence or structure) with specific properties.",
      "text": "Design"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/operation_3633"
        },
        "definition": "Prediction of retention time in a mass spectrometry experiment based on compositional and structural properties of the separated species.",
        "exact_synonyms": ["Retention time calculation"],
        "text": "Retention time prediction"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/operation_3936"
          },
          "definition": "A dimensionality reduction process that selects a subset of relevant features (variables, predictors) for use in model construction.",
          "exact_synonyms": ["Attribute selection", "Variable subset selection", "Variable selection"],
          "has_input": ["http://edamontology.org/data_0943"],
          "has_topic": ["http://edamontology.org/topic_0121"],
          "text": "Feature selection"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3937"
          },
          "definition": "A dimensionality reduction process which builds (ideally) informative and non-redundant values (features) from an initial set of measured data, to aid subsequent generalization, learning or interpretation.",
          "exact_synonyms": ["Feature projection"],
          "has_input": ["http://edamontology.org/data_0943"],
          "has_topic": ["http://edamontology.org/topic_0121"],
          "text": "Feature extraction"
        }],
        "data": {
          "uri": "http://edamontology.org/operation_3935"
        },
        "definition": "A process used in statistics, machine learning, and information theory that reduces the number of random variables by obtaining a set of principal variables.",
        "exact_synonyms": ["Dimension reduction"],
        "has_input": ["http://edamontology.org/data_0943"],
        "has_topic": ["http://edamontology.org/topic_0121"],
        "text": "Dimensionality reduction"
      }, {
        "children": [{
          "children": [{
            "comment": ["A stitch profile represents the alternative conformations that partly melted DNA can adopt in a temperature range."],
            "data": {
              "uri": "http://edamontology.org/operation_0457"
            },
            "definition": "Calculate and plot a DNA or DNA/RNA stitch profile.",
            "text": "Nucleic acid stitch profile plotting"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0459"
            },
            "definition": "Calculate and plot a DNA or DNA/RNA probability profile.",
            "text": "Nucleic acid probability profile plotting"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0458"
            },
            "definition": "Calculate and plot a DNA or DNA/RNA melting curve.",
            "text": "Nucleic acid melting curve plotting"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0460"
            },
            "definition": "Calculate and plot a DNA or DNA/RNA temperature profile.",
            "text": "Nucleic acid temperature profile plotting"
          }],
          "comment": ["A melting profile is used to visualise and analyse partly melted DNA conformations."],
          "data": {
            "uri": "http://edamontology.org/operation_0456"
          },
          "definition": "Calculate and plot a DNA or DNA/RNA melting profile.",
          "has_output": ["http://edamontology.org/data_1583"],
          "text": "Nucleic acid melting profile plotting"
        }, {
          "comment": ["This includes properties such as."],
          "data": {
            "uri": "http://edamontology.org/operation_0461"
          },
          "definition": "Calculate curvature and flexibility / stiffness of a nucleotide sequence.",
          "has_output": ["http://edamontology.org/data_0912"],
          "text": "Nucleic acid curvature calculation"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0455"
          },
          "definition": "Calculate a thermodynamic property of DNA or DNA/RNA, such as melting temperature, enthalpy and entropy.",
          "has_output": ["http://edamontology.org/data_2985"],
          "text": "Nucleic acid thermodynamic property calculation"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0365"
          },
          "definition": "Generate digest fragments for a nucleotide sequence containing restriction sites.",
          "exact_synonyms": ["Nucleic acid restriction digest"],
          "has_output": ["http://edamontology.org/data_1239"],
          "text": "Restriction digest"
        }],
        "data": {
          "uri": "http://edamontology.org/operation_0262"
        },
        "definition": "Calculate or predict physical or chemical properties of nucleic acid molecules, including any non-positional properties of the molecular sequence.",
        "has_output": ["http://edamontology.org/data_0912"],
        "text": "Nucleic acid property calculation"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/operation_0234"
          },
          "definition": "Calculate sequence complexity, for example to find low-complexity regions in sequences.",
          "has_output": ["http://edamontology.org/data_1259"],
          "has_topic": ["http://edamontology.org/topic_0157"],
          "text": "Sequence complexity calculation"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0380"
          },
          "definition": "Analyse repeat sequence organisation such as periodicity.",
          "text": "Repeat sequence organisation analysis"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0235"
          },
          "definition": "Calculate sequence ambiguity, for example identity regions in protein or nucleotide sequences with many ambiguity codes.",
          "has_output": ["http://edamontology.org/data_1260"],
          "has_topic": ["http://edamontology.org/topic_0157"],
          "text": "Sequence ambiguity calculation"
        }, {
          "comment": ["k-mer counting is used in genome and transcriptome assembly, metagenomic sequencing, and for error correction of sequence reads."],
          "data": {
            "uri": "http://edamontology.org/operation_3472"
          },
          "definition": "Count k-mers (substrings of length k) in DNA sequence data.",
          "text": "k-mer counting"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_2284"
          },
          "definition": "Calculate a density plot (of base composition) for a nucleotide sequence.",
          "text": "Nucleic acid density plotting"
        }],
        "data": {
          "uri": "http://edamontology.org/operation_0236"
        },
        "definition": "Calculate character or word composition or frequency of a molecular sequence.",
        "has_output": ["http://edamontology.org/data_1261"],
        "has_topic": ["http://edamontology.org/topic_0157"],
        "text": "Sequence composition calculation"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_3632"
        },
        "definition": "Calculate the isotope distribution of a given chemical species.",
        "has_input": ["http://edamontology.org/data_0943"],
        "has_topic": ["http://edamontology.org/topic_0121"],
        "text": "Isotopic distributions calculation"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/operation_3664"
          },
          "definition": "Construction of a statistical model, or a set of assumptions around some observed data, usually by describing a set of probability distributions which approximate the distribution of data.",
          "text": "Statistical modelling"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3960"
          },
          "definition": "A statistical procedure that uses an orthogonal transformation to convert a set of observations of possibly correlated variables into a set of values of linearly uncorrelated variables called principal components.",
          "text": "Principal component analysis"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3557"
          },
          "definition": "Replace missing data with substituted values, usually by using some statistical or other mathematical approach.",
          "exact_synonyms": ["Data imputation"],
          "text": "Imputation"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3659"
          },
          "definition": "A statistical calculation to estimate the relationships among variables.",
          "narrow_synonyms": ["Regression"],
          "text": "Regression analysis"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3658"
          },
          "definition": "Analyse data in order to deduce properties of an underlying distribution or population.",
          "narrow_synonyms": ["Empirical Bayes"],
          "text": "Statistical inference"
        }, {
          "comment": ["In the simplest normalisation means adjusting values measured on different scales to a common scale (often between 0.0 and 1.0), but can refer to more sophisticated adjustment whereby entire probability distributions of adjusted values are brought into alignment. Standardisation typically refers to an operation whereby a range of values are standardised to measure how many standard deviations a value is from its mean."],
          "data": {
            "uri": "http://edamontology.org/operation_3435"
          },
          "definition": "Standardize or normalize data by some statistical method.",
          "narrow_synonyms": ["Normalisation", "Standardisation"],
          "text": "Standardisation and normalisation"
        }],
        "data": {
          "uri": "http://edamontology.org/operation_2238"
        },
        "definition": "Perform a statistical data operation of some type, e.g. calibration or validation.",
        "exact_synonyms": ["Statistical testing", "Statistical test", "Significance testing", "Statistical analysis"],
        "narrow_synonyms": ["Gibbs sampling", "Expectation maximisation", "Hypothesis testing", "Omnibus test"],
        "text": "Statistical calculation"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_3797"
        },
        "definition": "The calculation of species richness for a number of individual samples, based on plots of the number of species as a function of the number of samples (rarefaction curves).",
        "exact_synonyms": ["Species richness assessment"],
        "text": "Rarefaction"
      }, {
        "children": [{
          "comment": ["This includes methods that generate a graphical rendering of antigenicity of a protein, such as a Hopp and Woods plot.", "This is usually done in the development of peptide-specific antibodies or multi-epitope vaccines. Methods might use sequence data (for example motifs) and / or structural data.", "Immunological system are cellular or humoral. In vaccine design to induces a cellular immune response, methods must search for antigens that can be recognized by the major histocompatibility complex (MHC) molecules present in T lymphocytes.  If a humoral response is required, antigens for B cells must be identified."],
          "data": {
            "uri": "http://edamontology.org/operation_0252"
          },
          "definition": "Predict antigenicity, allergenicity / immunogenicity, allergic cross-reactivity etc of peptides and proteins.",
          "exact_synonyms": ["Antigenicity prediction", "Immunogenicity prediction"],
          "has_output": ["http://edamontology.org/data_1534"],
          "has_topic": ["http://edamontology.org/topic_0804"],
          "narrow_synonyms": ["Hopp and Woods plotting", "MHC peptide immunogenicity prediction", "B cell peptide immunogenicity prediction"],
          "text": "Peptide immunogenicity prediction"
        }, {
          "children": [{
            "comment": ["Principal Component Analysis (PCA) is a multivariate statistical analysis to obtain collective variables and reduce the dimensionality of the system."],
            "data": {
              "uri": "http://edamontology.org/operation_3891"
            },
            "definition": "Compute Essential Dynamics (ED) on a simulation trajectory: an analysis of molecule dynamics using PCA (Principal Component Analysis) applied to the atomic positional fluctuations.",
            "exact_synonyms": ["Principal modes", "ED", "PCA"],
            "text": "Essential dynamics"
          }],
          "comment": ["Use this concept for analysis of flexible and rigid residues, local chain deformability, regions undergoing conformational change, molecular vibrations or fluctuational dynamics, domain motions or other large-scale structural transitions in a protein structure."],
          "data": {
            "uri": "http://edamontology.org/operation_0244"
          },
          "definition": "Analyse flexibility and motion in protein structure.",
          "exact_synonyms": ["Trajectory analysis", "CG analysis", "Protein Dynamics Analysis", "MD analysis"],
          "narrow_synonyms": ["Protein motion prediction", "Protein flexibility prediction", "Protein flexibility and motion analysis", "Nucleic Acid Dynamics Analysis"],
          "text": "Simulation analysis"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_2929"
            },
            "definition": "Calculate the molecular weight of a protein (or fragments) and compare it to another protein or reference data. Generally used for protein identification.",
            "exact_synonyms": ["Peptide mass fingerprinting", "PMF", "Protein fingerprinting"],
            "text": "Protein fragment weight comparison"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_0398"
          },
          "definition": "Calculate the molecular weight of a protein sequence or fragments.",
          "exact_synonyms": ["Peptide mass calculation"],
          "has_output": ["http://edamontology.org/data_1519"],
          "has_topic": ["http://edamontology.org/topic_0121"],
          "text": "Protein molecular weight calculation"
        }, {
          "comment": ["Methods usually involve multiple sequence alignment analysis."],
          "data": {
            "uri": "http://edamontology.org/operation_0272"
          },
          "definition": "Predict contacts, non-covalent interactions and distance (constraints) between amino acids in protein sequences.",
          "exact_synonyms": ["Residue interaction prediction"],
          "has_topic": ["http://edamontology.org/topic_0130"],
          "narrow_synonyms": ["Contact map prediction", "Protein contact map prediction"],
          "text": "Residue contact prediction"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0386"
          },
          "definition": "Calculate whether a protein structure has an unusually large net charge (dipole moment).",
          "has_output": ["http://edamontology.org/data_1545"],
          "text": "Protein dipole moment calculation"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0334"
          },
          "definition": "Calculate Km, Vmax and derived data for an enzyme reaction.",
          "has_output": ["http://edamontology.org/data_2024"],
          "has_topic": ["http://edamontology.org/topic_0821"],
          "text": "Enzyme kinetics calculation"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_0396"
            },
            "definition": "Calculate a Ramachandran plot of a protein structure.",
            "has_output": ["http://edamontology.org/data_1544"],
            "text": "Ramachandran plot calculation"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_0249"
          },
          "definition": "Calculate, visualise or analyse phi/psi angles of a protein structure.",
          "has_output": ["http://edamontology.org/data_2991"],
          "narrow_synonyms": ["Backbone torsion angle calculation", "Tau angle calculation", "Cysteine torsion angle calculation", "Torsion angle calculation"],
          "text": "Protein geometry calculation"
        }, {
          "comment": ["A 3D-1D scoring matrix scores the probability of amino acids occurring in different structural environments."],
          "data": {
            "uri": "http://edamontology.org/operation_2239"
          },
          "definition": "Calculate a 3D-1D scoring matrix from analysis of protein sequence and structural data.",
          "exact_synonyms": ["3D-1D scoring matrix construction"],
          "has_output": ["http://edamontology.org/data_1499"],
          "has_topic": ["http://edamontology.org/topic_0081"],
          "text": "3D-1D scoring matrix generation"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3860"
          },
          "definition": "Calculate a theoretical mass spectrometry spectra for given sequences.",
          "exact_synonyms": ["Spectrum prediction"],
          "has_input": ["http://edamontology.org/data_0943"],
          "text": "Spectrum calculation"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_0409"
            },
            "definition": "Predict the solubility or atomic solvation energy of a protein sequence.",
            "has_output": ["http://edamontology.org/data_1524"],
            "text": "Protein solubility prediction"
          }, {
            "comment": ["Hydrophobic moment is a peptides hydrophobicity measured for different angles of rotation."],
            "data": {
              "uri": "http://edamontology.org/operation_0407"
            },
            "definition": "Calculate the hydrophobic moment of a peptide sequence and recognize amphiphilicity.",
            "has_output": ["http://edamontology.org/data_1520"],
            "text": "Protein hydrophobic moment plotting"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0408"
            },
            "definition": "Predict the stability or globularity of a protein sequence, whether it is intrinsically unfolded etc.",
            "has_output": ["http://edamontology.org/data_1526"],
            "text": "Protein globularity prediction"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0406"
            },
            "definition": "Calculate aliphatic index (relative volume occupied by aliphatic side chains) of a protein.",
            "has_output": ["http://edamontology.org/data_1521"],
            "text": "Protein aliphatic index calculation"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0410"
            },
            "definition": "Predict crystallizability of a protein sequence.",
            "has_output": ["http://edamontology.org/data_1525"],
            "text": "Protein crystallizability prediction"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0405"
            },
            "definition": "Calculate hydrophobic or hydrophilic / charged regions of a protein sequence.",
            "text": "Protein hydrophobic region calculation"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_2574"
          },
          "definition": "Analyse the hydrophobic, hydrophilic or charge properties of a protein (from analysis of sequence or structural information).",
          "has_output": ["http://edamontology.org/data_2970"],
          "has_topic": ["http://edamontology.org/topic_0123"],
          "text": "Protein hydropathy calculation"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_0402"
            },
            "definition": "Plot a protein titration curve.",
            "has_output": ["http://edamontology.org/data_1527"],
            "text": "Protein titration curve plotting"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0403"
            },
            "definition": "Calculate isoelectric point of a protein sequence.",
            "has_output": ["http://edamontology.org/data_1528"],
            "text": "Protein isoelectric point calculation"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0404"
            },
            "definition": "Estimate hydrogen exchange rate of a protein sequence.",
            "has_output": ["http://edamontology.org/data_1530"],
            "text": "Protein hydrogen exchange rate calculation"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_0400"
          },
          "definition": "Calculate pH-dependent properties from pKa calculations of a protein sequence.",
          "exact_synonyms": ["Protein pH-dependent property calculation"],
          "has_output": ["http://edamontology.org/data_0897"],
          "has_topic": ["http://edamontology.org/topic_0123"],
          "text": "Protein pKa calculation"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0399"
          },
          "definition": "Predict extinction coefficients or optical density of a protein sequence.",
          "has_output": ["http://edamontology.org/data_1531"],
          "text": "Protein extinction coefficient calculation"
        }, {
          "children": [{
            "comment": ["Salt bridges are interactions between oppositely charged atoms in different residues. The output might include the inter-atomic distance."],
            "data": {
              "uri": "http://edamontology.org/operation_1839"
            },
            "definition": "Calculate (and possibly score) salt bridges in a protein structure.",
            "text": "Salt bridge calculation"
          }, {
            "comment": ["The output might include the atoms involved in the bond, bond geometric parameters and bond enthalpy."],
            "data": {
              "uri": "http://edamontology.org/operation_0394"
            },
            "definition": "Identify potential hydrogen bonds between amino acids and other groups.",
            "has_output": ["http://edamontology.org/data_1549"],
            "text": "Hydrogen bond calculation"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_1834"
            },
            "definition": "Calculate protein residue contacts with metal in a structure.",
            "exact_synonyms": ["Residue-metal contact calculation"],
            "text": "Protein-metal contact calculation"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_1831"
            },
            "definition": "Detect cysteines that are bound to metal in a protein structure.",
            "text": "Metal-bound cysteine detection"
          }, {
            "children": [{
              "comment": ["This includes for example clusters of hydrophobic or charged residues, or clusters of contacting residues which have a key structural or functional role."],
              "data": {
                "uri": "http://edamontology.org/operation_0393"
              },
              "definition": "Calculate clusters of contacting residues in protein structures.",
              "has_output": ["http://edamontology.org/data_1548"],
              "text": "Residue cluster calculation"
            }, {
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/operation_0392"
                },
                "definition": "Calculate a residue contact map (typically all-versus-all inter-residue contacts) for a protein structure.",
                "exact_synonyms": ["Protein contact map calculation"],
                "has_output": ["http://edamontology.org/data_1547"],
                "text": "Contact map calculation"
              }],
              "data": {
                "uri": "http://edamontology.org/operation_0391"
              },
              "definition": "Calculate a matrix of distance between residues (for example the C-alpha atoms) in a protein structure.",
              "has_output": ["http://edamontology.org/data_1546"],
              "text": "Protein distance matrix calculation"
            }],
            "comment": ["This includes identifying HET groups, which usually correspond to ligands, lipids, but might also (not consistently) include groups that are attached to amino acids. Each HET group is supposed to have a unique three letter code and a unique name which might be given in the output.  It can also include calculation of symmetry contacts, i.e. a contact between two atoms in different asymmetric unit."],
            "data": {
              "uri": "http://edamontology.org/operation_2950"
            },
            "definition": "Calculate contacts between residues, or between residues and other groups, in a protein structure, on the basis of distance calculations.",
            "narrow_synonyms": ["HET group detection", "Residue contact calculation (residue-nucleic acid)", "Residue contact calculation (residue-metal)", "Residue contact calculation (residue-negative ion)", "WHATIF:SymmetryContact", "Residue contact calculation (residue-ligand)"],
            "text": "Residue distance calculation"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_0248"
          },
          "definition": "Calculate or extract inter-atomic, inter-residue or residue-atom contacts, distances and interactions in protein structure(s).",
          "has_topic": ["http://edamontology.org/topic_0130"],
          "text": "Residue interaction calculation"
        }],
        "comment": ["This includes methods to render and visualise the properties of a protein sequence, and a residue-level search for properties such as solvent accessibility, hydropathy, secondary structure, ligand-binding etc."],
        "data": {
          "uri": "http://edamontology.org/operation_0250"
        },
        "definition": "Extract, calculate or predict non-positional (physical or chemical) properties of a protein, including any non-positional properties of the molecular sequence, from processing a protein sequence or 3D structure.",
        "exact_synonyms": ["Protein property rendering"],
        "narrow_synonyms": ["Protein property calculation (from sequence)", "Protein structural property calculation", "Structural property calculation", "Protein property calculation (from structure)"],
        "text": "Protein property calculation"
      }],
      "data": {
        "uri": "http://edamontology.org/operation_3438"
      },
      "definition": "Mathematical determination of the value of something, typically a properly of a  molecule.",
      "text": "Calculation"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/operation_0284"
        },
        "definition": "Calculate codon usage statistics and create a codon usage table.",
        "exact_synonyms": ["Codon usage table construction"],
        "has_output": ["http://edamontology.org/data_1597"],
        "text": "Codon usage table generation"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_0297"
        },
        "definition": "Generate some type of structural (3D) profile or template from a structure or structure alignment.",
        "exact_synonyms": ["Structural profile construction", "Structural profile generation"],
        "has_input": ["http://edamontology.org/data_0886", "http://edamontology.org/data_0883"],
        "has_output": ["http://edamontology.org/data_0889"],
        "text": "3D profile generation"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/operation_3481"
          },
          "definition": "Generate sequences from some probabilistic model, e.g. a model that simulates evolution.",
          "text": "Probabilistic sequence generation"
        }],
        "data": {
          "uri": "http://edamontology.org/operation_3480"
        },
        "definition": "Generate some data from a choosen probibalistic model, possibly to evaluate algorithms.",
        "text": "Probabilistic data generation"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_0502"
        },
        "definition": "Align RNA secondary structures.",
        "exact_synonyms": ["RNA secondary structure alignment construction", "RNA secondary structure alignment generation", "Secondary structure alignment (RNA)"],
        "has_input": ["http://edamontology.org/data_0880"],
        "has_output": ["http://edamontology.org/data_0881"],
        "text": "RNA secondary structure alignment"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_3348"
        },
        "definition": "Generate a checksum of a molecular sequence.",
        "has_input": ["http://edamontology.org/data_2044"],
        "has_topic": ["http://edamontology.org/topic_3077"],
        "text": "Sequence checksum generation"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/operation_3185"
          },
          "definition": "Identify base (nucleobase) sequence from a fluorescence 'trace' data generated by an automated DNA sequencer.",
          "exact_synonyms": ["Phred base-calling", "Base calling", "Phred base calling"],
          "has_topic": ["http://edamontology.org/topic_3168"],
          "text": "Base-calling"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0363"
          },
          "definition": "Generate the reverse and / or complement of a nucleotide sequence.",
          "exact_synonyms": ["Reverse and complement", "Reverse / complement", "Nucleic acid sequence reverse and complement"],
          "text": "Reverse complement"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0364"
          },
          "definition": "Generate a random sequence, for example, with a specific character composition.",
          "text": "Random sequence generation"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0366"
          },
          "definition": "Cleave a protein sequence into peptide fragments (corresponding to enzymatic or chemical cleavage).",
          "has_output": ["http://edamontology.org/data_1238"],
          "has_topic": ["http://edamontology.org/topic_0121"],
          "text": "Protein sequence cleavage"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0365"
          },
          "definition": "Generate digest fragments for a nucleotide sequence containing restriction sites.",
          "exact_synonyms": ["Nucleic acid restriction digest"],
          "has_output": ["http://edamontology.org/data_1239"],
          "text": "Restriction digest"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3481"
          },
          "definition": "Generate sequences from some probabilistic model, e.g. a model that simulates evolution.",
          "text": "Probabilistic sequence generation"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3644"
          },
          "definition": "Analytical process that derives a peptide's amino acid sequence from its tandem mass spectrum (MS/MS) without the assistance of a sequence database.",
          "text": "de Novo sequencing"
        }],
        "data": {
          "uri": "http://edamontology.org/operation_0230"
        },
        "definition": "Generate a molecular sequence by some means.",
        "narrow_synonyms": ["Sequence generation (nucleic acid)", "Sequence generation (protein)"],
        "text": "Sequence generation"
      }, {
        "children": [{
          "children": [{
            "comment": ["This includes methods that use an existing alignment."],
            "data": {
              "uri": "http://edamontology.org/operation_0504"
            },
            "definition": "Align (superimpose) more than two molecular tertiary structures.",
            "exact_synonyms": ["Structure alignment (multiple)"],
            "narrow_synonyms": ["Multiple protein structure alignment"],
            "text": "Multiple structure alignment"
          }, {
            "comment": ["Local alignment methods identify regions of local similarity, common substructures etc."],
            "data": {
              "uri": "http://edamontology.org/operation_0509"
            },
            "definition": "Locally align (superimpose) two or more molecular tertiary structures.",
            "exact_synonyms": ["Structure alignment (local)"],
            "narrow_synonyms": ["Local protein structure alignment"],
            "text": "Local structure alignment"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0503"
            },
            "definition": "Align (superimpose) exactly two molecular tertiary structures.",
            "exact_synonyms": ["Structure alignment (pairwise)"],
            "narrow_synonyms": ["Pairwise protein structure alignment"],
            "text": "Pairwise structure alignment"
          }, {
            "comment": ["Global alignment methods identify similarity across the entire structures."],
            "data": {
              "uri": "http://edamontology.org/operation_0510"
            },
            "definition": "Globally align (superimpose) two or more molecular tertiary structures.",
            "exact_synonyms": ["Structure alignment (global)"],
            "narrow_synonyms": ["Global protein structure alignment"],
            "text": "Global structure alignment"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_0295"
          },
          "definition": "Align (superimpose) molecular tertiary structures.",
          "exact_synonyms": ["Structural alignment"],
          "has_output": ["http://edamontology.org/data_0886"],
          "narrow_synonyms": ["3D profile-to-3D profile alignment", "Structural profile alignment", "3D profile alignment"],
          "text": "Structure alignment"
        }, {
          "children": [{
            "comment": ["Use this concept for methods that evaluate sequence-structure compatibility by assessing residue interactions in 3D. Methods might perform one-to-one, one-to-many or many-to-many comparisons."],
            "data": {
              "uri": "http://edamontology.org/operation_0302"
            },
            "definition": "Align molecular sequence to structure in 3D space (threading).",
            "exact_synonyms": ["Sequence-structure alignment"],
            "has_input": ["http://edamontology.org/data_1460"],
            "has_output": ["http://edamontology.org/data_0893"],
            "narrow_synonyms": ["Sequence-3D profile alignment", "Sequence-to-3D-profile alignment"],
            "text": "Protein threading"
          }],
          "comment": ["Methods use some type of mapping between sequence and fold, for example secondary structure prediction and alignment, profile comparison, sequence properties, homologous sequence search, kernel machines etc. Domains and folds might be taken from SCOP or CATH."],
          "data": {
            "uri": "http://edamontology.org/operation_0303"
          },
          "definition": "Recognize (predict and identify) known protein structural domains or folds in protein sequence(s) which (typically) are not accompanied by any significant sequence similarity to know structures.",
          "exact_synonyms": ["Protein fold recognition", "Fold prediction", "Protein domain prediction", "Domain prediction", "Protein fold prediction"],
          "text": "Fold recognition"
        }, {
          "children": [{
            "comment": ["A sequence profile typically represents a sequence alignment. Methods might perform one-to-one, one-to-many or many-to-many comparisons."],
            "data": {
              "uri": "http://edamontology.org/operation_0300"
            },
            "definition": "Align molecular sequence(s) to sequence profile(s), or profiles to other profiles.  A profile typically represents a sequence alignment.",
            "has_input": ["http://edamontology.org/data_1354"],
            "has_topic": ["http://edamontology.org/topic_0160"],
            "narrow_synonyms": ["Profile-profile alignment", "Sequence-to-profile alignment", "Sequence-profile alignment", "Profile-to-profile alignment"],
            "text": "Sequence profile alignment"
          }, {
            "comment": ["This is supposed to give a more biologically meaningful alignment than standard alignments."],
            "data": {
              "uri": "http://edamontology.org/operation_0499"
            },
            "definition": "Align multiple sequences using relative gap costs calculated from neighbors in a supplied phylogenetic tree.",
            "exact_synonyms": ["Multiple sequence alignment construction (phylogenetic tree-based)", "Multiple sequence alignment (phylogenetic tree-based)", "Phylogenetic tree-based multiple sequence alignment construction", "Sequence alignment (phylogenetic tree-based)", "Sequence alignment generation (phylogenetic tree-based)"],
            "has_topic": ["http://edamontology.org/topic_0084"],
            "text": "Tree-based sequence alignment"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0294"
            },
            "definition": "Align molecular sequences using sequence and structural information.",
            "exact_synonyms": ["Sequence alignment (structure-based)"],
            "text": "Structure-based sequence alignment"
          }, {
            "comment": ["Methods might perform one-to-one, one-to-many or many-to-many comparisons."],
            "data": {
              "uri": "http://edamontology.org/operation_0491"
            },
            "definition": "Align exactly two molecular sequences.",
            "exact_synonyms": ["Pairwise alignment"],
            "has_output": ["http://edamontology.org/data_1381"],
            "text": "Pairwise sequence alignment"
          }, {
            "comment": ["This includes methods that use an existing alignment, for example to incorporate sequences into an alignment, or combine several multiple alignments into a single, improved alignment."],
            "data": {
              "uri": "http://edamontology.org/operation_0492"
            },
            "definition": "Align more than two molecular sequences.",
            "exact_synonyms": ["Multiple alignment"],
            "text": "Multiple sequence alignment"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3182"
            },
            "definition": "Align two or more (tpyically huge) molecular sequences that represent genomes.",
            "exact_synonyms": ["Whole genome alignment", "Genome alignment construction"],
            "text": "Genome alignment"
          }, {
            "comment": ["Local alignment methods identify regions of local similarity."],
            "data": {
              "uri": "http://edamontology.org/operation_0495"
            },
            "definition": "Locally align two or more molecular sequences.",
            "exact_synonyms": ["Local sequence alignment", "Sequence alignment (local)"],
            "narrow_synonyms": ["Smith-Waterman"],
            "text": "Local alignment"
          }, {
            "comment": ["Global alignment methods identify similarity across the entire length of the sequences."],
            "data": {
              "uri": "http://edamontology.org/operation_0496"
            },
            "definition": "Globally align two or more molecular sequences.",
            "exact_synonyms": ["Global sequence alignment", "Sequence alignment (global)"],
            "text": "Global alignment"
          }],
          "comment": ["See also \"Read mapping\""],
          "data": {
            "uri": "http://edamontology.org/operation_0292"
          },
          "definition": "Align (identify equivalent sites within) molecular sequences.",
          "exact_synonyms": ["Sequence alignment construction", "Sequence alignment generation"],
          "has_output": ["http://edamontology.org/data_0863"],
          "narrow_synonyms": ["Consensus-based sequence alignment", "Constrained sequence alignment", "Sequence alignment (constrained)", "Multiple sequence alignment (constrained)"],
          "text": "Sequence alignment"
        }],
        "data": {
          "uri": "http://edamontology.org/operation_2928"
        },
        "definition": "Compare two or more entities, typically the sequence or structure (or derivatives) of macromolecules, to identify equivalent subunits.",
        "exact_synonyms": ["Alignment generation", "Alignment construction"],
        "text": "Alignment"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_0296"
        },
        "definition": "Generate some type of sequence profile (for example a hidden Markov model) from a sequence alignment.",
        "exact_synonyms": ["Sequence profile construction"],
        "has_input": ["http://edamontology.org/data_0863"],
        "has_output": ["http://edamontology.org/data_1354"],
        "has_topic": ["http://edamontology.org/topic_0160"],
        "text": "Sequence profile generation"
      }, {
        "comment": ["A 3D-1D scoring matrix scores the probability of amino acids occurring in different structural environments."],
        "data": {
          "uri": "http://edamontology.org/operation_2239"
        },
        "definition": "Calculate a 3D-1D scoring matrix from analysis of protein sequence and structural data.",
        "exact_synonyms": ["3D-1D scoring matrix construction"],
        "has_output": ["http://edamontology.org/data_1499"],
        "has_topic": ["http://edamontology.org/topic_0081"],
        "text": "3D-1D scoring matrix generation"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_3469"
        },
        "definition": "Compute the covariance model for (a family of) RNA secondary structures.",
        "has_topic": ["http://edamontology.org/topic_0097"],
        "text": "RNA structure covariance model generation"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_0289"
        },
        "definition": "Calculate a sequence distance matrix or otherwise estimate genetic distances between molecular sequences.",
        "exact_synonyms": ["Sequence distance calculation", "Phylogenetic distance matrix generation", "Sequence distance matrix construction"],
        "has_output": ["http://edamontology.org/data_0870"],
        "has_topic": ["http://edamontology.org/topic_0084"],
        "text": "Sequence distance matrix generation"
      }, {
        "children": [{
          "comment": ["Different techniques are used to generate gap sequences to connect contigs, depending on the size of the gap. For small (5-20kb) gaps, PCR amplification and sequencing is used.  For large (>20kb) gaps, fragments are cloned (e.g. in BAC (Bacterial artificial chromosomes) vectors) and then sequenced."],
          "data": {
            "uri": "http://edamontology.org/operation_3217"
          },
          "definition": "Fill the gaps in a sequence assembly (scaffold) by merging in additional sequences.",
          "text": "Scaffold gap completion"
        }],
        "comment": ["Scaffold may be positioned along a chromosome physical map to create a \"golden path\"."],
        "data": {
          "uri": "http://edamontology.org/operation_3216"
        },
        "definition": "Link together a non-contiguous series of genomic sequences into a scaffold, consisting of sequences separated by gaps of known length.  The sequences that are linked are typically typically contigs; contiguous sequences corresponding to read overlaps.",
        "exact_synonyms": ["Scaffold generation", "Scaffold construction"],
        "has_topic": ["http://edamontology.org/topic_0077"],
        "text": "Scaffolding"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_3349"
        },
        "definition": "Construct a bibliography from the scientific literature.",
        "exact_synonyms": ["Bibliography construction"],
        "has_output": ["http://edamontology.org/data_3505"],
        "text": "Bibliography generation"
      }, {
        "children": [{
          "comment": ["Note that this is somewhat different from simply analysing an existing tree or constructing a completely new one."],
          "data": {
            "uri": "http://edamontology.org/operation_3478"
          },
          "definition": "Reconstructing the inner node labels of a phylogenetic tree from its leafes.",
          "exact_synonyms": ["Phylogenetic tree reconstruction"],
          "has_topic": ["http://edamontology.org/topic_0084"],
          "narrow_synonyms": ["Gene tree reconstruction", "Species tree reconstruction"],
          "text": "Phylogenetic reconstruction"
        }, {
          "comment": ["Methods typically test for topological similarity between trees using for example a congruence index."],
          "data": {
            "uri": "http://edamontology.org/operation_0555"
          },
          "definition": "Compare two or more phylogenetic trees to produce a consensus tree.",
          "exact_synonyms": ["Phylogenetic tree generation (consensus)", "Phylogenetic tree construction (consensus)"],
          "text": "Consensus tree construction"
        }, {
          "comment": ["Phylogenetic shadowing is a type of footprinting where many closely related species are used.  A phylogenetic 'shadow' represents the additive differences between individual sequences. By masking or 'shadowing' variable positions a conserved sequence is produced with few or none of the variations, which is then compared to the sequences of interest to identify significant regions of conservation."],
          "data": {
            "uri": "http://edamontology.org/operation_0327"
          },
          "definition": "Comparison of a DNA sequence to orthologous sequences in different species and inference of a phylogenetic tree, in order to identify regulatory elements such as transcription factor binding sites (TFBS).",
          "has_topic": ["http://edamontology.org/topic_0194"],
          "narrow_synonyms": ["Phylogenetic shadowing"],
          "text": "Phylogenetic footprinting"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0544"
          },
          "definition": "Construct a phylogenetic species tree, for example, from a genome-wide sequence comparison.",
          "exact_synonyms": ["Phylogenetic species tree generation", "Phylogenetic species tree construction"],
          "text": "Species tree construction"
        }, {
          "comment": ["Gene trees can provide evidence for gene duplication events, as well as speciation events. Where sequences from different homologs are included in a gene tree, subsequent clustering of the orthologs can demonstrate evolutionary history of the orthologs."],
          "data": {
            "uri": "http://edamontology.org/operation_0553"
          },
          "definition": "Construct a \"gene tree\" which represents the evolutionary history of the genes included in the study.  This can be used to predict families of genes and gene function based on their position in a phylogenetic tree.",
          "exact_synonyms": ["Phylogenetic tree analysis (gene family prediction)"],
          "has_output": ["http://edamontology.org/data_0916"],
          "has_topic": ["http://edamontology.org/topic_0194"],
          "text": "Gene tree construction"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_0542"
            },
            "definition": "Phylogenetic tree construction from gene frequency data.",
            "exact_synonyms": ["Phylogenetic tree generation (from gene frequencies)", "Phylogenetic tree construction (from gene frequencies)"],
            "has_input": ["http://edamontology.org/data_2873"],
            "has_topic": ["http://edamontology.org/topic_0203"],
            "text": "Phylogenetic inference (from gene frequencies)"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0543"
            },
            "definition": "Phylogenetic tree construction from polymorphism data including microsatellites, RFLP (restriction fragment length polymorphisms), RAPD (random-amplified polymorphic DNA) and AFLP (amplified fragment length polymorphisms) data.",
            "exact_synonyms": ["Phylogenetic tree generation (from polymorphism data)", "Phylogenetic tree construction (from polymorphism data)"],
            "has_topic": ["http://edamontology.org/topic_0199"],
            "text": "Phylogenetic inference (from polymorphism data)"
          }, {
            "comment": ["Methods typically compare multiple molecular sequence and estimate evolutionary distances and relationships to infer gene families or make functional predictions."],
            "data": {
              "uri": "http://edamontology.org/operation_0540"
            },
            "definition": "Phylogenetic tree construction from molecular sequences.",
            "exact_synonyms": ["Phylogenetic tree generation (from molecular sequences)", "Phylogenetic tree construction (from molecular sequences)"],
            "text": "Phylogenetic inference (from molecular sequences)"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0541"
            },
            "definition": "Phylogenetic tree construction from continuous quantitative character data.",
            "exact_synonyms": ["Phylogenetic tree generation (from continuous quantitative characters)", "Phylogenetic tree construction (from continuous quantitative characters)"],
            "has_input": ["http://edamontology.org/data_1426"],
            "text": "Phylogenetic inference (from continuous quantitative characters)"
          }],
          "comment": ["Subconcepts of this concept reflect different types of data used to generate a tree, and provide an alternate axis for curation."],
          "data": {
            "uri": "http://edamontology.org/operation_0538"
          },
          "definition": "Construct a phylogenetic tree from a specific type of data.",
          "exact_synonyms": ["Phylogenetic tree construction (data centric)", "Phylogenetic tree generation (data centric)"],
          "text": "Phylogenetic inference (data centric)"
        }, {
          "children": [{
            "comment": ["This includes evolutionary parsimony (invariants) methods."],
            "data": {
              "uri": "http://edamontology.org/operation_0545"
            },
            "definition": "Construct a phylogenetic tree by computing a sequence alignment and searching for the tree with the fewest number of character-state changes from the alignment.",
            "exact_synonyms": ["Phylogenetic tree generation (parsimony methods)", "Phylogenetic tree construction (parsimony methods)"],
            "text": "Phylogenetic inference (parsimony methods)"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0549"
            },
            "definition": "Construct a phylogenetic tree by using artificial-intelligence methods, for example genetic algorithms.",
            "exact_synonyms": ["Phylogenetic tree construction (AI methods)", "Phylogenetic tree generation (AI methods)"],
            "text": "Phylogenetic inference (AI methods)"
          }, {
            "comment": ["This includes neighbor joining (NJ) clustering method."],
            "data": {
              "uri": "http://edamontology.org/operation_0546"
            },
            "definition": "Construct a phylogenetic tree by computing (or using precomputed) distances between sequences and searching for the tree with minimal discrepancies between pairwise distances.",
            "exact_synonyms": ["Phylogenetic tree construction (minimum distance methods)", "Phylogenetic tree generation (minimum distance methods)"],
            "text": "Phylogenetic inference (minimum distance methods)"
          }, {
            "comment": ["Maximum likelihood methods search for a tree that maximizes a likelihood function, i.e. that is most likely given the data and model. Bayesian analysis estimate the probability of tree for branch lengths and topology, typically using a Monte Carlo algorithm."],
            "data": {
              "uri": "http://edamontology.org/operation_0547"
            },
            "definition": "Construct a phylogenetic tree by relating sequence data to a hypothetical tree topology using a model of sequence evolution.",
            "exact_synonyms": ["Phylogenetic tree construction (maximum likelihood and Bayesian methods)", "Phylogenetic tree generation (maximum likelihood and Bayesian methods)"],
            "text": "Phylogenetic inference (maximum likelihood and Bayesian methods)"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0548"
            },
            "definition": "Construct a phylogenetic tree by computing four-taxon trees (4-trees) and searching for the phylogeny that matches most closely.",
            "exact_synonyms": ["Phylogenetic tree construction (quartet methods)", "Phylogenetic tree generation (quartet methods)"],
            "text": "Phylogenetic inference (quartet methods)"
          }],
          "comment": ["Subconcepts of this concept reflect different computational methods used to generate a tree, and provide an alternate axis for curation."],
          "data": {
            "uri": "http://edamontology.org/operation_0539"
          },
          "definition": "Construct a phylogenetic tree using a specific method.",
          "exact_synonyms": ["Phylogenetic tree construction (method centric)", "Phylogenetic tree generation (method centric)"],
          "text": "Phylogenetic inference (method centric)"
        }],
        "comment": ["Phylogenetic trees are usually constructed from a set of sequences from which an alignment (or data matrix) is calculated."],
        "data": {
          "uri": "http://edamontology.org/operation_0323"
        },
        "definition": "Construct a phylogenetic tree.",
        "exact_synonyms": ["Phlyogenetic tree construction", "Phylogenetic reconstruction", "Phylogenetic tree generation"],
        "has_output": ["http://edamontology.org/data_0872"],
        "has_topic": ["http://edamontology.org/topic_0080"],
        "text": "Phylogenetic inference"
      }, {
        "comment": ["The heat map usually uses a coloring scheme to represent expression values. They can show how quantitative measurements were influenced by experimental conditions."],
        "data": {
          "uri": "http://edamontology.org/operation_0531"
        },
        "definition": "Generate a heat map of expression data from e.g. microarray data.",
        "exact_synonyms": ["Heat map construction", "Heatmap generation"],
        "has_output": ["http://edamontology.org/data_1636"],
        "text": "Heat map generation"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/operation_3459"
          },
          "definition": "Clustering of molecular sequences on the basis of their function, typically using information from an ontology of gene function, or some other measure of functional phenotype.",
          "exact_synonyms": ["Functional sequence clustering"],
          "has_topic": ["http://edamontology.org/topic_1775"],
          "text": "Functional clustering"
        }],
        "comment": ["The clusters may be output or used internally for some other purpose."],
        "data": {
          "uri": "http://edamontology.org/operation_0291"
        },
        "definition": "Build clusters of similar sequences, typically using scores from pair-wise alignment or other comparison of the sequences.",
        "exact_synonyms": ["Sequence cluster construction", "Sequence cluster generation"],
        "has_output": ["http://edamontology.org/data_1235"],
        "text": "Sequence clustering"
      }],
      "comment": ["For non-analytical operations, see the 'Processing' branch."],
      "data": {
        "uri": "http://edamontology.org/operation_3429"
      },
      "definition": "Construct some data entity.",
      "exact_synonyms": ["Construction"],
      "text": "Generation"
    }, {
      "children": [{
        "children": [{
          "comment": ["This includes methods that use an existing alignment."],
          "data": {
            "uri": "http://edamontology.org/operation_0504"
          },
          "definition": "Align (superimpose) more than two molecular tertiary structures.",
          "exact_synonyms": ["Structure alignment (multiple)"],
          "narrow_synonyms": ["Multiple protein structure alignment"],
          "text": "Multiple structure alignment"
        }, {
          "comment": ["Local alignment methods identify regions of local similarity, common substructures etc."],
          "data": {
            "uri": "http://edamontology.org/operation_0509"
          },
          "definition": "Locally align (superimpose) two or more molecular tertiary structures.",
          "exact_synonyms": ["Structure alignment (local)"],
          "narrow_synonyms": ["Local protein structure alignment"],
          "text": "Local structure alignment"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0503"
          },
          "definition": "Align (superimpose) exactly two molecular tertiary structures.",
          "exact_synonyms": ["Structure alignment (pairwise)"],
          "narrow_synonyms": ["Pairwise protein structure alignment"],
          "text": "Pairwise structure alignment"
        }, {
          "comment": ["Global alignment methods identify similarity across the entire structures."],
          "data": {
            "uri": "http://edamontology.org/operation_0510"
          },
          "definition": "Globally align (superimpose) two or more molecular tertiary structures.",
          "exact_synonyms": ["Structure alignment (global)"],
          "narrow_synonyms": ["Global protein structure alignment"],
          "text": "Global structure alignment"
        }],
        "data": {
          "uri": "http://edamontology.org/operation_0295"
        },
        "definition": "Align (superimpose) molecular tertiary structures.",
        "exact_synonyms": ["Structural alignment"],
        "has_output": ["http://edamontology.org/data_0886"],
        "narrow_synonyms": ["3D profile-to-3D profile alignment", "Structural profile alignment", "3D profile alignment"],
        "text": "Structure alignment"
      }, {
        "children": [{
          "comment": ["Use this concept for methods that evaluate sequence-structure compatibility by assessing residue interactions in 3D. Methods might perform one-to-one, one-to-many or many-to-many comparisons."],
          "data": {
            "uri": "http://edamontology.org/operation_0302"
          },
          "definition": "Align molecular sequence to structure in 3D space (threading).",
          "exact_synonyms": ["Sequence-structure alignment"],
          "has_input": ["http://edamontology.org/data_1460"],
          "has_output": ["http://edamontology.org/data_0893"],
          "narrow_synonyms": ["Sequence-3D profile alignment", "Sequence-to-3D-profile alignment"],
          "text": "Protein threading"
        }],
        "comment": ["Methods use some type of mapping between sequence and fold, for example secondary structure prediction and alignment, profile comparison, sequence properties, homologous sequence search, kernel machines etc. Domains and folds might be taken from SCOP or CATH."],
        "data": {
          "uri": "http://edamontology.org/operation_0303"
        },
        "definition": "Recognize (predict and identify) known protein structural domains or folds in protein sequence(s) which (typically) are not accompanied by any significant sequence similarity to know structures.",
        "exact_synonyms": ["Protein fold recognition", "Fold prediction", "Protein domain prediction", "Domain prediction", "Protein fold prediction"],
        "text": "Fold recognition"
      }, {
        "children": [{
          "comment": ["A sequence profile typically represents a sequence alignment. Methods might perform one-to-one, one-to-many or many-to-many comparisons."],
          "data": {
            "uri": "http://edamontology.org/operation_0300"
          },
          "definition": "Align molecular sequence(s) to sequence profile(s), or profiles to other profiles.  A profile typically represents a sequence alignment.",
          "has_input": ["http://edamontology.org/data_1354"],
          "has_topic": ["http://edamontology.org/topic_0160"],
          "narrow_synonyms": ["Profile-profile alignment", "Sequence-to-profile alignment", "Sequence-profile alignment", "Profile-to-profile alignment"],
          "text": "Sequence profile alignment"
        }, {
          "comment": ["This is supposed to give a more biologically meaningful alignment than standard alignments."],
          "data": {
            "uri": "http://edamontology.org/operation_0499"
          },
          "definition": "Align multiple sequences using relative gap costs calculated from neighbors in a supplied phylogenetic tree.",
          "exact_synonyms": ["Multiple sequence alignment construction (phylogenetic tree-based)", "Multiple sequence alignment (phylogenetic tree-based)", "Phylogenetic tree-based multiple sequence alignment construction", "Sequence alignment (phylogenetic tree-based)", "Sequence alignment generation (phylogenetic tree-based)"],
          "has_topic": ["http://edamontology.org/topic_0084"],
          "text": "Tree-based sequence alignment"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0294"
          },
          "definition": "Align molecular sequences using sequence and structural information.",
          "exact_synonyms": ["Sequence alignment (structure-based)"],
          "text": "Structure-based sequence alignment"
        }, {
          "comment": ["Methods might perform one-to-one, one-to-many or many-to-many comparisons."],
          "data": {
            "uri": "http://edamontology.org/operation_0491"
          },
          "definition": "Align exactly two molecular sequences.",
          "exact_synonyms": ["Pairwise alignment"],
          "has_output": ["http://edamontology.org/data_1381"],
          "text": "Pairwise sequence alignment"
        }, {
          "comment": ["This includes methods that use an existing alignment, for example to incorporate sequences into an alignment, or combine several multiple alignments into a single, improved alignment."],
          "data": {
            "uri": "http://edamontology.org/operation_0492"
          },
          "definition": "Align more than two molecular sequences.",
          "exact_synonyms": ["Multiple alignment"],
          "text": "Multiple sequence alignment"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3182"
          },
          "definition": "Align two or more (tpyically huge) molecular sequences that represent genomes.",
          "exact_synonyms": ["Whole genome alignment", "Genome alignment construction"],
          "text": "Genome alignment"
        }, {
          "comment": ["Local alignment methods identify regions of local similarity."],
          "data": {
            "uri": "http://edamontology.org/operation_0495"
          },
          "definition": "Locally align two or more molecular sequences.",
          "exact_synonyms": ["Local sequence alignment", "Sequence alignment (local)"],
          "narrow_synonyms": ["Smith-Waterman"],
          "text": "Local alignment"
        }, {
          "comment": ["Global alignment methods identify similarity across the entire length of the sequences."],
          "data": {
            "uri": "http://edamontology.org/operation_0496"
          },
          "definition": "Globally align two or more molecular sequences.",
          "exact_synonyms": ["Global sequence alignment", "Sequence alignment (global)"],
          "text": "Global alignment"
        }],
        "comment": ["See also \"Read mapping\""],
        "data": {
          "uri": "http://edamontology.org/operation_0292"
        },
        "definition": "Align (identify equivalent sites within) molecular sequences.",
        "exact_synonyms": ["Sequence alignment construction", "Sequence alignment generation"],
        "has_output": ["http://edamontology.org/data_0863"],
        "narrow_synonyms": ["Consensus-based sequence alignment", "Constrained sequence alignment", "Sequence alignment (constrained)", "Multiple sequence alignment (constrained)"],
        "text": "Sequence alignment"
      }],
      "data": {
        "uri": "http://edamontology.org/operation_2928"
      },
      "definition": "Compare two or more entities, typically the sequence or structure (or derivatives) of macromolecules, to identify equivalent subunits.",
      "exact_synonyms": ["Alignment generation", "Alignment construction"],
      "text": "Alignment"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/operation_3763"
        },
        "definition": "An operation supporting the calling (invocation) of other tools and services.",
        "text": "Service invocation"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_3761"
        },
        "definition": "An operation supporting the browsing or discovery of other tools and services.",
        "text": "Service discovery"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_3762"
        },
        "definition": "An operation supporting the aggregation of other services (at least two) into a funtional unit, for the automation of some task.",
        "text": "Service composition"
      }],
      "data": {
        "uri": "http://edamontology.org/operation_3760"
      },
      "definition": "Operations concerning the handling and use of other tools.",
      "narrow_synonyms": ["Endpoint management"],
      "text": "Service management"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/operation_3649"
        },
        "definition": "Statistical estimation of false discovery rate from score distribution for peptide-spectrum-matches, following a peptide database search, and by comparison to search results with a database containing incorrect information.",
        "text": "Target-Decoy"
      }, {
        "children": [{
          "comment": ["For example process paired end reads to trim low quality ends remove short sequences, identify sequence inserts, detect chimeric reads, or remove low quality sequnces including vector, adaptor, low complexity and contaminant sequences. Sequences might come from genomic DNA library, EST libraries, SSH library and so on."],
          "data": {
            "uri": "http://edamontology.org/operation_3219"
          },
          "definition": "Pre-process sequence reads to ensure (or improve) quality and reliability.",
          "exact_synonyms": ["Sequence read pre-processing"],
          "text": "Read pre-processing"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3187"
          },
          "definition": "Identify and filter a (typically large) sequence data set to remove sequences from contaminants in the sample that was sequenced.",
          "text": "Sequence contamination filtering"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3675"
          },
          "definition": "Variant filtering is used to eliminate false positive variants based for example on base calling quality, strand and position information, and mapping info.",
          "text": "Variant filtering"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3180"
          },
          "definition": "Evaluate a DNA sequence assembly, typically for purposes of quality control.",
          "exact_synonyms": ["Assembly quality evaluation", "Sequence assembly quality evaluation", "Sequence assembly QC", "Assembly QC"],
          "has_input": ["http://edamontology.org/data_0925"],
          "has_output": ["http://edamontology.org/data_3181"],
          "has_topic": ["http://edamontology.org/topic_0196"],
          "text": "Sequence assembly validation"
        }],
        "comment": ["Analyse raw sequence data from a sequencing pipeline and identify (and possiby fix) problems."],
        "data": {
          "uri": "http://edamontology.org/operation_3218"
        },
        "definition": "Raw sequence data quality control.",
        "exact_synonyms": ["Sequencing QC", "Sequencing quality assessment"],
        "text": "Sequencing quality control"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/operation_1843"
          },
          "definition": "Identify poorly packed residues in protein structures.",
          "text": "Residue packing validation"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_1836"
          },
          "definition": "Detect 'bumps' between residues in a structure, i.e. those with pairs of atoms whose Van der Waals' radii interpenetrate more than a defined distance.",
          "text": "Residue bump detection"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_1844"
          },
          "definition": "Validate protein geometry, for example bond lengths, bond angles, torsion angles, chiralities, planaraties etc.  An example is validation of a Ramachandran plot of a protein structure.",
          "narrow_synonyms": ["Ramachandran plot validation"],
          "text": "Protein geometry validation"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3560"
          },
          "definition": "A method for making numerical assessments about the maximum percent of time that a conformer of a flexible macromolecule can exist and still be compatible with the experimental data.",
          "text": "Maximum occurence analysis"
        }],
        "comment": ["Model validation might involve checks for atomic packing, steric clashes (bumps), volume irregularities, agreement with electron density maps, number of amino acid residues, percentage of residues with missing or bad atoms, irregular Ramachandran Z-scores, irregular Chi-1 / Chi-2 normality scores, RMS-Z score on bonds and angles etc.", "This includes methods that calculate poor quality residues. The scoring function to identify poor quality residues may consider residues with bad atoms or atoms with high B-factor, residues in the N- or C-terminal position, adjacent to an unstructured residue, non-canonical residues, glycine and proline (or adjacent to these such residues).", "The PDB file format has had difficulties, inconsistencies and errors. Corrections can include identifying a meaningful sequence, removal of alternate atoms, correction of nomenclature problems, removal of incomplete residues and spurious waters, addition or removal of water, modelling of missing side chains, optimisation of cysteine bonds, regularisation of bond lengths, bond angles and planarities etc."],
        "data": {
          "uri": "http://edamontology.org/operation_0321"
        },
        "definition": "Evaluate the quality or correctness a protein three-dimensional model.",
        "exact_synonyms": ["Protein model validation"],
        "has_output": ["http://edamontology.org/data_1539"],
        "has_topic": ["http://edamontology.org/topic_2275"],
        "narrow_synonyms": ["Residue validation"],
        "text": "Protein structure validation"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_0336"
        },
        "definition": "Test and validate the format and content of a data file.",
        "exact_synonyms": ["File format validation"],
        "text": "Format validation"
      }, {
        "comment": ["Evaluation might be purely sequence-based or use structural information."],
        "data": {
          "uri": "http://edamontology.org/operation_0447"
        },
        "definition": "Evaluate molecular sequence alignment accuracy.",
        "exact_synonyms": ["Sequence alignment quality evaluation"],
        "text": "Sequence alignment validation"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_0552"
        },
        "definition": "Apply bootstrapping or other measures to estimate confidence of a phylogenetic tree.",
        "text": "Phylogenetic tree bootstrapping"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_3180"
        },
        "definition": "Evaluate a DNA sequence assembly, typically for purposes of quality control.",
        "exact_synonyms": ["Assembly quality evaluation", "Sequence assembly quality evaluation", "Sequence assembly QC", "Assembly QC"],
        "has_input": ["http://edamontology.org/data_0925"],
        "has_output": ["http://edamontology.org/data_3181"],
        "has_topic": ["http://edamontology.org/topic_0196"],
        "text": "Sequence assembly validation"
      }],
      "data": {
        "uri": "http://edamontology.org/operation_2428"
      },
      "definition": "Validate some data.",
      "narrow_synonyms": ["Quality control"],
      "text": "Validation"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/operation_2844"
        },
        "definition": "Build clusters of similar structures, typically using scores from structural alignment methods.",
        "exact_synonyms": ["Structural clustering"],
        "text": "Structure clustering"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_3279"
        },
        "definition": "Cluster (group) documents on the basis of their calculated similarity.",
        "text": "Document clustering"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_0313"
        },
        "definition": "Perform cluster analysis of expression data to identify groups with similar expression profiles, for example by clustering.",
        "has_output": ["http://edamontology.org/data_3111"],
        "narrow_synonyms": ["Gene expression profile clustering", "Gene expression clustering"],
        "text": "Expression profile clustering"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/operation_3459"
          },
          "definition": "Clustering of molecular sequences on the basis of their function, typically using information from an ontology of gene function, or some other measure of functional phenotype.",
          "exact_synonyms": ["Functional sequence clustering"],
          "has_topic": ["http://edamontology.org/topic_1775"],
          "text": "Functional clustering"
        }],
        "comment": ["The clusters may be output or used internally for some other purpose."],
        "data": {
          "uri": "http://edamontology.org/operation_0291"
        },
        "definition": "Build clusters of similar sequences, typically using scores from pair-wise alignment or other comparison of the sequences.",
        "exact_synonyms": ["Sequence cluster construction", "Sequence cluster generation"],
        "has_output": ["http://edamontology.org/data_1235"],
        "text": "Sequence clustering"
      }],
      "data": {
        "uri": "http://edamontology.org/operation_3432"
      },
      "definition": "Group together some data entities on the basis of similarities such that entities in the same group (cluster) are more similar to each other than to those in other groups (clusters).",
      "text": "Clustering"
    }, {
      "children": [{
        "children": [{
          "data": {
            "uri": "http://edamontology.org/operation_0319"
          },
          "definition": "Assign secondary structure from protein coordinate or experimental data.",
          "has_topic": ["http://edamontology.org/topic_1317", "http://edamontology.org/topic_2814"],
          "text": "Protein secondary structure assignment"
        }, {
          "children": [{
            "comment": ["A free cysteine is neither involved in a cysteine bridge, nor functions as a ligand to a metal."],
            "data": {
              "uri": "http://edamontology.org/operation_1830"
            },
            "definition": "Detect free cysteines in a protein structure.",
            "text": "Free cysteine detection"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_1829"
            },
            "definition": "Detect cysteine bridges (from coordinate data) in a protein structure.",
            "text": "Cysteine bridge detection"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_1831"
            },
            "definition": "Detect cysteines that are bound to metal in a protein structure.",
            "text": "Metal-bound cysteine detection"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_1850"
          },
          "definition": "Assign cysteine bonding state and disulfide bond partners in protein structures.",
          "has_topic": ["http://edamontology.org/topic_0130"],
          "text": "Protein cysteine and disulfide bond assignment"
        }],
        "data": {
          "uri": "http://edamontology.org/operation_0320"
        },
        "definition": "Assign a protein tertiary structure (3D coordinates), or other aspects of protein structure, from raw experimental data.",
        "has_output": ["http://edamontology.org/data_1460"],
        "has_topic": ["http://edamontology.org/topic_1317"],
        "narrow_synonyms": ["Structure calculation", "NOE assignment"],
        "text": "Protein structure assignment"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/operation_0428"
          },
          "definition": "Detect polyA signals in nucleotide sequences.",
          "exact_synonyms": ["PolyA detection", "Polyadenylation signal prediction", "Polyadenylation signal detection", "PolyA signal prediction", "PolyA prediction"],
          "text": "PolyA signal detection"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0431"
          },
          "definition": "Find and identify restriction enzyme cleavage sites (restriction sites) in (typically) DNA sequences, for example to generate a restriction map.",
          "has_topic": ["http://edamontology.org/topic_0160"],
          "text": "Restriction site recognition"
        }, {
          "comment": ["Chip-sequencing combines chromatin immunoprecipitation (ChIP) with massively parallel DNA sequencing to generate a set of reads, which are aligned to a genome sequence.  The enriched areas contain the binding sites of DNA-associated proteins.  For example, a transcription factor binding site. ChIP-on-chip in contrast combines chromatin immunoprecipitation ('ChIP') with microarray ('chip').  \"Peak-pair calling\" is similar to \"Peak calling\" in the context of ChIP-exo."],
          "data": {
            "uri": "http://edamontology.org/operation_3222"
          },
          "definition": "Identify putative protein-binding regions in a genome sequence from analysis of Chip-sequencing data or ChIP-on-chip data.",
          "exact_synonyms": ["Protein binding peak detection"],
          "narrow_synonyms": ["Peak-pair calling"],
          "text": "Peak calling"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0379"
          },
          "definition": "Find (and possibly render) short repetitive subsequences (repeat sequences) in (typically nucleotide) sequences.",
          "text": "Repeat sequence detection"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0266"
          },
          "definition": "Detect vector sequences in nucleotide sequence, typically by comparison to a set of known vector sequences.",
          "text": "Vector sequence detection"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0432"
          },
          "definition": "Identify or predict nucleosome exclusion sequences (nucleosome free regions) in DNA.",
          "narrow_synonyms": ["Nucleosome exclusion sequence prediction", "Nucleosome formation sequence prediction"],
          "text": "Nucleosome position prediction"
        }, {
          "comment": ["An isochore is long region (> 3 KB) of DNA with very uniform GC content, in contrast to the rest of the genome. Isochores tend tends to have more genes, higher local melting or denaturation temperatures, and different flexibility. Methods might calculate fractional GC content or variation of GC content, predict methylation status of CpG islands etc. This includes methods that visualise CpG rich regions in a nucleotide sequence, for example plot isochores in a genome sequence."],
          "data": {
            "uri": "http://edamontology.org/operation_0430"
          },
          "definition": "Find CpG rich regions in a nucleotide sequence or isochores in genome sequences.",
          "exact_synonyms": ["CpG island and isochores rendering", "CpG island and isochores detection"],
          "has_topic": ["http://edamontology.org/topic_0157"],
          "text": "CpG island and isochore detection"
        }, {
          "comment": ["Methods might use RNA motifs, predicted intermolecular contacts, or RNA sequence-structure compatibility (inverse RNA folding)."],
          "data": {
            "uri": "http://edamontology.org/operation_0278"
          },
          "definition": "Predict RNA secondary structure (for example knots, pseudoknots, alternative structures etc).",
          "has_output": ["http://edamontology.org/data_0880"],
          "narrow_synonyms": ["RNA shape prediction"],
          "text": "RNA secondary structure prediction"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0427"
          },
          "definition": "Detect or predict transposons, retrotransposons / retrotransposition signatures etc.",
          "text": "Transposon prediction"
        }, {
          "comment": ["Quadruplex (4-stranded) structures are formed by guanine-rich regions and are implicated in various important biological processes and as therapeutic targets."],
          "data": {
            "uri": "http://edamontology.org/operation_0429"
          },
          "definition": "Detect quadruplex-forming motifs in nucleotide sequences.",
          "exact_synonyms": ["Quadruplex structure prediction"],
          "has_output": ["http://edamontology.org/data_3128"],
          "text": "Quadruplex formation site detection"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3677"
          },
          "definition": "Identify binding sites in nucleic acid sequences that are statistically significantly differentially bound between sample groups.",
          "text": "Differential binding analysis"
        }],
        "comment": ["Methods typically involve scanning for known motifs, patterns and regular expressions.", "This is placeholder but does not comprehensively include all child concepts - please inspect other concepts under \"Nucleic acid sequence analysis\" for example \"Gene prediction\", for other feature detection operations."],
        "data": {
          "uri": "http://edamontology.org/operation_0415"
        },
        "definition": "Predict, recognise and identify features in nucleotide sequences such as functional sites or regions, typically by scanning for known motifs, patterns and regular expressions.",
        "exact_synonyms": ["Sequence feature detection (nucleic acid)"],
        "has_output": ["http://edamontology.org/data_1276"],
        "has_topic": ["http://edamontology.org/topic_0160"],
        "narrow_synonyms": ["Nucleic acid feature recognition", "Nucleic acid site prediction", "Nucleic acid feature prediction", "Nucleic acid site recognition", "Nucleic acid site detection"],
        "text": "Nucleic acid feature detection"
      }, {
        "comment": ["Includes methods that try to suggest the most likely biological unit for a given protein X-ray crystal structure based on crystal symmetry and scoring of putative protein-protein interfaces."],
        "data": {
          "uri": "http://edamontology.org/operation_2475"
        },
        "definition": "Identify the architecture of a protein structure.",
        "text": "Protein architecture recognition"
      }, {
        "comment": ["Protein SNP mapping maps and modesl the effects of single nucleotide polymorphisms (SNPs) on protein structure(s).  Methods might predict silent or pathological mutations."],
        "data": {
          "uri": "http://edamontology.org/operation_0331"
        },
        "definition": "Predict the effect of point mutation on a protein structure, in terms of strucural effects and protein folding, stability and function.",
        "exact_synonyms": ["Variant functional prediction"],
        "has_topic": ["http://edamontology.org/topic_0130", "http://edamontology.org/topic_0199"],
        "narrow_synonyms": ["Protein stability change prediction", "Protein mutation modelling", "Protein SNP mapping"],
        "text": "Variant effect prediction"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_3461"
        },
        "definition": "The prediction of the degree of pathogenicity of a microorganism from analysis of molecular sequences.",
        "exact_synonyms": ["Pathogenicity prediction"],
        "has_topic": ["http://edamontology.org/topic_3301"],
        "text": "Virulence prediction"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_3350"
        },
        "definition": "Predict the structure of a multi-subunit protein and particularly how the subunits fit together.",
        "text": "Protein quaternary structure prediction"
      }, {
        "children": [{
          "comment": ["This includes methods that generate a graphical rendering of antigenicity of a protein, such as a Hopp and Woods plot.", "This is usually done in the development of peptide-specific antibodies or multi-epitope vaccines. Methods might use sequence data (for example motifs) and / or structural data.", "Immunological system are cellular or humoral. In vaccine design to induces a cellular immune response, methods must search for antigens that can be recognized by the major histocompatibility complex (MHC) molecules present in T lymphocytes.  If a humoral response is required, antigens for B cells must be identified."],
          "data": {
            "uri": "http://edamontology.org/operation_0252"
          },
          "definition": "Predict antigenicity, allergenicity / immunogenicity, allergic cross-reactivity etc of peptides and proteins.",
          "exact_synonyms": ["Antigenicity prediction", "Immunogenicity prediction"],
          "has_output": ["http://edamontology.org/data_1534"],
          "has_topic": ["http://edamontology.org/topic_0804"],
          "narrow_synonyms": ["Hopp and Woods plotting", "MHC peptide immunogenicity prediction", "B cell peptide immunogenicity prediction"],
          "text": "Peptide immunogenicity prediction"
        }, {
          "comment": ["Methods might use sequence motifs and features, amino acid composition, profiles, machine-learned classifiers, etc."],
          "data": {
            "uri": "http://edamontology.org/operation_0418"
          },
          "definition": "Detect or predict signal peptides and signal peptide cleavage sites in protein sequences.",
          "has_topic": ["http://edamontology.org/topic_0140"],
          "text": "Protein signal peptide detection"
        }, {
          "children": [{
            "children": [{
              "comment": ["Virtual screening is widely used for lead identification, lead optimization, and scaffold hopping during drug design and discovery."],
              "data": {
                "uri": "http://edamontology.org/operation_3938"
              },
              "definition": "Virtual screening is used in drug discovery to identify potential drug compounds.  It involves searching libraries of small molecules in order to identify those molecules which are most likely to bind to a drug target (typically a protein receptor or enzyme).",
              "has_output": ["http://edamontology.org/data_1461"],
              "has_topic": ["http://edamontology.org/topic_0128"],
              "narrow_synonyms": ["Structured-based virtual screening", "Ligand-based screening", "Virtual ligand screening", "Ligand-based virtual screening", "Structure-based screening"],
              "text": "Virtual screening"
            }],
            "comment": ["Virtual screening is used in drug discovery to search libraries of small molecules in order to identify those molecules which are most likely to bind to a drug target (typically a protein receptor or enzyme).", "Methods aim to predict the position and orientation of a ligand bound to a protein receptor or enzyme."],
            "data": {
              "uri": "http://edamontology.org/operation_0482"
            },
            "definition": "Model protein-ligand (for example protein-peptide) binding using comparative modelling or other techniques.",
            "exact_synonyms": ["Ligand-binding simulation"],
            "has_output": ["http://edamontology.org/data_1461"],
            "has_topic": ["http://edamontology.org/topic_0128"],
            "narrow_synonyms": ["Protein-peptide docking"],
            "text": "Protein-ligand docking"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3899"
            },
            "definition": "Model or simulate protein-protein binding using comparative modelling or other techniques.",
            "exact_synonyms": ["Protein docking"],
            "has_output": ["http://edamontology.org/data_1461"],
            "has_topic": ["http://edamontology.org/topic_0128"],
            "text": "Protein-protein docking"
          }],
          "comment": ["This includes protein-protein interactions, protein-nucleic acid, protein-ligand binding etc. Methods might predict whether the molecules are likely to bind in vivo, their conformation when bound, the strength of the interaction, possible mutations to achieve bonding and so on."],
          "data": {
            "uri": "http://edamontology.org/operation_0478"
          },
          "definition": "Model the structure of a protein in complex with a small molecule or another macromolecule.",
          "exact_synonyms": ["Macromolecular docking", "Docking simulation"],
          "has_output": ["http://edamontology.org/data_2877", "http://edamontology.org/data_1461"],
          "text": "Molecular docking"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_2464"
            },
            "definition": "Identify or predict protein-protein binding sites.",
            "exact_synonyms": ["Protein-protein binding site detection"],
            "has_output": ["http://edamontology.org/data_0906"],
            "has_topic": ["http://edamontology.org/topic_0128"],
            "text": "Protein-protein binding site prediction"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3898"
            },
            "definition": "Predict or detect metal ion-binding sites in proteins.",
            "exact_synonyms": ["Protein metal-binding site prediction", "Metal-binding site detection"],
            "text": "Metal-binding site prediction"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/operation_3903"
              },
              "definition": "Predict or detect DNA-binding sites in protein sequences.",
              "exact_synonyms": ["Protein-DNA binding site detection", "Protein-DNA binding site prediction"],
              "narrow_synonyms": ["DNA binding site detection"],
              "text": "DNA binding site prediction"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_3902"
              },
              "definition": "Predict or detect RNA-binding sites in protein sequences.",
              "exact_synonyms": ["RNA binding site detection", "Protein-RNA binding site detection", "Protein-RNA binding site prediction"],
              "text": "RNA binding site prediction"
            }],
            "comment": ["This includes methods that predict and optimise zinc finger protein domains for DNA/RNA binding (for example for transcription factors and nucleases)."],
            "data": {
              "uri": "http://edamontology.org/operation_0420"
            },
            "definition": "Predict or detect RNA and DNA-binding binding sites in protein sequences.",
            "exact_synonyms": ["Protein-nucleic acid binding site prediction", "Protein-nucleic acid binding detection", "Protein-nucleic acid binding prediction", "Protein-nucleic acid binding site detection"],
            "narrow_synonyms": ["Zinc finger prediction"],
            "text": "Nucleic acids-binding site prediction"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3896"
            },
            "definition": "Predict or detect active sites in proteins; the region of an enzyme which binds a substrate bind and catalyses a reaction.",
            "narrow_synonyms": ["Active site detection"],
            "text": "Active site prediction"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3897"
            },
            "definition": "Predict or detect ligand-binding sites in proteins; a region of a protein which reversibly binds a ligand for some biochemical purpose, such as transport or regulation of protein function.",
            "narrow_synonyms": ["Ligand-binding site detection", "Peptide-protein binding prediction"],
            "text": "Ligand-binding site prediction"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_2575"
          },
          "definition": "Identify or predict catalytic residues, active sites or other ligand-binding sites in protein sequences or structures.",
          "exact_synonyms": ["Protein binding site detection", "Protein binding site prediction"],
          "has_topic": ["http://edamontology.org/topic_0128"],
          "text": "Binding site prediction"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_1778"
          },
          "definition": "Compare the functional properties of two or more proteins.",
          "has_topic": ["http://edamontology.org/topic_1775"],
          "text": "Protein function comparison"
        }, {
          "comment": ["The prediction might include subcellular localisation (nuclear, cytoplasmic, mitochondrial, chloroplast, plastid, membrane etc) or export (extracellular proteins) of a protein."],
          "data": {
            "uri": "http://edamontology.org/operation_2489"
          },
          "definition": "Predict the subcellular localisation of a protein sequence.",
          "exact_synonyms": ["Protein cellular localization prediction", "Protein subcellular localisation prediction", "Protein targeting prediction"],
          "has_topic": ["http://edamontology.org/topic_0140"],
          "text": "Subcellular localisation prediction"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_3900"
            },
            "definition": "Predict DNA-binding proteins.",
            "exact_synonyms": ["DNA-binding protein detection", "DNA-protein interaction prediction", "Protein-DNA interaction prediction"],
            "has_output": ["http://edamontology.org/data_0906"],
            "has_topic": ["http://edamontology.org/topic_0128"],
            "text": "DNA-binding protein prediction"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3901"
            },
            "definition": "Predict RNA-binding proteins.",
            "exact_synonyms": ["RNA-binding protein detection", "RNA-protein interaction prediction", "Protein-RNA interaction prediction"],
            "has_output": ["http://edamontology.org/data_0906"],
            "has_topic": ["http://edamontology.org/topic_0128"],
            "text": "RNA-binding protein prediction"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_0389"
          },
          "definition": "Analyse the interaction of protein with nucleic acids, e.g. RNA or DNA-binding sites, interfaces etc.",
          "exact_synonyms": ["Protein-nucleic acid binding site analysis"],
          "has_topic": ["http://edamontology.org/topic_0128"],
          "narrow_synonyms": ["Protein-RNA interaction analysis", "Protein-DNA interaction analysis"],
          "text": "Protein-nucleic acid interaction analysis"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_0276"
            },
            "definition": "Analyse a network of protein interactions.",
            "has_output": ["http://edamontology.org/data_2984"],
            "has_topic": ["http://edamontology.org/topic_0128"],
            "narrow_synonyms": ["Protein interaction network comparison"],
            "text": "Protein interaction network analysis"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_2492"
            },
            "definition": "Predict the interactions of proteins with other proteins.",
            "exact_synonyms": ["Protein-protein interaction detection"],
            "has_output": ["http://edamontology.org/data_0906"],
            "has_topic": ["http://edamontology.org/topic_0128"],
            "narrow_synonyms": ["Protein-protein interaction prediction", "Protein-protein binding prediction"],
            "text": "Protein interaction prediction"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3094"
            },
            "definition": "Predict a network of protein interactions.",
            "text": "Protein interaction network prediction"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_2949"
          },
          "definition": "Analyse the interactions of proteins with other proteins.",
          "exact_synonyms": ["Protein interaction analysis"],
          "has_output": ["http://edamontology.org/data_0906"],
          "has_topic": ["http://edamontology.org/topic_0128"],
          "narrow_synonyms": ["Protein interaction simulation", "Protein interaction raw data analysis"],
          "text": "Protein-protein interaction analysis"
        }],
        "comment": ["For functional properties that can be mapped to a sequence, use 'Sequence feature detection (protein)' instead."],
        "data": {
          "uri": "http://edamontology.org/operation_1777"
        },
        "definition": "Predict the biological or biochemical role of a protein, or other aspects of a protein function.",
        "exact_synonyms": ["Protein functional analysis", "Protein function analysis"],
        "has_topic": ["http://edamontology.org/topic_1775"],
        "text": "Protein function prediction"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_0489"
        },
        "definition": "Predict genetic code from analysis of codon usage data.",
        "has_output": ["http://edamontology.org/data_1598"],
        "text": "Genetic code prediction"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/operation_0470"
          },
          "definition": "Predict open coils, non-regular secondary structure and intrinsically disordered / unstructured regions of protein sequences.",
          "text": "Protein secondary structure prediction (coils)"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0469"
          },
          "definition": "Predict turn structure (for example beta hairpin turns) of protein sequences.",
          "text": "Protein secondary structure prediction (turns)"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0468"
          },
          "definition": "Predict helical secondary structure of protein sequences.",
          "text": "Protein secondary structure prediction (helices)"
        }, {
          "comment": ["Super-secondary structures include leucine zippers, coiled coils, Helix-Turn-Helix etc."],
          "data": {
            "uri": "http://edamontology.org/operation_0268"
          },
          "definition": "Predict super-secondary structure of protein sequence(s).",
          "has_output": ["http://edamontology.org/data_1277"],
          "text": "Protein super-secondary structure prediction"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0269"
          },
          "definition": "Predict and/or classify transmembrane proteins or transmembrane (helical) domains or regions in protein sequences.",
          "text": "Transmembrane protein prediction"
        }],
        "comment": ["Methods might use amino acid composition, local sequence information, multiple sequence alignments, physicochemical features, estimated energy content, statistical algorithms, hidden Markov models, support vector machines, kernel machines, neural networks etc."],
        "data": {
          "uri": "http://edamontology.org/operation_0267"
        },
        "definition": "Predict secondary structure of protein sequences.",
        "exact_synonyms": ["Secondary structure prediction (protein)"],
        "text": "Protein secondary structure prediction"
      }, {
        "children": [{
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_3280"
            },
            "definition": "Recognise named entities, ontology concepts, tags, events, and dictionary terms within documents.",
            "narrow_synonyms": ["Concept mining", "NER", "Entity identification", "Named-entity recognition", "Entity chunking", "Event extraction", "Entity extraction"],
            "text": "Named-entity and concept recognition"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_3907"
          },
          "definition": "Extract structured information from unstructured (\"free\") or semi-structured textual documents.",
          "exact_synonyms": ["IE"],
          "text": "Information extraction"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_2422"
            },
            "definition": "Retrieve an entry (or part of an entry) from a data resource that matches a supplied query. This might include some primary data and annotation. The query is a data identifier or other indexed term. For example, retrieve a sequence record with the specified accession number, or matching supplied keywords.",
            "exact_synonyms": ["Retrieval", "Data extraction"],
            "has_input": ["http://edamontology.org/data_0842"],
            "narrow_synonyms": ["Metadata retrieval", "Data retrieval (metadata)"],
            "text": "Data retrieval"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_3908"
          },
          "definition": "Retrieve resources from information systems matching a specific information need.",
          "text": "Information retrieval"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3625"
          },
          "definition": "Identify semantic relations among entities and concepts within a text, using text mining techniques.",
          "exact_synonyms": ["Relationship inference", "Relationship extraction", "Relation inference", "Relation discovery", "Relationship discovery"],
          "text": "Relation extraction"
        }],
        "data": {
          "uri": "http://edamontology.org/operation_0306"
        },
        "definition": "Process and analyse text (typically scientific literature) to extract information from it.",
        "exact_synonyms": ["Literature mining", "Text data mining", "Text analytics"],
        "has_input": ["http://edamontology.org/data_3671"],
        "has_output": ["http://edamontology.org/data_0972"],
        "has_topic": ["http://edamontology.org/topic_0218"],
        "text": "Text mining"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_2437"
        },
        "definition": "Predict a network of gene regulation.",
        "text": "Gene regulatory network prediction"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/operation_0309"
          },
          "definition": "Predict and/or optimize oligonucleotide probes for DNA microarrays, for example for transcription profiling of genes, or for genomes and gene families.",
          "exact_synonyms": ["Microarray probe prediction"],
          "has_input": ["http://edamontology.org/data_2977"],
          "has_output": ["http://edamontology.org/data_2717"],
          "has_topic": ["http://edamontology.org/topic_0203", "http://edamontology.org/topic_0632"],
          "text": "Microarray probe design"
        }, {
          "comment": ["This includes predicting primers based on gene structure, promoters, exon-exon junctions, predicting primers that are conserved across multiple genomes or species, primers for for gene transcription profiling,  for genotyping polymorphisms, for example single nucleotide polymorphisms (SNPs),  for large scale sequencing, or for methylation PCRs.", "Primer design involves predicting or selecting primers that are specific to a provided PCR template. Primers can be designed with certain properties such as size of product desired, primer size etc. The output might be a minimal or overlapping primer set."],
          "data": {
            "uri": "http://edamontology.org/operation_0308"
          },
          "definition": "Design or predict oligonucleotide primers for PCR and DNA amplification etc.",
          "exact_synonyms": ["PCR primer prediction", "Primer design"],
          "has_input": ["http://edamontology.org/data_2977"],
          "has_output": ["http://edamontology.org/data_1240"],
          "has_topic": ["http://edamontology.org/topic_0632"],
          "narrow_synonyms": ["PCR primer design (for gene transcription profiling)", "PCR primer design (for methylation PCRs)", "PCR primer design (for large scale sequencing)", "PCR primer design (for conserved primers)", "PCR primer design (for genotyping polymorphisms)", "Primer quality estimation", "PCR primer design (based on gene structure)"],
          "text": "PCR primer design"
        }],
        "data": {
          "uri": "http://edamontology.org/operation_2419"
        },
        "definition": "Predict oligonucleotide primers or probes.",
        "exact_synonyms": ["Primer and probe prediction"],
        "has_topic": ["http://edamontology.org/topic_0632"],
        "text": "Primer and probe design"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_3929"
        },
        "definition": "Predict a metabolic pathway.",
        "text": "Metabolic pathway prediction"
      }, {
        "children": [{
          "comment": ["Methods might use sequence motifs and features, amino acid composition, profiles, machine-learned classifiers, etc."],
          "data": {
            "uri": "http://edamontology.org/operation_0418"
          },
          "definition": "Detect or predict signal peptides and signal peptide cleavage sites in protein sequences.",
          "has_topic": ["http://edamontology.org/topic_0140"],
          "text": "Protein signal peptide detection"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_2464"
            },
            "definition": "Identify or predict protein-protein binding sites.",
            "exact_synonyms": ["Protein-protein binding site detection"],
            "has_output": ["http://edamontology.org/data_0906"],
            "has_topic": ["http://edamontology.org/topic_0128"],
            "text": "Protein-protein binding site prediction"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3898"
            },
            "definition": "Predict or detect metal ion-binding sites in proteins.",
            "exact_synonyms": ["Protein metal-binding site prediction", "Metal-binding site detection"],
            "text": "Metal-binding site prediction"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/operation_3903"
              },
              "definition": "Predict or detect DNA-binding sites in protein sequences.",
              "exact_synonyms": ["Protein-DNA binding site detection", "Protein-DNA binding site prediction"],
              "narrow_synonyms": ["DNA binding site detection"],
              "text": "DNA binding site prediction"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_3902"
              },
              "definition": "Predict or detect RNA-binding sites in protein sequences.",
              "exact_synonyms": ["RNA binding site detection", "Protein-RNA binding site detection", "Protein-RNA binding site prediction"],
              "text": "RNA binding site prediction"
            }],
            "comment": ["This includes methods that predict and optimise zinc finger protein domains for DNA/RNA binding (for example for transcription factors and nucleases)."],
            "data": {
              "uri": "http://edamontology.org/operation_0420"
            },
            "definition": "Predict or detect RNA and DNA-binding binding sites in protein sequences.",
            "exact_synonyms": ["Protein-nucleic acid binding site prediction", "Protein-nucleic acid binding detection", "Protein-nucleic acid binding prediction", "Protein-nucleic acid binding site detection"],
            "narrow_synonyms": ["Zinc finger prediction"],
            "text": "Nucleic acids-binding site prediction"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3896"
            },
            "definition": "Predict or detect active sites in proteins; the region of an enzyme which binds a substrate bind and catalyses a reaction.",
            "narrow_synonyms": ["Active site detection"],
            "text": "Active site prediction"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3897"
            },
            "definition": "Predict or detect ligand-binding sites in proteins; a region of a protein which reversibly binds a ligand for some biochemical purpose, such as transport or regulation of protein function.",
            "narrow_synonyms": ["Ligand-binding site detection", "Peptide-protein binding prediction"],
            "text": "Ligand-binding site prediction"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_2575"
          },
          "definition": "Identify or predict catalytic residues, active sites or other ligand-binding sites in protein sequences or structures.",
          "exact_synonyms": ["Protein binding site detection", "Protein binding site prediction"],
          "has_topic": ["http://edamontology.org/topic_0128"],
          "text": "Binding site prediction"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_0470"
            },
            "definition": "Predict open coils, non-regular secondary structure and intrinsically disordered / unstructured regions of protein sequences.",
            "text": "Protein secondary structure prediction (coils)"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0469"
            },
            "definition": "Predict turn structure (for example beta hairpin turns) of protein sequences.",
            "text": "Protein secondary structure prediction (turns)"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0468"
            },
            "definition": "Predict helical secondary structure of protein sequences.",
            "text": "Protein secondary structure prediction (helices)"
          }, {
            "comment": ["Super-secondary structures include leucine zippers, coiled coils, Helix-Turn-Helix etc."],
            "data": {
              "uri": "http://edamontology.org/operation_0268"
            },
            "definition": "Predict super-secondary structure of protein sequence(s).",
            "has_output": ["http://edamontology.org/data_1277"],
            "text": "Protein super-secondary structure prediction"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0269"
            },
            "definition": "Predict and/or classify transmembrane proteins or transmembrane (helical) domains or regions in protein sequences.",
            "text": "Transmembrane protein prediction"
          }],
          "comment": ["Methods might use amino acid composition, local sequence information, multiple sequence alignments, physicochemical features, estimated energy content, statistical algorithms, hidden Markov models, support vector machines, kernel machines, neural networks etc."],
          "data": {
            "uri": "http://edamontology.org/operation_0267"
          },
          "definition": "Predict secondary structure of protein sequences.",
          "exact_synonyms": ["Secondary structure prediction (protein)"],
          "text": "Protein secondary structure prediction"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_0390"
            },
            "definition": "Decompose a structure into compact or globular fragments (protein peeling).",
            "text": "Protein peeling"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_0246"
          },
          "definition": "Identify structural domains in a protein structure from first principles (for example calculations on structural compactness).",
          "has_topic": ["http://edamontology.org/topic_0736"],
          "text": "Protein domain recognition"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3904"
          },
          "definition": "Identify or predict intrinsically disordered regions in proteins.",
          "has_topic": ["http://edamontology.org/topic_3301"],
          "text": "Protein disorder prediction"
        }, {
          "comment": ["Epitope mapping is commonly done during vaccine design."],
          "data": {
            "uri": "http://edamontology.org/operation_0416"
          },
          "definition": "Predict antigenic determinant sites (epitopes) in protein sequences.",
          "exact_synonyms": ["Antibody epitope prediction", "Epitope prediction"],
          "has_topic": ["http://edamontology.org/topic_0804"],
          "narrow_synonyms": ["T cell epitope prediction", "Epitope mapping (MHC Class II)", "T cell epitope mapping", "B cell epitope prediction", "Epitope mapping (MHC Class I)", "B cell epitope mapping"],
          "text": "Epitope mapping"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0471"
          },
          "definition": "Predict cysteine bonding state and disulfide bond partners in protein sequences.",
          "text": "Disulfide bond prediction"
        }, {
          "comment": ["This includes conserved substructures and conserved geometry, such as spatial arrangement of secondary structure or protein backbone. Methods might use structure alignment, structural templates, searches for similar electrostatic potential and molecular surface shape, surface-mapping of phylogenetic information etc."],
          "data": {
            "uri": "http://edamontology.org/operation_0245"
          },
          "definition": "Identify or screen for 3D structural motifs in protein structure(s).",
          "exact_synonyms": ["Protein structural feature identification", "Protein structural motif recognition"],
          "has_topic": ["http://edamontology.org/topic_0166"],
          "text": "Structural motif discovery"
        }, {
          "children": [{
            "comment": ["Use this concept for methods that evaluate sequence-structure compatibility by assessing residue interactions in 3D. Methods might perform one-to-one, one-to-many or many-to-many comparisons."],
            "data": {
              "uri": "http://edamontology.org/operation_0302"
            },
            "definition": "Align molecular sequence to structure in 3D space (threading).",
            "exact_synonyms": ["Sequence-structure alignment"],
            "has_input": ["http://edamontology.org/data_1460"],
            "has_output": ["http://edamontology.org/data_0893"],
            "narrow_synonyms": ["Sequence-3D profile alignment", "Sequence-to-3D-profile alignment"],
            "text": "Protein threading"
          }],
          "comment": ["Methods use some type of mapping between sequence and fold, for example secondary structure prediction and alignment, profile comparison, sequence properties, homologous sequence search, kernel machines etc. Domains and folds might be taken from SCOP or CATH."],
          "data": {
            "uri": "http://edamontology.org/operation_0303"
          },
          "definition": "Recognize (predict and identify) known protein structural domains or folds in protein sequence(s) which (typically) are not accompanied by any significant sequence similarity to know structures.",
          "exact_synonyms": ["Protein fold recognition", "Fold prediction", "Protein domain prediction", "Domain prediction", "Protein fold prediction"],
          "text": "Fold recognition"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0422"
          },
          "definition": "Detect or predict cleavage sites (enzymatic or chemical) in protein sequences.",
          "has_topic": ["http://edamontology.org/topic_0121"],
          "text": "Protein cleavage site prediction"
        }, {
          "comment": ["Methods might predict sites of methylation, N-terminal myristoylation, N-terminal acetylation, sumoylation, palmitoylation, phosphorylation, sulfation, glycosylation, glycosylphosphatidylinositol (GPI) modification sites (GPI lipid anchor signals) etc."],
          "data": {
            "uri": "http://edamontology.org/operation_0417"
          },
          "definition": "Predict post-translation modification sites in protein sequences.",
          "exact_synonyms": ["PTM analysis", "PTM site analysis", "Post-translational modification site prediction", "Post-translation modification site prediction", "Post-translational modification analysis", "PTM prediction", "Protein post-translation modification site prediction"],
          "has_topic": ["http://edamontology.org/topic_0601"],
          "narrow_synonyms": ["Succinylation prediction", "Ubiquitination site prediction", "Acetylation site prediction", "Methylation site prediction", "Phosphosite localization", "Hydroxylation prediction", "N-terminal acetylation prediction", "S-nitrosylation site prediction", "Acetylation prediction", "Sulfation site prediction", "Phosphoglycerylation prediction", "GPI anchor prediction", "Pupylation prediction", "Prenylation prediction", "GPI modification prediction", "Tyrosine nitration site prediction", "Methylation prediction", "N-myristoylation site prediction", "Succinylation site prediction", "Glycosylation prediction", "Phosphorylation prediction", "Phosphoglycerylation site prediction", "Pupylation site prediction", "S-sulfenylation site prediction", "Palmitoylation prediction", "Palmitoylation site prediction", "N-myristoylation prediction", "S-nitrosylation prediction", "Sumoylation site prediction", "N-terminal acetylation site prediction", "Tyrosine nitration prediction", "Phosphorylation site prediction", "N-terminal myristoylation prediction", "Glycosylation site prediction", "Dephosphorylation site prediction", "Ubiquitination prediction", "GPI anchor site prediction", "GPI modification site prediction", "Dephosphorylation prediction", "N-terminal myristoylation site prediction", "S-sulfenylation prediction", "Sumoylation prediction", "Sulfation prediction", "Prenylation site prediction", "Hydroxylation site prediction"],
          "text": "PTM site prediction"
        }, {
          "comment": ["An adhesin is a cell-surface component that facilitate the adherence of a microorganism to a cell or surface. They are important virulence factors during establishment of infection and thus are targetted during vaccine development approaches that seek to block adhesin function and prevent adherence to host cell."],
          "data": {
            "uri": "http://edamontology.org/operation_3968"
          },
          "definition": "Predict adhesins in protein sequences.",
          "has_topic": ["http://edamontology.org/topic_0804"],
          "text": "Adhesin prediction"
        }],
        "comment": ["Features includes functional sites or regions, secondary structure, structural domains and so on. Methods might use fingerprints, motifs, profiles, hidden Markov models, sequence alignment etc to provide a mapping of a query protein sequence to a discriminatory element. This includes methods that search a secondary protein database (Prosite, Blocks, ProDom, Prints, Pfam etc.) to assign a protein sequence(s) to a known protein family or group."],
        "data": {
          "uri": "http://edamontology.org/operation_3092"
        },
        "definition": "Predict, recognise and identify positional features in proteins from analysing protein sequences or structures.",
        "exact_synonyms": ["Protein feature prediction", "Protein feature recognition"],
        "has_output": ["http://edamontology.org/data_1277"],
        "has_topic": ["http://edamontology.org/topic_0078", "http://edamontology.org/topic_0160"],
        "narrow_synonyms": ["Sequence feature detection (protein)", "Protein site recognition", "Sequence profile database search", "Protein secondary database search", "Protein site prediction", "Protein site detection"],
        "text": "Protein feature detection"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_3904"
        },
        "definition": "Identify or predict intrinsically disordered regions in proteins.",
        "has_topic": ["http://edamontology.org/topic_3301"],
        "text": "Protein disorder prediction"
      }, {
        "children": [{
          "comment": ["Methods might use RNA motifs, predicted intermolecular contacts, or RNA sequence-structure compatibility (inverse RNA folding)."],
          "data": {
            "uri": "http://edamontology.org/operation_0278"
          },
          "definition": "Predict RNA secondary structure (for example knots, pseudoknots, alternative structures etc).",
          "has_output": ["http://edamontology.org/data_0880"],
          "narrow_synonyms": ["RNA shape prediction"],
          "text": "RNA secondary structure prediction"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0279"
          },
          "definition": "Analyse some aspect of RNA/DNA folding, typically by processing sequence and/or structural data.  For example, compute folding energies such as minimum folding energies for DNA or RNA sequences or energy landscape of RNA mutants.",
          "exact_synonyms": ["Nucleic acid folding", "Nucleic acid folding modelling", "Nucleic acid folding prediction"],
          "has_output": ["http://edamontology.org/data_1596"],
          "narrow_synonyms": ["Nucleic acid folding energy calculation"],
          "text": "Nucleic acid folding analysis"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_2441"
          },
          "definition": "Predict RNA tertiary structure.",
          "has_output": ["http://edamontology.org/data_1465"],
          "text": "RNA structure prediction"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_2442"
          },
          "definition": "Predict DNA tertiary structure.",
          "has_output": ["http://edamontology.org/data_1464"],
          "text": "DNA structure prediction"
        }],
        "comment": ["Methods might identify thermodynamically stable or evolutionarily conserved structures."],
        "data": {
          "uri": "http://edamontology.org/operation_0475"
        },
        "definition": "Predict structure of DNA or RNA.",
        "has_output": ["http://edamontology.org/data_1459"],
        "text": "Nucleic acid structure prediction"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_3767"
        },
        "definition": "Identification of protein, for example from one or more peptide identifications by tandem mass spectrometry.",
        "exact_synonyms": ["Protein inference"],
        "has_input": ["http://edamontology.org/data_0943"],
        "text": "Protein identification"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/operation_0476"
          },
          "definition": "Predict tertiary structure of protein sequence(s) without homologs of known structure.",
          "exact_synonyms": ["de novo structure prediction"],
          "text": "Ab initio structure prediction"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_0481"
            },
            "definition": "Model loop conformation in protein structures.",
            "exact_synonyms": ["Protein modelling (loops)", "Protein loop modelling"],
            "text": "Loop modelling"
          }, {
            "comment": ["This includes rotamer likelihood prediction: the prediction of rotamer likelihoods for all 20 amino acid types at each position in a protein structure, where output typically includes, for each residue position, the likelihoods for the 20 amino acid types with estimated reliability of the 20 likelihoods.", "Methods might use a residue rotamer library.", "Antibody optimisation is to optimize the antibody-interacting surface of the antigen (epitope).  Antigen optimisation is to optimize the antigen-interacting surface of the antibody (paratope). Antigen resurfacing is to resurface the antigen by varying the sequence of non-epitope regions."],
            "data": {
              "uri": "http://edamontology.org/operation_0480"
            },
            "definition": "Model, analyse or edit amino acid side chain conformation in protein structure, optimize side-chain packing, hydrogen bonding etc.",
            "exact_synonyms": ["Protein modelling (side chains)"],
            "narrow_synonyms": ["Antigen resurfacing", "Antibody optimisation", "Rotamer likelihood prediction", "Antigen optimisation"],
            "text": "Side chain modelling"
          }, {
            "comment": ["Methods might require a preliminary C(alpha) trace.", "Scaffold selection, scaffold search, epitope grafting and design optimization are stages of backbone modelling done during rational vaccine design."],
            "data": {
              "uri": "http://edamontology.org/operation_0479"
            },
            "definition": "Model protein backbone conformation.",
            "exact_synonyms": ["Protein modelling (backbone)"],
            "narrow_synonyms": ["Epitope grafting", "Scaffold selection", "Scaffold search", "Design optimization"],
            "text": "Backbone modelling"
          }],
          "comment": ["The model might be of a whole, part or aspect of protein structure. Molecular modelling methods might use sequence-structure alignment, structural templates, molecular dynamics, energy minimisation etc."],
          "data": {
            "uri": "http://edamontology.org/operation_0477"
          },
          "definition": "Build a three-dimensional protein model based on known (for example homologs) structures.",
          "exact_synonyms": ["Comparative modelling", "Homology modelling", "Protein structure comparative modelling", "Homology structure modelling"],
          "has_topic": ["http://edamontology.org/topic_2275"],
          "text": "Protein modelling"
        }],
        "data": {
          "uri": "http://edamontology.org/operation_0474"
        },
        "definition": "Predict tertiary structure (backbone and side-chain conformation) of protein sequences.",
        "has_output": ["http://edamontology.org/data_1460"],
        "narrow_synonyms": ["Protein folding pathway prediction"],
        "text": "Protein structure prediction"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_3482"
        },
        "definition": "Identify or predict causes for antibiotic resistance from molecular sequence analysis.",
        "has_topic": ["http://edamontology.org/topic_3301"],
        "text": "Antimicrobial resistance prediction"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_2476"
        },
        "definition": "The simulation of molecular (typically protein) conformation using a computational model of physical forces and computer simulation.",
        "exact_synonyms": ["Molecular dynamics simulation"],
        "has_output": ["http://edamontology.org/data_0883"],
        "has_topic": ["http://edamontology.org/topic_0176", "http://edamontology.org/topic_0082"],
        "narrow_synonyms": ["Protein dynamics"],
        "text": "Molecular dynamics"
      }, {
        "children": [{
          "comment": ["This includes methods that generate a graphical rendering of antigenicity of a protein, such as a Hopp and Woods plot.", "This is usually done in the development of peptide-specific antibodies or multi-epitope vaccines. Methods might use sequence data (for example motifs) and / or structural data.", "Immunological system are cellular or humoral. In vaccine design to induces a cellular immune response, methods must search for antigens that can be recognized by the major histocompatibility complex (MHC) molecules present in T lymphocytes.  If a humoral response is required, antigens for B cells must be identified."],
          "data": {
            "uri": "http://edamontology.org/operation_0252"
          },
          "definition": "Predict antigenicity, allergenicity / immunogenicity, allergic cross-reactivity etc of peptides and proteins.",
          "exact_synonyms": ["Antigenicity prediction", "Immunogenicity prediction"],
          "has_output": ["http://edamontology.org/data_1534"],
          "has_topic": ["http://edamontology.org/topic_0804"],
          "narrow_synonyms": ["Hopp and Woods plotting", "MHC peptide immunogenicity prediction", "B cell peptide immunogenicity prediction"],
          "text": "Peptide immunogenicity prediction"
        }, {
          "children": [{
            "comment": ["Principal Component Analysis (PCA) is a multivariate statistical analysis to obtain collective variables and reduce the dimensionality of the system."],
            "data": {
              "uri": "http://edamontology.org/operation_3891"
            },
            "definition": "Compute Essential Dynamics (ED) on a simulation trajectory: an analysis of molecule dynamics using PCA (Principal Component Analysis) applied to the atomic positional fluctuations.",
            "exact_synonyms": ["Principal modes", "ED", "PCA"],
            "text": "Essential dynamics"
          }],
          "comment": ["Use this concept for analysis of flexible and rigid residues, local chain deformability, regions undergoing conformational change, molecular vibrations or fluctuational dynamics, domain motions or other large-scale structural transitions in a protein structure."],
          "data": {
            "uri": "http://edamontology.org/operation_0244"
          },
          "definition": "Analyse flexibility and motion in protein structure.",
          "exact_synonyms": ["Trajectory analysis", "CG analysis", "Protein Dynamics Analysis", "MD analysis"],
          "narrow_synonyms": ["Protein motion prediction", "Protein flexibility prediction", "Protein flexibility and motion analysis", "Nucleic Acid Dynamics Analysis"],
          "text": "Simulation analysis"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_2929"
            },
            "definition": "Calculate the molecular weight of a protein (or fragments) and compare it to another protein or reference data. Generally used for protein identification.",
            "exact_synonyms": ["Peptide mass fingerprinting", "PMF", "Protein fingerprinting"],
            "text": "Protein fragment weight comparison"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_0398"
          },
          "definition": "Calculate the molecular weight of a protein sequence or fragments.",
          "exact_synonyms": ["Peptide mass calculation"],
          "has_output": ["http://edamontology.org/data_1519"],
          "has_topic": ["http://edamontology.org/topic_0121"],
          "text": "Protein molecular weight calculation"
        }, {
          "comment": ["Methods usually involve multiple sequence alignment analysis."],
          "data": {
            "uri": "http://edamontology.org/operation_0272"
          },
          "definition": "Predict contacts, non-covalent interactions and distance (constraints) between amino acids in protein sequences.",
          "exact_synonyms": ["Residue interaction prediction"],
          "has_topic": ["http://edamontology.org/topic_0130"],
          "narrow_synonyms": ["Contact map prediction", "Protein contact map prediction"],
          "text": "Residue contact prediction"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0386"
          },
          "definition": "Calculate whether a protein structure has an unusually large net charge (dipole moment).",
          "has_output": ["http://edamontology.org/data_1545"],
          "text": "Protein dipole moment calculation"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0334"
          },
          "definition": "Calculate Km, Vmax and derived data for an enzyme reaction.",
          "has_output": ["http://edamontology.org/data_2024"],
          "has_topic": ["http://edamontology.org/topic_0821"],
          "text": "Enzyme kinetics calculation"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_0396"
            },
            "definition": "Calculate a Ramachandran plot of a protein structure.",
            "has_output": ["http://edamontology.org/data_1544"],
            "text": "Ramachandran plot calculation"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_0249"
          },
          "definition": "Calculate, visualise or analyse phi/psi angles of a protein structure.",
          "has_output": ["http://edamontology.org/data_2991"],
          "narrow_synonyms": ["Backbone torsion angle calculation", "Tau angle calculation", "Cysteine torsion angle calculation", "Torsion angle calculation"],
          "text": "Protein geometry calculation"
        }, {
          "comment": ["A 3D-1D scoring matrix scores the probability of amino acids occurring in different structural environments."],
          "data": {
            "uri": "http://edamontology.org/operation_2239"
          },
          "definition": "Calculate a 3D-1D scoring matrix from analysis of protein sequence and structural data.",
          "exact_synonyms": ["3D-1D scoring matrix construction"],
          "has_output": ["http://edamontology.org/data_1499"],
          "has_topic": ["http://edamontology.org/topic_0081"],
          "text": "3D-1D scoring matrix generation"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3860"
          },
          "definition": "Calculate a theoretical mass spectrometry spectra for given sequences.",
          "exact_synonyms": ["Spectrum prediction"],
          "has_input": ["http://edamontology.org/data_0943"],
          "text": "Spectrum calculation"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_0409"
            },
            "definition": "Predict the solubility or atomic solvation energy of a protein sequence.",
            "has_output": ["http://edamontology.org/data_1524"],
            "text": "Protein solubility prediction"
          }, {
            "comment": ["Hydrophobic moment is a peptides hydrophobicity measured for different angles of rotation."],
            "data": {
              "uri": "http://edamontology.org/operation_0407"
            },
            "definition": "Calculate the hydrophobic moment of a peptide sequence and recognize amphiphilicity.",
            "has_output": ["http://edamontology.org/data_1520"],
            "text": "Protein hydrophobic moment plotting"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0408"
            },
            "definition": "Predict the stability or globularity of a protein sequence, whether it is intrinsically unfolded etc.",
            "has_output": ["http://edamontology.org/data_1526"],
            "text": "Protein globularity prediction"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0406"
            },
            "definition": "Calculate aliphatic index (relative volume occupied by aliphatic side chains) of a protein.",
            "has_output": ["http://edamontology.org/data_1521"],
            "text": "Protein aliphatic index calculation"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0410"
            },
            "definition": "Predict crystallizability of a protein sequence.",
            "has_output": ["http://edamontology.org/data_1525"],
            "text": "Protein crystallizability prediction"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0405"
            },
            "definition": "Calculate hydrophobic or hydrophilic / charged regions of a protein sequence.",
            "text": "Protein hydrophobic region calculation"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_2574"
          },
          "definition": "Analyse the hydrophobic, hydrophilic or charge properties of a protein (from analysis of sequence or structural information).",
          "has_output": ["http://edamontology.org/data_2970"],
          "has_topic": ["http://edamontology.org/topic_0123"],
          "text": "Protein hydropathy calculation"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_0402"
            },
            "definition": "Plot a protein titration curve.",
            "has_output": ["http://edamontology.org/data_1527"],
            "text": "Protein titration curve plotting"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0403"
            },
            "definition": "Calculate isoelectric point of a protein sequence.",
            "has_output": ["http://edamontology.org/data_1528"],
            "text": "Protein isoelectric point calculation"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0404"
            },
            "definition": "Estimate hydrogen exchange rate of a protein sequence.",
            "has_output": ["http://edamontology.org/data_1530"],
            "text": "Protein hydrogen exchange rate calculation"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_0400"
          },
          "definition": "Calculate pH-dependent properties from pKa calculations of a protein sequence.",
          "exact_synonyms": ["Protein pH-dependent property calculation"],
          "has_output": ["http://edamontology.org/data_0897"],
          "has_topic": ["http://edamontology.org/topic_0123"],
          "text": "Protein pKa calculation"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0399"
          },
          "definition": "Predict extinction coefficients or optical density of a protein sequence.",
          "has_output": ["http://edamontology.org/data_1531"],
          "text": "Protein extinction coefficient calculation"
        }, {
          "children": [{
            "comment": ["Salt bridges are interactions between oppositely charged atoms in different residues. The output might include the inter-atomic distance."],
            "data": {
              "uri": "http://edamontology.org/operation_1839"
            },
            "definition": "Calculate (and possibly score) salt bridges in a protein structure.",
            "text": "Salt bridge calculation"
          }, {
            "comment": ["The output might include the atoms involved in the bond, bond geometric parameters and bond enthalpy."],
            "data": {
              "uri": "http://edamontology.org/operation_0394"
            },
            "definition": "Identify potential hydrogen bonds between amino acids and other groups.",
            "has_output": ["http://edamontology.org/data_1549"],
            "text": "Hydrogen bond calculation"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_1834"
            },
            "definition": "Calculate protein residue contacts with metal in a structure.",
            "exact_synonyms": ["Residue-metal contact calculation"],
            "text": "Protein-metal contact calculation"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_1831"
            },
            "definition": "Detect cysteines that are bound to metal in a protein structure.",
            "text": "Metal-bound cysteine detection"
          }, {
            "children": [{
              "comment": ["This includes for example clusters of hydrophobic or charged residues, or clusters of contacting residues which have a key structural or functional role."],
              "data": {
                "uri": "http://edamontology.org/operation_0393"
              },
              "definition": "Calculate clusters of contacting residues in protein structures.",
              "has_output": ["http://edamontology.org/data_1548"],
              "text": "Residue cluster calculation"
            }, {
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/operation_0392"
                },
                "definition": "Calculate a residue contact map (typically all-versus-all inter-residue contacts) for a protein structure.",
                "exact_synonyms": ["Protein contact map calculation"],
                "has_output": ["http://edamontology.org/data_1547"],
                "text": "Contact map calculation"
              }],
              "data": {
                "uri": "http://edamontology.org/operation_0391"
              },
              "definition": "Calculate a matrix of distance between residues (for example the C-alpha atoms) in a protein structure.",
              "has_output": ["http://edamontology.org/data_1546"],
              "text": "Protein distance matrix calculation"
            }],
            "comment": ["This includes identifying HET groups, which usually correspond to ligands, lipids, but might also (not consistently) include groups that are attached to amino acids. Each HET group is supposed to have a unique three letter code and a unique name which might be given in the output.  It can also include calculation of symmetry contacts, i.e. a contact between two atoms in different asymmetric unit."],
            "data": {
              "uri": "http://edamontology.org/operation_2950"
            },
            "definition": "Calculate contacts between residues, or between residues and other groups, in a protein structure, on the basis of distance calculations.",
            "narrow_synonyms": ["HET group detection", "Residue contact calculation (residue-nucleic acid)", "Residue contact calculation (residue-metal)", "Residue contact calculation (residue-negative ion)", "WHATIF:SymmetryContact", "Residue contact calculation (residue-ligand)"],
            "text": "Residue distance calculation"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_0248"
          },
          "definition": "Calculate or extract inter-atomic, inter-residue or residue-atom contacts, distances and interactions in protein structure(s).",
          "has_topic": ["http://edamontology.org/topic_0130"],
          "text": "Residue interaction calculation"
        }],
        "comment": ["This includes methods to render and visualise the properties of a protein sequence, and a residue-level search for properties such as solvent accessibility, hydropathy, secondary structure, ligand-binding etc."],
        "data": {
          "uri": "http://edamontology.org/operation_0250"
        },
        "definition": "Extract, calculate or predict non-positional (physical or chemical) properties of a protein, including any non-positional properties of the molecular sequence, from processing a protein sequence or 3D structure.",
        "exact_synonyms": ["Protein property rendering"],
        "narrow_synonyms": ["Protein property calculation (from sequence)", "Protein structural property calculation", "Structural property calculation", "Protein property calculation (from structure)"],
        "text": "Protein property calculation"
      }, {
        "children": [{
          "comment": ["Motifs and patterns might be conserved or over-represented (occur with improbable frequency)."],
          "data": {
            "uri": "http://edamontology.org/operation_0238"
          },
          "definition": "Discover new motifs or conserved patterns in sequences or sequence alignments (de-novo discovery).",
          "exact_synonyms": ["Motif discovery"],
          "has_output": ["http://edamontology.org/data_0858"],
          "has_topic": ["http://edamontology.org/topic_0160"],
          "text": "Sequence motif discovery"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0239"
          },
          "definition": "Find (scan for) known motifs, patterns and regular expressions in molecular sequence(s).",
          "exact_synonyms": ["Sequence signature recognition", "Sequence signature detection", "Motif scanning"],
          "has_output": ["http://edamontology.org/data_0858"],
          "has_topic": ["http://edamontology.org/topic_0160"],
          "narrow_synonyms": ["Sequence profile search", "Sequence motif search", "Motif search", "Sequence motif detection", "Motif recognition", "Motif detection"],
          "text": "Sequence motif recognition"
        }],
        "comment": ["Look at \"Protein feature detection\" (http://edamontology.org/operation_3092) and \"Nucleic acid feature detection\" (http://edamontology.org/operation_0415) in case more specific terms are needed."],
        "data": {
          "uri": "http://edamontology.org/operation_0253"
        },
        "definition": "Predict, recognise and identify positional features in molecular sequences such as key functional sites or regions.",
        "exact_synonyms": ["Sequence feature prediction", "Sequence feature recognition"],
        "has_output": ["http://edamontology.org/data_1255"],
        "has_topic": ["http://edamontology.org/topic_0160"],
        "narrow_synonyms": ["Motif database search"],
        "text": "Sequence feature detection"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/operation_0264"
          },
          "definition": "Predict splicing alternatives or transcript isoforms from analysis of sequence data.",
          "exact_synonyms": ["Splice transcript prediction", "Alternative splicing detection", "Differential splicing analysis", "Alternative splicing analysis"],
          "has_topic": ["http://edamontology.org/topic_0114"],
          "text": "Alternative splicing prediction"
        }, {
          "comment": ["Methods might require a pre-mRNA or genomic DNA sequence."],
          "data": {
            "uri": "http://edamontology.org/operation_0433"
          },
          "definition": "Identify, predict or analyse splice sites in nucleotide sequences.",
          "exact_synonyms": ["Splice prediction"],
          "has_topic": ["http://edamontology.org/topic_0114"],
          "text": "Splice site prediction"
        }],
        "data": {
          "uri": "http://edamontology.org/operation_2499"
        },
        "definition": "Predict, analyse, characterize or model splice sites, splicing events and so on, typically by comparing multiple nucleic acid sequences.",
        "exact_synonyms": ["Splicing model analysis"],
        "has_topic": ["http://edamontology.org/topic_0114"],
        "text": "Splicing analysis"
      }],
      "data": {
        "uri": "http://edamontology.org/operation_2423"
      },
      "definition": "Predict, recognise, detect or identify some properties of a biomolecule.",
      "narrow_synonyms": ["Recognition", "Prediction", "Detection"],
      "text": "Prediction and recognition"
    }, {
      "children": [{
        "comment": ["Many sequence alignment tasks involving many or very large sequences rely on a precomputed index of the sequence to accelerate the alignment.  The Burrows-Wheeler Transform (BWT) is a permutation of the genome based on a suffix array algorithm.  A suffix array consists of the lexicographically sorted list of suffixes of a genome."],
        "data": {
          "uri": "http://edamontology.org/operation_3211"
        },
        "definition": "Generate an index of a genome sequence.",
        "has_output": ["http://edamontology.org/data_3210"],
        "narrow_synonyms": ["Genome indexing (suffix arrays)", "Burrows-Wheeler", "Genome indexing (Burrows-Wheeler)", "Suffix arrays"],
        "text": "Genome indexing"
      }],
      "data": {
        "uri": "http://edamontology.org/operation_0227"
      },
      "definition": "Generate an index of (typically a file of) biological data.",
      "exact_synonyms": ["Data indexing", "Database indexing"],
      "has_output": ["http://edamontology.org/data_0955"],
      "text": "Indexing"
    }, {
      "children": [{
        "children": [{
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_3704"
            },
            "definition": "Label-free quantification by integration of ion current (ion counting).",
            "exact_synonyms": ["Ion current integration"],
            "text": "Ion counting"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3637"
            },
            "definition": "Calculate number of identified MS2 spectra as approximation of peptide / protein quantity.",
            "text": "Spectral counting"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_3634"
          },
          "definition": "Quantification without the use of chemical tags.",
          "text": "Label-free quantification"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3636"
          },
          "definition": "Quantification by Selected/multiple Reaction Monitoring workflow (XIC quantitation of precursor / fragment mass pair).",
          "text": "MRM/SRM"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_3639"
            },
            "definition": "Quantification analysis using the AB SCIEX iTRAQ isobaric labelling workflow, wherein 2-8 reporter ions are measured in MS2 spectra near 114 m/z.",
            "text": "iTRAQ"
          }, {
            "comment": ["This includes N-15 metabolic labeling (labeling all proteins and (possibly) all amino acids using N-15 enriched grown medium or feed) and C-13 metabolic labeling (labeling all proteins and (possibly) all amino acids using C-13 enriched grown medium or feed)."],
            "data": {
              "uri": "http://edamontology.org/operation_3715"
            },
            "definition": "Labeling all proteins and (possibly) all amino acids using C-13 or N-15 enriched grown medium or feed.",
            "narrow_synonyms": ["C-13 metabolic labeling", "N-15 metabolic labeling"],
            "text": "Metabolic labeling"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3642"
            },
            "definition": "Quantification analysis using chemical labeling by stable isotope dimethylation",
            "text": "Dimethyl"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3705"
            },
            "definition": "Chemical tagging free amino groups of intact proteins with stable isotopes.",
            "exact_synonyms": ["ICPL"],
            "text": "Isotope-coded protein label"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3640"
            },
            "definition": "Quantification analysis using labeling based on 18O-enriched H2O.",
            "text": "18O labeling"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3641"
            },
            "definition": "Quantification analysis using the Thermo Fisher tandem mass tag labelling workflow.",
            "text": "TMT-tag"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3638"
            },
            "definition": "Quantification analysis using stable isotope labeling by amino acids in cell culture.",
            "text": "SILAC"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_3635"
          },
          "definition": "Quantification based on the use of chemical tags.",
          "text": "Labeled quantification"
        }],
        "data": {
          "uri": "http://edamontology.org/operation_3630"
        },
        "definition": "Technique for determining the amount of proteins in a sample.",
        "exact_synonyms": ["Protein quantitation"],
        "has_input": ["http://edamontology.org/data_0943"],
        "text": "Protein quantification"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_3800"
        },
        "definition": "Quantification of data arising from RNA-Seq high-throughput sequencing, typically the quantification of transcript abundances durnig transcriptome analysis in a gene expression study.",
        "exact_synonyms": ["RNA-Seq quantitation"],
        "text": "RNA-Seq quantification"
      }],
      "data": {
        "uri": "http://edamontology.org/operation_3799"
      },
      "definition": "Counting and measuring experimentally determined observations into quantities.",
      "exact_synonyms": ["Quantitation"],
      "text": "Quantification"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/operation_3463"
        },
        "definition": "Analyse the correlation patterns among features/molecules across across a variety of experiments, samples etc.",
        "exact_synonyms": ["Co-expression analysis"],
        "narrow_synonyms": ["Gene expression correlation", "Gene expression correlation analysis", "Gene co-expression network analysis"],
        "text": "Expression correlation analysis"
      }, {
        "comment": ["This is typically done to identify possible covarying positions and predict contacts or structural constraints in protein structures."],
        "data": {
          "uri": "http://edamontology.org/operation_0449"
        },
        "definition": "Analyse correlations between sites in a molecular sequence alignment.",
        "text": "Sequence alignment analysis (site correlation)"
      }],
      "data": {
        "uri": "http://edamontology.org/operation_3465"
      },
      "definition": "Identify a correlation, i.e. a statistical relationship between two random variables or two sets of data.",
      "has_topic": ["http://edamontology.org/topic_0121"],
      "text": "Correlation"
    }, {
      "children": [{
        "children": [{
          "comment": ["Includes methods that try to suggest the most likely biological unit for a given protein X-ray crystal structure based on crystal symmetry and scoring of putative protein-protein interfaces."],
          "data": {
            "uri": "http://edamontology.org/operation_2475"
          },
          "definition": "Identify the architecture of a protein structure.",
          "text": "Protein architecture recognition"
        }],
        "data": {
          "uri": "http://edamontology.org/operation_2996"
        },
        "definition": "Assign molecular structure(s) to a group or category.",
        "text": "Structure classification"
      }, {
        "comment": ["A micrograph can include particles in multiple different orientations and/or conformations. Particles are compared and organised into sets based on their similarity. Typically iterations of classification and alignment and are performed to optimise the final 3D EM map."],
        "data": {
          "uri": "http://edamontology.org/operation_3458"
        },
        "definition": "Compare (align and classify) multiple particle images from a micrograph in order to produce a representative image of the particle.",
        "text": "Single particle alignment and classification"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/operation_3460"
          },
          "definition": "Classifiication (typically of molecular sequences) by assignment to some taxonomic hierarchy.",
          "exact_synonyms": ["Taxonomy assignment"],
          "narrow_synonyms": ["Taxonomic profiling"],
          "text": "Taxonomic classification"
        }, {
          "comment": ["Variants are typically classified by their position (intronic, exonic, etc.) in a gene transcript and (for variants in coding exons) by their effect on the protein sequence (synonymous, non-synonymous, frameshifting, etc.)"],
          "data": {
            "uri": "http://edamontology.org/operation_3225"
          },
          "definition": "Classify variants based on their potential effect on genes, especially functional effects on the expressed proteins.",
          "text": "Variant classification"
        }],
        "data": {
          "uri": "http://edamontology.org/operation_2995"
        },
        "definition": "Assign molecular sequence(s) to a group or category.",
        "text": "Sequence classification"
      }],
      "data": {
        "uri": "http://edamontology.org/operation_2990"
      },
      "definition": "Assign molecular sequences, structures or other biological data to a specific group or category according to qualities it shares with that group or category.",
      "text": "Classification"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/operation_2089"
        },
        "definition": "Refine an existing sequence alignment.",
        "text": "Sequence alignment refinement"
      }, {
        "children": [{
          "comment": ["The technique solves the phase problem, i.e. retrieve information concern phases of the structure."],
          "data": {
            "uri": "http://edamontology.org/operation_3455"
          },
          "definition": "A technique used to construct an atomic model of an unknown structure from diffraction data, based upon an atomic model of a known structure, either a related protein or the same protein from a different crystal form.",
          "text": "Molecular replacement"
        }, {
          "comment": ["Rigid body refinement usually follows molecular replacement in the assignment of a structure from diffraction data."],
          "data": {
            "uri": "http://edamontology.org/operation_3456"
          },
          "definition": "A method used to refine a structure by moving the whole molecule or parts of it as a rigid unit, rather than moving individual atoms.",
          "text": "Rigid body refinement"
        }],
        "data": {
          "uri": "http://edamontology.org/operation_0322"
        },
        "definition": "Refine (after evaluation) a model of a molecular structure (typically a protein structure) to reduce steric clashes, volume irregularities etc.",
        "narrow_synonyms": ["Protein model refinement"],
        "text": "Molecular model refinement"
      }],
      "data": {
        "uri": "http://edamontology.org/operation_2425"
      },
      "definition": "Refine or optimise some data model.",
      "text": "Optimisation and refinement"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/operation_2943"
        },
        "definition": "Generate a box plot, i.e. a depiction of groups of numerical data through their quartiles.",
        "exact_synonyms": ["Box plot plotting"],
        "narrow_synonyms": ["Microarray Box-Whisker plot plotting"],
        "text": "Box-Whisker plot plotting"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_3552"
        },
        "definition": "Visualise images resulting from various types of microscopy.",
        "has_topic": ["http://edamontology.org/topic_3382"],
        "text": "Microscope image visualisation"
      }, {
        "children": [{
          "comment": ["A stitch profile represents the alternative conformations that partly melted DNA can adopt in a temperature range."],
          "data": {
            "uri": "http://edamontology.org/operation_0457"
          },
          "definition": "Calculate and plot a DNA or DNA/RNA stitch profile.",
          "text": "Nucleic acid stitch profile plotting"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0459"
          },
          "definition": "Calculate and plot a DNA or DNA/RNA probability profile.",
          "text": "Nucleic acid probability profile plotting"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0458"
          },
          "definition": "Calculate and plot a DNA or DNA/RNA melting curve.",
          "text": "Nucleic acid melting curve plotting"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0460"
          },
          "definition": "Calculate and plot a DNA or DNA/RNA temperature profile.",
          "text": "Nucleic acid temperature profile plotting"
        }],
        "comment": ["A melting profile is used to visualise and analyse partly melted DNA conformations."],
        "data": {
          "uri": "http://edamontology.org/operation_0456"
        },
        "definition": "Calculate and plot a DNA or DNA/RNA melting profile.",
        "has_output": ["http://edamontology.org/data_1583"],
        "text": "Nucleic acid melting profile plotting"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_3926"
        },
        "definition": "Render (visualise) a biological pathway.",
        "exact_synonyms": ["Pathway rendering"],
        "has_input": ["http://edamontology.org/data_2600"],
        "text": "Pathway visualisation"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_3503"
        },
        "definition": "Plot an incident curve such as a survival curve, death curve, mortality curve.",
        "text": "Incident curve plotting"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_0567"
        },
        "definition": "Render or visualise a phylogenetic tree.",
        "exact_synonyms": ["Phylogenetic tree rendering"],
        "has_output": ["http://edamontology.org/data_0872"],
        "text": "Phylogenetic tree visualisation"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_0402"
        },
        "definition": "Plot a protein titration curve.",
        "has_output": ["http://edamontology.org/data_1527"],
        "text": "Protein titration curve plotting"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_2940"
        },
        "definition": "Render a graph in which the values of two variables are plotted along two axes; the pattern of the points reveals any correlation.",
        "exact_synonyms": ["Scatter chart plotting"],
        "narrow_synonyms": ["Microarray scatter plot rendering", "Microarray scatter plot plotting"],
        "text": "Scatter plot plotting"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_3203"
        },
        "definition": "Visualise, format or render an image of a Chromatogram.",
        "exact_synonyms": ["Chromatogram viewing"],
        "text": "Chromatogram visualisation"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_3744"
        },
        "definition": "Visualise, format or render data arising from an analysis of multiple samples from a metagenomics/community experiment.",
        "text": "Multiple sample visualisation"
      }, {
        "comment": ["The use of Principal Component Analysis (PCA), a multivariate statistical analysis to obtain collective variables on the atomic positional fluctuations, helps to separate the configurational space in two subspaces: an essential subspace containing relevant motions, and another one containing irrelevant local fluctuations."],
        "data": {
          "uri": "http://edamontology.org/operation_2939"
        },
        "definition": "Visualize the results of a principal component analysis (orthogonal data transformation).  For example, visualization of the principal components (essential subspace) coming from a Principal Component Analysis (PCA) on the trajectory atomistic coordinates of a molecular structure.",
        "exact_synonyms": ["Principal component plotting", "PCA plotting"],
        "narrow_synonyms": ["Microarray principal component plotting", "Microarray principal component rendering", "PCA visualization", "Principal modes visualization", "Essential Dynamics visualization", "ED visualization"],
        "text": "Principal component visualisation"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_3925"
        },
        "definition": "Render (visualise) a network - typically a biological network of some sort.",
        "exact_synonyms": ["Network rendering"],
        "has_input": ["http://edamontology.org/data_2600"],
        "narrow_synonyms": ["Protein interaction network rendering", "Protein interaction network visualisation"],
        "text": "Network visualisation"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_0566"
        },
        "definition": "Visualise, format or render sequence clusters.",
        "exact_synonyms": ["Sequence cluster rendering"],
        "has_input": ["http://edamontology.org/data_1235"],
        "text": "Sequence cluster visualisation"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/operation_2938"
          },
          "definition": "Visualise clustered expression data using a tree diagram.",
          "exact_synonyms": ["Expression data tree visualisation", "Expression data tree or dendrogram rendering", "Dendrograph plotting", "Dendrogram plotting", "Dendrograph visualisation"],
          "narrow_synonyms": ["Microarray checks view rendering", "Microarray 2-way dendrogram rendering", "Microarray tree or dendrogram rendering", "Microarray matrix tree plot rendering"],
          "text": "Dendrogram visualisation"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_2937"
          },
          "definition": "Generate a plot of distances (distance or correlation matrix) between expression values.",
          "exact_synonyms": ["Distance matrix rendering", "Distance matrix plotting", "Proximity map rendering", "Distance map rendering"],
          "narrow_synonyms": ["Microarray proximity map rendering", "Correlation matrix plotting", "Microarray distance map rendering", "Correlation matrix rendering", "Microarray proximity map plotting"],
          "text": "Proximity map plotting"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_2935"
          },
          "definition": "Visualise clustered quantitative data as set of different profiles, where each profile is plotted versus different entities or samples on the X-axis.",
          "exact_synonyms": ["Clustered quantitative data rendering", "Wave graph plotting", "Clustered quantitative data plotting"],
          "narrow_synonyms": ["Microarray wave graph rendering", "Microarray cluster temporal graph rendering", "Microarray wave graph plotting"],
          "text": "Clustering profile plotting"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_2942"
          },
          "definition": "Visualise gene expression data after hierarchical clustering for representing hierarchical relationships.",
          "exact_synonyms": ["Treemapping", "Expression data tree-map rendering"],
          "narrow_synonyms": ["Microarray tree-map rendering"],
          "text": "Treemap visualisation"
        }, {
          "comment": ["The heat map usually uses a coloring scheme to represent expression values. They can show how quantitative measurements were influenced by experimental conditions."],
          "data": {
            "uri": "http://edamontology.org/operation_0531"
          },
          "definition": "Generate a heat map of expression data from e.g. microarray data.",
          "exact_synonyms": ["Heat map construction", "Heatmap generation"],
          "has_output": ["http://edamontology.org/data_1636"],
          "text": "Heat map generation"
        }],
        "data": {
          "uri": "http://edamontology.org/operation_0571"
        },
        "definition": "Visualise microarray or other expression data.",
        "exact_synonyms": ["Expression data rendering"],
        "has_input": ["http://edamontology.org/data_3117"],
        "narrow_synonyms": ["Microarray data rendering", "Gene expression data visualisation"],
        "text": "Expression data visualisation"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/operation_3184"
          },
          "definition": "Render and visualise a DNA sequence assembly.",
          "exact_synonyms": ["Assembly visualisation", "Assembly rendering", "Sequence assembly rendering"],
          "text": "Sequence assembly visualisation"
        }, {
          "comment": ["Hydrophobic moment is a peptides hydrophobicity measured for different angles of rotation."],
          "data": {
            "uri": "http://edamontology.org/operation_0407"
          },
          "definition": "Calculate the hydrophobic moment of a peptide sequence and recognize amphiphilicity.",
          "has_output": ["http://edamontology.org/data_1520"],
          "text": "Protein hydrophobic moment plotting"
        }, {
          "comment": ["Dot plots are useful when having not too many (e.g. 20) data points for each category. Example: draw a dotplot of sequence similarities identified from word-matching or character comparison."],
          "data": {
            "uri": "http://edamontology.org/operation_0490"
          },
          "definition": "Render a representation of a distribution that consists of group of data points plotted on a simple scale.",
          "exact_synonyms": ["Categorical plot plotting", "Dotplot plotting"],
          "has_output": ["http://edamontology.org/data_0862"],
          "text": "Dot plot plotting"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0287"
          },
          "definition": "Identify and plot third base position variability in a nucleotide sequence.",
          "has_output": ["http://edamontology.org/data_1263"],
          "has_topic": ["http://edamontology.org/topic_0114"],
          "text": "Base position variability plotting"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3208"
          },
          "definition": "Visualise, format or render a nucleic acid sequence that is part of (and in context of) a complete genome sequence.",
          "exact_synonyms": ["Genome viewing", "Genome rendering", "Genome browsing", "Genome browser"],
          "text": "Genome visualisation"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_2284"
          },
          "definition": "Calculate a density plot (of base composition) for a nucleotide sequence.",
          "text": "Nucleic acid density plotting"
        }],
        "data": {
          "uri": "http://edamontology.org/operation_0564"
        },
        "definition": "Visualise, format or render a molecular sequence or sequences such as a sequence alignment, possibly with sequence features or properties shown.",
        "exact_synonyms": ["Sequence rendering"],
        "has_input": ["http://edamontology.org/data_2044"],
        "has_output": ["http://edamontology.org/data_2969"],
        "narrow_synonyms": ["Sequence alignment visualisation"],
        "text": "Sequence visualisation"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_3559"
        },
        "definition": "Visualise, format or render data from an ontology, typically a tree of terms.",
        "exact_synonyms": ["Ontology browsing"],
        "text": "Ontology visualisation"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_3694"
        },
        "definition": "Visualise, format or render a mass spectrum.",
        "text": "Mass spectrum visualisation"
      }, {
        "children": [{
          "comment": ["A dot has three coordinates (x,y,z) and (typically) a color."],
          "data": {
            "uri": "http://edamontology.org/operation_1816"
          },
          "definition": "Calculate the positions of dots that are homogeneously distributed over the surface of a molecule.",
          "text": "Surface rendering"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_2241"
          },
          "definition": "Visualise transmembrane proteins, typically the transmembrane regions within a sequence.",
          "exact_synonyms": ["Transmembrane protein rendering"],
          "has_output": ["http://edamontology.org/data_2992"],
          "text": "Transmembrane protein visualisation"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3890"
          },
          "definition": "3D visualization of a molecular trajectory.",
          "has_output": ["http://edamontology.org/data_2162"],
          "text": "Trajectory visualization"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_2485"
          },
          "definition": "Render a helical wheel representation of protein secondary structure.",
          "exact_synonyms": ["Helical wheel rendering"],
          "has_output": ["http://edamontology.org/data_2162"],
          "text": "Helical wheel drawing"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_2486"
          },
          "definition": "Render a topology diagram of protein secondary structure.",
          "exact_synonyms": ["Topology diagram rendering"],
          "has_output": ["http://edamontology.org/data_2992"],
          "text": "Topology diagram drawing"
        }],
        "comment": ["This includes visualisation of protein secondary structure such as knots, pseudoknots etc. as well as tertiary and quaternary structure."],
        "data": {
          "uri": "http://edamontology.org/operation_0570"
        },
        "definition": "Visualise or render molecular 3D structure, for example a high-quality static picture or animation.",
        "exact_synonyms": ["Structure rendering"],
        "has_input": ["http://edamontology.org/data_0883"],
        "has_output": ["http://edamontology.org/data_1710"],
        "narrow_synonyms": ["RNA secondary structure visualisation", "Protein secondary structure visualisation"],
        "text": "Structure visualisation"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/operation_0579"
          },
          "definition": "Visualise operon structure etc.",
          "exact_synonyms": ["Operon rendering"],
          "has_topic": ["http://edamontology.org/topic_0114"],
          "text": "Operon drawing"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0578"
          },
          "definition": "Draw a circular maps of DNA, for example a plasmid map.",
          "text": "Plasmid map drawing"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0575"
          },
          "definition": "Draw or visualise restriction maps in DNA sequences.",
          "has_output": ["http://edamontology.org/data_1289"],
          "text": "Restriction map drawing"
        }],
        "data": {
          "uri": "http://edamontology.org/operation_0573"
        },
        "definition": "Draw or visualise a DNA map.",
        "exact_synonyms": ["DNA map drawing", "Map rendering"],
        "has_input": ["http://edamontology.org/data_1274"],
        "text": "Map drawing"
      }],
      "comment": ["This includes methods to render and visualise molecules."],
      "data": {
        "uri": "http://edamontology.org/operation_0337"
      },
      "definition": "Visualise, plot or render (graphically) biomolecular data such as molecular sequences or structures.",
      "exact_synonyms": ["Rendering", "Data visualisation"],
      "has_input": ["http://edamontology.org/data_2968"],
      "has_output": ["http://edamontology.org/data_2968"],
      "has_topic": ["http://edamontology.org/topic_0092"],
      "narrow_synonyms": ["Plotting", "Molecular visualisation"],
      "text": "Visualisation"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/operation_3436"
        },
        "definition": "Combine multiple files or data items into a single file or object.",
        "text": "Aggregation"
      }, {
        "comment": ["'Format recognition' is not a bioinformatics-specific operation, but of great relevance in bioinformatics. Should be removed from EDAM if/when captured satisfactorily in a suitable domain-generic ontology."],
        "data": {
          "uri": "http://edamontology.org/operation_3357"
        },
        "definition": "Recognition of which format the given data is in.",
        "exact_synonyms": ["Format identification", "Format recognition", "Format inference"],
        "has_input": ["http://edamontology.org/data_0006"],
        "has_output": ["http://edamontology.org/data_3358"],
        "text": "Format detection"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/operation_3080"
          },
          "definition": "Edit, convert or otherwise change a  molecular tertiary structure, either randomly or specifically.",
          "has_input": ["http://edamontology.org/data_0883"],
          "text": "Structure editing"
        }, {
          "children": [{
            "children": [{
              "data": {
                "uri": "http://edamontology.org/operation_3237"
              },
              "definition": "Remove forward and/or reverse primers from nucleic acid sequences (typically PCR products).",
              "text": "Primer removal"
            }, {
              "comment": ["This includes\n\nennd trimming\nTrim sequences (typically from an automated DNA sequencer) to remove misleading ends.\nFor example trim polyA tails, introns and primer sequence flanking the sequence of amplified exons, or other unwanted sequence.\n\ntrimming to a reference sequence,\nTrim sequences (typically from an automated DNA sequencer) to remove the sequence ends that extend beyond an assembled reference sequence.\n\nvector trimming\nTrim sequences (typically from an automated DNA sequencer) to remove sequence-specific end regions, typically contamination from vector sequences."],
              "data": {
                "uri": "http://edamontology.org/operation_3192"
              },
              "definition": "Cut (remove) the end from a molecular sequence.",
              "exact_synonyms": ["Trimming"],
              "narrow_synonyms": ["Trim ends", "Barcode sequence removal", "Trim vector", "Trim to reference"],
              "text": "Sequence trimming"
            }],
            "data": {
              "uri": "http://edamontology.org/operation_0369"
            },
            "definition": "Cut (remove) characters or a region from a molecular sequence.",
            "text": "Sequence cutting"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0232"
            },
            "definition": "Merge two or more (typically overlapping) molecular sequences.",
            "exact_synonyms": ["Sequence splicing"],
            "narrow_synonyms": ["Paired-end merging", "Paired-end stitching", "Read stitching", "Read merging"],
            "text": "Sequence merging"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/operation_2510"
              },
              "definition": "Back-translate a protein sequence into DNA.",
              "has_topic": ["http://edamontology.org/topic_0108"],
              "text": "DNA back-translation"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_0372"
              },
              "definition": "Transcribe a nucleotide sequence into mRNA sequence(s).",
              "has_topic": ["http://edamontology.org/topic_0203"],
              "text": "DNA transcription"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_0371"
              },
              "definition": "Translate a DNA sequence into protein.",
              "has_topic": ["http://edamontology.org/topic_0108"],
              "text": "DNA translation"
            }],
            "data": {
              "uri": "http://edamontology.org/operation_0233"
            },
            "definition": "Convert a molecular sequence from one type to another.",
            "text": "Sequence conversion"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0367"
            },
            "definition": "Mutate a molecular sequence a specified amount or shuffle it to produce a randomised sequence with the same overall composition.",
            "text": "Sequence mutation and randomisation"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_2121"
            },
            "definition": "Perform basic (non-analytical) operations on a report or file of sequences (which might include features), such as file concatenation, removal or ordering of sequences, creation of subset or a new file of sequences.",
            "text": "Sequence file editing"
          }, {
            "comment": ["For example, SNPs or repeats in a DNA sequence might be masked."],
            "data": {
              "uri": "http://edamontology.org/operation_0368"
            },
            "definition": "Mask characters in a molecular sequence (replacing those characters with a mask character).",
            "text": "Sequence masking"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0370"
            },
            "definition": "Create (or remove) restriction sites in sequences, for example using silent mutations.",
            "text": "Restriction site creation"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_0231"
          },
          "definition": "Edit or change a molecular sequence, either randomly or specifically.",
          "text": "Sequence editing"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_0260"
            },
            "definition": "Convert a molecular sequence alignment from one type to another (for example amino acid to coding nucleotide sequence).",
            "text": "Sequence alignment conversion"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_3081"
          },
          "definition": "Edit, convert or otherwise change a molecular sequence alignment, either randomly or specifically.",
          "text": "Sequence alignment editing"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0326"
          },
          "definition": "Edit a phylogenetic tree.",
          "has_input": ["http://edamontology.org/data_0872"],
          "has_output": ["http://edamontology.org/data_0872"],
          "text": "Phylogenetic tree editing"
        }],
        "data": {
          "uri": "http://edamontology.org/operation_3096"
        },
        "definition": "Edit a data entity, either randomly or specifically.",
        "text": "Editing"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_3359"
        },
        "definition": "Split a file containing multiple data items into many files, each containing one item",
        "exact_synonyms": ["File splitting"],
        "text": "Splitting"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_3802"
        },
        "definition": "Sort a set of files or data items according to some property.",
        "text": "Sorting"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/operation_2422"
          },
          "definition": "Retrieve an entry (or part of an entry) from a data resource that matches a supplied query. This might include some primary data and annotation. The query is a data identifier or other indexed term. For example, retrieve a sequence record with the specified accession number, or matching supplied keywords.",
          "exact_synonyms": ["Retrieval", "Data extraction"],
          "has_input": ["http://edamontology.org/data_0842"],
          "narrow_synonyms": ["Metadata retrieval", "Data retrieval (metadata)"],
          "text": "Data retrieval"
        }, {
          "children": [{
            "children": [{
              "data": {
                "uri": "http://edamontology.org/operation_0346"
              },
              "definition": "Search a sequence database and retrieve sequences that are similar to a query sequence.",
              "narrow_synonyms": ["Structure database search (by sequence)", "Sequence database search (by sequence)"],
              "text": "Sequence similarity search"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_0349"
              },
              "definition": "Search a sequence database and retrieve sequences with a specified property, typically a physicochemical or compositional property.",
              "text": "Sequence database search (by property)"
            }],
            "comment": ["This excludes direct retrieval methods (e.g. the dbfetch program)."],
            "data": {
              "uri": "http://edamontology.org/operation_0338"
            },
            "definition": "Search a sequence database by sequence comparison and retrieve similar sequences.\nsequences matching a given sequence motif or pattern, such as a Prosite pattern or regular expression.",
            "has_output": ["http://edamontology.org/data_0857"],
            "text": "Sequence database search"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/operation_3649"
              },
              "definition": "Statistical estimation of false discovery rate from score distribution for peptide-spectrum-matches, following a peptide database search, and by comparison to search results with a database containing incorrect information.",
              "text": "Target-Decoy"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_3647"
              },
              "definition": "Peptide database search for identification of known and unknown PTMs looking for mass difference mismatches.",
              "exact_synonyms": ["Modification-tolerant peptide database search", "Unrestricted peptide database search"],
              "text": "Blind peptide database search"
            }],
            "data": {
              "uri": "http://edamontology.org/operation_3646"
            },
            "definition": "Determination of best matches between MS/MS spectrum and a database of protein or nucleic acid sequences.",
            "text": "Peptide database search"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0305"
            },
            "definition": "Query scientific literature, in search for articles, article data, concepts, named entities, or for statistics.",
            "has_topic": ["http://edamontology.org/topic_3068"],
            "text": "Literature search"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/operation_0360"
              },
              "definition": "Search a database of molecular structure and retrieve structures that are similar to a query structure.",
              "exact_synonyms": ["Structure retrieval by structure", "Structure database search (by structure)"],
              "text": "Structural similarity search"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_0346"
              },
              "definition": "Search a sequence database and retrieve sequences that are similar to a query sequence.",
              "narrow_synonyms": ["Structure database search (by sequence)", "Sequence database search (by sequence)"],
              "text": "Sequence similarity search"
            }],
            "data": {
              "uri": "http://edamontology.org/operation_0339"
            },
            "definition": "Search a tertiary structure database, typically by sequence and/or structure comparison, or some other means, and retrieve structures and associated data.",
            "has_topic": ["http://edamontology.org/topic_0081"],
            "text": "Structure database search"
          }],
          "comment": ["Typically the query is compared to each entry and high scoring matches (hits) are returned. For example, a BLAST search of a sequence database."],
          "data": {
            "uri": "http://edamontology.org/operation_2421"
          },
          "definition": "Search a database (or other data resource) with a supplied query and retrieve entries (or parts of entries) that are similar to the query.",
          "exact_synonyms": ["Search"],
          "has_output": ["http://edamontology.org/data_2080"],
          "text": "Database search"
        }],
        "data": {
          "uri": "http://edamontology.org/operation_0224"
        },
        "definition": "Search or query a data resource and retrieve entries and / or annotation.",
        "exact_synonyms": ["Database retrieval"],
        "has_output": ["http://edamontology.org/data_0006"],
        "has_topic": ["http://edamontology.org/topic_3071"],
        "narrow_synonyms": ["Query"],
        "text": "Query and retrieval"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_3695"
        },
        "definition": "Filter a set of files or data items according to some property.",
        "narrow_synonyms": ["Sequence filtering", "rRNA filtering"],
        "text": "Filtering"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_3283"
        },
        "definition": "Process data in such a way that makes it hard to trace to the person which the data concerns.",
        "exact_synonyms": ["Data anonymisation"],
        "text": "Anonymisation"
      }, {
        "comment": ["For non-analytical operations, see the 'Processing' branch."],
        "data": {
          "uri": "http://edamontology.org/operation_3431"
        },
        "definition": "Deposit some data in a database or some other type of repository or software system.",
        "exact_synonyms": ["Submission", "Data deposition", "Data submission", "Database submission", "Database deposition"],
        "text": "Deposition"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_0335"
        },
        "definition": "Reformat a file of data (or equivalent entity in memory).",
        "exact_synonyms": ["File reformatting", "File format conversion", "Reformatting", "File formatting", "Format conversion"],
        "text": "Formatting"
      }, {
        "data": {
          "uri": "http://edamontology.org/operation_1812"
        },
        "definition": "Parse, prepare or load a user-specified data file so that it is available for use.",
        "exact_synonyms": ["Data loading", "Loading"],
        "has_input": ["http://edamontology.org/data_0842"],
        "text": "Parsing"
      }],
      "data": {
        "uri": "http://edamontology.org/operation_2409"
      },
      "definition": "Basic (non-analytical) operations of some data, either a file or equivalent entity in memory, such that the same basic type of data is consumed as input and generated as output.",
      "exact_synonyms": ["Utility operation", "Report handling", "File handling", "File processing"],
      "has_topic": ["http://edamontology.org/topic_3489"],
      "narrow_synonyms": ["Processing"],
      "text": "Data handling"
    }, {
      "children": [{
        "children": [{
          "children": [{
            "comment": ["A micrograph can include particles in multiple different orientations and/or conformations. Particles are compared and organised into sets based on their similarity. Typically iterations of classification and alignment and are performed to optimise the final 3D EM map."],
            "data": {
              "uri": "http://edamontology.org/operation_3458"
            },
            "definition": "Compare (align and classify) multiple particle images from a micrograph in order to produce a representative image of the particle.",
            "text": "Single particle alignment and classification"
          }],
          "comment": ["Single particle analysis is used to improve the information that can be obtained by relatively low resolution techniques, , e.g. an image of a protein or virus from transmission electron microscopy (TEM)."],
          "data": {
            "uri": "http://edamontology.org/operation_3457"
          },
          "definition": "An image processing technique that combines and analyze multiple images of a particulate sample, in order to produce an image with clearer features that are more easily interpreted.",
          "has_topic": ["http://edamontology.org/topic_1317"],
          "text": "Single particle analysis"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3450"
          },
          "definition": "Measurement of neurites; projections (axons or dendrites) from the cell body of a neuron, from analysis of neuron images.",
          "has_topic": ["http://edamontology.org/topic_2229"],
          "text": "Neurite measurement"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3446"
          },
          "definition": "Analysis of cell migration images in order to study cell migration, typically in order to study the processes that play a role in the disease progression.",
          "has_topic": ["http://edamontology.org/topic_2229"],
          "text": "Cell migration analysis"
        }],
        "data": {
          "uri": "http://edamontology.org/operation_3443"
        },
        "definition": "The analysis of a image (typically a digital image) of some type in order to extract information from it.",
        "has_topic": ["http://edamontology.org/topic_3382"],
        "text": "Image analysis"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/operation_3502"
          },
          "definition": "Analyse a dataset with respect to concepts from an ontology of chemical structure, leveraging chemical similarity information.",
          "exact_synonyms": ["Chemical class enrichment"],
          "has_topic": ["http://edamontology.org/topic_1775"],
          "text": "Chemical similarity enrichment"
        }, {
          "comment": ["\"Gene set analysis\" (often used interchangeably or in an overlapping sense with \"gene-set enrichment analysis\") refers to the functional analysis (term enrichment) of a differentially expressed set of genes, rather than all genes analysed.", "The Gene Ontology (GO) is typically used, the input is a set of Gene IDs, and the output of the analysis is typically a ranked list of GO concepts, each associated with a p-value."],
          "data": {
            "uri": "http://edamontology.org/operation_2436"
          },
          "definition": "Identify classes of genes or proteins that are over or under-represented in a large set of genes or proteins.  For example analysis of a set of genes corresponding to a gene expression profile, annotated with Gene Ontology (GO) concepts, where eventual over-/under-representation of certain GO concept within the studied set of genes is revealed.",
          "exact_synonyms": ["GSEA", "Functional enrichment analysis", "Gene-set over-represenation analysis"],
          "has_output": ["http://edamontology.org/data_3754"],
          "has_topic": ["http://edamontology.org/topic_1775"],
          "narrow_synonyms": ["Gene set analysis"],
          "text": "Gene-set enrichment analysis"
        }],
        "comment": ["Categories from a relevant ontology can be used. The input is typically a set of genes or other biological objects, possibly represented by their identifiers, and the output of the analysis is typically a ranked list of categories, each associated with a statistical metric of over-/under-representation within the studied data."],
        "data": {
          "uri": "http://edamontology.org/operation_3501"
        },
        "definition": "Analysis of a set of objects, such as genes, annotated with given categories, where eventual over-/under-representation of certain categories within the studied set of objects is revealed.",
        "exact_synonyms": ["Enrichment", "Over-representation analysis"],
        "has_output": ["http://edamontology.org/data_3753"],
        "narrow_synonyms": ["Functional enrichment"],
        "text": "Enrichment analysis"
      }, {
        "children": [{
          "comment": ["This includes methods that generate a graphical rendering of antigenicity of a protein, such as a Hopp and Woods plot.", "This is usually done in the development of peptide-specific antibodies or multi-epitope vaccines. Methods might use sequence data (for example motifs) and / or structural data.", "Immunological system are cellular or humoral. In vaccine design to induces a cellular immune response, methods must search for antigens that can be recognized by the major histocompatibility complex (MHC) molecules present in T lymphocytes.  If a humoral response is required, antigens for B cells must be identified."],
          "data": {
            "uri": "http://edamontology.org/operation_0252"
          },
          "definition": "Predict antigenicity, allergenicity / immunogenicity, allergic cross-reactivity etc of peptides and proteins.",
          "exact_synonyms": ["Antigenicity prediction", "Immunogenicity prediction"],
          "has_output": ["http://edamontology.org/data_1534"],
          "has_topic": ["http://edamontology.org/topic_0804"],
          "narrow_synonyms": ["Hopp and Woods plotting", "MHC peptide immunogenicity prediction", "B cell peptide immunogenicity prediction"],
          "text": "Peptide immunogenicity prediction"
        }, {
          "comment": ["Methods might use sequence motifs and features, amino acid composition, profiles, machine-learned classifiers, etc."],
          "data": {
            "uri": "http://edamontology.org/operation_0418"
          },
          "definition": "Detect or predict signal peptides and signal peptide cleavage sites in protein sequences.",
          "has_topic": ["http://edamontology.org/topic_0140"],
          "text": "Protein signal peptide detection"
        }, {
          "children": [{
            "children": [{
              "comment": ["Virtual screening is widely used for lead identification, lead optimization, and scaffold hopping during drug design and discovery."],
              "data": {
                "uri": "http://edamontology.org/operation_3938"
              },
              "definition": "Virtual screening is used in drug discovery to identify potential drug compounds.  It involves searching libraries of small molecules in order to identify those molecules which are most likely to bind to a drug target (typically a protein receptor or enzyme).",
              "has_output": ["http://edamontology.org/data_1461"],
              "has_topic": ["http://edamontology.org/topic_0128"],
              "narrow_synonyms": ["Structured-based virtual screening", "Ligand-based screening", "Virtual ligand screening", "Ligand-based virtual screening", "Structure-based screening"],
              "text": "Virtual screening"
            }],
            "comment": ["Virtual screening is used in drug discovery to search libraries of small molecules in order to identify those molecules which are most likely to bind to a drug target (typically a protein receptor or enzyme).", "Methods aim to predict the position and orientation of a ligand bound to a protein receptor or enzyme."],
            "data": {
              "uri": "http://edamontology.org/operation_0482"
            },
            "definition": "Model protein-ligand (for example protein-peptide) binding using comparative modelling or other techniques.",
            "exact_synonyms": ["Ligand-binding simulation"],
            "has_output": ["http://edamontology.org/data_1461"],
            "has_topic": ["http://edamontology.org/topic_0128"],
            "narrow_synonyms": ["Protein-peptide docking"],
            "text": "Protein-ligand docking"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3899"
            },
            "definition": "Model or simulate protein-protein binding using comparative modelling or other techniques.",
            "exact_synonyms": ["Protein docking"],
            "has_output": ["http://edamontology.org/data_1461"],
            "has_topic": ["http://edamontology.org/topic_0128"],
            "text": "Protein-protein docking"
          }],
          "comment": ["This includes protein-protein interactions, protein-nucleic acid, protein-ligand binding etc. Methods might predict whether the molecules are likely to bind in vivo, their conformation when bound, the strength of the interaction, possible mutations to achieve bonding and so on."],
          "data": {
            "uri": "http://edamontology.org/operation_0478"
          },
          "definition": "Model the structure of a protein in complex with a small molecule or another macromolecule.",
          "exact_synonyms": ["Macromolecular docking", "Docking simulation"],
          "has_output": ["http://edamontology.org/data_2877", "http://edamontology.org/data_1461"],
          "text": "Molecular docking"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_2464"
            },
            "definition": "Identify or predict protein-protein binding sites.",
            "exact_synonyms": ["Protein-protein binding site detection"],
            "has_output": ["http://edamontology.org/data_0906"],
            "has_topic": ["http://edamontology.org/topic_0128"],
            "text": "Protein-protein binding site prediction"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3898"
            },
            "definition": "Predict or detect metal ion-binding sites in proteins.",
            "exact_synonyms": ["Protein metal-binding site prediction", "Metal-binding site detection"],
            "text": "Metal-binding site prediction"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/operation_3903"
              },
              "definition": "Predict or detect DNA-binding sites in protein sequences.",
              "exact_synonyms": ["Protein-DNA binding site detection", "Protein-DNA binding site prediction"],
              "narrow_synonyms": ["DNA binding site detection"],
              "text": "DNA binding site prediction"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_3902"
              },
              "definition": "Predict or detect RNA-binding sites in protein sequences.",
              "exact_synonyms": ["RNA binding site detection", "Protein-RNA binding site detection", "Protein-RNA binding site prediction"],
              "text": "RNA binding site prediction"
            }],
            "comment": ["This includes methods that predict and optimise zinc finger protein domains for DNA/RNA binding (for example for transcription factors and nucleases)."],
            "data": {
              "uri": "http://edamontology.org/operation_0420"
            },
            "definition": "Predict or detect RNA and DNA-binding binding sites in protein sequences.",
            "exact_synonyms": ["Protein-nucleic acid binding site prediction", "Protein-nucleic acid binding detection", "Protein-nucleic acid binding prediction", "Protein-nucleic acid binding site detection"],
            "narrow_synonyms": ["Zinc finger prediction"],
            "text": "Nucleic acids-binding site prediction"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3896"
            },
            "definition": "Predict or detect active sites in proteins; the region of an enzyme which binds a substrate bind and catalyses a reaction.",
            "narrow_synonyms": ["Active site detection"],
            "text": "Active site prediction"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3897"
            },
            "definition": "Predict or detect ligand-binding sites in proteins; a region of a protein which reversibly binds a ligand for some biochemical purpose, such as transport or regulation of protein function.",
            "narrow_synonyms": ["Ligand-binding site detection", "Peptide-protein binding prediction"],
            "text": "Ligand-binding site prediction"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_2575"
          },
          "definition": "Identify or predict catalytic residues, active sites or other ligand-binding sites in protein sequences or structures.",
          "exact_synonyms": ["Protein binding site detection", "Protein binding site prediction"],
          "has_topic": ["http://edamontology.org/topic_0128"],
          "text": "Binding site prediction"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_1778"
          },
          "definition": "Compare the functional properties of two or more proteins.",
          "has_topic": ["http://edamontology.org/topic_1775"],
          "text": "Protein function comparison"
        }, {
          "comment": ["The prediction might include subcellular localisation (nuclear, cytoplasmic, mitochondrial, chloroplast, plastid, membrane etc) or export (extracellular proteins) of a protein."],
          "data": {
            "uri": "http://edamontology.org/operation_2489"
          },
          "definition": "Predict the subcellular localisation of a protein sequence.",
          "exact_synonyms": ["Protein cellular localization prediction", "Protein subcellular localisation prediction", "Protein targeting prediction"],
          "has_topic": ["http://edamontology.org/topic_0140"],
          "text": "Subcellular localisation prediction"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_3900"
            },
            "definition": "Predict DNA-binding proteins.",
            "exact_synonyms": ["DNA-binding protein detection", "DNA-protein interaction prediction", "Protein-DNA interaction prediction"],
            "has_output": ["http://edamontology.org/data_0906"],
            "has_topic": ["http://edamontology.org/topic_0128"],
            "text": "DNA-binding protein prediction"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3901"
            },
            "definition": "Predict RNA-binding proteins.",
            "exact_synonyms": ["RNA-binding protein detection", "RNA-protein interaction prediction", "Protein-RNA interaction prediction"],
            "has_output": ["http://edamontology.org/data_0906"],
            "has_topic": ["http://edamontology.org/topic_0128"],
            "text": "RNA-binding protein prediction"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_0389"
          },
          "definition": "Analyse the interaction of protein with nucleic acids, e.g. RNA or DNA-binding sites, interfaces etc.",
          "exact_synonyms": ["Protein-nucleic acid binding site analysis"],
          "has_topic": ["http://edamontology.org/topic_0128"],
          "narrow_synonyms": ["Protein-RNA interaction analysis", "Protein-DNA interaction analysis"],
          "text": "Protein-nucleic acid interaction analysis"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_0276"
            },
            "definition": "Analyse a network of protein interactions.",
            "has_output": ["http://edamontology.org/data_2984"],
            "has_topic": ["http://edamontology.org/topic_0128"],
            "narrow_synonyms": ["Protein interaction network comparison"],
            "text": "Protein interaction network analysis"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_2492"
            },
            "definition": "Predict the interactions of proteins with other proteins.",
            "exact_synonyms": ["Protein-protein interaction detection"],
            "has_output": ["http://edamontology.org/data_0906"],
            "has_topic": ["http://edamontology.org/topic_0128"],
            "narrow_synonyms": ["Protein-protein interaction prediction", "Protein-protein binding prediction"],
            "text": "Protein interaction prediction"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3094"
            },
            "definition": "Predict a network of protein interactions.",
            "text": "Protein interaction network prediction"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_2949"
          },
          "definition": "Analyse the interactions of proteins with other proteins.",
          "exact_synonyms": ["Protein interaction analysis"],
          "has_output": ["http://edamontology.org/data_0906"],
          "has_topic": ["http://edamontology.org/topic_0128"],
          "narrow_synonyms": ["Protein interaction simulation", "Protein interaction raw data analysis"],
          "text": "Protein-protein interaction analysis"
        }],
        "comment": ["For functional properties that can be mapped to a sequence, use 'Sequence feature detection (protein)' instead."],
        "data": {
          "uri": "http://edamontology.org/operation_1777"
        },
        "definition": "Predict the biological or biochemical role of a protein, or other aspects of a protein function.",
        "exact_synonyms": ["Protein functional analysis", "Protein function analysis"],
        "has_topic": ["http://edamontology.org/topic_1775"],
        "text": "Protein function prediction"
      }, {
        "children": [{
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_3280"
            },
            "definition": "Recognise named entities, ontology concepts, tags, events, and dictionary terms within documents.",
            "narrow_synonyms": ["Concept mining", "NER", "Entity identification", "Named-entity recognition", "Entity chunking", "Event extraction", "Entity extraction"],
            "text": "Named-entity and concept recognition"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_3907"
          },
          "definition": "Extract structured information from unstructured (\"free\") or semi-structured textual documents.",
          "exact_synonyms": ["IE"],
          "text": "Information extraction"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_2422"
            },
            "definition": "Retrieve an entry (or part of an entry) from a data resource that matches a supplied query. This might include some primary data and annotation. The query is a data identifier or other indexed term. For example, retrieve a sequence record with the specified accession number, or matching supplied keywords.",
            "exact_synonyms": ["Retrieval", "Data extraction"],
            "has_input": ["http://edamontology.org/data_0842"],
            "narrow_synonyms": ["Metadata retrieval", "Data retrieval (metadata)"],
            "text": "Data retrieval"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_3908"
          },
          "definition": "Retrieve resources from information systems matching a specific information need.",
          "text": "Information retrieval"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3625"
          },
          "definition": "Identify semantic relations among entities and concepts within a text, using text mining techniques.",
          "exact_synonyms": ["Relationship inference", "Relationship extraction", "Relation inference", "Relation discovery", "Relationship discovery"],
          "text": "Relation extraction"
        }],
        "data": {
          "uri": "http://edamontology.org/operation_0306"
        },
        "definition": "Process and analyse text (typically scientific literature) to extract information from it.",
        "exact_synonyms": ["Literature mining", "Text data mining", "Text analytics"],
        "has_input": ["http://edamontology.org/data_3671"],
        "has_output": ["http://edamontology.org/data_0972"],
        "has_topic": ["http://edamontology.org/topic_0218"],
        "text": "Text mining"
      }, {
        "children": [{
          "children": [{
            "comment": ["Includes methods that try to suggest the most likely biological unit for a given protein X-ray crystal structure based on crystal symmetry and scoring of putative protein-protein interfaces."],
            "data": {
              "uri": "http://edamontology.org/operation_2475"
            },
            "definition": "Identify the architecture of a protein structure.",
            "text": "Protein architecture recognition"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_2996"
          },
          "definition": "Assign molecular structure(s) to a group or category.",
          "text": "Structure classification"
        }, {
          "children": [{
            "children": [{
              "data": {
                "uri": "http://edamontology.org/operation_0319"
              },
              "definition": "Assign secondary structure from protein coordinate or experimental data.",
              "has_topic": ["http://edamontology.org/topic_1317", "http://edamontology.org/topic_2814"],
              "text": "Protein secondary structure assignment"
            }, {
              "children": [{
                "comment": ["A free cysteine is neither involved in a cysteine bridge, nor functions as a ligand to a metal."],
                "data": {
                  "uri": "http://edamontology.org/operation_1830"
                },
                "definition": "Detect free cysteines in a protein structure.",
                "text": "Free cysteine detection"
              }, {
                "data": {
                  "uri": "http://edamontology.org/operation_1829"
                },
                "definition": "Detect cysteine bridges (from coordinate data) in a protein structure.",
                "text": "Cysteine bridge detection"
              }, {
                "data": {
                  "uri": "http://edamontology.org/operation_1831"
                },
                "definition": "Detect cysteines that are bound to metal in a protein structure.",
                "text": "Metal-bound cysteine detection"
              }],
              "data": {
                "uri": "http://edamontology.org/operation_1850"
              },
              "definition": "Assign cysteine bonding state and disulfide bond partners in protein structures.",
              "has_topic": ["http://edamontology.org/topic_0130"],
              "text": "Protein cysteine and disulfide bond assignment"
            }],
            "data": {
              "uri": "http://edamontology.org/operation_0320"
            },
            "definition": "Assign a protein tertiary structure (3D coordinates), or other aspects of protein structure, from raw experimental data.",
            "has_output": ["http://edamontology.org/data_1460"],
            "has_topic": ["http://edamontology.org/topic_1317"],
            "narrow_synonyms": ["Structure calculation", "NOE assignment"],
            "text": "Protein structure assignment"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_2415"
            },
            "definition": "Analyse, simulate or predict protein folding, typically by processing sequence and / or structural data.  For example, predict sites of nucleation or stabilisation key to protein folding.",
            "exact_synonyms": ["Protein folding modelling"],
            "has_output": ["http://edamontology.org/data_1537"],
            "has_topic": ["http://edamontology.org/topic_0130"],
            "narrow_synonyms": ["Protein folding site prediction", "Protein folding simulation"],
            "text": "Protein folding analysis"
          }, {
            "children": [{
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/operation_0470"
                },
                "definition": "Predict open coils, non-regular secondary structure and intrinsically disordered / unstructured regions of protein sequences.",
                "text": "Protein secondary structure prediction (coils)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/operation_0469"
                },
                "definition": "Predict turn structure (for example beta hairpin turns) of protein sequences.",
                "text": "Protein secondary structure prediction (turns)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/operation_0468"
                },
                "definition": "Predict helical secondary structure of protein sequences.",
                "text": "Protein secondary structure prediction (helices)"
              }, {
                "comment": ["Super-secondary structures include leucine zippers, coiled coils, Helix-Turn-Helix etc."],
                "data": {
                  "uri": "http://edamontology.org/operation_0268"
                },
                "definition": "Predict super-secondary structure of protein sequence(s).",
                "has_output": ["http://edamontology.org/data_1277"],
                "text": "Protein super-secondary structure prediction"
              }, {
                "data": {
                  "uri": "http://edamontology.org/operation_0269"
                },
                "definition": "Predict and/or classify transmembrane proteins or transmembrane (helical) domains or regions in protein sequences.",
                "text": "Transmembrane protein prediction"
              }],
              "comment": ["Methods might use amino acid composition, local sequence information, multiple sequence alignments, physicochemical features, estimated energy content, statistical algorithms, hidden Markov models, support vector machines, kernel machines, neural networks etc."],
              "data": {
                "uri": "http://edamontology.org/operation_0267"
              },
              "definition": "Predict secondary structure of protein sequences.",
              "exact_synonyms": ["Secondary structure prediction (protein)"],
              "text": "Protein secondary structure prediction"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_2488"
              },
              "definition": "Compare protein secondary structures.",
              "exact_synonyms": ["Secondary structure comparison (protein)", "Protein secondary structure"],
              "narrow_synonyms": ["Protein secondary structure alignment"],
              "text": "Protein secondary structure comparison"
            }],
            "data": {
              "uri": "http://edamontology.org/operation_2416"
            },
            "definition": "Analyse protein secondary structure data.",
            "exact_synonyms": ["Secondary structure analysis (protein)"],
            "has_output": ["http://edamontology.org/data_2956"],
            "has_topic": ["http://edamontology.org/topic_2814"],
            "text": "Protein secondary structure analysis"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/operation_0390"
              },
              "definition": "Decompose a structure into compact or globular fragments (protein peeling).",
              "text": "Protein peeling"
            }],
            "data": {
              "uri": "http://edamontology.org/operation_0246"
            },
            "definition": "Identify structural domains in a protein structure from first principles (for example calculations on structural compactness).",
            "has_topic": ["http://edamontology.org/topic_0736"],
            "text": "Protein domain recognition"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/operation_1843"
              },
              "definition": "Identify poorly packed residues in protein structures.",
              "text": "Residue packing validation"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_1836"
              },
              "definition": "Detect 'bumps' between residues in a structure, i.e. those with pairs of atoms whose Van der Waals' radii interpenetrate more than a defined distance.",
              "text": "Residue bump detection"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_1844"
              },
              "definition": "Validate protein geometry, for example bond lengths, bond angles, torsion angles, chiralities, planaraties etc.  An example is validation of a Ramachandran plot of a protein structure.",
              "narrow_synonyms": ["Ramachandran plot validation"],
              "text": "Protein geometry validation"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_3560"
              },
              "definition": "A method for making numerical assessments about the maximum percent of time that a conformer of a flexible macromolecule can exist and still be compatible with the experimental data.",
              "text": "Maximum occurence analysis"
            }],
            "comment": ["Model validation might involve checks for atomic packing, steric clashes (bumps), volume irregularities, agreement with electron density maps, number of amino acid residues, percentage of residues with missing or bad atoms, irregular Ramachandran Z-scores, irregular Chi-1 / Chi-2 normality scores, RMS-Z score on bonds and angles etc.", "This includes methods that calculate poor quality residues. The scoring function to identify poor quality residues may consider residues with bad atoms or atoms with high B-factor, residues in the N- or C-terminal position, adjacent to an unstructured residue, non-canonical residues, glycine and proline (or adjacent to these such residues).", "The PDB file format has had difficulties, inconsistencies and errors. Corrections can include identifying a meaningful sequence, removal of alternate atoms, correction of nomenclature problems, removal of incomplete residues and spurious waters, addition or removal of water, modelling of missing side chains, optimisation of cysteine bonds, regularisation of bond lengths, bond angles and planarities etc."],
            "data": {
              "uri": "http://edamontology.org/operation_0321"
            },
            "definition": "Evaluate the quality or correctness a protein three-dimensional model.",
            "exact_synonyms": ["Protein model validation"],
            "has_output": ["http://edamontology.org/data_1539"],
            "has_topic": ["http://edamontology.org/topic_2275"],
            "narrow_synonyms": ["Residue validation"],
            "text": "Protein structure validation"
          }, {
            "children": [{
              "comment": ["Includes methods that try to suggest the most likely biological unit for a given protein X-ray crystal structure based on crystal symmetry and scoring of putative protein-protein interfaces."],
              "data": {
                "uri": "http://edamontology.org/operation_2475"
              },
              "definition": "Identify the architecture of a protein structure.",
              "text": "Protein architecture recognition"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_2474"
              },
              "definition": "Compare the architecture of two or more protein structures.",
              "text": "Protein architecture comparison"
            }],
            "data": {
              "uri": "http://edamontology.org/operation_0247"
            },
            "definition": "Analyse the architecture (spatial arrangement of secondary structure) of protein structure(s).",
            "text": "Protein architecture analysis"
          }, {
            "comment": ["This includes conserved substructures and conserved geometry, such as spatial arrangement of secondary structure or protein backbone. Methods might use structure alignment, structural templates, searches for similar electrostatic potential and molecular surface shape, surface-mapping of phylogenetic information etc."],
            "data": {
              "uri": "http://edamontology.org/operation_0245"
            },
            "definition": "Identify or screen for 3D structural motifs in protein structure(s).",
            "exact_synonyms": ["Protein structural feature identification", "Protein structural motif recognition"],
            "has_topic": ["http://edamontology.org/topic_0166"],
            "text": "Structural motif discovery"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/operation_0476"
              },
              "definition": "Predict tertiary structure of protein sequence(s) without homologs of known structure.",
              "exact_synonyms": ["de novo structure prediction"],
              "text": "Ab initio structure prediction"
            }, {
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/operation_0481"
                },
                "definition": "Model loop conformation in protein structures.",
                "exact_synonyms": ["Protein modelling (loops)", "Protein loop modelling"],
                "text": "Loop modelling"
              }, {
                "comment": ["This includes rotamer likelihood prediction: the prediction of rotamer likelihoods for all 20 amino acid types at each position in a protein structure, where output typically includes, for each residue position, the likelihoods for the 20 amino acid types with estimated reliability of the 20 likelihoods.", "Methods might use a residue rotamer library.", "Antibody optimisation is to optimize the antibody-interacting surface of the antigen (epitope).  Antigen optimisation is to optimize the antigen-interacting surface of the antibody (paratope). Antigen resurfacing is to resurface the antigen by varying the sequence of non-epitope regions."],
                "data": {
                  "uri": "http://edamontology.org/operation_0480"
                },
                "definition": "Model, analyse or edit amino acid side chain conformation in protein structure, optimize side-chain packing, hydrogen bonding etc.",
                "exact_synonyms": ["Protein modelling (side chains)"],
                "narrow_synonyms": ["Antigen resurfacing", "Antibody optimisation", "Rotamer likelihood prediction", "Antigen optimisation"],
                "text": "Side chain modelling"
              }, {
                "comment": ["Methods might require a preliminary C(alpha) trace.", "Scaffold selection, scaffold search, epitope grafting and design optimization are stages of backbone modelling done during rational vaccine design."],
                "data": {
                  "uri": "http://edamontology.org/operation_0479"
                },
                "definition": "Model protein backbone conformation.",
                "exact_synonyms": ["Protein modelling (backbone)"],
                "narrow_synonyms": ["Epitope grafting", "Scaffold selection", "Scaffold search", "Design optimization"],
                "text": "Backbone modelling"
              }],
              "comment": ["The model might be of a whole, part or aspect of protein structure. Molecular modelling methods might use sequence-structure alignment, structural templates, molecular dynamics, energy minimisation etc."],
              "data": {
                "uri": "http://edamontology.org/operation_0477"
              },
              "definition": "Build a three-dimensional protein model based on known (for example homologs) structures.",
              "exact_synonyms": ["Comparative modelling", "Homology modelling", "Protein structure comparative modelling", "Homology structure modelling"],
              "has_topic": ["http://edamontology.org/topic_2275"],
              "text": "Protein modelling"
            }],
            "data": {
              "uri": "http://edamontology.org/operation_0474"
            },
            "definition": "Predict tertiary structure (backbone and side-chain conformation) of protein sequences.",
            "has_output": ["http://edamontology.org/data_1460"],
            "narrow_synonyms": ["Protein folding pathway prediction"],
            "text": "Protein structure prediction"
          }, {
            "children": [{
              "comment": ["Use this concept for methods that evaluate sequence-structure compatibility by assessing residue interactions in 3D. Methods might perform one-to-one, one-to-many or many-to-many comparisons."],
              "data": {
                "uri": "http://edamontology.org/operation_0302"
              },
              "definition": "Align molecular sequence to structure in 3D space (threading).",
              "exact_synonyms": ["Sequence-structure alignment"],
              "has_input": ["http://edamontology.org/data_1460"],
              "has_output": ["http://edamontology.org/data_0893"],
              "narrow_synonyms": ["Sequence-3D profile alignment", "Sequence-to-3D-profile alignment"],
              "text": "Protein threading"
            }],
            "comment": ["Methods use some type of mapping between sequence and fold, for example secondary structure prediction and alignment, profile comparison, sequence properties, homologous sequence search, kernel machines etc. Domains and folds might be taken from SCOP or CATH."],
            "data": {
              "uri": "http://edamontology.org/operation_0303"
            },
            "definition": "Recognize (predict and identify) known protein structural domains or folds in protein sequence(s) which (typically) are not accompanied by any significant sequence similarity to know structures.",
            "exact_synonyms": ["Protein fold recognition", "Fold prediction", "Protein domain prediction", "Domain prediction", "Protein fold prediction"],
            "text": "Fold recognition"
          }, {
            "comment": ["Methods might identify structural neighbors, find structural similarities or define a structural core."],
            "data": {
              "uri": "http://edamontology.org/operation_2487"
            },
            "definition": "Compare protein tertiary structures.",
            "exact_synonyms": ["Structure comparison (protein)"],
            "has_input": ["http://edamontology.org/data_1460"],
            "text": "Protein structure comparison"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_2406"
          },
          "definition": "Analyse protein structural data.",
          "exact_synonyms": ["Structure analysis (protein)"],
          "has_input": ["http://edamontology.org/data_1460"],
          "has_topic": ["http://edamontology.org/topic_2814"],
          "text": "Protein structure analysis"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_0360"
            },
            "definition": "Search a database of molecular structure and retrieve structures that are similar to a query structure.",
            "exact_synonyms": ["Structure retrieval by structure", "Structure database search (by structure)"],
            "text": "Structural similarity search"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3564"
            },
            "definition": "Identify and remove redudancy from a set of small molecule structures.",
            "text": "Chemical redundancy removal"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_2518"
            },
            "definition": "Compare nucleic acid tertiary structures.",
            "exact_synonyms": ["Structure comparison (nucleic acid)"],
            "text": "Nucleic acid structure comparison"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3666"
            },
            "definition": "Compare two or more molecular surfaces.",
            "text": "Molecular surface comparison"
          }, {
            "children": [{
              "comment": ["This includes methods that use an existing alignment."],
              "data": {
                "uri": "http://edamontology.org/operation_0504"
              },
              "definition": "Align (superimpose) more than two molecular tertiary structures.",
              "exact_synonyms": ["Structure alignment (multiple)"],
              "narrow_synonyms": ["Multiple protein structure alignment"],
              "text": "Multiple structure alignment"
            }, {
              "comment": ["Local alignment methods identify regions of local similarity, common substructures etc."],
              "data": {
                "uri": "http://edamontology.org/operation_0509"
              },
              "definition": "Locally align (superimpose) two or more molecular tertiary structures.",
              "exact_synonyms": ["Structure alignment (local)"],
              "narrow_synonyms": ["Local protein structure alignment"],
              "text": "Local structure alignment"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_0503"
              },
              "definition": "Align (superimpose) exactly two molecular tertiary structures.",
              "exact_synonyms": ["Structure alignment (pairwise)"],
              "narrow_synonyms": ["Pairwise protein structure alignment"],
              "text": "Pairwise structure alignment"
            }, {
              "comment": ["Global alignment methods identify similarity across the entire structures."],
              "data": {
                "uri": "http://edamontology.org/operation_0510"
              },
              "definition": "Globally align (superimpose) two or more molecular tertiary structures.",
              "exact_synonyms": ["Structure alignment (global)"],
              "narrow_synonyms": ["Global protein structure alignment"],
              "text": "Global structure alignment"
            }],
            "data": {
              "uri": "http://edamontology.org/operation_0295"
            },
            "definition": "Align (superimpose) molecular tertiary structures.",
            "exact_synonyms": ["Structural alignment"],
            "has_output": ["http://edamontology.org/data_0886"],
            "narrow_synonyms": ["3D profile-to-3D profile alignment", "Structural profile alignment", "3D profile alignment"],
            "text": "Structure alignment"
          }, {
            "comment": ["Methods might identify structural neighbors, find structural similarities or define a structural core."],
            "data": {
              "uri": "http://edamontology.org/operation_2487"
            },
            "definition": "Compare protein tertiary structures.",
            "exact_synonyms": ["Structure comparison (protein)"],
            "has_input": ["http://edamontology.org/data_1460"],
            "text": "Protein structure comparison"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_2483"
          },
          "definition": "Compare two or more molecular tertiary structures.",
          "has_topic": ["http://edamontology.org/topic_0081"],
          "text": "Structure comparison"
        }, {
          "children": [{
            "children": [{
              "comment": ["Virtual screening is widely used for lead identification, lead optimization, and scaffold hopping during drug design and discovery."],
              "data": {
                "uri": "http://edamontology.org/operation_3938"
              },
              "definition": "Virtual screening is used in drug discovery to identify potential drug compounds.  It involves searching libraries of small molecules in order to identify those molecules which are most likely to bind to a drug target (typically a protein receptor or enzyme).",
              "has_output": ["http://edamontology.org/data_1461"],
              "has_topic": ["http://edamontology.org/topic_0128"],
              "narrow_synonyms": ["Structured-based virtual screening", "Ligand-based screening", "Virtual ligand screening", "Ligand-based virtual screening", "Structure-based screening"],
              "text": "Virtual screening"
            }],
            "comment": ["Virtual screening is used in drug discovery to search libraries of small molecules in order to identify those molecules which are most likely to bind to a drug target (typically a protein receptor or enzyme).", "Methods aim to predict the position and orientation of a ligand bound to a protein receptor or enzyme."],
            "data": {
              "uri": "http://edamontology.org/operation_0482"
            },
            "definition": "Model protein-ligand (for example protein-peptide) binding using comparative modelling or other techniques.",
            "exact_synonyms": ["Ligand-binding simulation"],
            "has_output": ["http://edamontology.org/data_1461"],
            "has_topic": ["http://edamontology.org/topic_0128"],
            "narrow_synonyms": ["Protein-peptide docking"],
            "text": "Protein-ligand docking"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3899"
            },
            "definition": "Model or simulate protein-protein binding using comparative modelling or other techniques.",
            "exact_synonyms": ["Protein docking"],
            "has_output": ["http://edamontology.org/data_1461"],
            "has_topic": ["http://edamontology.org/topic_0128"],
            "text": "Protein-protein docking"
          }],
          "comment": ["This includes protein-protein interactions, protein-nucleic acid, protein-ligand binding etc. Methods might predict whether the molecules are likely to bind in vivo, their conformation when bound, the strength of the interaction, possible mutations to achieve bonding and so on."],
          "data": {
            "uri": "http://edamontology.org/operation_0478"
          },
          "definition": "Model the structure of a protein in complex with a small molecule or another macromolecule.",
          "exact_synonyms": ["Macromolecular docking", "Docking simulation"],
          "has_output": ["http://edamontology.org/data_2877", "http://edamontology.org/data_1461"],
          "text": "Molecular docking"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_0387"
            },
            "definition": "Calculate the molecular surface area in proteins and other macromolecules.",
            "narrow_synonyms": ["Protein surface and interior calculation", "Protein surface calculation", "Protein residue surface calculation", "Protein atom surface calculation"],
            "text": "Molecular surface calculation"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3666"
            },
            "definition": "Compare two or more molecular surfaces.",
            "text": "Molecular surface comparison"
          }, {
            "comment": ["Solvent accessibility might be calculated for the backbone, sidechain and total (backbone plus sidechain)."],
            "data": {
              "uri": "http://edamontology.org/operation_0384"
            },
            "definition": "Calculate solvent accessible or buried surface areas in protein or other molecular structures.",
            "has_output": ["http://edamontology.org/data_1542"],
            "narrow_synonyms": ["Protein solvent accessibility calculation"],
            "text": "Accessible surface calculation"
          }, {
            "comment": ["A dot has three coordinates (x,y,z) and (typically) a color."],
            "data": {
              "uri": "http://edamontology.org/operation_1816"
            },
            "definition": "Calculate the positions of dots that are homogeneously distributed over the surface of a molecule.",
            "text": "Surface rendering"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_3351"
          },
          "definition": "Analyse the surface properties of proteins or other macromolecules, including surface accessible pockets, interior inaccessible cavities etc.",
          "has_topic": ["http://edamontology.org/topic_0166", "http://edamontology.org/topic_0123"],
          "text": "Molecular surface analysis"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_3453"
            },
            "definition": "The evaluation of diffraction intensities and integration of diffraction maxima from a diffraction experiment.",
            "narrow_synonyms": ["Diffraction profile fitting", "Diffraction summation integration"],
            "text": "Diffraction data integration"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3447"
            },
            "definition": "Processing of diffraction data into a corrected, ordered, and simplified form.",
            "text": "Diffraction data reduction"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3454"
            },
            "definition": "Phase a macromolecular crystal structure, for example by using molecular replacement or experimental phasing methods.",
            "text": "Phasing"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_3445"
          },
          "definition": "Analysis of data from a diffraction experiment.",
          "text": "Diffraction data analysis"
        }, {
          "children": [{
            "comment": ["A micrograph can include particles in multiple different orientations and/or conformations. Particles are compared and organised into sets based on their similarity. Typically iterations of classification and alignment and are performed to optimise the final 3D EM map."],
            "data": {
              "uri": "http://edamontology.org/operation_3458"
            },
            "definition": "Compare (align and classify) multiple particle images from a micrograph in order to produce a representative image of the particle.",
            "text": "Single particle alignment and classification"
          }],
          "comment": ["Single particle analysis is used to improve the information that can be obtained by relatively low resolution techniques, , e.g. an image of a protein or virus from transmission electron microscopy (TEM)."],
          "data": {
            "uri": "http://edamontology.org/operation_3457"
          },
          "definition": "An image processing technique that combines and analyze multiple images of a particulate sample, in order to produce an image with clearer features that are more easily interpreted.",
          "has_topic": ["http://edamontology.org/topic_1317"],
          "text": "Single particle analysis"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0297"
          },
          "definition": "Generate some type of structural (3D) profile or template from a structure or structure alignment.",
          "exact_synonyms": ["Structural profile construction", "Structural profile generation"],
          "has_input": ["http://edamontology.org/data_0886", "http://edamontology.org/data_0883"],
          "has_output": ["http://edamontology.org/data_0889"],
          "text": "3D profile generation"
        }, {
          "children": [{
            "children": [{
              "data": {
                "uri": "http://edamontology.org/operation_0502"
              },
              "definition": "Align RNA secondary structures.",
              "exact_synonyms": ["RNA secondary structure alignment construction", "RNA secondary structure alignment generation", "Secondary structure alignment (RNA)"],
              "has_input": ["http://edamontology.org/data_0880"],
              "has_output": ["http://edamontology.org/data_0881"],
              "text": "RNA secondary structure alignment"
            }, {
              "comment": ["Methods might use RNA motifs, predicted intermolecular contacts, or RNA sequence-structure compatibility (inverse RNA folding)."],
              "data": {
                "uri": "http://edamontology.org/operation_0278"
              },
              "definition": "Predict RNA secondary structure (for example knots, pseudoknots, alternative structures etc).",
              "has_output": ["http://edamontology.org/data_0880"],
              "narrow_synonyms": ["RNA shape prediction"],
              "text": "RNA secondary structure prediction"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_3469"
              },
              "definition": "Compute the covariance model for (a family of) RNA secondary structures.",
              "has_topic": ["http://edamontology.org/topic_0097"],
              "text": "RNA structure covariance model generation"
            }],
            "data": {
              "uri": "http://edamontology.org/operation_2439"
            },
            "definition": "Process (read and / or write) RNA secondary structure data.",
            "has_topic": ["http://edamontology.org/topic_0097"],
            "text": "RNA secondary structure analysis"
          }, {
            "comment": ["Principal Component Analysis (PCA) is a multivariate statistical analysis to obtain collective variables and reduce the dimensionality of the system."],
            "data": {
              "uri": "http://edamontology.org/operation_3891"
            },
            "definition": "Compute Essential Dynamics (ED) on a simulation trajectory: an analysis of molecule dynamics using PCA (Principal Component Analysis) applied to the atomic positional fluctuations.",
            "exact_synonyms": ["Principal modes", "ED", "PCA"],
            "text": "Essential dynamics"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_2518"
            },
            "definition": "Compare nucleic acid tertiary structures.",
            "exact_synonyms": ["Structure comparison (nucleic acid)"],
            "text": "Nucleic acid structure comparison"
          }, {
            "children": [{
              "comment": ["Methods might use RNA motifs, predicted intermolecular contacts, or RNA sequence-structure compatibility (inverse RNA folding)."],
              "data": {
                "uri": "http://edamontology.org/operation_0278"
              },
              "definition": "Predict RNA secondary structure (for example knots, pseudoknots, alternative structures etc).",
              "has_output": ["http://edamontology.org/data_0880"],
              "narrow_synonyms": ["RNA shape prediction"],
              "text": "RNA secondary structure prediction"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_0279"
              },
              "definition": "Analyse some aspect of RNA/DNA folding, typically by processing sequence and/or structural data.  For example, compute folding energies such as minimum folding energies for DNA or RNA sequences or energy landscape of RNA mutants.",
              "exact_synonyms": ["Nucleic acid folding", "Nucleic acid folding modelling", "Nucleic acid folding prediction"],
              "has_output": ["http://edamontology.org/data_1596"],
              "narrow_synonyms": ["Nucleic acid folding energy calculation"],
              "text": "Nucleic acid folding analysis"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_2441"
              },
              "definition": "Predict RNA tertiary structure.",
              "has_output": ["http://edamontology.org/data_1465"],
              "text": "RNA structure prediction"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_2442"
              },
              "definition": "Predict DNA tertiary structure.",
              "has_output": ["http://edamontology.org/data_1464"],
              "text": "DNA structure prediction"
            }],
            "comment": ["Methods might identify thermodynamically stable or evolutionarily conserved structures."],
            "data": {
              "uri": "http://edamontology.org/operation_0475"
            },
            "definition": "Predict structure of DNA or RNA.",
            "has_output": ["http://edamontology.org/data_1459"],
            "text": "Nucleic acid structure prediction"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0279"
            },
            "definition": "Analyse some aspect of RNA/DNA folding, typically by processing sequence and/or structural data.  For example, compute folding energies such as minimum folding energies for DNA or RNA sequences or energy landscape of RNA mutants.",
            "exact_synonyms": ["Nucleic acid folding", "Nucleic acid folding modelling", "Nucleic acid folding prediction"],
            "has_output": ["http://edamontology.org/data_1596"],
            "narrow_synonyms": ["Nucleic acid folding energy calculation"],
            "text": "Nucleic acid folding analysis"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_2481"
          },
          "definition": "Analyse nucleic acid tertiary structural data.",
          "has_input": ["http://edamontology.org/data_1459"],
          "has_topic": ["http://edamontology.org/topic_0097"],
          "text": "Nucleic acid structure analysis"
        }, {
          "children": [{
            "comment": ["The technique solves the phase problem, i.e. retrieve information concern phases of the structure."],
            "data": {
              "uri": "http://edamontology.org/operation_3455"
            },
            "definition": "A technique used to construct an atomic model of an unknown structure from diffraction data, based upon an atomic model of a known structure, either a related protein or the same protein from a different crystal form.",
            "text": "Molecular replacement"
          }, {
            "comment": ["Rigid body refinement usually follows molecular replacement in the assignment of a structure from diffraction data."],
            "data": {
              "uri": "http://edamontology.org/operation_3456"
            },
            "definition": "A method used to refine a structure by moving the whole molecule or parts of it as a rigid unit, rather than moving individual atoms.",
            "text": "Rigid body refinement"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_0322"
          },
          "definition": "Refine (after evaluation) a model of a molecular structure (typically a protein structure) to reduce steric clashes, volume irregularities etc.",
          "narrow_synonyms": ["Protein model refinement"],
          "text": "Molecular model refinement"
        }, {
          "children": [{
            "comment": ["This includes methods that use an existing alignment."],
            "data": {
              "uri": "http://edamontology.org/operation_0504"
            },
            "definition": "Align (superimpose) more than two molecular tertiary structures.",
            "exact_synonyms": ["Structure alignment (multiple)"],
            "narrow_synonyms": ["Multiple protein structure alignment"],
            "text": "Multiple structure alignment"
          }, {
            "comment": ["Local alignment methods identify regions of local similarity, common substructures etc."],
            "data": {
              "uri": "http://edamontology.org/operation_0509"
            },
            "definition": "Locally align (superimpose) two or more molecular tertiary structures.",
            "exact_synonyms": ["Structure alignment (local)"],
            "narrow_synonyms": ["Local protein structure alignment"],
            "text": "Local structure alignment"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0503"
            },
            "definition": "Align (superimpose) exactly two molecular tertiary structures.",
            "exact_synonyms": ["Structure alignment (pairwise)"],
            "narrow_synonyms": ["Pairwise protein structure alignment"],
            "text": "Pairwise structure alignment"
          }, {
            "comment": ["Global alignment methods identify similarity across the entire structures."],
            "data": {
              "uri": "http://edamontology.org/operation_0510"
            },
            "definition": "Globally align (superimpose) two or more molecular tertiary structures.",
            "exact_synonyms": ["Structure alignment (global)"],
            "narrow_synonyms": ["Global protein structure alignment"],
            "text": "Global structure alignment"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_0295"
          },
          "definition": "Align (superimpose) molecular tertiary structures.",
          "exact_synonyms": ["Structural alignment"],
          "has_output": ["http://edamontology.org/data_0886"],
          "narrow_synonyms": ["3D profile-to-3D profile alignment", "Structural profile alignment", "3D profile alignment"],
          "text": "Structure alignment"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_2476"
          },
          "definition": "The simulation of molecular (typically protein) conformation using a computational model of physical forces and computer simulation.",
          "exact_synonyms": ["Molecular dynamics simulation"],
          "has_output": ["http://edamontology.org/data_0883"],
          "has_topic": ["http://edamontology.org/topic_0176", "http://edamontology.org/topic_0082"],
          "narrow_synonyms": ["Protein dynamics"],
          "text": "Molecular dynamics"
        }, {
          "children": [{
            "comment": ["A dot has three coordinates (x,y,z) and (typically) a color."],
            "data": {
              "uri": "http://edamontology.org/operation_1816"
            },
            "definition": "Calculate the positions of dots that are homogeneously distributed over the surface of a molecule.",
            "text": "Surface rendering"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_2241"
            },
            "definition": "Visualise transmembrane proteins, typically the transmembrane regions within a sequence.",
            "exact_synonyms": ["Transmembrane protein rendering"],
            "has_output": ["http://edamontology.org/data_2992"],
            "text": "Transmembrane protein visualisation"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3890"
            },
            "definition": "3D visualization of a molecular trajectory.",
            "has_output": ["http://edamontology.org/data_2162"],
            "text": "Trajectory visualization"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_2485"
            },
            "definition": "Render a helical wheel representation of protein secondary structure.",
            "exact_synonyms": ["Helical wheel rendering"],
            "has_output": ["http://edamontology.org/data_2162"],
            "text": "Helical wheel drawing"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_2486"
            },
            "definition": "Render a topology diagram of protein secondary structure.",
            "exact_synonyms": ["Topology diagram rendering"],
            "has_output": ["http://edamontology.org/data_2992"],
            "text": "Topology diagram drawing"
          }],
          "comment": ["This includes visualisation of protein secondary structure such as knots, pseudoknots etc. as well as tertiary and quaternary structure."],
          "data": {
            "uri": "http://edamontology.org/operation_0570"
          },
          "definition": "Visualise or render molecular 3D structure, for example a high-quality static picture or animation.",
          "exact_synonyms": ["Structure rendering"],
          "has_input": ["http://edamontology.org/data_0883"],
          "has_output": ["http://edamontology.org/data_1710"],
          "narrow_synonyms": ["RNA secondary structure visualisation", "Protein secondary structure visualisation"],
          "text": "Structure visualisation"
        }],
        "data": {
          "uri": "http://edamontology.org/operation_2480"
        },
        "definition": "Analyse known molecular tertiary structures.",
        "has_topic": ["http://edamontology.org/topic_0081"],
        "text": "Structure analysis"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/operation_3703"
          },
          "definition": "Identification of the best reference for mapping for a specific dataset from a list of potential references, when performing genetic variation analysis.",
          "text": "Reference identification"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_3840"
            },
            "definition": "Genotyping of multiple loci, typically characterizing microbial species isolates using internal fragments of multiple housekeeping genes.",
            "exact_synonyms": ["MLST"],
            "text": "Multilocus sequence typing"
          }],
          "comment": ["Methods might consider cytogenetic analyses, copy number polymorphism (and calculate copy number calls for copy-number variation(CNV) regions), single nucleotide polymorphism (SNP), , rare copy number variation (CNV) identification, loss of heterozygosity data and so on."],
          "data": {
            "uri": "http://edamontology.org/operation_3196"
          },
          "definition": "Analyse DNA sequence data to identify differences between the genetic composition (genotype) of an individual compared to other individual's or a reference sequence.",
          "text": "Genotyping"
        }, {
          "children": [{
            "children": [{
              "data": {
                "uri": "http://edamontology.org/operation_3965"
              },
              "definition": "Identify amplification events causing the number of repeats in the genome to vary between individuals.",
              "text": "Amplification detection"
            }, {
              "comment": ["Methods typically implement some statistical model for hypothesis testing, and methods estimate total copy number, i.e. do not distinguish the two inherited chromosomes quantities (specific copy number)."],
              "data": {
                "uri": "http://edamontology.org/operation_3233"
              },
              "definition": "Estimate the number of copies of loci of particular gene(s) in DNA sequences typically from gene-expression profiling technology based on microarray hybridisation-based experiments. For example, estimate copy number (or marker dosage) of a dominant marker in samples from polyploid plant cells or tissues, or chromosomal gains and losses in tumors.",
              "exact_synonyms": ["Transcript copy number estimation"],
              "text": "Copy number estimation"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_3964"
              },
              "definition": "Identify copy number variations which are complex, e.g. multi-allelic variations that have many structural alleles and have rearranged multiple times in the ancestral genomes.",
              "text": "Complex CNV detection"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_3962"
              },
              "definition": "Identify deletion events causing the number of repeats in the genome to vary between individuals.",
              "text": "Deletion detection"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_3963"
              },
              "definition": "Identify duplication events causing the number of repeats in the genome to vary between individuals.",
              "text": "Duplication detection"
            }],
            "data": {
              "uri": "http://edamontology.org/operation_3961"
            },
            "definition": "Identify where sections of the genome are repeated and the number of repeats in the genome varies between individuals.",
            "exact_synonyms": ["CNV detection"],
            "text": "Copy number variation detection"
          }],
          "comment": ["Methods might involve analysis of whole-genome array comparative genome hybridisation or single-nucleotide polymorphism arrays, paired-end mapping of sequencing data, or from analysis of short reads from new sequencing technologies."],
          "data": {
            "uri": "http://edamontology.org/operation_3228"
          },
          "definition": "Detect large regions in a genome subject to copy-number variation, or other structural variations in genome(s).",
          "exact_synonyms": ["Structural variation discovery"],
          "text": "Structural variation detection"
        }, {
          "comment": ["Genome-wide association studies (GWAS) analyse a genome-wide set of genetic variants in different individuals to see if any variant is associated with a trait. Traditional association techniques can lack the power to detect the significance of rare variants individually, or measure their compound effect (rare variant burden).  \"Collapsing methods\" were developed to overcome these problems."],
          "data": {
            "uri": "http://edamontology.org/operation_3791"
          },
          "definition": "A method whereby data on several variants are \"collapsed\" into a single covariate based on regions such as genes.",
          "text": "Collapsing methods"
        }, {
          "comment": ["Methods often utilise a database of aligned reads."],
          "data": {
            "uri": "http://edamontology.org/operation_3504"
          },
          "definition": "Identify and map patterns of genomic variations.",
          "text": "Variant pattern analysis"
        }, {
          "children": [{
            "comment": ["Tools might use a genetic algorithm, quartet-mapping, bootscanning, graphical methods, random forest model and so on."],
            "data": {
              "uri": "http://edamontology.org/operation_0452"
            },
            "definition": "Identify insertion, deletion and duplication events from a sequence alignment.",
            "exact_synonyms": ["Sequence alignment analysis (indel detection)", "Indel discovery"],
            "text": "Indel detection"
          }, {
            "comment": ["Methods include sequence alignment (if related sequences are available) and word-based sequence comparison."],
            "data": {
              "uri": "http://edamontology.org/operation_0265"
            },
            "definition": "Detect frameshifts in DNA sequences, including frameshift sites and signals, and frameshift errors from sequencing projects.",
            "has_topic": ["http://edamontology.org/topic_3168"],
            "narrow_synonyms": ["Frameshift error detection"],
            "text": "Frameshift detection"
          }, {
            "comment": ["This includes functional SNPs for large-scale genotyping purposes, disease-associated non-synonymous SNPs etc."],
            "data": {
              "uri": "http://edamontology.org/operation_0484"
            },
            "definition": "Find single nucleotide polymorphisms (SNPs) - single nucleotide change in base positions - between sequences. Typically done for sequences from a high-throughput sequencing experiment that differ from a reference genome and which might, especially by reference to population frequency or functional data, indicate a polymorphism.",
            "exact_synonyms": ["SNP discovery", "Single nucleotide polymorphism detection", "SNP calling"],
            "text": "SNP detection"
          }],
          "comment": ["Variant detection", "Methods often utilise a database of aligned reads.", "Somatic variant calling is the detection of variations established in somatic cells and hence not inherited as a germ line variant."],
          "data": {
            "uri": "http://edamontology.org/operation_3227"
          },
          "definition": "Detect, identify and map mutations, such as single nucleotide polymorphisms, short indels and structural variants, in multiple DNA sequences. Typically the alignment and comparison of the fluorescent traces produced by DNA sequencing hardware, to study genomic alterations.",
          "exact_synonyms": ["Variant mapping"],
          "narrow_synonyms": ["Genome variant detection", "Mutation detection", "Germ line variant calling", "Exome variant detection", "de novo mutation detection", "Somatic variant calling", "Allele calling"],
          "text": "Variant calling"
        }, {
          "comment": ["Variants are typically classified by their position (intronic, exonic, etc.) in a gene transcript and (for variants in coding exons) by their effect on the protein sequence (synonymous, non-synonymous, frameshifting, etc.)"],
          "data": {
            "uri": "http://edamontology.org/operation_3225"
          },
          "definition": "Classify variants based on their potential effect on genes, especially functional effects on the expressed proteins.",
          "text": "Variant classification"
        }, {
          "comment": ["Variant prioritisation can be used for example to produce a list of variants responsible for 'knocking out' genes in specific genomes. Methods amino acid substitution, aggregative approaches, probabilistic approach, inheritance and unified likelihood-frameworks."],
          "data": {
            "uri": "http://edamontology.org/operation_3226"
          },
          "definition": "Identify biologically interesting variants by prioritizing individual variants, for example, homozygous variants absent in control genomes.",
          "text": "Variant prioritisation"
        }],
        "comment": ["Genetic variation annotation provides contextual interpretation of coding SNP consequences in transcripts. It allows comparisons to be made between variation data in different populations or strains for the same transcript."],
        "data": {
          "uri": "http://edamontology.org/operation_3197"
        },
        "definition": "Analyse a genetic variation, for example to annotate its location, alleles, classification, and effects on individual transcripts predicted for a gene model.",
        "exact_synonyms": ["Genetic variation annotation", "Sequence variation analysis", "Variant analysis"],
        "narrow_synonyms": ["Transcript variant analysis"],
        "text": "Genetic variation analysis"
      }, {
        "children": [{
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_0346"
            },
            "definition": "Search a sequence database and retrieve sequences that are similar to a query sequence.",
            "narrow_synonyms": ["Structure database search (by sequence)", "Sequence database search (by sequence)"],
            "text": "Sequence similarity search"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0349"
            },
            "definition": "Search a sequence database and retrieve sequences with a specified property, typically a physicochemical or compositional property.",
            "text": "Sequence database search (by property)"
          }],
          "comment": ["This excludes direct retrieval methods (e.g. the dbfetch program)."],
          "data": {
            "uri": "http://edamontology.org/operation_0338"
          },
          "definition": "Search a sequence database by sequence comparison and retrieve similar sequences.\nsequences matching a given sequence motif or pattern, such as a Prosite pattern or regular expression.",
          "has_output": ["http://edamontology.org/data_0857"],
          "text": "Sequence database search"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_2089"
            },
            "definition": "Refine an existing sequence alignment.",
            "text": "Sequence alignment refinement"
          }, {
            "comment": ["See also 'Sequence profile alignment'."],
            "data": {
              "uri": "http://edamontology.org/operation_0259"
            },
            "definition": "Compare (typically by aligning) two molecular sequence alignments.",
            "text": "Sequence alignment comparison"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0296"
            },
            "definition": "Generate some type of sequence profile (for example a hidden Markov model) from a sequence alignment.",
            "exact_synonyms": ["Sequence profile construction"],
            "has_input": ["http://edamontology.org/data_0863"],
            "has_output": ["http://edamontology.org/data_1354"],
            "has_topic": ["http://edamontology.org/topic_0160"],
            "text": "Sequence profile generation"
          }, {
            "comment": ["Evaluation might be purely sequence-based or use structural information."],
            "data": {
              "uri": "http://edamontology.org/operation_0447"
            },
            "definition": "Evaluate molecular sequence alignment accuracy.",
            "exact_synonyms": ["Sequence alignment quality evaluation"],
            "text": "Sequence alignment validation"
          }, {
            "comment": ["This is typically done to identify possible covarying positions and predict contacts or structural constraints in protein structures."],
            "data": {
              "uri": "http://edamontology.org/operation_0449"
            },
            "definition": "Analyse correlations between sites in a molecular sequence alignment.",
            "text": "Sequence alignment analysis (site correlation)"
          }, {
            "comment": ["Use this concept for methods that calculate substitution rates, estimate relative site variability, identify sites with biased properties, derive a consensus sequence, or identify highly conserved or very poorly conserved sites, regions, blocks etc."],
            "data": {
              "uri": "http://edamontology.org/operation_0448"
            },
            "definition": "Analyse character conservation in a molecular sequence alignment, for example to derive a consensus sequence.",
            "exact_synonyms": ["Residue conservation analysis"],
            "text": "Sequence alignment analysis (conservation)"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_0258"
          },
          "definition": "Analyse a molecular sequence alignment.",
          "has_input": ["http://edamontology.org/data_0863"],
          "text": "Sequence alignment analysis"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3461"
          },
          "definition": "The prediction of the degree of pathogenicity of a microorganism from analysis of molecular sequences.",
          "exact_synonyms": ["Pathogenicity prediction"],
          "has_topic": ["http://edamontology.org/topic_3301"],
          "text": "Virulence prediction"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_3185"
            },
            "definition": "Identify base (nucleobase) sequence from a fluorescence 'trace' data generated by an automated DNA sequencer.",
            "exact_synonyms": ["Phred base-calling", "Base calling", "Phred base calling"],
            "has_topic": ["http://edamontology.org/topic_3168"],
            "text": "Base-calling"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0363"
            },
            "definition": "Generate the reverse and / or complement of a nucleotide sequence.",
            "exact_synonyms": ["Reverse and complement", "Reverse / complement", "Nucleic acid sequence reverse and complement"],
            "text": "Reverse complement"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0364"
            },
            "definition": "Generate a random sequence, for example, with a specific character composition.",
            "text": "Random sequence generation"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0366"
            },
            "definition": "Cleave a protein sequence into peptide fragments (corresponding to enzymatic or chemical cleavage).",
            "has_output": ["http://edamontology.org/data_1238"],
            "has_topic": ["http://edamontology.org/topic_0121"],
            "text": "Protein sequence cleavage"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0365"
            },
            "definition": "Generate digest fragments for a nucleotide sequence containing restriction sites.",
            "exact_synonyms": ["Nucleic acid restriction digest"],
            "has_output": ["http://edamontology.org/data_1239"],
            "text": "Restriction digest"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3481"
            },
            "definition": "Generate sequences from some probabilistic model, e.g. a model that simulates evolution.",
            "text": "Probabilistic sequence generation"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3644"
            },
            "definition": "Analytical process that derives a peptide's amino acid sequence from its tandem mass spectrum (MS/MS) without the assistance of a sequence database.",
            "text": "de Novo sequencing"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_0230"
          },
          "definition": "Generate a molecular sequence by some means.",
          "narrow_synonyms": ["Sequence generation (nucleic acid)", "Sequence generation (protein)"],
          "text": "Sequence generation"
        }, {
          "children": [{
            "children": [{
              "data": {
                "uri": "http://edamontology.org/operation_0428"
              },
              "definition": "Detect polyA signals in nucleotide sequences.",
              "exact_synonyms": ["PolyA detection", "Polyadenylation signal prediction", "Polyadenylation signal detection", "PolyA signal prediction", "PolyA prediction"],
              "text": "PolyA signal detection"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_0431"
              },
              "definition": "Find and identify restriction enzyme cleavage sites (restriction sites) in (typically) DNA sequences, for example to generate a restriction map.",
              "has_topic": ["http://edamontology.org/topic_0160"],
              "text": "Restriction site recognition"
            }, {
              "comment": ["Chip-sequencing combines chromatin immunoprecipitation (ChIP) with massively parallel DNA sequencing to generate a set of reads, which are aligned to a genome sequence.  The enriched areas contain the binding sites of DNA-associated proteins.  For example, a transcription factor binding site. ChIP-on-chip in contrast combines chromatin immunoprecipitation ('ChIP') with microarray ('chip').  \"Peak-pair calling\" is similar to \"Peak calling\" in the context of ChIP-exo."],
              "data": {
                "uri": "http://edamontology.org/operation_3222"
              },
              "definition": "Identify putative protein-binding regions in a genome sequence from analysis of Chip-sequencing data or ChIP-on-chip data.",
              "exact_synonyms": ["Protein binding peak detection"],
              "narrow_synonyms": ["Peak-pair calling"],
              "text": "Peak calling"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_0379"
              },
              "definition": "Find (and possibly render) short repetitive subsequences (repeat sequences) in (typically nucleotide) sequences.",
              "text": "Repeat sequence detection"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_0266"
              },
              "definition": "Detect vector sequences in nucleotide sequence, typically by comparison to a set of known vector sequences.",
              "text": "Vector sequence detection"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_0432"
              },
              "definition": "Identify or predict nucleosome exclusion sequences (nucleosome free regions) in DNA.",
              "narrow_synonyms": ["Nucleosome exclusion sequence prediction", "Nucleosome formation sequence prediction"],
              "text": "Nucleosome position prediction"
            }, {
              "comment": ["An isochore is long region (> 3 KB) of DNA with very uniform GC content, in contrast to the rest of the genome. Isochores tend tends to have more genes, higher local melting or denaturation temperatures, and different flexibility. Methods might calculate fractional GC content or variation of GC content, predict methylation status of CpG islands etc. This includes methods that visualise CpG rich regions in a nucleotide sequence, for example plot isochores in a genome sequence."],
              "data": {
                "uri": "http://edamontology.org/operation_0430"
              },
              "definition": "Find CpG rich regions in a nucleotide sequence or isochores in genome sequences.",
              "exact_synonyms": ["CpG island and isochores rendering", "CpG island and isochores detection"],
              "has_topic": ["http://edamontology.org/topic_0157"],
              "text": "CpG island and isochore detection"
            }, {
              "comment": ["Methods might use RNA motifs, predicted intermolecular contacts, or RNA sequence-structure compatibility (inverse RNA folding)."],
              "data": {
                "uri": "http://edamontology.org/operation_0278"
              },
              "definition": "Predict RNA secondary structure (for example knots, pseudoknots, alternative structures etc).",
              "has_output": ["http://edamontology.org/data_0880"],
              "narrow_synonyms": ["RNA shape prediction"],
              "text": "RNA secondary structure prediction"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_0427"
              },
              "definition": "Detect or predict transposons, retrotransposons / retrotransposition signatures etc.",
              "text": "Transposon prediction"
            }, {
              "comment": ["Quadruplex (4-stranded) structures are formed by guanine-rich regions and are implicated in various important biological processes and as therapeutic targets."],
              "data": {
                "uri": "http://edamontology.org/operation_0429"
              },
              "definition": "Detect quadruplex-forming motifs in nucleotide sequences.",
              "exact_synonyms": ["Quadruplex structure prediction"],
              "has_output": ["http://edamontology.org/data_3128"],
              "text": "Quadruplex formation site detection"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_3677"
              },
              "definition": "Identify binding sites in nucleic acid sequences that are statistically significantly differentially bound between sample groups.",
              "text": "Differential binding analysis"
            }],
            "comment": ["Methods typically involve scanning for known motifs, patterns and regular expressions.", "This is placeholder but does not comprehensively include all child concepts - please inspect other concepts under \"Nucleic acid sequence analysis\" for example \"Gene prediction\", for other feature detection operations."],
            "data": {
              "uri": "http://edamontology.org/operation_0415"
            },
            "definition": "Predict, recognise and identify features in nucleotide sequences such as functional sites or regions, typically by scanning for known motifs, patterns and regular expressions.",
            "exact_synonyms": ["Sequence feature detection (nucleic acid)"],
            "has_output": ["http://edamontology.org/data_1276"],
            "has_topic": ["http://edamontology.org/topic_0160"],
            "narrow_synonyms": ["Nucleic acid feature recognition", "Nucleic acid site prediction", "Nucleic acid feature prediction", "Nucleic acid site recognition", "Nucleic acid site detection"],
            "text": "Nucleic acid feature detection"
          }, {
            "children": [{
              "comment": ["For example process paired end reads to trim low quality ends remove short sequences, identify sequence inserts, detect chimeric reads, or remove low quality sequnces including vector, adaptor, low complexity and contaminant sequences. Sequences might come from genomic DNA library, EST libraries, SSH library and so on."],
              "data": {
                "uri": "http://edamontology.org/operation_3219"
              },
              "definition": "Pre-process sequence reads to ensure (or improve) quality and reliability.",
              "exact_synonyms": ["Sequence read pre-processing"],
              "text": "Read pre-processing"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_3187"
              },
              "definition": "Identify and filter a (typically large) sequence data set to remove sequences from contaminants in the sample that was sequenced.",
              "text": "Sequence contamination filtering"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_3675"
              },
              "definition": "Variant filtering is used to eliminate false positive variants based for example on base calling quality, strand and position information, and mapping info.",
              "text": "Variant filtering"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_3180"
              },
              "definition": "Evaluate a DNA sequence assembly, typically for purposes of quality control.",
              "exact_synonyms": ["Assembly quality evaluation", "Sequence assembly quality evaluation", "Sequence assembly QC", "Assembly QC"],
              "has_input": ["http://edamontology.org/data_0925"],
              "has_output": ["http://edamontology.org/data_3181"],
              "has_topic": ["http://edamontology.org/topic_0196"],
              "text": "Sequence assembly validation"
            }],
            "comment": ["Analyse raw sequence data from a sequencing pipeline and identify (and possiby fix) problems."],
            "data": {
              "uri": "http://edamontology.org/operation_3218"
            },
            "definition": "Raw sequence data quality control.",
            "exact_synonyms": ["Sequencing QC", "Sequencing quality assessment"],
            "text": "Sequencing quality control"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/operation_0284"
              },
              "definition": "Calculate codon usage statistics and create a codon usage table.",
              "exact_synonyms": ["Codon usage table construction"],
              "has_output": ["http://edamontology.org/data_1597"],
              "text": "Codon usage table generation"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_2964"
              },
              "definition": "Calculate the differences in codon usage fractions between two sequences, sets of sequences, codon usage tables etc.",
              "has_output": ["http://edamontology.org/data_1602"],
              "text": "Codon usage fraction calculation"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_0489"
              },
              "definition": "Predict genetic code from analysis of codon usage data.",
              "has_output": ["http://edamontology.org/data_1598"],
              "text": "Genetic code prediction"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_3946"
              },
              "definition": "The development and use of mathematical models and systems analysis for the description of ecological processes, and applications such as the sustainable management of resources.",
              "has_output": ["http://edamontology.org/data_1439"],
              "has_topic": ["http://edamontology.org/topic_0084"],
              "text": "Ecological modelling"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_0285"
              },
              "definition": "Compare two or more codon usage tables.",
              "text": "Codon usage table comparison"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_0550"
              },
              "definition": "Identify a plausible model of DNA substitution that explains a molecular (DNA or protein) sequence alignment.",
              "exact_synonyms": ["Nucleotide substitution modelling"],
              "has_output": ["http://edamontology.org/data_1439"],
              "has_topic": ["http://edamontology.org/topic_0084"],
              "text": "DNA substitution modelling"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_0287"
              },
              "definition": "Identify and plot third base position variability in a nucleotide sequence.",
              "has_output": ["http://edamontology.org/data_1263"],
              "has_topic": ["http://edamontology.org/topic_0114"],
              "text": "Base position variability plotting"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_2962"
              },
              "definition": "Calculate codon usage bias, e.g. generate a codon usage bias plot.",
              "has_output": ["http://edamontology.org/data_2865"],
              "narrow_synonyms": ["Codon usage bias plotting"],
              "text": "Codon usage bias calculation"
            }],
            "data": {
              "uri": "http://edamontology.org/operation_0286"
            },
            "definition": "Analyse codon usage in molecular sequences or process codon usage data (e.g. a codon usage table).",
            "exact_synonyms": ["Codon usage data analysis", "Codon usage table analysis"],
            "has_input": ["http://edamontology.org/data_2977", "http://edamontology.org/data_1597"],
            "has_output": ["http://edamontology.org/data_1597", "http://edamontology.org/data_0914"],
            "has_topic": ["http://edamontology.org/topic_0203"],
            "text": "Codon usage analysis"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/operation_3793"
              },
              "definition": "Counting and summarising the number of short sequence reads that map to genomic features.",
              "text": "Read summarisation"
            }, {
              "comment": ["For example process paired end reads to trim low quality ends remove short sequences, identify sequence inserts, detect chimeric reads, or remove low quality sequnces including vector, adaptor, low complexity and contaminant sequences. Sequences might come from genomic DNA library, EST libraries, SSH library and so on."],
              "data": {
                "uri": "http://edamontology.org/operation_3219"
              },
              "definition": "Pre-process sequence reads to ensure (or improve) quality and reliability.",
              "exact_synonyms": ["Sequence read pre-processing"],
              "text": "Read pre-processing"
            }, {
              "comment": ["Binning methods use one or a combination of compositional features or sequence similarity."],
              "data": {
                "uri": "http://edamontology.org/operation_3798"
              },
              "definition": "An operation which groups reads or contigs and assigns them to operational taxonomic units.",
              "exact_synonyms": ["Binning", "Binning shotgun reads"],
              "text": "Read binning"
            }, {
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/operation_3199"
                },
                "definition": "A varient of oligonucleotide mapping where a read is mapped to two separate locations because of possible structural variation.",
                "exact_synonyms": ["Split-read mapping"],
                "text": "Split read mapping"
              }],
              "comment": ["The purpose of read mapping is to identify the location of sequenced fragments within a reference genome and assumes that there is, in fact, at least local similarity between the fragment and reference sequences."],
              "data": {
                "uri": "http://edamontology.org/operation_3198"
              },
              "definition": "Align short oligonucleotide sequences (reads) to a larger (genomic) sequence.",
              "exact_synonyms": ["Short read alignment", "Oligonucleotide alignment", "Short oligonucleotide alignment", "Oligonucleotide mapping", "Oligonucleotide alignment generation", "Read alignment", "Short sequence read mapping", "Short read mapping", "Oligonucleotide alignment construction"],
              "text": "Read mapping"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_3230"
              },
              "definition": "Analyse mapping density (read depth) of (typically) short reads from sequencing platforms, for example, to detect deletions and duplications.",
              "text": "Read depth analysis"
            }, {
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/operation_3565"
                },
                "definition": "Analyze time series data from an RNA-seq experiment.",
                "text": "RNA-seq time series data analysis"
              }, {
                "data": {
                  "uri": "http://edamontology.org/operation_3563"
                },
                "definition": "Analyze read counts from RNA-seq experiments.",
                "text": "RNA-seq read count analysis"
              }],
              "data": {
                "uri": "http://edamontology.org/operation_3680"
              },
              "definition": "Analyze data from RNA-seq experiments.",
              "text": "RNA-Seq analysis"
            }, {
              "comment": ["NGS sequence runs are often performed with multiple samples pooled together.  In such cases, an index tag (or \"barcode\") - a unique sequence of between 6 and 12bp - is ligated to each sample's genetic material so that the sequence reads from different samples can be identified. The process of demultiplexing (dividing sequence reads into separate files for each index tag/sample) may be performed automatically by the sequencing hardware. Alternatively the reads may be lumped together in one file with barcodes still attached, requiring you to do the splitting using software. In such cases, a \"mapping\" file is used which indicates which barcodes correspond to which samples."],
              "data": {
                "uri": "http://edamontology.org/operation_3933"
              },
              "definition": "Assigning sequence reads to separate groups / files based on their index tag (sample origin).",
              "exact_synonyms": ["Sequence demultiplexing"],
              "text": "Demultiplexing"
            }],
            "data": {
              "uri": "http://edamontology.org/operation_3921"
            },
            "definition": "The processing of reads from high-throughput sequencing machines.",
            "text": "Sequence read processing"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3950"
            },
            "definition": "The detection of genetic selection, or (the end result of) the process by which certain traits become more prevalent in a species than other traits.",
            "text": "Selection detection"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3894"
            },
            "definition": "Analyse DNA sequences in order to determine an individual's DNA characteristics, for example in criminal forensics, parentage testing and so on.",
            "exact_synonyms": ["DNA fingerprinting"],
            "text": "DNA profiling"
          }, {
            "children": [{
              "children": [{
                "comment": ["Haplotype inference can help in population genetic studies and the identification of complex disease genes, , and is typically based on aligned single nucleotide polymorphism (SNP) fragments. Haplotype comparison is a useful way to characterize the genetic variation between individuals. An individual's haplotype describes which nucleotide base occurs at each position for a set of common SNPs. Tools might use combinatorial functions (for example parsimony) or a likelihood function or model with optimisation such as minimum error correction (MEC) model, expectation-maximisation algorithm (EM), genetic algorithm or Markov chain Monte Carlo (MCMC)."],
                "data": {
                  "uri": "http://edamontology.org/operation_0487"
                },
                "definition": "Infer haplotypes, either alleles at multiple loci that are transmitted together on the same chromosome, or a set of single nucleotide polymorphisms (SNPs) on a single chromatid that are statistically associated.",
                "exact_synonyms": ["Haplotype reconstruction", "Haplotype map generation", "Haplotype inference"],
                "has_output": ["http://edamontology.org/data_1863"],
                "text": "Haplotype mapping"
              }],
              "comment": ["Mapping involves ordering genetic loci along a chromosome and estimating the physical distance between loci. A genetic map shows the relative (not physical) position of known genes and genetic markers.", "This includes mapping of the genetic architecture of dynamic complex traits (functional mapping), e.g. by characterisation of the underlying quantitative trait loci (QTLs) or nucleotides (QTNs)."],
              "data": {
                "uri": "http://edamontology.org/operation_0282"
              },
              "definition": "Generate a genetic (linkage) map of a DNA sequence (typically a chromosome) showing the relative positions of genetic markers based on estimation of non-physical distances.",
              "exact_synonyms": ["Genetic cartography", "Genetic map construction", "Functional mapping", "Genetic map generation", "Linkage mapping"],
              "has_output": ["http://edamontology.org/data_1278"],
              "narrow_synonyms": ["QTL mapping"],
              "text": "Genetic mapping"
            }, {
              "comment": ["Linkage disequilibrium is identified where a combination of alleles (or genetic markers) occurs more or less frequently in a population than expected by chance formation of haplotypes."],
              "data": {
                "uri": "http://edamontology.org/operation_0488"
              },
              "definition": "Calculate linkage disequilibrium; the non-random association of alleles or polymorphisms at two or more loci (not necessarily on the same chromosome).",
              "has_output": ["http://edamontology.org/data_0927"],
              "text": "Linkage disequilibrium calculation"
            }],
            "comment": ["For example, estimate how close two genes are on a chromosome by calculating how often they are transmitted together to an offspring, ascertain whether two genes are linked and parental linkage, calculate linkage map distance etc."],
            "data": {
              "uri": "http://edamontology.org/operation_0283"
            },
            "definition": "Analyse genetic linkage.",
            "has_output": ["http://edamontology.org/data_0927"],
            "has_topic": ["http://edamontology.org/topic_0102"],
            "text": "Linkage analysis"
          }, {
            "children": [{
              "comment": ["The final sequence will resemble the backbone sequence. Mapping assemblers are usually much faster and less memory intensive than de-novo assemblers."],
              "data": {
                "uri": "http://edamontology.org/operation_0523"
              },
              "definition": "Sequence assembly by combining fragments using an existing backbone sequence, typically a reference genome.",
              "exact_synonyms": ["Sequence assembly (mapping assembly)"],
              "text": "Mapping assembly"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_3730"
              },
              "definition": "Construction of a single sequence assembly of all reads from different samples, typically as part of a comparative metagenomic analysis.",
              "exact_synonyms": ["Sequence assembly (cross-assembly)"],
              "text": "Cross-assembly"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_3258"
              },
              "definition": "Infer a transcriptome sequence by analysis of short sequence reads.",
              "has_output": ["http://edamontology.org/data_0925"],
              "has_topic": ["http://edamontology.org/topic_0196"],
              "text": "Transcriptome assembly"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_3183"
              },
              "definition": "Reconstruction of a sequence assembly in a localised area.",
              "text": "Localised reassembly"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_3229"
              },
              "definition": "Analyse sequencing data from experiments aiming to selectively sequence the coding regions of the genome.",
              "exact_synonyms": ["Exome sequence analysis"],
              "text": "Exome assembly"
            }, {
              "comment": ["De-novo assemblers are much slower and more memory intensive than mapping assemblers."],
              "data": {
                "uri": "http://edamontology.org/operation_0524"
              },
              "definition": "Sequence assembly by combining fragments without the aid of a reference sequence or genome.",
              "exact_synonyms": ["De Bruijn graph", "Sequence assembly (de-novo assembly)"],
              "text": "De-novo assembly"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_0525"
              },
              "definition": "The process of assembling many short DNA sequences together such thay they represent the original chromosomes from which the DNA originated.",
              "exact_synonyms": ["Genomic assembly", "Sequence assembly (genome assembly)"],
              "narrow_synonyms": ["Breakend assembly"],
              "text": "Genome assembly"
            }, {
              "children": [{
                "comment": ["Different techniques are used to generate gap sequences to connect contigs, depending on the size of the gap. For small (5-20kb) gaps, PCR amplification and sequencing is used.  For large (>20kb) gaps, fragments are cloned (e.g. in BAC (Bacterial artificial chromosomes) vectors) and then sequenced."],
                "data": {
                  "uri": "http://edamontology.org/operation_3217"
                },
                "definition": "Fill the gaps in a sequence assembly (scaffold) by merging in additional sequences.",
                "text": "Scaffold gap completion"
              }],
              "comment": ["Scaffold may be positioned along a chromosome physical map to create a \"golden path\"."],
              "data": {
                "uri": "http://edamontology.org/operation_3216"
              },
              "definition": "Link together a non-contiguous series of genomic sequences into a scaffold, consisting of sequences separated by gaps of known length.  The sequences that are linked are typically typically contigs; contiguous sequences corresponding to read overlaps.",
              "exact_synonyms": ["Scaffold generation", "Scaffold construction"],
              "has_topic": ["http://edamontology.org/topic_0077"],
              "text": "Scaffolding"
            }, {
              "comment": ["Assemblers must handle (or be complicated by) alternative splicing, trans-splicing, single-nucleotide polymorphism (SNP), recoding, and post-transcriptional modification."],
              "data": {
                "uri": "http://edamontology.org/operation_0526"
              },
              "definition": "Sequence assembly for EST sequences (transcribed mRNA).",
              "exact_synonyms": ["Sequence assembly (EST assembly)"],
              "text": "EST assembly"
            }],
            "comment": ["For example, assemble overlapping reads from paired-end sequencers into contigs (a contiguous sequence corresponding to read overlaps). Or assemble contigs, for example ESTs and genomic DNA fragments, depending on the detected fragment overlaps."],
            "data": {
              "uri": "http://edamontology.org/operation_0310"
            },
            "definition": "Combine (align and merge) overlapping fragments of a DNA sequence to reconstruct the original sequence.",
            "has_output": ["http://edamontology.org/data_0925"],
            "has_topic": ["http://edamontology.org/topic_0196"],
            "narrow_synonyms": ["Sequence assembly editing", "Metagenomic assembly"],
            "text": "Sequence assembly"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/operation_0435"
              },
              "definition": "Find operons (operators, promoters and genes) in bacteria genes.",
              "text": "Operon prediction"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_3663"
              },
              "definition": "Prediction of genes or gene components by reference to homologous genes.",
              "exact_synonyms": ["Empirical gene finding", "Evidence-based gene prediction", "Empirical gene prediction", "Similarity-based gene prediction", "Gene prediction (homology-based)"],
              "narrow_synonyms": ["Homology prediction", "Orthology prediction"],
              "text": "Homology-based gene prediction"
            }, {
              "children": [{
                "children": [{
                  "data": {
                    "uri": "http://edamontology.org/operation_0445"
                  },
                  "definition": "Identify or predict transcription factor binding sites in DNA sequences.",
                  "text": "Transcription factor binding site prediction"
                }, {
                  "comment": ["An exonic splicing enhancer (ESE) is 6-base DNA sequence motif in an exon that enhances or directs splicing of pre-mRNA or hetero-nuclear RNA (hnRNA) into mRNA."],
                  "data": {
                    "uri": "http://edamontology.org/operation_0446"
                  },
                  "definition": "Identify or predict exonic splicing enhancers (ESE) in exons.",
                  "has_topic": ["http://edamontology.org/topic_0114"],
                  "text": "Exonic splicing enhancer prediction"
                }],
                "comment": ["Methods might recognize CG content, CpG islands, splice sites, polyA signals etc."],
                "data": {
                  "uri": "http://edamontology.org/operation_0440"
                },
                "definition": "Identify or predict whole promoters or promoter elements (transcription start sites, RNA polymerase binding site, transcription factor binding sites, promoter enhancers etc) in DNA sequences.",
                "text": "Promoter prediction"
              }, {
                "children": [{
                  "data": {
                    "uri": "http://edamontology.org/operation_0465"
                  },
                  "definition": "Assess binding specificity of putative siRNA sequence(s), for example for a functional assay, typically with respect to designing specific siRNA sequences.",
                  "has_topic": ["http://edamontology.org/topic_0659"],
                  "text": "siRNA binding specificity prediction"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/operation_2008"
                  },
                  "definition": "Identify or predict siRNA duplexes in RNA.",
                  "has_topic": ["http://edamontology.org/topic_0659"],
                  "text": "siRNA duplex prediction"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/operation_0463"
                  },
                  "definition": "Identify or predict microRNA sequences (miRNA) and precursors or microRNA targets / binding sites in a DNA sequence.",
                  "exact_synonyms": ["microRNA detection", "microRNA target detection", "miRNA prediction"],
                  "text": "miRNA target prediction"
                }],
                "comment": ["Trans-regulatory elements regulate genes distant from the gene from which they were transcribed."],
                "data": {
                  "uri": "http://edamontology.org/operation_0443"
                },
                "definition": "Identify or predict functional RNA sequences with a gene regulatory role (trans-regulatory elements) or targets.",
                "exact_synonyms": ["Functional RNA identification", "Transcriptional regulatory element prediction (trans)"],
                "has_topic": ["http://edamontology.org/topic_0659"],
                "text": "trans-regulatory element prediction"
              }, {
                "comment": ["Cis-regulatory elements (cis-elements) regulate the expression of genes located on the same strand from which the element was transcribed. Cis-elements are found in the 5' promoter region of the gene, in an intron, or in the 3' untranslated region. Cis-elements are often binding sites of one or more trans-acting factors. They also occur in RNA sequences, e.g. a riboswitch is a region of an mRNA molecule that bind a small target molecule that regulates the gene's activity."],
                "data": {
                  "uri": "http://edamontology.org/operation_0441"
                },
                "definition": "Identify, predict or analyse cis-regulatory elements  in DNA sequences (TATA box, Pribnow box, SOS box, CAAT box, CCAAT box, operator etc.) or in RNA sequences (e.g. riboswitches).",
                "narrow_synonyms": ["Transcriptional regulatory element prediction (DNA-cis)", "Transcriptional regulatory element prediction (RNA-cis)"],
                "text": "cis-regulatory element prediction"
              }, {
                "comment": ["MAR/SAR sites often flank a gene or gene cluster and are found nearby cis-regulatory sequences. They might contribute to transcription regulation."],
                "data": {
                  "uri": "http://edamontology.org/operation_0444"
                },
                "definition": "Identify matrix/scaffold attachment regions (MARs/SARs) in DNA sequences.",
                "exact_synonyms": ["MAR/SAR prediction", "Matrix/scaffold attachment site prediction"],
                "text": "S/MAR prediction"
              }],
              "comment": ["This includes promoters, enhancers, silencers and boundary elements / insulators, regulatory protein or transcription factor binding sites etc. Methods might be specific to a particular genome and use motifs, word-based / grammatical methods, position-specific frequency matrices, discriminative pattern analysis etc."],
              "data": {
                "uri": "http://edamontology.org/operation_0438"
              },
              "definition": "Identify or predict transcriptional regulatory motifs, patterns, elements or regions in DNA sequences.",
              "exact_synonyms": ["Transcription regulatory element prediction", "Regulatory element prediction"],
              "has_topic": ["http://edamontology.org/topic_0749"],
              "narrow_synonyms": ["Conserved transcription regulatory sequence identification", "Translational regulatory element prediction"],
              "text": "Transcriptional regulatory element prediction"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_3662"
              },
              "definition": "Prediction of genes or gene components from first principles, i.e. without reference to existing genes.",
              "exact_synonyms": ["Gene prediction (ab-initio)"],
              "text": "Ab-initio gene prediction"
            }, {
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/operation_0439"
                },
                "definition": "Predict translation initiation sites, possibly by searching a database of sites.",
                "has_topic": ["http://edamontology.org/topic_0108"],
                "text": "Translation initiation site prediction"
              }],
              "data": {
                "uri": "http://edamontology.org/operation_0436"
              },
              "definition": "Predict protein-coding regions (CDS or exon) or open reading frames in nucleotide sequences.",
              "exact_synonyms": ["ORF finding", "ORF prediction"],
              "text": "Coding region prediction"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_0464"
              },
              "definition": "Identify or predict tRNA genes in genomic sequences (tRNA).",
              "has_topic": ["http://edamontology.org/topic_0659"],
              "text": "tRNA gene prediction"
            }, {
              "comment": ["SECIS elements are around 60 nucleotides in length with a stem-loop structure directs the cell to translate UGA codons as selenocysteines."],
              "data": {
                "uri": "http://edamontology.org/operation_0437"
              },
              "definition": "Predict selenocysteine insertion sequence (SECIS) in a DNA sequence.",
              "exact_synonyms": ["Selenocysteine insertion sequence (SECIS) prediction"],
              "has_output": ["http://edamontology.org/data_0916"],
              "text": "SECIS element prediction"
            }, {
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/operation_0264"
                },
                "definition": "Predict splicing alternatives or transcript isoforms from analysis of sequence data.",
                "exact_synonyms": ["Splice transcript prediction", "Alternative splicing detection", "Differential splicing analysis", "Alternative splicing analysis"],
                "has_topic": ["http://edamontology.org/topic_0114"],
                "text": "Alternative splicing prediction"
              }, {
                "comment": ["Methods might require a pre-mRNA or genomic DNA sequence."],
                "data": {
                  "uri": "http://edamontology.org/operation_0433"
                },
                "definition": "Identify, predict or analyse splice sites in nucleotide sequences.",
                "exact_synonyms": ["Splice prediction"],
                "has_topic": ["http://edamontology.org/topic_0114"],
                "text": "Splice site prediction"
              }],
              "data": {
                "uri": "http://edamontology.org/operation_2499"
              },
              "definition": "Predict, analyse, characterize or model splice sites, splicing events and so on, typically by comparing multiple nucleic acid sequences.",
              "exact_synonyms": ["Splicing model analysis"],
              "has_topic": ["http://edamontology.org/topic_0114"],
              "text": "Splicing analysis"
            }],
            "comment": ["Methods for gene prediction might be ab initio, based on phylogenetic comparisons, use motifs, sequence features, support vector machine, alignment etc."],
            "data": {
              "uri": "http://edamontology.org/operation_2454"
            },
            "definition": "Detect, predict and identify genes or components of genes in DNA sequences, including promoters, coding regions, splice sites, etc.",
            "exact_synonyms": ["Gene finding", "Gene calling"],
            "has_output": ["http://edamontology.org/data_0916"],
            "has_topic": ["http://edamontology.org/topic_0114"],
            "narrow_synonyms": ["Whole gene prediction"],
            "text": "Gene prediction"
          }, {
            "children": [{
              "comment": ["Many sequence alignment tasks involving many or very large sequences rely on a precomputed index of the sequence to accelerate the alignment.  The Burrows-Wheeler Transform (BWT) is a permutation of the genome based on a suffix array algorithm.  A suffix array consists of the lexicographically sorted list of suffixes of a genome."],
              "data": {
                "uri": "http://edamontology.org/operation_3211"
              },
              "definition": "Generate an index of a genome sequence.",
              "has_output": ["http://edamontology.org/data_3210"],
              "narrow_synonyms": ["Genome indexing (suffix arrays)", "Burrows-Wheeler", "Genome indexing (Burrows-Wheeler)", "Suffix arrays"],
              "text": "Genome indexing"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_3209"
              },
              "definition": "Compare the sequence or features of two or more genomes, for example, to find matching regions.",
              "exact_synonyms": ["Genomic region matching"],
              "text": "Genome comparison"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_0362"
              },
              "definition": "Annotate a genome sequence with terms from a controlled vocabulary.",
              "narrow_synonyms": ["Structural genome annotation", "Metagenome annotation", "Functional genome annotation"],
              "text": "Genome annotation"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_3182"
              },
              "definition": "Align two or more (tpyically huge) molecular sequences that represent genomes.",
              "exact_synonyms": ["Whole genome alignment", "Genome alignment construction"],
              "text": "Genome alignment"
            }, {
              "comment": ["Genomic elements that might be compared include genes, indels, single nucleotide polymorphisms (SNPs), retrotransposons, tandem repeats and so on."],
              "data": {
                "uri": "http://edamontology.org/operation_3194"
              },
              "definition": "Compare the features of two genome sequences.",
              "text": "Genome feature comparison"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_3208"
              },
              "definition": "Visualise, format or render a nucleic acid sequence that is part of (and in context of) a complete genome sequence.",
              "exact_synonyms": ["Genome viewing", "Genome rendering", "Genome browsing", "Genome browser"],
              "text": "Genome visualisation"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_0525"
              },
              "definition": "The process of assembling many short DNA sequences together such thay they represent the original chromosomes from which the DNA originated.",
              "exact_synonyms": ["Genomic assembly", "Sequence assembly (genome assembly)"],
              "narrow_synonyms": ["Breakend assembly"],
              "text": "Genome assembly"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_3206"
              },
              "definition": "Measure the overall level of methyl cytosines in a genome from analysis of experimental data, typically from chromatographic methods and methyl accepting capacity assay.",
              "exact_synonyms": ["Methylation level analysis (global)", "Genome methylation analysis", "Global methylation analysis"],
              "text": "Whole genome methylation analysis"
            }],
            "data": {
              "uri": "http://edamontology.org/operation_3918"
            },
            "definition": "Detects chimeric sequences (chimeras) from a sequence alignment.",
            "has_topic": ["http://edamontology.org/topic_0622"],
            "text": "Genome analysis"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3200"
            },
            "definition": "Analyse DNA sequences in order to identify a DNA 'barcode'; marker genes or any short fragment(s) of DNA that are useful to diagnose the taxa of biological organisms.",
            "exact_synonyms": ["Community profiling", "Sample barcoding"],
            "text": "DNA barcoding"
          }, {
            "comment": ["Tools might use a genetic algorithm, quartet-mapping, bootscanning, graphical methods, random forest model and so on."],
            "data": {
              "uri": "http://edamontology.org/operation_0451"
            },
            "definition": "Detect recombination (hotspots and coldspots) and identify recombination breakpoints in a sequence alignment.",
            "exact_synonyms": ["Sequence alignment analysis (recombination detection)"],
            "text": "Recombination detection"
          }, {
            "comment": ["A chimera includes regions from two or more phylogenetically distinct sequences. They are usually artifacts of PCR and are thought to occur when a prematurely terminated amplicon reanneals to another DNA strand and is subsequently copied to completion in later PCR cycles."],
            "data": {
              "uri": "http://edamontology.org/operation_0450"
            },
            "definition": "Detects chimeric sequences (chimeras) from a sequence alignment.",
            "exact_synonyms": ["Chimeric sequence detection"],
            "text": "Chimera detection"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/operation_3207"
              },
              "definition": "Analysing the DNA methylation of specific genes or regions of interest.",
              "exact_synonyms": ["Gene-specific methylation analysis", "Methylation level analysis (gene-specific)"],
              "text": "Gene methylation analysis"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_3809"
              },
              "definition": "Identify and assess specific genes or regulatory regions of interest that are differentially methylated.",
              "exact_synonyms": ["Differentially-methylated region identification"],
              "text": "DMR identification"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_3919"
              },
              "definition": "The determination of cytosine methylation status of specific positions in a nucleic acid sequences (usually reads from a bisulfite sequencing experiment).",
              "text": "Methylation calling"
            }, {
              "comment": ["Bisulfite mapping follows high-throughput sequencing of DNA which has undergone bisulfite treatment followed by PCR amplification; unmethylated cytosines are specifically converted to thymine, allowing the methylation status of cytosine in the DNA to be detected."],
              "data": {
                "uri": "http://edamontology.org/operation_3186"
              },
              "definition": "The mapping of methylation sites in a DNA (genome) sequence.  Typically, the mapping of high-throughput bisulfite reads to the reference genome.",
              "exact_synonyms": ["Bisulfite sequence alignment", "Bisulfite sequence mapping", "Bisulfite read mapping"],
              "text": "Bisulfite mapping"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_3206"
              },
              "definition": "Measure the overall level of methyl cytosines in a genome from analysis of experimental data, typically from chromatographic methods and methyl accepting capacity assay.",
              "exact_synonyms": ["Methylation level analysis (global)", "Genome methylation analysis", "Global methylation analysis"],
              "text": "Whole genome methylation analysis"
            }],
            "data": {
              "uri": "http://edamontology.org/operation_3204"
            },
            "definition": "Analyse cytosine methylation states in nucleic acid sequences.",
            "exact_synonyms": ["Methylation profile analysis"],
            "text": "Methylation analysis"
          }, {
            "children": [{
              "comment": ["Tools might use a genetic algorithm, quartet-mapping, bootscanning, graphical methods, random forest model and so on."],
              "data": {
                "uri": "http://edamontology.org/operation_0452"
              },
              "definition": "Identify insertion, deletion and duplication events from a sequence alignment.",
              "exact_synonyms": ["Sequence alignment analysis (indel detection)", "Indel discovery"],
              "text": "Indel detection"
            }, {
              "comment": ["Methods include sequence alignment (if related sequences are available) and word-based sequence comparison."],
              "data": {
                "uri": "http://edamontology.org/operation_0265"
              },
              "definition": "Detect frameshifts in DNA sequences, including frameshift sites and signals, and frameshift errors from sequencing projects.",
              "has_topic": ["http://edamontology.org/topic_3168"],
              "narrow_synonyms": ["Frameshift error detection"],
              "text": "Frameshift detection"
            }, {
              "comment": ["This includes functional SNPs for large-scale genotyping purposes, disease-associated non-synonymous SNPs etc."],
              "data": {
                "uri": "http://edamontology.org/operation_0484"
              },
              "definition": "Find single nucleotide polymorphisms (SNPs) - single nucleotide change in base positions - between sequences. Typically done for sequences from a high-throughput sequencing experiment that differ from a reference genome and which might, especially by reference to population frequency or functional data, indicate a polymorphism.",
              "exact_synonyms": ["SNP discovery", "Single nucleotide polymorphism detection", "SNP calling"],
              "text": "SNP detection"
            }],
            "comment": ["Variant detection", "Methods often utilise a database of aligned reads.", "Somatic variant calling is the detection of variations established in somatic cells and hence not inherited as a germ line variant."],
            "data": {
              "uri": "http://edamontology.org/operation_3227"
            },
            "definition": "Detect, identify and map mutations, such as single nucleotide polymorphisms, short indels and structural variants, in multiple DNA sequences. Typically the alignment and comparison of the fluorescent traces produced by DNA sequencing hardware, to study genomic alterations.",
            "exact_synonyms": ["Variant mapping"],
            "narrow_synonyms": ["Genome variant detection", "Mutation detection", "Germ line variant calling", "Exome variant detection", "de novo mutation detection", "Somatic variant calling", "Allele calling"],
            "text": "Variant calling"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3221"
            },
            "definition": "Estimate the frequencies of different species from analysis of the molecular sequences, typically of DNA recovered from environmental samples.",
            "has_topic": ["http://edamontology.org/topic_3174"],
            "text": "Species frequency estimation"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/operation_3795"
              },
              "definition": "A technique whereby molecules with desired properties and function are isolated from libraries of random molecules, through iterative cycles of selection, amplification, and mutagenesis.",
              "text": "In vitro selection"
            }, {
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/operation_0309"
                },
                "definition": "Predict and/or optimize oligonucleotide probes for DNA microarrays, for example for transcription profiling of genes, or for genomes and gene families.",
                "exact_synonyms": ["Microarray probe prediction"],
                "has_input": ["http://edamontology.org/data_2977"],
                "has_output": ["http://edamontology.org/data_2717"],
                "has_topic": ["http://edamontology.org/topic_0203", "http://edamontology.org/topic_0632"],
                "text": "Microarray probe design"
              }, {
                "comment": ["This includes predicting primers based on gene structure, promoters, exon-exon junctions, predicting primers that are conserved across multiple genomes or species, primers for for gene transcription profiling,  for genotyping polymorphisms, for example single nucleotide polymorphisms (SNPs),  for large scale sequencing, or for methylation PCRs.", "Primer design involves predicting or selecting primers that are specific to a provided PCR template. Primers can be designed with certain properties such as size of product desired, primer size etc. The output might be a minimal or overlapping primer set."],
                "data": {
                  "uri": "http://edamontology.org/operation_0308"
                },
                "definition": "Design or predict oligonucleotide primers for PCR and DNA amplification etc.",
                "exact_synonyms": ["PCR primer prediction", "Primer design"],
                "has_input": ["http://edamontology.org/data_2977"],
                "has_output": ["http://edamontology.org/data_1240"],
                "has_topic": ["http://edamontology.org/topic_0632"],
                "narrow_synonyms": ["PCR primer design (for gene transcription profiling)", "PCR primer design (for methylation PCRs)", "PCR primer design (for large scale sequencing)", "PCR primer design (for conserved primers)", "PCR primer design (for genotyping polymorphisms)", "Primer quality estimation", "PCR primer design (based on gene structure)"],
                "text": "PCR primer design"
              }],
              "data": {
                "uri": "http://edamontology.org/operation_2419"
              },
              "definition": "Predict oligonucleotide primers or probes.",
              "exact_synonyms": ["Primer and probe prediction"],
              "has_topic": ["http://edamontology.org/topic_0632"],
              "text": "Primer and probe design"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_0483"
              },
              "definition": "Predict or optimise RNA sequences (sequence pools) with likely secondary and tertiary structure for in vitro selection.",
              "exact_synonyms": ["Structured RNA prediction and optimisation", "Nucleic acid folding family identification"],
              "has_output": ["http://edamontology.org/data_1234"],
              "text": "RNA inverse folding"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_0560"
              },
              "definition": "Predict or optimise DNA to elicit (via DNA vaccination) an immunological response.",
              "has_topic": ["http://edamontology.org/topic_0804"],
              "text": "DNA vaccine design"
            }],
            "data": {
              "uri": "http://edamontology.org/operation_3095"
            },
            "definition": "Design (or predict) nucleic acid sequences with specific chemical or physical properties.",
            "narrow_synonyms": ["Gene design"],
            "text": "Nucleic acid design"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0307"
            },
            "definition": "Perform in-silico (virtual) PCR.",
            "text": "Virtual PCR"
          }, {
            "comment": ["This can include indirect methods which reveal the results of genetic changes, such as RNA analysis to indicate gene expression, or biochemical analysis to identify expressed proteins."],
            "data": {
              "uri": "http://edamontology.org/operation_3920"
            },
            "definition": "The identification of changes in DNA sequence or chromosome structure, usually in the context of diagnostic tests for disease, or to study ancestry or phylogeny.",
            "exact_synonyms": ["Genetic testing"],
            "has_topic": ["http://edamontology.org/topic_0622"],
            "text": "DNA testing"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_2478"
          },
          "definition": "Analyse a nucleic acid sequence (using methods that are only applicable to nucleic acid sequences).",
          "exact_synonyms": ["Sequence analysis (nucleic acid)"],
          "has_input": ["http://edamontology.org/data_2977"],
          "has_topic": ["http://edamontology.org/topic_0077"],
          "narrow_synonyms": ["Nucleic acid sequence alignment analysis", "Sequence alignment analysis (nucleic acid)"],
          "text": "Nucleic acid sequence analysis"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_0240"
            },
            "definition": "Find motifs shared by molecular sequences.",
            "has_output": ["http://edamontology.org/data_0858"],
            "has_topic": ["http://edamontology.org/topic_0160"],
            "text": "Sequence motif comparison"
          }, {
            "children": [{
              "comment": ["Methods include sequence alignment (if related sequences are available) and word-based sequence comparison."],
              "data": {
                "uri": "http://edamontology.org/operation_0265"
              },
              "definition": "Detect frameshifts in DNA sequences, including frameshift sites and signals, and frameshift errors from sequencing projects.",
              "has_topic": ["http://edamontology.org/topic_3168"],
              "narrow_synonyms": ["Frameshift error detection"],
              "text": "Frameshift detection"
            }],
            "data": {
              "uri": "http://edamontology.org/operation_3195"
            },
            "definition": "Detect errors in DNA sequences generated from sequencing projects).",
            "exact_synonyms": ["Short read error correction", "Short-read error correction"],
            "has_topic": ["http://edamontology.org/topic_3168"],
            "text": "Sequencing error detection"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0290"
            },
            "definition": "Compare two or more molecular sequences, identify and remove redundant sequences based on some criteria.",
            "has_output": ["http://edamontology.org/data_2044"],
            "text": "Sequence redundancy removal"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3209"
            },
            "definition": "Compare the sequence or features of two or more genomes, for example, to find matching regions.",
            "exact_synonyms": ["Genomic region matching"],
            "text": "Genome comparison"
          }, {
            "children": [{
              "comment": ["Dot plots are useful when having not too many (e.g. 20) data points for each category. Example: draw a dotplot of sequence similarities identified from word-matching or character comparison."],
              "data": {
                "uri": "http://edamontology.org/operation_0490"
              },
              "definition": "Render a representation of a distribution that consists of group of data points plotted on a simple scale.",
              "exact_synonyms": ["Categorical plot plotting", "Dotplot plotting"],
              "has_output": ["http://edamontology.org/data_0862"],
              "text": "Dot plot plotting"
            }],
            "data": {
              "uri": "http://edamontology.org/operation_0288"
            },
            "definition": "Find exact character or word matches between molecular sequences without full sequence alignment.",
            "text": "Sequence word comparison"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0346"
            },
            "definition": "Search a sequence database and retrieve sequences that are similar to a query sequence.",
            "narrow_synonyms": ["Structure database search (by sequence)", "Sequence database search (by sequence)"],
            "text": "Sequence similarity search"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0289"
            },
            "definition": "Calculate a sequence distance matrix or otherwise estimate genetic distances between molecular sequences.",
            "exact_synonyms": ["Sequence distance calculation", "Phylogenetic distance matrix generation", "Sequence distance matrix construction"],
            "has_output": ["http://edamontology.org/data_0870"],
            "has_topic": ["http://edamontology.org/topic_0084"],
            "text": "Sequence distance matrix generation"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_2233"
            },
            "definition": "Identify a representative sequence from a set of sequences, typically using scores from pair-wise alignment or other comparison of the sequences.",
            "text": "Representative sequence identification"
          }, {
            "children": [{
              "comment": ["A sequence profile typically represents a sequence alignment. Methods might perform one-to-one, one-to-many or many-to-many comparisons."],
              "data": {
                "uri": "http://edamontology.org/operation_0300"
              },
              "definition": "Align molecular sequence(s) to sequence profile(s), or profiles to other profiles.  A profile typically represents a sequence alignment.",
              "has_input": ["http://edamontology.org/data_1354"],
              "has_topic": ["http://edamontology.org/topic_0160"],
              "narrow_synonyms": ["Profile-profile alignment", "Sequence-to-profile alignment", "Sequence-profile alignment", "Profile-to-profile alignment"],
              "text": "Sequence profile alignment"
            }, {
              "comment": ["This is supposed to give a more biologically meaningful alignment than standard alignments."],
              "data": {
                "uri": "http://edamontology.org/operation_0499"
              },
              "definition": "Align multiple sequences using relative gap costs calculated from neighbors in a supplied phylogenetic tree.",
              "exact_synonyms": ["Multiple sequence alignment construction (phylogenetic tree-based)", "Multiple sequence alignment (phylogenetic tree-based)", "Phylogenetic tree-based multiple sequence alignment construction", "Sequence alignment (phylogenetic tree-based)", "Sequence alignment generation (phylogenetic tree-based)"],
              "has_topic": ["http://edamontology.org/topic_0084"],
              "text": "Tree-based sequence alignment"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_0294"
              },
              "definition": "Align molecular sequences using sequence and structural information.",
              "exact_synonyms": ["Sequence alignment (structure-based)"],
              "text": "Structure-based sequence alignment"
            }, {
              "comment": ["Methods might perform one-to-one, one-to-many or many-to-many comparisons."],
              "data": {
                "uri": "http://edamontology.org/operation_0491"
              },
              "definition": "Align exactly two molecular sequences.",
              "exact_synonyms": ["Pairwise alignment"],
              "has_output": ["http://edamontology.org/data_1381"],
              "text": "Pairwise sequence alignment"
            }, {
              "comment": ["This includes methods that use an existing alignment, for example to incorporate sequences into an alignment, or combine several multiple alignments into a single, improved alignment."],
              "data": {
                "uri": "http://edamontology.org/operation_0492"
              },
              "definition": "Align more than two molecular sequences.",
              "exact_synonyms": ["Multiple alignment"],
              "text": "Multiple sequence alignment"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_3182"
              },
              "definition": "Align two or more (tpyically huge) molecular sequences that represent genomes.",
              "exact_synonyms": ["Whole genome alignment", "Genome alignment construction"],
              "text": "Genome alignment"
            }, {
              "comment": ["Local alignment methods identify regions of local similarity."],
              "data": {
                "uri": "http://edamontology.org/operation_0495"
              },
              "definition": "Locally align two or more molecular sequences.",
              "exact_synonyms": ["Local sequence alignment", "Sequence alignment (local)"],
              "narrow_synonyms": ["Smith-Waterman"],
              "text": "Local alignment"
            }, {
              "comment": ["Global alignment methods identify similarity across the entire length of the sequences."],
              "data": {
                "uri": "http://edamontology.org/operation_0496"
              },
              "definition": "Globally align two or more molecular sequences.",
              "exact_synonyms": ["Global sequence alignment", "Sequence alignment (global)"],
              "text": "Global alignment"
            }],
            "comment": ["See also \"Read mapping\""],
            "data": {
              "uri": "http://edamontology.org/operation_0292"
            },
            "definition": "Align (identify equivalent sites within) molecular sequences.",
            "exact_synonyms": ["Sequence alignment construction", "Sequence alignment generation"],
            "has_output": ["http://edamontology.org/data_0863"],
            "narrow_synonyms": ["Consensus-based sequence alignment", "Constrained sequence alignment", "Sequence alignment (constrained)", "Multiple sequence alignment (constrained)"],
            "text": "Sequence alignment"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/operation_3459"
              },
              "definition": "Clustering of molecular sequences on the basis of their function, typically using information from an ontology of gene function, or some other measure of functional phenotype.",
              "exact_synonyms": ["Functional sequence clustering"],
              "has_topic": ["http://edamontology.org/topic_1775"],
              "text": "Functional clustering"
            }],
            "comment": ["The clusters may be output or used internally for some other purpose."],
            "data": {
              "uri": "http://edamontology.org/operation_0291"
            },
            "definition": "Build clusters of similar sequences, typically using scores from pair-wise alignment or other comparison of the sequences.",
            "exact_synonyms": ["Sequence cluster construction", "Sequence cluster generation"],
            "has_output": ["http://edamontology.org/data_1235"],
            "text": "Sequence clustering"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_2451"
          },
          "definition": "Compare two or more molecular sequences.",
          "has_input": ["http://edamontology.org/data_2044"],
          "has_output": ["http://edamontology.org/data_2955"],
          "text": "Sequence comparison"
        }, {
          "children": [{
            "children": [{
              "data": {
                "uri": "http://edamontology.org/operation_3237"
              },
              "definition": "Remove forward and/or reverse primers from nucleic acid sequences (typically PCR products).",
              "text": "Primer removal"
            }, {
              "comment": ["This includes\n\nennd trimming\nTrim sequences (typically from an automated DNA sequencer) to remove misleading ends.\nFor example trim polyA tails, introns and primer sequence flanking the sequence of amplified exons, or other unwanted sequence.\n\ntrimming to a reference sequence,\nTrim sequences (typically from an automated DNA sequencer) to remove the sequence ends that extend beyond an assembled reference sequence.\n\nvector trimming\nTrim sequences (typically from an automated DNA sequencer) to remove sequence-specific end regions, typically contamination from vector sequences."],
              "data": {
                "uri": "http://edamontology.org/operation_3192"
              },
              "definition": "Cut (remove) the end from a molecular sequence.",
              "exact_synonyms": ["Trimming"],
              "narrow_synonyms": ["Trim ends", "Barcode sequence removal", "Trim vector", "Trim to reference"],
              "text": "Sequence trimming"
            }],
            "data": {
              "uri": "http://edamontology.org/operation_0369"
            },
            "definition": "Cut (remove) characters or a region from a molecular sequence.",
            "text": "Sequence cutting"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0232"
            },
            "definition": "Merge two or more (typically overlapping) molecular sequences.",
            "exact_synonyms": ["Sequence splicing"],
            "narrow_synonyms": ["Paired-end merging", "Paired-end stitching", "Read stitching", "Read merging"],
            "text": "Sequence merging"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/operation_2510"
              },
              "definition": "Back-translate a protein sequence into DNA.",
              "has_topic": ["http://edamontology.org/topic_0108"],
              "text": "DNA back-translation"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_0372"
              },
              "definition": "Transcribe a nucleotide sequence into mRNA sequence(s).",
              "has_topic": ["http://edamontology.org/topic_0203"],
              "text": "DNA transcription"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_0371"
              },
              "definition": "Translate a DNA sequence into protein.",
              "has_topic": ["http://edamontology.org/topic_0108"],
              "text": "DNA translation"
            }],
            "data": {
              "uri": "http://edamontology.org/operation_0233"
            },
            "definition": "Convert a molecular sequence from one type to another.",
            "text": "Sequence conversion"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0367"
            },
            "definition": "Mutate a molecular sequence a specified amount or shuffle it to produce a randomised sequence with the same overall composition.",
            "text": "Sequence mutation and randomisation"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_2121"
            },
            "definition": "Perform basic (non-analytical) operations on a report or file of sequences (which might include features), such as file concatenation, removal or ordering of sequences, creation of subset or a new file of sequences.",
            "text": "Sequence file editing"
          }, {
            "comment": ["For example, SNPs or repeats in a DNA sequence might be masked."],
            "data": {
              "uri": "http://edamontology.org/operation_0368"
            },
            "definition": "Mask characters in a molecular sequence (replacing those characters with a mask character).",
            "text": "Sequence masking"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0370"
            },
            "definition": "Create (or remove) restriction sites in sequences, for example using silent mutations.",
            "text": "Restriction site creation"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_0231"
          },
          "definition": "Edit or change a molecular sequence, either randomly or specifically.",
          "text": "Sequence editing"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_0234"
            },
            "definition": "Calculate sequence complexity, for example to find low-complexity regions in sequences.",
            "has_output": ["http://edamontology.org/data_1259"],
            "has_topic": ["http://edamontology.org/topic_0157"],
            "text": "Sequence complexity calculation"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0380"
            },
            "definition": "Analyse repeat sequence organisation such as periodicity.",
            "text": "Repeat sequence organisation analysis"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0235"
            },
            "definition": "Calculate sequence ambiguity, for example identity regions in protein or nucleotide sequences with many ambiguity codes.",
            "has_output": ["http://edamontology.org/data_1260"],
            "has_topic": ["http://edamontology.org/topic_0157"],
            "text": "Sequence ambiguity calculation"
          }, {
            "comment": ["k-mer counting is used in genome and transcriptome assembly, metagenomic sequencing, and for error correction of sequence reads."],
            "data": {
              "uri": "http://edamontology.org/operation_3472"
            },
            "definition": "Count k-mers (substrings of length k) in DNA sequence data.",
            "text": "k-mer counting"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_2284"
            },
            "definition": "Calculate a density plot (of base composition) for a nucleotide sequence.",
            "text": "Nucleic acid density plotting"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_0236"
          },
          "definition": "Calculate character or word composition or frequency of a molecular sequence.",
          "has_output": ["http://edamontology.org/data_1261"],
          "has_topic": ["http://edamontology.org/topic_0157"],
          "text": "Sequence composition calculation"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_0240"
            },
            "definition": "Find motifs shared by molecular sequences.",
            "has_output": ["http://edamontology.org/data_0858"],
            "has_topic": ["http://edamontology.org/topic_0160"],
            "text": "Sequence motif comparison"
          }, {
            "comment": ["Motifs and patterns might be conserved or over-represented (occur with improbable frequency)."],
            "data": {
              "uri": "http://edamontology.org/operation_0238"
            },
            "definition": "Discover new motifs or conserved patterns in sequences or sequence alignments (de-novo discovery).",
            "exact_synonyms": ["Motif discovery"],
            "has_output": ["http://edamontology.org/data_0858"],
            "has_topic": ["http://edamontology.org/topic_0160"],
            "text": "Sequence motif discovery"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0239"
            },
            "definition": "Find (scan for) known motifs, patterns and regular expressions in molecular sequence(s).",
            "exact_synonyms": ["Sequence signature recognition", "Sequence signature detection", "Motif scanning"],
            "has_output": ["http://edamontology.org/data_0858"],
            "has_topic": ["http://edamontology.org/topic_0160"],
            "narrow_synonyms": ["Sequence profile search", "Sequence motif search", "Motif search", "Sequence motif detection", "Motif recognition", "Motif detection"],
            "text": "Sequence motif recognition"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_2404"
          },
          "definition": "Analyse molecular sequence motifs.",
          "exact_synonyms": ["Sequence motif processing"],
          "text": "Sequence motif analysis"
        }, {
          "comment": ["Methods typically compare multiple molecular sequence and estimate evolutionary distances and relationships to infer gene families or make functional predictions."],
          "data": {
            "uri": "http://edamontology.org/operation_0540"
          },
          "definition": "Phylogenetic tree construction from molecular sequences.",
          "exact_synonyms": ["Phylogenetic tree generation (from molecular sequences)", "Phylogenetic tree construction (from molecular sequences)"],
          "text": "Phylogenetic inference (from molecular sequences)"
        }, {
          "children": [{
            "comment": ["Methods usually involve multiple sequence alignment analysis."],
            "data": {
              "uri": "http://edamontology.org/operation_0272"
            },
            "definition": "Predict contacts, non-covalent interactions and distance (constraints) between amino acids in protein sequences.",
            "exact_synonyms": ["Residue interaction prediction"],
            "has_topic": ["http://edamontology.org/topic_0130"],
            "narrow_synonyms": ["Contact map prediction", "Protein contact map prediction"],
            "text": "Residue contact prediction"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/operation_0470"
              },
              "definition": "Predict open coils, non-regular secondary structure and intrinsically disordered / unstructured regions of protein sequences.",
              "text": "Protein secondary structure prediction (coils)"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_0469"
              },
              "definition": "Predict turn structure (for example beta hairpin turns) of protein sequences.",
              "text": "Protein secondary structure prediction (turns)"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_0468"
              },
              "definition": "Predict helical secondary structure of protein sequences.",
              "text": "Protein secondary structure prediction (helices)"
            }, {
              "comment": ["Super-secondary structures include leucine zippers, coiled coils, Helix-Turn-Helix etc."],
              "data": {
                "uri": "http://edamontology.org/operation_0268"
              },
              "definition": "Predict super-secondary structure of protein sequence(s).",
              "has_output": ["http://edamontology.org/data_1277"],
              "text": "Protein super-secondary structure prediction"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_0269"
              },
              "definition": "Predict and/or classify transmembrane proteins or transmembrane (helical) domains or regions in protein sequences.",
              "text": "Transmembrane protein prediction"
            }],
            "comment": ["Methods might use amino acid composition, local sequence information, multiple sequence alignments, physicochemical features, estimated energy content, statistical algorithms, hidden Markov models, support vector machines, kernel machines, neural networks etc."],
            "data": {
              "uri": "http://edamontology.org/operation_0267"
            },
            "definition": "Predict secondary structure of protein sequences.",
            "exact_synonyms": ["Secondary structure prediction (protein)"],
            "text": "Protein secondary structure prediction"
          }, {
            "children": [{
              "comment": ["Methods might use sequence motifs and features, amino acid composition, profiles, machine-learned classifiers, etc."],
              "data": {
                "uri": "http://edamontology.org/operation_0418"
              },
              "definition": "Detect or predict signal peptides and signal peptide cleavage sites in protein sequences.",
              "has_topic": ["http://edamontology.org/topic_0140"],
              "text": "Protein signal peptide detection"
            }, {
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/operation_2464"
                },
                "definition": "Identify or predict protein-protein binding sites.",
                "exact_synonyms": ["Protein-protein binding site detection"],
                "has_output": ["http://edamontology.org/data_0906"],
                "has_topic": ["http://edamontology.org/topic_0128"],
                "text": "Protein-protein binding site prediction"
              }, {
                "data": {
                  "uri": "http://edamontology.org/operation_3898"
                },
                "definition": "Predict or detect metal ion-binding sites in proteins.",
                "exact_synonyms": ["Protein metal-binding site prediction", "Metal-binding site detection"],
                "text": "Metal-binding site prediction"
              }, {
                "children": [{
                  "data": {
                    "uri": "http://edamontology.org/operation_3903"
                  },
                  "definition": "Predict or detect DNA-binding sites in protein sequences.",
                  "exact_synonyms": ["Protein-DNA binding site detection", "Protein-DNA binding site prediction"],
                  "narrow_synonyms": ["DNA binding site detection"],
                  "text": "DNA binding site prediction"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/operation_3902"
                  },
                  "definition": "Predict or detect RNA-binding sites in protein sequences.",
                  "exact_synonyms": ["RNA binding site detection", "Protein-RNA binding site detection", "Protein-RNA binding site prediction"],
                  "text": "RNA binding site prediction"
                }],
                "comment": ["This includes methods that predict and optimise zinc finger protein domains for DNA/RNA binding (for example for transcription factors and nucleases)."],
                "data": {
                  "uri": "http://edamontology.org/operation_0420"
                },
                "definition": "Predict or detect RNA and DNA-binding binding sites in protein sequences.",
                "exact_synonyms": ["Protein-nucleic acid binding site prediction", "Protein-nucleic acid binding detection", "Protein-nucleic acid binding prediction", "Protein-nucleic acid binding site detection"],
                "narrow_synonyms": ["Zinc finger prediction"],
                "text": "Nucleic acids-binding site prediction"
              }, {
                "data": {
                  "uri": "http://edamontology.org/operation_3896"
                },
                "definition": "Predict or detect active sites in proteins; the region of an enzyme which binds a substrate bind and catalyses a reaction.",
                "narrow_synonyms": ["Active site detection"],
                "text": "Active site prediction"
              }, {
                "data": {
                  "uri": "http://edamontology.org/operation_3897"
                },
                "definition": "Predict or detect ligand-binding sites in proteins; a region of a protein which reversibly binds a ligand for some biochemical purpose, such as transport or regulation of protein function.",
                "narrow_synonyms": ["Ligand-binding site detection", "Peptide-protein binding prediction"],
                "text": "Ligand-binding site prediction"
              }],
              "data": {
                "uri": "http://edamontology.org/operation_2575"
              },
              "definition": "Identify or predict catalytic residues, active sites or other ligand-binding sites in protein sequences or structures.",
              "exact_synonyms": ["Protein binding site detection", "Protein binding site prediction"],
              "has_topic": ["http://edamontology.org/topic_0128"],
              "text": "Binding site prediction"
            }, {
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/operation_0470"
                },
                "definition": "Predict open coils, non-regular secondary structure and intrinsically disordered / unstructured regions of protein sequences.",
                "text": "Protein secondary structure prediction (coils)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/operation_0469"
                },
                "definition": "Predict turn structure (for example beta hairpin turns) of protein sequences.",
                "text": "Protein secondary structure prediction (turns)"
              }, {
                "data": {
                  "uri": "http://edamontology.org/operation_0468"
                },
                "definition": "Predict helical secondary structure of protein sequences.",
                "text": "Protein secondary structure prediction (helices)"
              }, {
                "comment": ["Super-secondary structures include leucine zippers, coiled coils, Helix-Turn-Helix etc."],
                "data": {
                  "uri": "http://edamontology.org/operation_0268"
                },
                "definition": "Predict super-secondary structure of protein sequence(s).",
                "has_output": ["http://edamontology.org/data_1277"],
                "text": "Protein super-secondary structure prediction"
              }, {
                "data": {
                  "uri": "http://edamontology.org/operation_0269"
                },
                "definition": "Predict and/or classify transmembrane proteins or transmembrane (helical) domains or regions in protein sequences.",
                "text": "Transmembrane protein prediction"
              }],
              "comment": ["Methods might use amino acid composition, local sequence information, multiple sequence alignments, physicochemical features, estimated energy content, statistical algorithms, hidden Markov models, support vector machines, kernel machines, neural networks etc."],
              "data": {
                "uri": "http://edamontology.org/operation_0267"
              },
              "definition": "Predict secondary structure of protein sequences.",
              "exact_synonyms": ["Secondary structure prediction (protein)"],
              "text": "Protein secondary structure prediction"
            }, {
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/operation_0390"
                },
                "definition": "Decompose a structure into compact or globular fragments (protein peeling).",
                "text": "Protein peeling"
              }],
              "data": {
                "uri": "http://edamontology.org/operation_0246"
              },
              "definition": "Identify structural domains in a protein structure from first principles (for example calculations on structural compactness).",
              "has_topic": ["http://edamontology.org/topic_0736"],
              "text": "Protein domain recognition"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_3904"
              },
              "definition": "Identify or predict intrinsically disordered regions in proteins.",
              "has_topic": ["http://edamontology.org/topic_3301"],
              "text": "Protein disorder prediction"
            }, {
              "comment": ["Epitope mapping is commonly done during vaccine design."],
              "data": {
                "uri": "http://edamontology.org/operation_0416"
              },
              "definition": "Predict antigenic determinant sites (epitopes) in protein sequences.",
              "exact_synonyms": ["Antibody epitope prediction", "Epitope prediction"],
              "has_topic": ["http://edamontology.org/topic_0804"],
              "narrow_synonyms": ["T cell epitope prediction", "Epitope mapping (MHC Class II)", "T cell epitope mapping", "B cell epitope prediction", "Epitope mapping (MHC Class I)", "B cell epitope mapping"],
              "text": "Epitope mapping"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_0471"
              },
              "definition": "Predict cysteine bonding state and disulfide bond partners in protein sequences.",
              "text": "Disulfide bond prediction"
            }, {
              "comment": ["This includes conserved substructures and conserved geometry, such as spatial arrangement of secondary structure or protein backbone. Methods might use structure alignment, structural templates, searches for similar electrostatic potential and molecular surface shape, surface-mapping of phylogenetic information etc."],
              "data": {
                "uri": "http://edamontology.org/operation_0245"
              },
              "definition": "Identify or screen for 3D structural motifs in protein structure(s).",
              "exact_synonyms": ["Protein structural feature identification", "Protein structural motif recognition"],
              "has_topic": ["http://edamontology.org/topic_0166"],
              "text": "Structural motif discovery"
            }, {
              "children": [{
                "comment": ["Use this concept for methods that evaluate sequence-structure compatibility by assessing residue interactions in 3D. Methods might perform one-to-one, one-to-many or many-to-many comparisons."],
                "data": {
                  "uri": "http://edamontology.org/operation_0302"
                },
                "definition": "Align molecular sequence to structure in 3D space (threading).",
                "exact_synonyms": ["Sequence-structure alignment"],
                "has_input": ["http://edamontology.org/data_1460"],
                "has_output": ["http://edamontology.org/data_0893"],
                "narrow_synonyms": ["Sequence-3D profile alignment", "Sequence-to-3D-profile alignment"],
                "text": "Protein threading"
              }],
              "comment": ["Methods use some type of mapping between sequence and fold, for example secondary structure prediction and alignment, profile comparison, sequence properties, homologous sequence search, kernel machines etc. Domains and folds might be taken from SCOP or CATH."],
              "data": {
                "uri": "http://edamontology.org/operation_0303"
              },
              "definition": "Recognize (predict and identify) known protein structural domains or folds in protein sequence(s) which (typically) are not accompanied by any significant sequence similarity to know structures.",
              "exact_synonyms": ["Protein fold recognition", "Fold prediction", "Protein domain prediction", "Domain prediction", "Protein fold prediction"],
              "text": "Fold recognition"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_0422"
              },
              "definition": "Detect or predict cleavage sites (enzymatic or chemical) in protein sequences.",
              "has_topic": ["http://edamontology.org/topic_0121"],
              "text": "Protein cleavage site prediction"
            }, {
              "comment": ["Methods might predict sites of methylation, N-terminal myristoylation, N-terminal acetylation, sumoylation, palmitoylation, phosphorylation, sulfation, glycosylation, glycosylphosphatidylinositol (GPI) modification sites (GPI lipid anchor signals) etc."],
              "data": {
                "uri": "http://edamontology.org/operation_0417"
              },
              "definition": "Predict post-translation modification sites in protein sequences.",
              "exact_synonyms": ["PTM analysis", "PTM site analysis", "Post-translational modification site prediction", "Post-translation modification site prediction", "Post-translational modification analysis", "PTM prediction", "Protein post-translation modification site prediction"],
              "has_topic": ["http://edamontology.org/topic_0601"],
              "narrow_synonyms": ["Succinylation prediction", "Ubiquitination site prediction", "Acetylation site prediction", "Methylation site prediction", "Phosphosite localization", "Hydroxylation prediction", "N-terminal acetylation prediction", "S-nitrosylation site prediction", "Acetylation prediction", "Sulfation site prediction", "Phosphoglycerylation prediction", "GPI anchor prediction", "Pupylation prediction", "Prenylation prediction", "GPI modification prediction", "Tyrosine nitration site prediction", "Methylation prediction", "N-myristoylation site prediction", "Succinylation site prediction", "Glycosylation prediction", "Phosphorylation prediction", "Phosphoglycerylation site prediction", "Pupylation site prediction", "S-sulfenylation site prediction", "Palmitoylation prediction", "Palmitoylation site prediction", "N-myristoylation prediction", "S-nitrosylation prediction", "Sumoylation site prediction", "N-terminal acetylation site prediction", "Tyrosine nitration prediction", "Phosphorylation site prediction", "N-terminal myristoylation prediction", "Glycosylation site prediction", "Dephosphorylation site prediction", "Ubiquitination prediction", "GPI anchor site prediction", "GPI modification site prediction", "Dephosphorylation prediction", "N-terminal myristoylation site prediction", "S-sulfenylation prediction", "Sumoylation prediction", "Sulfation prediction", "Prenylation site prediction", "Hydroxylation site prediction"],
              "text": "PTM site prediction"
            }, {
              "comment": ["An adhesin is a cell-surface component that facilitate the adherence of a microorganism to a cell or surface. They are important virulence factors during establishment of infection and thus are targetted during vaccine development approaches that seek to block adhesin function and prevent adherence to host cell."],
              "data": {
                "uri": "http://edamontology.org/operation_3968"
              },
              "definition": "Predict adhesins in protein sequences.",
              "has_topic": ["http://edamontology.org/topic_0804"],
              "text": "Adhesin prediction"
            }],
            "comment": ["Features includes functional sites or regions, secondary structure, structural domains and so on. Methods might use fingerprints, motifs, profiles, hidden Markov models, sequence alignment etc to provide a mapping of a query protein sequence to a discriminatory element. This includes methods that search a secondary protein database (Prosite, Blocks, ProDom, Prints, Pfam etc.) to assign a protein sequence(s) to a known protein family or group."],
            "data": {
              "uri": "http://edamontology.org/operation_3092"
            },
            "definition": "Predict, recognise and identify positional features in proteins from analysing protein sequences or structures.",
            "exact_synonyms": ["Protein feature prediction", "Protein feature recognition"],
            "has_output": ["http://edamontology.org/data_1277"],
            "has_topic": ["http://edamontology.org/topic_0078", "http://edamontology.org/topic_0160"],
            "narrow_synonyms": ["Sequence feature detection (protein)", "Protein site recognition", "Sequence profile database search", "Protein secondary database search", "Protein site prediction", "Protein site detection"],
            "text": "Protein feature detection"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/operation_0476"
              },
              "definition": "Predict tertiary structure of protein sequence(s) without homologs of known structure.",
              "exact_synonyms": ["de novo structure prediction"],
              "text": "Ab initio structure prediction"
            }, {
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/operation_0481"
                },
                "definition": "Model loop conformation in protein structures.",
                "exact_synonyms": ["Protein modelling (loops)", "Protein loop modelling"],
                "text": "Loop modelling"
              }, {
                "comment": ["This includes rotamer likelihood prediction: the prediction of rotamer likelihoods for all 20 amino acid types at each position in a protein structure, where output typically includes, for each residue position, the likelihoods for the 20 amino acid types with estimated reliability of the 20 likelihoods.", "Methods might use a residue rotamer library.", "Antibody optimisation is to optimize the antibody-interacting surface of the antigen (epitope).  Antigen optimisation is to optimize the antigen-interacting surface of the antibody (paratope). Antigen resurfacing is to resurface the antigen by varying the sequence of non-epitope regions."],
                "data": {
                  "uri": "http://edamontology.org/operation_0480"
                },
                "definition": "Model, analyse or edit amino acid side chain conformation in protein structure, optimize side-chain packing, hydrogen bonding etc.",
                "exact_synonyms": ["Protein modelling (side chains)"],
                "narrow_synonyms": ["Antigen resurfacing", "Antibody optimisation", "Rotamer likelihood prediction", "Antigen optimisation"],
                "text": "Side chain modelling"
              }, {
                "comment": ["Methods might require a preliminary C(alpha) trace.", "Scaffold selection, scaffold search, epitope grafting and design optimization are stages of backbone modelling done during rational vaccine design."],
                "data": {
                  "uri": "http://edamontology.org/operation_0479"
                },
                "definition": "Model protein backbone conformation.",
                "exact_synonyms": ["Protein modelling (backbone)"],
                "narrow_synonyms": ["Epitope grafting", "Scaffold selection", "Scaffold search", "Design optimization"],
                "text": "Backbone modelling"
              }],
              "comment": ["The model might be of a whole, part or aspect of protein structure. Molecular modelling methods might use sequence-structure alignment, structural templates, molecular dynamics, energy minimisation etc."],
              "data": {
                "uri": "http://edamontology.org/operation_0477"
              },
              "definition": "Build a three-dimensional protein model based on known (for example homologs) structures.",
              "exact_synonyms": ["Comparative modelling", "Homology modelling", "Protein structure comparative modelling", "Homology structure modelling"],
              "has_topic": ["http://edamontology.org/topic_2275"],
              "text": "Protein modelling"
            }],
            "data": {
              "uri": "http://edamontology.org/operation_0474"
            },
            "definition": "Predict tertiary structure (backbone and side-chain conformation) of protein sequences.",
            "has_output": ["http://edamontology.org/data_1460"],
            "narrow_synonyms": ["Protein folding pathway prediction"],
            "text": "Protein structure prediction"
          }, {
            "children": [{
              "comment": ["Use this concept for methods that evaluate sequence-structure compatibility by assessing residue interactions in 3D. Methods might perform one-to-one, one-to-many or many-to-many comparisons."],
              "data": {
                "uri": "http://edamontology.org/operation_0302"
              },
              "definition": "Align molecular sequence to structure in 3D space (threading).",
              "exact_synonyms": ["Sequence-structure alignment"],
              "has_input": ["http://edamontology.org/data_1460"],
              "has_output": ["http://edamontology.org/data_0893"],
              "narrow_synonyms": ["Sequence-3D profile alignment", "Sequence-to-3D-profile alignment"],
              "text": "Protein threading"
            }],
            "comment": ["Methods use some type of mapping between sequence and fold, for example secondary structure prediction and alignment, profile comparison, sequence properties, homologous sequence search, kernel machines etc. Domains and folds might be taken from SCOP or CATH."],
            "data": {
              "uri": "http://edamontology.org/operation_0303"
            },
            "definition": "Recognize (predict and identify) known protein structural domains or folds in protein sequence(s) which (typically) are not accompanied by any significant sequence similarity to know structures.",
            "exact_synonyms": ["Protein fold recognition", "Fold prediction", "Protein domain prediction", "Domain prediction", "Protein fold prediction"],
            "text": "Fold recognition"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_2479"
          },
          "definition": "Analyse a protein sequence (using methods that are only applicable to protein sequences).",
          "exact_synonyms": ["Sequence analysis (protein)"],
          "has_input": ["http://edamontology.org/data_2976"],
          "has_topic": ["http://edamontology.org/topic_0078"],
          "narrow_synonyms": ["Protein sequence alignment analysis", "Sequence alignment analysis (protein)"],
          "text": "Protein sequence analysis"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_2121"
          },
          "definition": "Perform basic (non-analytical) operations on a report or file of sequences (which might include features), such as file concatenation, removal or ordering of sequences, creation of subset or a new file of sequences.",
          "text": "Sequence file editing"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_0379"
            },
            "definition": "Find (and possibly render) short repetitive subsequences (repeat sequences) in (typically nucleotide) sequences.",
            "text": "Repeat sequence detection"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0380"
            },
            "definition": "Analyse repeat sequence organisation such as periodicity.",
            "text": "Repeat sequence organisation analysis"
          }],
          "comment": ["Repeat sequences include tandem repeats, inverted or palindromic repeats, DNA microsatellites (Simple Sequence Repeats or SSRs), interspersed repeats, maximal duplications and reverse, complemented and reverse complemented repeats etc. Repeat units can be exact or imperfect, in tandem or dispersed, of specified or unspecified length."],
          "data": {
            "uri": "http://edamontology.org/operation_0237"
          },
          "definition": "Find and/or analyse repeat sequences in (typically nucleotide) sequences.",
          "has_topic": ["http://edamontology.org/topic_0157"],
          "text": "Repeat sequence analysis"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3482"
          },
          "definition": "Identify or predict causes for antibiotic resistance from molecular sequence analysis.",
          "has_topic": ["http://edamontology.org/topic_3301"],
          "text": "Antimicrobial resistance prediction"
        }, {
          "children": [{
            "comment": ["Genomic elements that might be compared include genes, indels, single nucleotide polymorphisms (SNPs), retrotransposons, tandem repeats and so on."],
            "data": {
              "uri": "http://edamontology.org/operation_3194"
            },
            "definition": "Compare the features of two genome sequences.",
            "text": "Genome feature comparison"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_0256"
          },
          "definition": "Compare the feature tables of two or more molecular sequences.",
          "exact_synonyms": ["Feature table comparison", "Feature comparison"],
          "has_input": ["http://edamontology.org/data_1270", "http://edamontology.org/data_0849"],
          "has_topic": ["http://edamontology.org/topic_0160"],
          "text": "Sequence feature comparison"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_3184"
            },
            "definition": "Render and visualise a DNA sequence assembly.",
            "exact_synonyms": ["Assembly visualisation", "Assembly rendering", "Sequence assembly rendering"],
            "text": "Sequence assembly visualisation"
          }, {
            "comment": ["Hydrophobic moment is a peptides hydrophobicity measured for different angles of rotation."],
            "data": {
              "uri": "http://edamontology.org/operation_0407"
            },
            "definition": "Calculate the hydrophobic moment of a peptide sequence and recognize amphiphilicity.",
            "has_output": ["http://edamontology.org/data_1520"],
            "text": "Protein hydrophobic moment plotting"
          }, {
            "comment": ["Dot plots are useful when having not too many (e.g. 20) data points for each category. Example: draw a dotplot of sequence similarities identified from word-matching or character comparison."],
            "data": {
              "uri": "http://edamontology.org/operation_0490"
            },
            "definition": "Render a representation of a distribution that consists of group of data points plotted on a simple scale.",
            "exact_synonyms": ["Categorical plot plotting", "Dotplot plotting"],
            "has_output": ["http://edamontology.org/data_0862"],
            "text": "Dot plot plotting"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0287"
            },
            "definition": "Identify and plot third base position variability in a nucleotide sequence.",
            "has_output": ["http://edamontology.org/data_1263"],
            "has_topic": ["http://edamontology.org/topic_0114"],
            "text": "Base position variability plotting"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3208"
            },
            "definition": "Visualise, format or render a nucleic acid sequence that is part of (and in context of) a complete genome sequence.",
            "exact_synonyms": ["Genome viewing", "Genome rendering", "Genome browsing", "Genome browser"],
            "text": "Genome visualisation"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_2284"
            },
            "definition": "Calculate a density plot (of base composition) for a nucleotide sequence.",
            "text": "Nucleic acid density plotting"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_0564"
          },
          "definition": "Visualise, format or render a molecular sequence or sequences such as a sequence alignment, possibly with sequence features or properties shown.",
          "exact_synonyms": ["Sequence rendering"],
          "has_input": ["http://edamontology.org/data_2044"],
          "has_output": ["http://edamontology.org/data_2969"],
          "narrow_synonyms": ["Sequence alignment visualisation"],
          "text": "Sequence visualisation"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_3460"
            },
            "definition": "Classifiication (typically of molecular sequences) by assignment to some taxonomic hierarchy.",
            "exact_synonyms": ["Taxonomy assignment"],
            "narrow_synonyms": ["Taxonomic profiling"],
            "text": "Taxonomic classification"
          }, {
            "comment": ["Variants are typically classified by their position (intronic, exonic, etc.) in a gene transcript and (for variants in coding exons) by their effect on the protein sequence (synonymous, non-synonymous, frameshifting, etc.)"],
            "data": {
              "uri": "http://edamontology.org/operation_3225"
            },
            "definition": "Classify variants based on their potential effect on genes, especially functional effects on the expressed proteins.",
            "text": "Variant classification"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_2995"
          },
          "definition": "Assign molecular sequence(s) to a group or category.",
          "text": "Sequence classification"
        }, {
          "children": [{
            "comment": ["A sequence profile typically represents a sequence alignment. Methods might perform one-to-one, one-to-many or many-to-many comparisons."],
            "data": {
              "uri": "http://edamontology.org/operation_0300"
            },
            "definition": "Align molecular sequence(s) to sequence profile(s), or profiles to other profiles.  A profile typically represents a sequence alignment.",
            "has_input": ["http://edamontology.org/data_1354"],
            "has_topic": ["http://edamontology.org/topic_0160"],
            "narrow_synonyms": ["Profile-profile alignment", "Sequence-to-profile alignment", "Sequence-profile alignment", "Profile-to-profile alignment"],
            "text": "Sequence profile alignment"
          }, {
            "comment": ["This is supposed to give a more biologically meaningful alignment than standard alignments."],
            "data": {
              "uri": "http://edamontology.org/operation_0499"
            },
            "definition": "Align multiple sequences using relative gap costs calculated from neighbors in a supplied phylogenetic tree.",
            "exact_synonyms": ["Multiple sequence alignment construction (phylogenetic tree-based)", "Multiple sequence alignment (phylogenetic tree-based)", "Phylogenetic tree-based multiple sequence alignment construction", "Sequence alignment (phylogenetic tree-based)", "Sequence alignment generation (phylogenetic tree-based)"],
            "has_topic": ["http://edamontology.org/topic_0084"],
            "text": "Tree-based sequence alignment"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0294"
            },
            "definition": "Align molecular sequences using sequence and structural information.",
            "exact_synonyms": ["Sequence alignment (structure-based)"],
            "text": "Structure-based sequence alignment"
          }, {
            "comment": ["Methods might perform one-to-one, one-to-many or many-to-many comparisons."],
            "data": {
              "uri": "http://edamontology.org/operation_0491"
            },
            "definition": "Align exactly two molecular sequences.",
            "exact_synonyms": ["Pairwise alignment"],
            "has_output": ["http://edamontology.org/data_1381"],
            "text": "Pairwise sequence alignment"
          }, {
            "comment": ["This includes methods that use an existing alignment, for example to incorporate sequences into an alignment, or combine several multiple alignments into a single, improved alignment."],
            "data": {
              "uri": "http://edamontology.org/operation_0492"
            },
            "definition": "Align more than two molecular sequences.",
            "exact_synonyms": ["Multiple alignment"],
            "text": "Multiple sequence alignment"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3182"
            },
            "definition": "Align two or more (tpyically huge) molecular sequences that represent genomes.",
            "exact_synonyms": ["Whole genome alignment", "Genome alignment construction"],
            "text": "Genome alignment"
          }, {
            "comment": ["Local alignment methods identify regions of local similarity."],
            "data": {
              "uri": "http://edamontology.org/operation_0495"
            },
            "definition": "Locally align two or more molecular sequences.",
            "exact_synonyms": ["Local sequence alignment", "Sequence alignment (local)"],
            "narrow_synonyms": ["Smith-Waterman"],
            "text": "Local alignment"
          }, {
            "comment": ["Global alignment methods identify similarity across the entire length of the sequences."],
            "data": {
              "uri": "http://edamontology.org/operation_0496"
            },
            "definition": "Globally align two or more molecular sequences.",
            "exact_synonyms": ["Global sequence alignment", "Sequence alignment (global)"],
            "text": "Global alignment"
          }],
          "comment": ["See also \"Read mapping\""],
          "data": {
            "uri": "http://edamontology.org/operation_0292"
          },
          "definition": "Align (identify equivalent sites within) molecular sequences.",
          "exact_synonyms": ["Sequence alignment construction", "Sequence alignment generation"],
          "has_output": ["http://edamontology.org/data_0863"],
          "narrow_synonyms": ["Consensus-based sequence alignment", "Constrained sequence alignment", "Sequence alignment (constrained)", "Multiple sequence alignment (constrained)"],
          "text": "Sequence alignment"
        }, {
          "children": [{
            "comment": ["Motifs and patterns might be conserved or over-represented (occur with improbable frequency)."],
            "data": {
              "uri": "http://edamontology.org/operation_0238"
            },
            "definition": "Discover new motifs or conserved patterns in sequences or sequence alignments (de-novo discovery).",
            "exact_synonyms": ["Motif discovery"],
            "has_output": ["http://edamontology.org/data_0858"],
            "has_topic": ["http://edamontology.org/topic_0160"],
            "text": "Sequence motif discovery"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0239"
            },
            "definition": "Find (scan for) known motifs, patterns and regular expressions in molecular sequence(s).",
            "exact_synonyms": ["Sequence signature recognition", "Sequence signature detection", "Motif scanning"],
            "has_output": ["http://edamontology.org/data_0858"],
            "has_topic": ["http://edamontology.org/topic_0160"],
            "narrow_synonyms": ["Sequence profile search", "Sequence motif search", "Motif search", "Sequence motif detection", "Motif recognition", "Motif detection"],
            "text": "Sequence motif recognition"
          }],
          "comment": ["Look at \"Protein feature detection\" (http://edamontology.org/operation_3092) and \"Nucleic acid feature detection\" (http://edamontology.org/operation_0415) in case more specific terms are needed."],
          "data": {
            "uri": "http://edamontology.org/operation_0253"
          },
          "definition": "Predict, recognise and identify positional features in molecular sequences such as key functional sites or regions.",
          "exact_synonyms": ["Sequence feature prediction", "Sequence feature recognition"],
          "has_output": ["http://edamontology.org/data_1255"],
          "has_topic": ["http://edamontology.org/topic_0160"],
          "narrow_synonyms": ["Motif database search"],
          "text": "Sequence feature detection"
        }],
        "data": {
          "uri": "http://edamontology.org/operation_2403"
        },
        "definition": "Analyse one or more known molecular sequences.",
        "exact_synonyms": ["Sequence analysis (general)"],
        "has_topic": ["http://edamontology.org/topic_0080"],
        "text": "Sequence analysis"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/operation_0276"
          },
          "definition": "Analyse a network of protein interactions.",
          "has_output": ["http://edamontology.org/data_2984"],
          "has_topic": ["http://edamontology.org/topic_0128"],
          "narrow_synonyms": ["Protein interaction network comparison"],
          "text": "Protein interaction network analysis"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3766"
          },
          "definition": "A data mining method typically used for studying biological networks based on pairwise correlations between variables.",
          "exact_synonyms": ["Weighted gene co-expression network analysis", "WGCNA"],
          "has_topic": ["http://edamontology.org/topic_0602"],
          "text": "Weighted correlation network analysis"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_2437"
          },
          "definition": "Predict a network of gene regulation.",
          "text": "Gene regulatory network prediction"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_1781"
          },
          "definition": "Analyse a known network of gene regulation.",
          "has_topic": ["http://edamontology.org/topic_0602"],
          "narrow_synonyms": ["Regulatory network comparison", "Regulatory network modelling", "Gene regulatory network modelling", "Gene regulatory network comparison"],
          "text": "Gene regulatory network analysis"
        }, {
          "comment": ["The terms and synyonyms here reflect that for practical intents and purposes, \"pathway\" and \"network\" can be treated the same."],
          "data": {
            "uri": "http://edamontology.org/operation_3660"
          },
          "definition": "Model a metabolic network.  This can include 1) reconstruction to break down a metabolic pathways into reactions, enzymes, and other relevant information, and compilation of this into a mathematical model and 2) simulations of metabolism based on the model.",
          "exact_synonyms": [{
            "@id": "http://edamontology.org/Metabolic%20pathway%20modelling"
          }],
          "has_topic": ["http://edamontology.org/topic_2259"],
          "narrow_synonyms": ["Metabolic network reconstruction", "Metabolic network simulation", "Metabolic pathway simulation", "Metabolic reconstruction", {
            "@id": "http://edamontology.org/Metabolic%20pathway%20reconstruction"
          }],
          "text": "Metabolic network modelling"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3925"
          },
          "definition": "Render (visualise) a network - typically a biological network of some sort.",
          "exact_synonyms": ["Network rendering"],
          "has_input": ["http://edamontology.org/data_2600"],
          "narrow_synonyms": ["Protein interaction network rendering", "Protein interaction network visualisation"],
          "text": "Network visualisation"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3094"
          },
          "definition": "Predict a network of protein interactions.",
          "text": "Protein interaction network prediction"
        }],
        "data": {
          "uri": "http://edamontology.org/operation_3927"
        },
        "definition": "Generate, process or analyse a biological network.",
        "exact_synonyms": ["Biological network analysis"],
        "has_topic": ["http://edamontology.org/topic_2259", "http://edamontology.org/topic_0602"],
        "narrow_synonyms": ["Network simulation", "Network comparison", "Biological network modelling", "Biological network prediction", "Network modelling", "Network topology simulation", "Network prediction"],
        "text": "Network analysis"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/operation_3926"
          },
          "definition": "Render (visualise) a biological pathway.",
          "exact_synonyms": ["Pathway rendering"],
          "has_input": ["http://edamontology.org/data_2600"],
          "text": "Pathway visualisation"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3929"
          },
          "definition": "Predict a metabolic pathway.",
          "text": "Metabolic pathway prediction"
        }, {
          "comment": ["The terms and synyonyms here reflect that for practical intents and purposes, \"pathway\" and \"network\" can be treated the same."],
          "data": {
            "uri": "http://edamontology.org/operation_3660"
          },
          "definition": "Model a metabolic network.  This can include 1) reconstruction to break down a metabolic pathways into reactions, enzymes, and other relevant information, and compilation of this into a mathematical model and 2) simulations of metabolism based on the model.",
          "exact_synonyms": [{
            "@id": "http://edamontology.org/Metabolic%20pathway%20modelling"
          }],
          "has_topic": ["http://edamontology.org/topic_2259"],
          "narrow_synonyms": ["Metabolic network reconstruction", "Metabolic network simulation", "Metabolic pathway simulation", "Metabolic reconstruction", {
            "@id": "http://edamontology.org/Metabolic%20pathway%20reconstruction"
          }],
          "text": "Metabolic network modelling"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0533"
          },
          "definition": "Map an expression profile to known biological pathways, for example, to identify or reconstruct a pathway.",
          "exact_synonyms": ["Pathway mapping"],
          "has_output": ["http://edamontology.org/data_2984"],
          "narrow_synonyms": ["Gene-to-pathway mapping", "Gene expression profile pathway mapping", "Gene to pathway mapping"],
          "text": "Expression profile pathway mapping"
        }],
        "data": {
          "uri": "http://edamontology.org/operation_3928"
        },
        "definition": "Generate, process or analyse a biological pathway.",
        "exact_synonyms": ["Biological pathway analysis"],
        "has_topic": ["http://edamontology.org/topic_2259", "http://edamontology.org/topic_0602"],
        "narrow_synonyms": ["Biological pathway modelling", "Pathway comparison", "Biological pathway prediction", "Pathway prediction", "Pathway modelling", "Functional pathway analysis", "Pathway simulation"],
        "text": "Pathway analysis"
      }, {
        "children": [{
          "children": [{
            "comment": ["Methods typically test for topological similarity between trees using for example a congruence index."],
            "data": {
              "uri": "http://edamontology.org/operation_0555"
            },
            "definition": "Compare two or more phylogenetic trees to produce a consensus tree.",
            "exact_synonyms": ["Phylogenetic tree generation (consensus)", "Phylogenetic tree construction (consensus)"],
            "text": "Consensus tree construction"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0556"
            },
            "definition": "Compare two or more phylogenetic trees to detect subtrees or supertrees.",
            "exact_synonyms": ["Phylogenetic sub/super tree detection"],
            "narrow_synonyms": ["Supertree construction", "Subtree construction"],
            "text": "Phylogenetic sub/super tree construction"
          }, {
            "comment": ["Methods typically test for topological similarity between trees using for example a congruence index."],
            "data": {
              "uri": "http://edamontology.org/operation_3947"
            },
            "definition": "Mapping between gene tree nodes and species tree nodes or branches, to analyse and account for possible differences between gene histories and species histories, explaining this in terms of gene-scale events such as duplication, loss, transfer etc.",
            "exact_synonyms": ["Gene tree / species tree reconciliation"],
            "text": "Phylogenetic tree reconciliation"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0557"
            },
            "definition": "Compare two or more phylogenetic trees to calculate distances between trees.",
            "has_output": ["http://edamontology.org/data_1442"],
            "text": "Phylogenetic tree distances calculation"
          }],
          "comment": ["For example, to produce a consensus tree, subtrees, supertrees, calculate distances between trees or test topological similarity between trees (e.g. a congruence index) etc."],
          "data": {
            "uri": "http://edamontology.org/operation_0325"
          },
          "definition": "Compare two or more phylogenetic trees.",
          "text": "Phylogenetic tree comparison"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0551"
          },
          "definition": "Analyse the shape (topology) of a phylogenetic tree.",
          "exact_synonyms": ["Phylogenetic tree analysis (shape)"],
          "text": "Phylogenetic tree topology analysis"
        }, {
          "comment": ["Stabilizing/purifying (directional) selection favors a single phenotype and tends to decrease genetic diversity as a population stabilizes on a particular trait, selecting out trait extremes or deleterious mutations. In contrast, balancing selection maintain genetic polymorphisms (or multiple alleles), whereas disruptive (or diversifying) selection favors individuals at both extremes of a trait."],
          "data": {
            "uri": "http://edamontology.org/operation_0554"
          },
          "definition": "Analyse a phylogenetic tree to identify allele frequency distribution and change that is subject to evolutionary pressures (natural selection, genetic drift, mutation and gene flow). Identify type of natural selection (such as stabilizing, balancing or disruptive).",
          "exact_synonyms": ["Phylogenetic tree analysis (natural selection)"],
          "text": "Allele frequency distribution analysis"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0567"
          },
          "definition": "Render or visualise a phylogenetic tree.",
          "exact_synonyms": ["Phylogenetic tree rendering"],
          "has_output": ["http://edamontology.org/data_0872"],
          "text": "Phylogenetic tree visualisation"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0552"
          },
          "definition": "Apply bootstrapping or other measures to estimate confidence of a phylogenetic tree.",
          "text": "Phylogenetic tree bootstrapping"
        }, {
          "comment": ["Ancestral reconstruction is often used to recover possible ancestral character states of ancient, extinct organisms."],
          "data": {
            "uri": "http://edamontology.org/operation_3745"
          },
          "definition": "The extrapolation of empirical characteristics of individuals or populations, backwards in time, to their common ancestors.",
          "exact_synonyms": ["Character optimisation", "Ancestral sequence reconstruction", "Character mapping"],
          "text": "Ancestral reconstruction"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3942"
          },
          "definition": "The application of phylogenetic and other methods to estimate paleogeographical events such as speciation.",
          "exact_synonyms": ["Tree-dating", "Biogeographic dating", "Species tree dating", "Speciation dating"],
          "text": "Tree dating"
        }, {
          "children": [{
            "comment": ["Note that this is somewhat different from simply analysing an existing tree or constructing a completely new one."],
            "data": {
              "uri": "http://edamontology.org/operation_3478"
            },
            "definition": "Reconstructing the inner node labels of a phylogenetic tree from its leafes.",
            "exact_synonyms": ["Phylogenetic tree reconstruction"],
            "has_topic": ["http://edamontology.org/topic_0084"],
            "narrow_synonyms": ["Gene tree reconstruction", "Species tree reconstruction"],
            "text": "Phylogenetic reconstruction"
          }, {
            "comment": ["Methods typically test for topological similarity between trees using for example a congruence index."],
            "data": {
              "uri": "http://edamontology.org/operation_0555"
            },
            "definition": "Compare two or more phylogenetic trees to produce a consensus tree.",
            "exact_synonyms": ["Phylogenetic tree generation (consensus)", "Phylogenetic tree construction (consensus)"],
            "text": "Consensus tree construction"
          }, {
            "comment": ["Phylogenetic shadowing is a type of footprinting where many closely related species are used.  A phylogenetic 'shadow' represents the additive differences between individual sequences. By masking or 'shadowing' variable positions a conserved sequence is produced with few or none of the variations, which is then compared to the sequences of interest to identify significant regions of conservation."],
            "data": {
              "uri": "http://edamontology.org/operation_0327"
            },
            "definition": "Comparison of a DNA sequence to orthologous sequences in different species and inference of a phylogenetic tree, in order to identify regulatory elements such as transcription factor binding sites (TFBS).",
            "has_topic": ["http://edamontology.org/topic_0194"],
            "narrow_synonyms": ["Phylogenetic shadowing"],
            "text": "Phylogenetic footprinting"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0544"
            },
            "definition": "Construct a phylogenetic species tree, for example, from a genome-wide sequence comparison.",
            "exact_synonyms": ["Phylogenetic species tree generation", "Phylogenetic species tree construction"],
            "text": "Species tree construction"
          }, {
            "comment": ["Gene trees can provide evidence for gene duplication events, as well as speciation events. Where sequences from different homologs are included in a gene tree, subsequent clustering of the orthologs can demonstrate evolutionary history of the orthologs."],
            "data": {
              "uri": "http://edamontology.org/operation_0553"
            },
            "definition": "Construct a \"gene tree\" which represents the evolutionary history of the genes included in the study.  This can be used to predict families of genes and gene function based on their position in a phylogenetic tree.",
            "exact_synonyms": ["Phylogenetic tree analysis (gene family prediction)"],
            "has_output": ["http://edamontology.org/data_0916"],
            "has_topic": ["http://edamontology.org/topic_0194"],
            "text": "Gene tree construction"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/operation_0542"
              },
              "definition": "Phylogenetic tree construction from gene frequency data.",
              "exact_synonyms": ["Phylogenetic tree generation (from gene frequencies)", "Phylogenetic tree construction (from gene frequencies)"],
              "has_input": ["http://edamontology.org/data_2873"],
              "has_topic": ["http://edamontology.org/topic_0203"],
              "text": "Phylogenetic inference (from gene frequencies)"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_0543"
              },
              "definition": "Phylogenetic tree construction from polymorphism data including microsatellites, RFLP (restriction fragment length polymorphisms), RAPD (random-amplified polymorphic DNA) and AFLP (amplified fragment length polymorphisms) data.",
              "exact_synonyms": ["Phylogenetic tree generation (from polymorphism data)", "Phylogenetic tree construction (from polymorphism data)"],
              "has_topic": ["http://edamontology.org/topic_0199"],
              "text": "Phylogenetic inference (from polymorphism data)"
            }, {
              "comment": ["Methods typically compare multiple molecular sequence and estimate evolutionary distances and relationships to infer gene families or make functional predictions."],
              "data": {
                "uri": "http://edamontology.org/operation_0540"
              },
              "definition": "Phylogenetic tree construction from molecular sequences.",
              "exact_synonyms": ["Phylogenetic tree generation (from molecular sequences)", "Phylogenetic tree construction (from molecular sequences)"],
              "text": "Phylogenetic inference (from molecular sequences)"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_0541"
              },
              "definition": "Phylogenetic tree construction from continuous quantitative character data.",
              "exact_synonyms": ["Phylogenetic tree generation (from continuous quantitative characters)", "Phylogenetic tree construction (from continuous quantitative characters)"],
              "has_input": ["http://edamontology.org/data_1426"],
              "text": "Phylogenetic inference (from continuous quantitative characters)"
            }],
            "comment": ["Subconcepts of this concept reflect different types of data used to generate a tree, and provide an alternate axis for curation."],
            "data": {
              "uri": "http://edamontology.org/operation_0538"
            },
            "definition": "Construct a phylogenetic tree from a specific type of data.",
            "exact_synonyms": ["Phylogenetic tree construction (data centric)", "Phylogenetic tree generation (data centric)"],
            "text": "Phylogenetic inference (data centric)"
          }, {
            "children": [{
              "comment": ["This includes evolutionary parsimony (invariants) methods."],
              "data": {
                "uri": "http://edamontology.org/operation_0545"
              },
              "definition": "Construct a phylogenetic tree by computing a sequence alignment and searching for the tree with the fewest number of character-state changes from the alignment.",
              "exact_synonyms": ["Phylogenetic tree generation (parsimony methods)", "Phylogenetic tree construction (parsimony methods)"],
              "text": "Phylogenetic inference (parsimony methods)"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_0549"
              },
              "definition": "Construct a phylogenetic tree by using artificial-intelligence methods, for example genetic algorithms.",
              "exact_synonyms": ["Phylogenetic tree construction (AI methods)", "Phylogenetic tree generation (AI methods)"],
              "text": "Phylogenetic inference (AI methods)"
            }, {
              "comment": ["This includes neighbor joining (NJ) clustering method."],
              "data": {
                "uri": "http://edamontology.org/operation_0546"
              },
              "definition": "Construct a phylogenetic tree by computing (or using precomputed) distances between sequences and searching for the tree with minimal discrepancies between pairwise distances.",
              "exact_synonyms": ["Phylogenetic tree construction (minimum distance methods)", "Phylogenetic tree generation (minimum distance methods)"],
              "text": "Phylogenetic inference (minimum distance methods)"
            }, {
              "comment": ["Maximum likelihood methods search for a tree that maximizes a likelihood function, i.e. that is most likely given the data and model. Bayesian analysis estimate the probability of tree for branch lengths and topology, typically using a Monte Carlo algorithm."],
              "data": {
                "uri": "http://edamontology.org/operation_0547"
              },
              "definition": "Construct a phylogenetic tree by relating sequence data to a hypothetical tree topology using a model of sequence evolution.",
              "exact_synonyms": ["Phylogenetic tree construction (maximum likelihood and Bayesian methods)", "Phylogenetic tree generation (maximum likelihood and Bayesian methods)"],
              "text": "Phylogenetic inference (maximum likelihood and Bayesian methods)"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_0548"
              },
              "definition": "Construct a phylogenetic tree by computing four-taxon trees (4-trees) and searching for the phylogeny that matches most closely.",
              "exact_synonyms": ["Phylogenetic tree construction (quartet methods)", "Phylogenetic tree generation (quartet methods)"],
              "text": "Phylogenetic inference (quartet methods)"
            }],
            "comment": ["Subconcepts of this concept reflect different computational methods used to generate a tree, and provide an alternate axis for curation."],
            "data": {
              "uri": "http://edamontology.org/operation_0539"
            },
            "definition": "Construct a phylogenetic tree using a specific method.",
            "exact_synonyms": ["Phylogenetic tree construction (method centric)", "Phylogenetic tree generation (method centric)"],
            "text": "Phylogenetic inference (method centric)"
          }],
          "comment": ["Phylogenetic trees are usually constructed from a set of sequences from which an alignment (or data matrix) is calculated."],
          "data": {
            "uri": "http://edamontology.org/operation_0323"
          },
          "definition": "Construct a phylogenetic tree.",
          "exact_synonyms": ["Phlyogenetic tree construction", "Phylogenetic reconstruction", "Phylogenetic tree generation"],
          "has_output": ["http://edamontology.org/data_0872"],
          "has_topic": ["http://edamontology.org/topic_0080"],
          "text": "Phylogenetic inference"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0326"
          },
          "definition": "Edit a phylogenetic tree.",
          "has_input": ["http://edamontology.org/data_0872"],
          "has_output": ["http://edamontology.org/data_0872"],
          "text": "Phylogenetic tree editing"
        }],
        "comment": ["Phylgenetic modelling is the modelling of trait evolution and prediction of trait values using phylogeny as a basis."],
        "data": {
          "uri": "http://edamontology.org/operation_0324"
        },
        "definition": "Analyse an existing phylogenetic tree or trees, typically to detect features or make predictions.",
        "exact_synonyms": ["Phylogenetic tree analysis"],
        "has_topic": ["http://edamontology.org/topic_0084"],
        "narrow_synonyms": ["Phylogenetic modelling"],
        "text": "Phylogenetic analysis"
      }, {
        "children": [{
          "children": [{
            "children": [{
              "data": {
                "uri": "http://edamontology.org/operation_3704"
              },
              "definition": "Label-free quantification by integration of ion current (ion counting).",
              "exact_synonyms": ["Ion current integration"],
              "text": "Ion counting"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_3637"
              },
              "definition": "Calculate number of identified MS2 spectra as approximation of peptide / protein quantity.",
              "text": "Spectral counting"
            }],
            "data": {
              "uri": "http://edamontology.org/operation_3634"
            },
            "definition": "Quantification without the use of chemical tags.",
            "text": "Label-free quantification"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3636"
            },
            "definition": "Quantification by Selected/multiple Reaction Monitoring workflow (XIC quantitation of precursor / fragment mass pair).",
            "text": "MRM/SRM"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/operation_3639"
              },
              "definition": "Quantification analysis using the AB SCIEX iTRAQ isobaric labelling workflow, wherein 2-8 reporter ions are measured in MS2 spectra near 114 m/z.",
              "text": "iTRAQ"
            }, {
              "comment": ["This includes N-15 metabolic labeling (labeling all proteins and (possibly) all amino acids using N-15 enriched grown medium or feed) and C-13 metabolic labeling (labeling all proteins and (possibly) all amino acids using C-13 enriched grown medium or feed)."],
              "data": {
                "uri": "http://edamontology.org/operation_3715"
              },
              "definition": "Labeling all proteins and (possibly) all amino acids using C-13 or N-15 enriched grown medium or feed.",
              "narrow_synonyms": ["C-13 metabolic labeling", "N-15 metabolic labeling"],
              "text": "Metabolic labeling"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_3642"
              },
              "definition": "Quantification analysis using chemical labeling by stable isotope dimethylation",
              "text": "Dimethyl"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_3705"
              },
              "definition": "Chemical tagging free amino groups of intact proteins with stable isotopes.",
              "exact_synonyms": ["ICPL"],
              "text": "Isotope-coded protein label"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_3640"
              },
              "definition": "Quantification analysis using labeling based on 18O-enriched H2O.",
              "text": "18O labeling"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_3641"
              },
              "definition": "Quantification analysis using the Thermo Fisher tandem mass tag labelling workflow.",
              "text": "TMT-tag"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_3638"
              },
              "definition": "Quantification analysis using stable isotope labeling by amino acids in cell culture.",
              "text": "SILAC"
            }],
            "data": {
              "uri": "http://edamontology.org/operation_3635"
            },
            "definition": "Quantification based on the use of chemical tags.",
            "text": "Labeled quantification"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_3630"
          },
          "definition": "Technique for determining the amount of proteins in a sample.",
          "exact_synonyms": ["Protein quantitation"],
          "has_input": ["http://edamontology.org/data_0943"],
          "text": "Protein quantification"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3628"
          },
          "definition": "Align multiple data sets using information from chromatography and/or peptide identification, from mass spectrometry experiments.",
          "has_input": ["http://edamontology.org/data_0943"],
          "text": "Chromatographic alignment"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3803"
          },
          "definition": "Mass spectra identification of compounds that are produced by living systems. Including polyketides, terpenoids, phenylpropanoids, alkaloids and antibiotics.",
          "narrow_synonyms": ["De novo metabolite identification", "Metabolite identification", "Fragmenation tree generation"],
          "text": "Natural product identification"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3215"
          },
          "definition": "Identify peaks in a spectrum from a mass spectrometry, NMR, or some other spectrum-generating experiment.",
          "exact_synonyms": ["Peak assignment", "Peak finding"],
          "has_input": ["http://edamontology.org/data_0943"],
          "text": "Peak detection"
        }, {
          "comment": ["Deisotoping is commonly done to reduce complexity, and done in conjunction with the charge state deconvolution."],
          "data": {
            "uri": "http://edamontology.org/operation_3629"
          },
          "definition": "The removal of isotope peaks in a spectrum, to represent the fragment ion as one data point.",
          "exact_synonyms": ["Deconvolution"],
          "has_input": ["http://edamontology.org/data_0943"],
          "text": "Deisotoping"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3767"
          },
          "definition": "Identification of protein, for example from one or more peptide identifications by tandem mass spectrometry.",
          "exact_synonyms": ["Protein inference"],
          "has_input": ["http://edamontology.org/data_0943"],
          "text": "Protein identification"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3627"
          },
          "definition": "Re-adjust the output of mass spectrometry experiments with shifted ppm values.",
          "has_input": ["http://edamontology.org/data_0943"],
          "text": "Mass spectra calibration"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3860"
          },
          "definition": "Calculate a theoretical mass spectrometry spectra for given sequences.",
          "exact_synonyms": ["Spectrum prediction"],
          "has_input": ["http://edamontology.org/data_0943"],
          "text": "Spectrum calculation"
        }, {
          "children": [{
            "children": [{
              "data": {
                "uri": "http://edamontology.org/operation_3649"
              },
              "definition": "Statistical estimation of false discovery rate from score distribution for peptide-spectrum-matches, following a peptide database search, and by comparison to search results with a database containing incorrect information.",
              "text": "Target-Decoy"
            }, {
              "data": {
                "uri": "http://edamontology.org/operation_3647"
              },
              "definition": "Peptide database search for identification of known and unknown PTMs looking for mass difference mismatches.",
              "exact_synonyms": ["Modification-tolerant peptide database search", "Unrestricted peptide database search"],
              "text": "Blind peptide database search"
            }],
            "data": {
              "uri": "http://edamontology.org/operation_3646"
            },
            "definition": "Determination of best matches between MS/MS spectrum and a database of protein or nucleic acid sequences.",
            "text": "Peptide database search"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3643"
            },
            "definition": "Peptide sequence tags are used as piece of information about a peptide obtained by tandem mass spectrometry.",
            "text": "Tag-based peptide identification"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3801"
            },
            "definition": "Match experimentally measured mass spectrum to a spectrum in a spectral library or database.",
            "has_input": ["http://edamontology.org/data_0943"],
            "text": "Spectral library search"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/operation_3755"
              },
              "definition": "Site localisation of post-translational modifications in peptide or protein mass spectra.",
              "exact_synonyms": ["PTM scoring", "Site localisation"],
              "text": "PTM localisation"
            }],
            "data": {
              "uri": "http://edamontology.org/operation_3645"
            },
            "definition": "Identification of post-translational modifications (PTMs) of peptides/proteins in mass spectrum.",
            "text": "PTM identification"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3644"
            },
            "definition": "Analytical process that derives a peptide's amino acid sequence from its tandem mass spectrum (MS/MS) without the assistance of a sequence database.",
            "text": "de Novo sequencing"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_3631"
          },
          "definition": "Determination of peptide sequence from mass spectrum.",
          "exact_synonyms": ["Peptide-spectrum-matching"],
          "has_input": ["http://edamontology.org/data_0943"],
          "text": "Peptide identification"
        }],
        "data": {
          "uri": "http://edamontology.org/operation_3214"
        },
        "definition": "Analyse one or more spectra from mass spectrometry (or other) experiments.",
        "exact_synonyms": ["Spectrum analysis", "Mass spectrum analysis"],
        "has_topic": ["http://edamontology.org/topic_0121"],
        "text": "Spectral analysis"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/operation_2437"
          },
          "definition": "Predict a network of gene regulation.",
          "text": "Gene regulatory network prediction"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3232"
          },
          "definition": "Combine classical quantitative trait loci (QTL) analysis with gene expression profiling, for example, to describe describe cis- and trans-controlling elements for the expression of phenotype associated genes.",
          "exact_synonyms": ["Gene expression quantitative trait loci profiling", "Gene expression QTL profiling", "eQTL profiling"],
          "text": "Gene expression QTL analysis"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_1781"
          },
          "definition": "Analyse a known network of gene regulation.",
          "has_topic": ["http://edamontology.org/topic_0602"],
          "narrow_synonyms": ["Regulatory network comparison", "Regulatory network modelling", "Gene regulatory network modelling", "Gene regulatory network comparison"],
          "text": "Gene regulatory network analysis"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_3741"
            },
            "definition": "The analysis, using proteomics techniques, to identify proteins whose encoding genes are differentially expressed under a given experimental setup.",
            "exact_synonyms": ["Differential protein expression analysis"],
            "text": "Differential protein expression profiling"
          }, {
            "comment": ["Differential gene expression analysis is used, for example, to identify which genes are up-regulated (increased expression) or down-regulated (decreased expression) between a group treated with a drug and a control groups."],
            "data": {
              "uri": "http://edamontology.org/operation_3223"
            },
            "definition": "Identify from molecular sequence analysis (typically from analysis of microarray or RNA-seq data) genes whose expression levels are significantly different between two sample groups.",
            "exact_synonyms": ["Differentially expressed gene identification", "Differential expression analysis", "Differential gene expression analysis", "Differential gene analysis"],
            "text": "Differential gene expression profiling"
          }],
          "comment": ["Gene expression profiling generates some sort of gene expression profile, for example from microarray data."],
          "data": {
            "uri": "http://edamontology.org/operation_0314"
          },
          "definition": "The measurement of the activity (expression) of multiple genes in a cell, tissue, sample etc., in order to get an impression of biological function.",
          "exact_synonyms": ["Gene expression quantification", "Functional profiling", "Gene expression profile construction", "Gene expression profile generation", "Gene transcription profiling", "Feature expression analysis"],
          "narrow_synonyms": ["RNA profiling", "Protein profiling", "Non-coding RNA profiling", "mRNA profiling"],
          "text": "Gene expression profiling"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_3792"
          },
          "definition": "The analysis of microRNAs (miRNAs) : short, highly conserved small noncoding RNA molecules that are naturally occurring plant and animal genomes.",
          "exact_synonyms": ["miRNA expression profiling"],
          "text": "miRNA expression analysis"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_3463"
            },
            "definition": "Analyse the correlation patterns among features/molecules across across a variety of experiments, samples etc.",
            "exact_synonyms": ["Co-expression analysis"],
            "narrow_synonyms": ["Gene expression correlation", "Gene expression correlation analysis", "Gene co-expression network analysis"],
            "text": "Expression correlation analysis"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_0313"
            },
            "definition": "Perform cluster analysis of expression data to identify groups with similar expression profiles, for example by clustering.",
            "has_output": ["http://edamontology.org/data_3111"],
            "narrow_synonyms": ["Gene expression profile clustering", "Gene expression clustering"],
            "text": "Expression profile clustering"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_0315"
          },
          "definition": "Comparison of expression profiles.",
          "narrow_synonyms": ["Gene expression profile comparison", "Gene expression comparison"],
          "text": "Expression profile comparison"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_3565"
            },
            "definition": "Analyze time series data from an RNA-seq experiment.",
            "text": "RNA-seq time series data analysis"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_3563"
            },
            "definition": "Analyze read counts from RNA-seq experiments.",
            "text": "RNA-seq read count analysis"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_3680"
          },
          "definition": "Analyze data from RNA-seq experiments.",
          "text": "RNA-Seq analysis"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/operation_2938"
            },
            "definition": "Visualise clustered expression data using a tree diagram.",
            "exact_synonyms": ["Expression data tree visualisation", "Expression data tree or dendrogram rendering", "Dendrograph plotting", "Dendrogram plotting", "Dendrograph visualisation"],
            "narrow_synonyms": ["Microarray checks view rendering", "Microarray 2-way dendrogram rendering", "Microarray tree or dendrogram rendering", "Microarray matrix tree plot rendering"],
            "text": "Dendrogram visualisation"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_2937"
            },
            "definition": "Generate a plot of distances (distance or correlation matrix) between expression values.",
            "exact_synonyms": ["Distance matrix rendering", "Distance matrix plotting", "Proximity map rendering", "Distance map rendering"],
            "narrow_synonyms": ["Microarray proximity map rendering", "Correlation matrix plotting", "Microarray distance map rendering", "Correlation matrix rendering", "Microarray proximity map plotting"],
            "text": "Proximity map plotting"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_2935"
            },
            "definition": "Visualise clustered quantitative data as set of different profiles, where each profile is plotted versus different entities or samples on the X-axis.",
            "exact_synonyms": ["Clustered quantitative data rendering", "Wave graph plotting", "Clustered quantitative data plotting"],
            "narrow_synonyms": ["Microarray wave graph rendering", "Microarray cluster temporal graph rendering", "Microarray wave graph plotting"],
            "text": "Clustering profile plotting"
          }, {
            "data": {
              "uri": "http://edamontology.org/operation_2942"
            },
            "definition": "Visualise gene expression data after hierarchical clustering for representing hierarchical relationships.",
            "exact_synonyms": ["Treemapping", "Expression data tree-map rendering"],
            "narrow_synonyms": ["Microarray tree-map rendering"],
            "text": "Treemap visualisation"
          }, {
            "comment": ["The heat map usually uses a coloring scheme to represent expression values. They can show how quantitative measurements were influenced by experimental conditions."],
            "data": {
              "uri": "http://edamontology.org/operation_0531"
            },
            "definition": "Generate a heat map of expression data from e.g. microarray data.",
            "exact_synonyms": ["Heat map construction", "Heatmap generation"],
            "has_output": ["http://edamontology.org/data_1636"],
            "text": "Heat map generation"
          }],
          "data": {
            "uri": "http://edamontology.org/operation_0571"
          },
          "definition": "Visualise microarray or other expression data.",
          "exact_synonyms": ["Expression data rendering"],
          "has_input": ["http://edamontology.org/data_3117"],
          "narrow_synonyms": ["Microarray data rendering", "Gene expression data visualisation"],
          "text": "Expression data visualisation"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0533"
          },
          "definition": "Map an expression profile to known biological pathways, for example, to identify or reconstruct a pathway.",
          "exact_synonyms": ["Pathway mapping"],
          "has_output": ["http://edamontology.org/data_2984"],
          "narrow_synonyms": ["Gene-to-pathway mapping", "Gene expression profile pathway mapping", "Gene to pathway mapping"],
          "text": "Expression profile pathway mapping"
        }, {
          "comment": ["\"Gene set analysis\" (often used interchangeably or in an overlapping sense with \"gene-set enrichment analysis\") refers to the functional analysis (term enrichment) of a differentially expressed set of genes, rather than all genes analysed.", "The Gene Ontology (GO) is typically used, the input is a set of Gene IDs, and the output of the analysis is typically a ranked list of GO concepts, each associated with a p-value."],
          "data": {
            "uri": "http://edamontology.org/operation_2436"
          },
          "definition": "Identify classes of genes or proteins that are over or under-represented in a large set of genes or proteins.  For example analysis of a set of genes corresponding to a gene expression profile, annotated with Gene Ontology (GO) concepts, where eventual over-/under-representation of certain GO concept within the studied set of genes is revealed.",
          "exact_synonyms": ["GSEA", "Functional enrichment analysis", "Gene-set over-represenation analysis"],
          "has_output": ["http://edamontology.org/data_3754"],
          "has_topic": ["http://edamontology.org/topic_1775"],
          "narrow_synonyms": ["Gene set analysis"],
          "text": "Gene-set enrichment analysis"
        }],
        "data": {
          "uri": "http://edamontology.org/operation_2495"
        },
        "definition": "Process (read and/or write) expression data from experiments measuring molecules (e.g. omics data), including analysis of one or more expression profiles, typically to interpret them in functional terms.",
        "exact_synonyms": ["Expression data analysis"],
        "has_topic": ["http://edamontology.org/topic_0203"],
        "narrow_synonyms": ["Metagenomic inference", "Gene expression data analysis", "Gene expression regulation analysis", "Gene expression analysis", "Protein expression analysis", "Microarray data analysis"],
        "text": "Expression analysis"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/operation_2241"
          },
          "definition": "Visualise transmembrane proteins, typically the transmembrane regions within a sequence.",
          "exact_synonyms": ["Transmembrane protein rendering"],
          "has_output": ["http://edamontology.org/data_2992"],
          "text": "Transmembrane protein visualisation"
        }, {
          "data": {
            "uri": "http://edamontology.org/operation_0269"
          },
          "definition": "Predict and/or classify transmembrane proteins or transmembrane (helical) domains or regions in protein sequences.",
          "text": "Transmembrane protein prediction"
        }],
        "comment": ["Use this (or child) concept for analysis of transmembrane domains (buried and exposed faces), transmembrane helices, helix topology, orientation, inter-helical contacts, membrane dipping (re-entrant) loops and other secondary structure etc. Methods might use pattern discovery, hidden Markov models, sequence alignment, structural profiles, amino acid property analysis, comparison to known domains or some combination (hybrid methods)."],
        "data": {
          "uri": "http://edamontology.org/operation_0270"
        },
        "definition": "Analyse transmembrane protein(s), typically by processing sequence and / or structural data, and write an informative report for example about the protein and its transmembrane domains / regions.",
        "has_topic": ["http://edamontology.org/topic_0820"],
        "text": "Transmembrane protein analysis"
      }],
      "comment": ["This excludes non-analytical methods that read and write the same basic type of data (for that, see 'Data handling')."],
      "data": {
        "uri": "http://edamontology.org/operation_2945"
      },
      "definition": "Apply analytical methods to existing data of a specific type.",
      "text": "Analysis"
    }],
    "comment": ["Special cases are: a) An operation that consumes no input (has no input arguments). Such operation is either a constant function, or an operation depending only on the underlying state. b) An operation that may modify the underlying state but has no output. c) The singular-case operation with no input or output, that still may modify the underlying state."],
    "data": {
      "uri": "http://edamontology.org/operation_0004"
    },
    "definition": "A function that processes a set of inputs and results in a set of outputs, or associates arguments (inputs) with values (outputs).",
    "narrow_synonyms": ["Mathematical operation", "Mathematical function", "Computational method", "Lambda abstraction", "Computational procedure", "Computational subroutine", "Computational operation", "Function (programming)"],
    "text": "Operation"
  }, {
    "children": [{
      "children": [{
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_1316"
          },
          "definition": "Format of a report on exon-intron structure generated by EMBOSS est2genome.",
          "text": "est2genome format"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3979"
          },
          "definition": "WEGO native format used by the Web Gene Ontology Annotation Plot application.   Tab-delimited format with gene names and others GO IDs (columns) with one annotation record per line.",
          "text": "WEGO"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3850"
          },
          "definition": "OrthoXML is designed broadly to allow the storage and comparison of orthology data from any ortholog database. It establishes a structure for describing orthology relationships while still allowing flexibility for database-specific information to be encapsulated in the same format.",
          "text": "OrthoXML"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2031"
        },
        "definition": "Format of a report on a particular locus, gene, gene system or groups of genes.",
        "exact_synonyms": ["Gene features format"],
        "is_format_of": ["http://edamontology.org/data_0916"],
        "text": "Gene annotation format"
      }, {
        "children": [{
          "comment": ["mirGFF3 is a specialisation of GFF3; produced by small-RNA-Seq analysis workflows, usable and convertible with the miRTop API (https://mirtop.readthedocs.io/en/latest/), and consumable by tools for downstream analysis."],
          "data": {
            "uri": "http://edamontology.org/format_3864"
          },
          "definition": "mirGFF3 is a common format for microRNA data resulting from small-RNA RNA-Seq workflows.",
          "exact_synonyms": ["miRTop format"],
          "text": "mirGFF3"
        }],
        "data": {
          "uri": "http://edamontology.org/format_3865"
        },
        "definition": "A \"placeholder\" concept for formats of annotated RNA data, including e.g. microRNA and RNA-Seq data.",
        "narrow_synonyms": ["miRNA data format", "microRNA data format"],
        "text": "RNA annotation format"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_3915"
          },
          "definition": "The Zarr format is an implementation of chunked, compressed, N-dimensional arrays for storing data.",
          "is_format_of": ["http://edamontology.org/data_2535", "http://edamontology.org/data_3112"],
          "text": "Zarr"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3626"
          },
          "definition": "Binary format used by MATLAB files to store workspace variables.",
          "exact_synonyms": ["MAT file format", "MATLAB file format", ".mat file format"],
          "is_format_of": ["http://edamontology.org/data_1499"],
          "text": "MAT"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_1504"
            },
            "definition": "Amino acid index format used by the AAindex database.",
            "text": "aaindex"
          }],
          "data": {
            "uri": "http://edamontology.org/format_2017"
          },
          "definition": "Data format for an amino acid index.",
          "is_format_of": ["http://edamontology.org/data_1501"],
          "text": "Amino acid index format"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3916"
          },
          "definition": "The Matrix Market matrix (MTX) format stores numerical or pattern matrices in a dense (array format) or sparse (coordinate format) representation.",
          "is_format_of": ["http://edamontology.org/data_3112", "http://edamontology.org/data_2535"],
          "text": "MTX"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_2064"
          },
          "definition": "Format of a matrix of 3D-1D scores (amino acid environment probabilities).",
          "is_format_of": ["http://edamontology.org/data_1499"],
          "text": "3D-1D scoring matrix format"
        }],
        "data": {
          "uri": "http://edamontology.org/format_3033"
        },
        "definition": "Format of a matrix (array) of numerical values.",
        "is_format_of": ["http://edamontology.org/data_2082"],
        "text": "Matrix format"
      }, {
        "children": [{
          "comment": ["BcForms is related to http://edamontology.org/format_3909. (BcForms uses BpForms to describe subunits which are DNA, RNA, or protein polymers.) However, that format isn't the parent of BcForms. BcForms is similarly related to SMILES (http://edamontology.org/data_2301)."],
          "data": {
            "uri": "http://edamontology.org/format_3951"
          },
          "definition": "BcForms is a format for abstractly describing the molecular structure (atoms and bonds) of macromolecular complexes as a collection of subunits and crosslinks. Each subunit can be described with BpForms (http://edamontology.org/format_3909) or SMILES (http://edamontology.org/data_2301). BcForms uses an ontology of crosslinks to abstract the chemical details of crosslinks from the descriptions of complexes (see https://bpforms.org/crosslink.html).",
          "text": "BcForms"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3816"
          },
          "definition": "Complete, portable representation of a SYBYL molecule. ASCII file which contains all the information needed to reconstruct a SYBYL molecule.",
          "text": "Mol2"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1705"
          },
          "definition": "The format of an entry from the HET group dictionary (HET groups from PDB files).",
          "text": "HET group dictionary entry format"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3815"
          },
          "definition": "An MDL Molfile is a file format for holding information about the atoms, bonds, connectivity and coordinates of a molecule.",
          "text": "Molfile"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3814"
          },
          "definition": "SDF is one of a family of chemical-data file formats developed by MDL Information Systems; it is intended especially for structural information.",
          "text": "SDF"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2030"
        },
        "definition": "Format of a report on a chemical compound.",
        "exact_synonyms": ["Chemical compound annotation format", "Chemical structure format", "Small molecule structure format", "Small molecule report format"],
        "is_format_of": ["http://edamontology.org/data_0962"],
        "text": "Chemical data format"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_1736"
          },
          "definition": "CiteXplore 'core' citation format including title, journal, authors and abstract.",
          "text": "CiteXplore-core"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3848"
          },
          "definition": "XML format for collected entries from biobliographic databases MEDLINE and PubMed.",
          "exact_synonyms": ["MEDLINE XML"],
          "text": "PubMed XML"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1737"
          },
          "definition": "CiteXplore 'all' citation format includes all known details such as Mesh terms and cross-references.",
          "text": "CiteXplore-all"
        }, {
          "comment": ["Bibliographic reference information including citation information is included"],
          "data": {
            "uri": "http://edamontology.org/format_1735"
          },
          "definition": "Format for abstracts of scientific articles from the Medline database.",
          "text": "Medline Display Format"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1734"
          },
          "definition": "Format of bibliographic reference as used by the PubMed database.",
          "text": "PubMed citation"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2848"
        },
        "definition": "Format of a bibliographic reference.",
        "is_format_of": ["http://edamontology.org/data_2849", "http://edamontology.org/data_0970"],
        "text": "Bibliographic reference format"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_3693"
          },
          "definition": "AGP is a tabular format for a sequence assembly (a contig, a scaffold/supercontig, or a chromosome).",
          "text": "AGP"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_3976"
            },
            "definition": "Graphical Fragment Assembly captures sequence graphs as the product of an assembly, a representation of variation in genomes, splice graphs in genes, or even overlap between reads from long-read sequencing technology.",
            "text": "GFA 2"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3582"
            },
            "definition": "AFG is a single text-based file assembly format  that holds read and consensus information together",
            "text": "afg"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1631"
            },
            "definition": "Sequence assembly project file EXP format.",
            "exact_synonyms": ["EXP", "Affymetrix EXP format"],
            "text": "EXP"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1630"
            },
            "definition": "Common Assembly Format (CAF). A sequence assembly format including contigs, base-call qualities, and other metadata.",
            "text": "CAF"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3975"
            },
            "definition": "Graphical Fragment Assembly captures sequence graphs as the product of an assembly, a representation of variation in genomes, splice graphs in genes, or even overlap between reads from long-read sequencing technology.",
            "text": "GFA 1"
          }, {
            "comment": ["It is called FASTG, like FASTA, but the G stands for \"graph\"."],
            "data": {
              "uri": "http://edamontology.org/format_3823"
            },
            "definition": "FASTG is a format for faithfully representing genome assemblies in the face of allelic polymorphism and assembly uncertainty.",
            "exact_synonyms": ["FASTG assembly graph format"],
            "text": "FASTG"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3818"
            },
            "definition": "Tab-delimited text file format used by Eland - the read-mapping program distributed by Illumina with its sequencing analysis pipeline - which maps short Solexa sequence reads to the human reference genome.",
            "exact_synonyms": ["ELAND", "eland"],
            "text": "ELAND format"
          }],
          "data": {
            "uri": "http://edamontology.org/format_2561"
          },
          "definition": "Text format for sequence assembly data.",
          "text": "Sequence assembly format (text)"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3001"
          },
          "definition": "ACE sequence assembly format including contigs, base-call qualities, and other metadata (version Aug 1998 and onwards).",
          "text": "ACE"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2055"
        },
        "definition": "Format for sequence assembly data.",
        "is_format_of": ["http://edamontology.org/data_0925"],
        "text": "Sequence assembly format"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_3239"
          },
          "definition": "CopasiML, the native format of COPASI.",
          "text": "CopasiML"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3155"
          },
          "definition": "Systems Biology Result Markup Language (SBRML), the standard XML format for simulated or calculated results (e.g. trajectories) of systems biology models.",
          "text": "SBRML"
        }],
        "data": {
          "uri": "http://edamontology.org/format_3166"
        },
        "definition": "Data format for a report of information derived from a biological pathway or network.",
        "is_format_of": ["http://edamontology.org/data_2984"],
        "text": "Biological pathway or network report format"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_1248"
          },
          "definition": "Format for sequence positions (feature location) as used in DDBJ/EMBL/GenBank database.",
          "exact_synonyms": ["Feature location"],
          "text": "EMBL feature location"
        }, {
          "comment": ["Reflects a UCSC Browser DB table."],
          "data": {
            "uri": "http://edamontology.org/format_3235"
          },
          "definition": "Cytoband format for chromosome cytobands.",
          "is_format_of": ["http://edamontology.org/data_3236"],
          "text": "Cytoband format"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2078"
        },
        "definition": "Format used to specify range(s) of sequence positions.",
        "is_format_of": ["http://edamontology.org/data_1017"],
        "text": "Sequence range format"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_3829"
          },
          "definition": "GenePix Results (GPR) text file format developed by Axon Instruments that is used to save GenePix Results data.",
          "text": "GPR"
        }],
        "data": {
          "uri": "http://edamontology.org/format_3828"
        },
        "definition": "Data format for raw microarray data.",
        "exact_synonyms": ["Microarray data format"],
        "is_format_of": ["http://edamontology.org/data_3110"],
        "text": "Raw microarray data format"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_3491"
          },
          "definition": "Bowtie format for indexed reference genome for \"large\" genomes.",
          "exact_synonyms": ["Bowtie long index format"],
          "is_format_of": ["http://edamontology.org/data_3210"],
          "text": "ebwtl"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3327"
          },
          "definition": "BAM indexing format",
          "is_format_of": ["http://edamontology.org/data_0955"],
          "text": "BAI"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3624"
          },
          "definition": "An index of a genome database, indexed for use by the snpeff tool.",
          "text": "snpeffdb"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3484"
          },
          "definition": "Bowtie format for indexed reference genome for \"small\" genomes.",
          "exact_synonyms": ["Bowtie index format"],
          "is_format_of": ["http://edamontology.org/data_3210"],
          "text": "ebwt"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3700"
          },
          "definition": "Index file format used by the samtools package to index TAB-delimited genome position files.",
          "is_format_of": ["http://edamontology.org/data_0955"],
          "text": "Tabix index file format"
        }],
        "data": {
          "uri": "http://edamontology.org/format_3326"
        },
        "definition": "Format of a data index of some type.",
        "is_format_of": ["http://edamontology.org/data_0955"],
        "text": "Data index format"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_1582"
          },
          "definition": "A report format for the kinetics of enzyme-catalysed reaction(s) in a format generated by EMBOSS findkm. This includes Michaelis Menten plot, Hanes Woolf plot, Michaelis Menten constant (Km) and maximum velocity (Vmax).",
          "text": "findkm"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2027"
        },
        "definition": "Data format for reports on enzyme kinetics.",
        "is_format_of": ["http://edamontology.org/data_2024"],
        "text": "Enzyme kinetics report format"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_2171"
          },
          "definition": "Format used for clusters of protein sequences.",
          "text": "Sequence cluster format (protein)"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_1639"
            },
            "definition": "Format of affymetrix gene cluster files (hc-genes.txt, hc-chips.txt) from hierarchical clustering.",
            "text": "affymetrix"
          }],
          "data": {
            "uri": "http://edamontology.org/format_2172"
          },
          "definition": "Format used for clusters of nucleotide sequences.",
          "text": "Sequence cluster format (nucleic acid)"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2170"
        },
        "definition": "Format used for clusters of molecular sequences.",
        "is_format_of": ["http://edamontology.org/data_1235"],
        "text": "Sequence cluster format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3787"
        },
        "definition": "A query language (format) for structured database queries.",
        "exact_synonyms": ["Query format"],
        "is_format_of": ["http://edamontology.org/data_3786"],
        "text": "Query language"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_3777"
          },
          "definition": "The FAO/Bioversity/IPGRI Multi-Crop Passport Descriptors (MCPD) is an international standard format for exchange of germplasm information.",
          "exact_synonyms": ["MCPD format", "Bioversity MCPD", "Multi-Crop Passport Descriptors", "FAO MCPD", "Multi-Crop Passport Descriptors format"],
          "is_format_of": ["http://edamontology.org/data_2530", "http://edamontology.org/data_3113", "http://edamontology.org/data_3567"],
          "narrow_synonyms": ["IPGRI MCPD", "MCPD V.1", "MCPD V.2"],
          "text": "MCPD"
        }, {
          "comment": ["BIOM is a recognised standard for the Earth Microbiome Project, and is a project supported by Genomics Standards Consortium. Supported in QIIME, Mothur, MEGAN, etc."],
          "data": {
            "uri": "http://edamontology.org/format_3746"
          },
          "definition": "The BIological Observation Matrix (BIOM) is a format for representing biological sample by observation contingency tables in broad areas of comparative omics. The primary use of this format is to represent OTU tables and metagenome tables.",
          "exact_synonyms": ["BIological Observation Matrix format"],
          "text": "BIOM format"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3708"
          },
          "definition": "Exchange format of the Access to Biological Collections Data (ABCD) Schema; a standard for the access to and exchange of data about specimens and observations (primary biodiversity data).",
          "exact_synonyms": ["ABCD"],
          "is_format_of": ["http://edamontology.org/data_3707"],
          "text": "ABCD format"
        }],
        "data": {
          "uri": "http://edamontology.org/format_3706"
        },
        "definition": "Data format for biodiversity data.",
        "is_format_of": ["http://edamontology.org/data_3707"],
        "text": "Biodiversity data format"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_3468"
          },
          "definition": "Microsoft Excel spreadsheet format.",
          "exact_synonyms": ["Microsoft Excel format"],
          "text": "xls"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3506"
          },
          "definition": "Microsoft Word format.",
          "exact_synonyms": ["Microsoft Word format", "doc"],
          "text": "docx"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_3977"
            },
            "definition": "ObjTables is a toolkit for creating re-usable datasets that are both human and machine-readable, combining the ease of spreadsheets (e.g., Excel workbooks) with the rigor of schemas (classes, their attributes, the type of each attribute, and the possible relationships between instances of classes). ObjTables consists of a format for describing schemas for spreadsheets, numerous data types for science, a syntax for indicating the class and attribute represented by each table and column in a workbook, and software for using schemas to rigorously validate, merge, split, compare, and revision datasets.",
            "is_format_of": ["http://edamontology.org/data_0006"],
            "text": "ObjTables"
          }],
          "data": {
            "uri": "http://edamontology.org/format_3620"
          },
          "definition": "MS Excel spreadsheet format consisting of a set of XML documents stored in a ZIP-compressed file.",
          "text": "xlsx"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3508"
          },
          "definition": "Portable Document Format",
          "text": "PDF"
        }, {
          "comment": ["uses the TeX typesetting program format"],
          "data": {
            "uri": "http://edamontology.org/format_3817"
          },
          "definition": "format for the LaTeX document preparation system",
          "exact_synonyms": ["LaTeX format"],
          "text": "latex"
        }],
        "data": {
          "uri": "http://edamontology.org/format_3507"
        },
        "definition": "Format of documents including word processor, spreadsheet and presentation.",
        "text": "Document format"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_1350"
          },
          "definition": "Dirichlet distribution MEME format.",
          "text": "MEME Dirichlet prior"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1349"
          },
          "definition": "Dirichlet distribution HMMER format.",
          "text": "HMMER Dirichlet prior"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2074"
        },
        "definition": "Data format of a dirichlet distribution.",
        "is_format_of": ["http://edamontology.org/data_1347"],
        "text": "Dirichlet distribution format"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_3622"
          },
          "definition": "Data format used by the SQLite database conformant to the Gemini schema.",
          "text": "Gemini SQLite format"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3016"
          },
          "definition": "Variant Call Format (VCF) for sequence variation (indels, polymorphisms, structural variation).",
          "text": "VCF"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3019"
          },
          "definition": "Genome Variation Format (GVF). A GFF3-compatible format with defined header and attribute tags for sequence variation.",
          "text": "GVF"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3499"
          },
          "definition": "Ensembl standard format for variation data.",
          "text": "Ensembl variation file format"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3020"
          },
          "definition": "BCF, the binary version of Variant Call Format (VCF) for sequence variation (indels, polymorphisms, structural variation).",
          "text": "BCF"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2921"
        },
        "definition": "Format of sequence variation annotation.",
        "is_format_of": ["http://edamontology.org/data_3498"],
        "text": "Sequence variation annotation format"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_2194"
          },
          "definition": "Abstract format used by MedLine database.",
          "text": "medline"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1739"
          },
          "definition": "Article format of the PubMed Central database.",
          "text": "pmc"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2020"
        },
        "definition": "Data format for a full-text scientific article.",
        "exact_synonyms": ["Literature format"],
        "is_format_of": ["http://edamontology.org/data_0971"],
        "text": "Article format"
      }, {
        "children": [{
          "comment": ["GROMACS itp files are used also to define position restrictions on the molecule, or to define the force field parameters for a particular ligand."],
          "data": {
            "uri": "http://edamontology.org/format_3883"
          },
          "definition": "GROMACS itp files (include topology) contain structure topology information, and are tipically included in GROMACS topology files (GROMACS top). Itp files are used to define individual (or multiple) components of a topology as a separate file. This is particularly useful if there is a molecule that is used frequently, and also reduces the size of the system topology file, splitting it in different parts.",
          "text": "GROMACS itp"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3888"
          },
          "definition": "AMBER frcmod (Force field Modification) is a file format to store any modification to the standard force field needed for a particular molecule to be properly represented in the simulation.",
          "text": "AMBER frcmod"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3889"
          },
          "definition": "AMBER Object File Format library files (OFF library files) store residue libraries (forcefield residue parameters).",
          "exact_synonyms": ["AMBER Object File Format", "AMBER lib"],
          "text": "AMBER off"
        }],
        "comment": ["Many different file formats exist describing force field parameters. Tipically, each MD package or simulation software works with their own implementation (e.g. GROMACS itp, CHARMM rtf, AMBER off / frcmod)."],
        "data": {
          "uri": "http://edamontology.org/format_3884"
        },
        "definition": "Format of force field parameter files, which store the set of parameters (charges, masses, radii, bond lengths, bond dihedrals, etc.) that are essential for the proper description and simulation of a molecular system.",
        "is_format_of": ["http://edamontology.org/data_3872"],
        "text": "FF parameter format"
      }, {
        "children": [{
          "children": [{
            "comment": ["For SOLiD data, the sequence is in color space, except the first position. The quality values are those of the Sanger format."],
            "data": {
              "uri": "http://edamontology.org/format_3610"
            },
            "definition": "FASTQ format subset for Phred sequencing quality score data only (no sequences) for SOLiD data.",
            "text": "qualsolid"
          }, {
            "comment": ["Starting in Illumina 1.5 and before Illumina 1.8, the Phred scores 0 to 2 have a slightly different meaning. The values 0 and 1 are no longer used and the value 2, encoded by ASCII 66 \"B\", is used also at the end of reads as a Read Segment Quality Control Indicator."],
            "data": {
              "uri": "http://edamontology.org/format_3609"
            },
            "definition": "FASTQ format subset for Phred sequencing quality score data only (no sequences) from Illumina 1.5 and before Illumina 1.8.",
            "text": "qualillumina"
          }, {
            "comment": ["Solexa/Illumina 1.0 format can encode a Solexa/Illumina quality score from -5 to 62 using ASCII 59 to 126 (although in raw read data Solexa scores from -5 to 40 only are expected)"],
            "data": {
              "uri": "http://edamontology.org/format_3608"
            },
            "definition": "FASTQ format subset for Phred sequencing quality score data only (no sequences) for Solexa/Illumina 1.0 format.",
            "text": "qualsolexa"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3611"
            },
            "definition": "FASTQ format subset for Phred sequencing quality score data only (no sequences) from 454 sequencers.",
            "text": "qual454"
          }],
          "comment": ["Phred quality scores  are defined as a property which is logarithmically related to the base-calling error probabilities."],
          "data": {
            "uri": "http://edamontology.org/format_3607"
          },
          "definition": "FASTQ format subset for Phred sequencing quality score data only (no sequences).",
          "text": "qual"
        }],
        "data": {
          "uri": "http://edamontology.org/format_3606"
        },
        "definition": "Textual report format for sequence quality for reports from sequencing machines.",
        "is_format_of": ["http://edamontology.org/data_2048"],
        "text": "Sequence quality report format (text)"
      }, {
        "children": [{
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_1434"
            },
            "definition": "Format of PHYLIP cliques data.",
            "text": "Phylip cliques format"
          }],
          "data": {
            "uri": "http://edamontology.org/format_2039"
          },
          "definition": "Format of phylogenetic cliques data.",
          "is_format_of": ["http://edamontology.org/data_1428"],
          "text": "Phylogenetic tree report (cliques) format"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_1432"
            },
            "definition": "PHYLIP file format for phylogenetics character frequency data.",
            "text": "Phylip character frequencies format"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1430"
            },
            "definition": "PHYLIP file format for continuous quantitative character data.",
            "text": "Phylip continuous quantitative characters"
          }],
          "data": {
            "uri": "http://edamontology.org/format_2037"
          },
          "definition": "Format of phylogenetic continuous quantitative character data.",
          "is_format_of": ["http://edamontology.org/data_1426"],
          "text": "Phylogenetic continuous quantitative character format"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_2040"
          },
          "definition": "Format of phylogenetic invariants data.",
          "is_format_of": ["http://edamontology.org/data_1429"],
          "text": "Phylogenetic tree report (invariants) format"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_1433"
            },
            "definition": "Format of PHYLIP discrete states data.",
            "text": "Phylip discrete states format"
          }],
          "data": {
            "uri": "http://edamontology.org/format_2038"
          },
          "definition": "Format of phylogenetic discrete states data.",
          "is_format_of": ["http://edamontology.org/data_1427"],
          "text": "Phylogenetic discrete states format"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2036"
        },
        "definition": "Format of raw (unplotted) phylogenetic data.",
        "is_format_of": ["http://edamontology.org/data_0871"],
        "text": "Phylogenetic character data format"
      }, {
        "children": [{
          "children": [{
            "comment": ["It is basically a translation of the ASCII atom coordinate format to binary code. The only additional information stored is a magic number that identifies the BinPos format and the number of atoms per snapshot. The remainder is the chain of coordinates binary encoded. A drawback of this format is its architecture dependency. Integers and floats codification depends on the architecture, thus it needs to be converted if working in different platforms (little endian, big endian)."],
            "data": {
              "uri": "http://edamontology.org/format_3885"
            },
            "definition": "Scripps Research Institute BinPos format is a binary formatted file to store atom coordinates.",
            "exact_synonyms": ["Scripps Research Institute BinPos"],
            "text": "BinPos"
          }, {
            "comment": ["Fully architecture-independent format, regarding both endianness and the ability to mix single/double precision trajectories and I/O libraries. Self-sufficient, it should not require any other files for reading, and all the data should be contained in a single file for easy transport. Temporal compression of data, improving the compression rate of the previous XTC format. Possibility to store meta-data with information about the simulation. Direct access to a particular frame. Efficient parallel I/O."],
            "data": {
              "uri": "http://edamontology.org/format_3876"
            },
            "definition": "Trajectory Next Generation (TNG) is a format for storage of molecular simulation data. It is designed and implemented by the GROMACS development group, and it is called to be the substitute of the XTC format.",
            "exact_synonyms": ["Trajectory Next Generation format"],
            "text": "TNG"
          }, {
            "comment": ["The compression is made projecting the Cartesian snapshots collected along the trajectory into an orthogonal space defined by the most relevant eigenvectors obtained by diagonalization of the covariance matrix (PCA). In the compression/decompression process, part of the original information is lost, depending on the final number of eigenvectors chosen. However, with a reasonable choice of the set of eigenvectors the compression typically reduces the trajectory file to less than one tenth of their original size with very acceptable loss of information. Compression with PCAZip can only be applied to unsolvated structures."],
            "data": {
              "uri": "http://edamontology.org/format_3874"
            },
            "definition": "PCAZip format is a binary compressed file to store atom coordinates based on Essential Dynamics (ED) and Principal Component Analysis (PCA).",
            "text": "PCAzip"
          }, {
            "comment": ["HDF is currently supported by many commercial and non-commercial software platforms such as Java, MATLAB/Scilab, Octave, Python and R."],
            "data": {
              "uri": "http://edamontology.org/format_3873"
            },
            "definition": "HDF is the name of a set of file formats and libraries designed to store and organize large amounts of numerical data, originally developed at the National Center for Supercomputing Applications at the University of Illinois.",
            "text": "HDF"
          }, {
            "comment": ["XTC uses the External Data Representation (xdr) routines for writing and reading data which were created for the Unix Network File System (NFS). XTC files use a reduced precision (lossy) algorithm which works multiplying the coordinates by a scaling factor (typically 1000), so converting them to pm (GROMACS standard distance unit is nm). This allows an integer rounding of the values. Several other tricks are performed, such as making use of atom proximity information: atoms close in sequence are usually close in space (e.g. water molecules). That makes XTC format the most efficient in terms of disk usage, in most cases reducing by a factor of 2 the size of any other binary trajectory format."],
            "data": {
              "uri": "http://edamontology.org/format_3875"
            },
            "definition": "Portable binary format for trajectories produced by GROMACS package.",
            "text": "XTC"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/format_3913"
              },
              "definition": "The Loom file format is based on HDF5, a standard for storing large numerical datasets. The Loom format is designed to efficiently hold large omics datasets. Typically, such data takes the form of a large matrix of numbers, along with metadata for the rows and columns.",
              "is_format_of": ["http://edamontology.org/data_2535", "http://edamontology.org/data_3112"],
              "text": "Loom"
            }],
            "comment": ["HDF5 is the new version, according to the HDF group, a completely different technology (https://support.hdfgroup.org/products/hdf4/ compared to HDF.", "An HDF5 file appears to the user as a directed graph. The nodes of this graph are the higher-level HDF5 objects that are exposed by the HDF5 APIs: Groups, Datasets, Named datatypes. Currently supported by the Python MDTraj package."],
            "data": {
              "uri": "http://edamontology.org/format_3590"
            },
            "definition": "HDF5 is a data model, library, and file format for storing and managing data, based on Hierarchical Data Format (HDF).",
            "exact_synonyms": ["h5"],
            "text": "HDF5"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3650"
            },
            "definition": "Format used by netCDF software  library for writing and reading chromatography-MS data files.  Also used to store trajectory atom coordinates information, such as the ones obtained by Molecular Dynamics simulations.",
            "exact_synonyms": ["ANDI-MS"],
            "text": "netCDF"
          }],
          "data": {
            "uri": "http://edamontology.org/format_3867"
          },
          "definition": "Binary file format to store trajectory information for a 3D structure .",
          "text": "Trajectory format (binary)"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_3910"
            },
            "definition": "Format of trr files that contain the trajectory of a simulation experiment used by GROMACS.",
            "text": "trr"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3886"
            },
            "definition": "AMBER coordinate/restart file with 6 coordinates per line and decimal format F12.7 (fixed point notation with field width 12 and 7 decimal places)",
            "exact_synonyms": ["restrt", "rst7"],
            "text": "RST"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3878"
            },
            "definition": "AMBER trajectory (also called mdcrd), with 10 coordinates per line and format F8.3 (fixed point notation with field width 8 and 3 decimal places).",
            "exact_synonyms": ["inpcrd", "AMBER trajectory format"],
            "text": "mdcrd"
          }, {
            "comment": ["XYZ files are structured in this way:  First line contains the number of atoms in the file.  Second line contains a title, comment, or filename. Remaining lines contain atom information. Each line starts with the element symbol, followed by x, y and z coordinates in angstroms separated by whitespace. Multiple molecules or frames can be contained within one file, so it supports trajectory storage. XYZ files can be directly represented by a molecular viewer, as they contain all the basic information needed to build the 3D model."],
            "data": {
              "uri": "http://edamontology.org/format_3877"
            },
            "definition": "The XYZ chemical file format is widely supported by many programs, although many slightly different XYZ file formats coexist (Tinker XYZ, UniChem XYZ, etc.). Basic information stored for each atom in the system are x, y and z coordinates and atom element/atomic number.",
            "text": "XYZ"
          }],
          "data": {
            "uri": "http://edamontology.org/format_3868"
          },
          "definition": "Textual file format to store trajectory information for a 3D structure .",
          "text": "Trajectory format (text)"
        }],
        "comment": ["Formats differ on what they are able to store (coordinates, velocities, topologies) and how they are storing it (raw, compressed, textual, binary)."],
        "data": {
          "uri": "http://edamontology.org/format_3866"
        },
        "definition": "File format to store trajectory information for a 3D structure .",
        "is_format_of": ["http://edamontology.org/data_3870"],
        "narrow_synonyms": ["CG trajectory formats", "MD trajectory formats", "Protein trajectory formats", "NA trajectory formats"],
        "text": "Trajectory format"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_1627"
          },
          "definition": "Report format on PCR primers and hybridisation oligos as generated by Whitehead primer3 program.",
          "text": "Primer3 primer"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2061"
        },
        "definition": "Format of a report on PCR primers or hybridisation oligos in a nucleic acid sequence.",
        "text": "Nucleic acid features (primers) format"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_2352"
          },
          "definition": "BioXSD-schema-based XML format of sequence-based data and some other common data - sequence records, alignments, feature records, references to resources, and more - optimised for integrative bioinformatics, Web services, and object-oriented programming.",
          "exact_synonyms": ["BioXSD XML", "BioXSD+XML", "BioXSD XML format", "BioXSD in XML", "BioXSD in XML format"],
          "is_format_of": ["http://edamontology.org/data_1772", "http://edamontology.org/data_1255", "http://edamontology.org/data_3108", "http://edamontology.org/data_0863", "http://edamontology.org/data_2044"],
          "text": "BioXSD (XML)"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_3826"
            },
            "definition": ". proBAM is an adaptation of BAM (format_2572), which was extended to meet specific requirements entailed by proteomics data.",
            "text": "proBAM"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1628"
            },
            "definition": "A format of raw sequence read data from an Applied Biosystems sequencing machine.",
            "text": "ABI"
          }, {
            "comment": ["The format supports short and long reads (up to 128Mbp) produced by different sequencing platforms and is used to hold mapped data within the GATK and across the Broad Institute, the Sanger Centre, and throughout the 1000 Genomes project."],
            "data": {
              "uri": "http://edamontology.org/format_2573"
            },
            "definition": "Sequence Alignment/Map (SAM) format for alignment of nucleotide sequences (e.g. sequencing reads) to (a) reference sequence(s). May contain base-call and alignment qualities and other data.",
            "text": "SAM"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3017"
            },
            "definition": "Sequence Read Format (SRF) of sequence trace data. Supports submission to the NCBI Short Read Archive.",
            "text": "SRF"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3284"
            },
            "definition": "Standard flowgram format (SFF) is a binary file format used to encode results of pyrosequencing from the 454 Life Sciences platform for high-throughput sequencing.",
            "exact_synonyms": ["Standard flowgram format"],
            "text": "SFF"
          }, {
            "comment": ["AB1 uses the generic binary Applied Biosystems, Inc. Format (ABIF)."],
            "data": {
              "uri": "http://edamontology.org/format_3000"
            },
            "definition": "AB1 binary format of raw DNA sequence reads (output of Applied Biosystems' sequencing analysis software). Contains an electropherogram and the DNA base sequence.",
            "text": "AB1"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3018"
            },
            "definition": "ZTR format for storing chromatogram data from DNA sequencing instruments.",
            "text": "ZTR"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_2572"
            },
            "definition": "BAM format, the binary, BGZF-formatted compressed version of SAM format for alignment of nucleotide sequences (e.g. sequencing reads) to (a) reference sequence(s). May contain base-call and alignment qualities and other data.",
            "text": "BAM"
          }, {
            "children": [{
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/format_1932"
                },
                "definition": "FASTQ short read format with phred quality.",
                "text": "FASTQ-sanger"
              }, {
                "children": [{
                  "comment": ["Solexa/Illumina 1.0 format can encode a Solexa/Illumina quality score from -5 to 62 using ASCII 59 to 126 (although in raw read data Solexa scores from -5 to 40 only are expected)"],
                  "data": {
                    "uri": "http://edamontology.org/format_3608"
                  },
                  "definition": "FASTQ format subset for Phred sequencing quality score data only (no sequences) for Solexa/Illumina 1.0 format.",
                  "text": "qualsolexa"
                }],
                "data": {
                  "uri": "http://edamontology.org/format_1933"
                },
                "definition": "FASTQ Solexa/Illumina 1.0 short read format.",
                "text": "FASTQ-solexa"
              }, {
                "children": [{
                  "comment": ["For SOLiD data, the sequence is in color space, except the first position. The quality values are those of the Sanger format."],
                  "data": {
                    "uri": "http://edamontology.org/format_3610"
                  },
                  "definition": "FASTQ format subset for Phred sequencing quality score data only (no sequences) for SOLiD data.",
                  "text": "qualsolid"
                }, {
                  "comment": ["Starting in Illumina 1.5 and before Illumina 1.8, the Phred scores 0 to 2 have a slightly different meaning. The values 0 and 1 are no longer used and the value 2, encoded by ASCII 66 \"B\", is used also at the end of reads as a Read Segment Quality Control Indicator."],
                  "data": {
                    "uri": "http://edamontology.org/format_3609"
                  },
                  "definition": "FASTQ format subset for Phred sequencing quality score data only (no sequences) from Illumina 1.5 and before Illumina 1.8.",
                  "text": "qualillumina"
                }, {
                  "comment": ["Solexa/Illumina 1.0 format can encode a Solexa/Illumina quality score from -5 to 62 using ASCII 59 to 126 (although in raw read data Solexa scores from -5 to 40 only are expected)"],
                  "data": {
                    "uri": "http://edamontology.org/format_3608"
                  },
                  "definition": "FASTQ format subset for Phred sequencing quality score data only (no sequences) for Solexa/Illumina 1.0 format.",
                  "text": "qualsolexa"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/format_3611"
                  },
                  "definition": "FASTQ format subset for Phred sequencing quality score data only (no sequences) from 454 sequencers.",
                  "text": "qual454"
                }],
                "comment": ["Phred quality scores  are defined as a property which is logarithmically related to the base-calling error probabilities."],
                "data": {
                  "uri": "http://edamontology.org/format_3607"
                },
                "definition": "FASTQ format subset for Phred sequencing quality score data only (no sequences).",
                "text": "qual"
              }, {
                "children": [{
                  "comment": ["Starting in Illumina 1.5 and before Illumina 1.8, the Phred scores 0 to 2 have a slightly different meaning. The values 0 and 1 are no longer used and the value 2, encoded by ASCII 66 \"B\", is used also at the end of reads as a Read Segment Quality Control Indicator."],
                  "data": {
                    "uri": "http://edamontology.org/format_3609"
                  },
                  "definition": "FASTQ format subset for Phred sequencing quality score data only (no sequences) from Illumina 1.5 and before Illumina 1.8.",
                  "text": "qualillumina"
                }],
                "data": {
                  "uri": "http://edamontology.org/format_1931"
                },
                "definition": "FASTQ Illumina 1.3 short read format.",
                "text": "FASTQ-illumina"
              }, {
                "data": {
                  "uri": "http://edamontology.org/format_1930"
                },
                "definition": "FASTQ short read format ignoring quality scores.",
                "exact_synonyms": ["FASTAQ", "fq"],
                "text": "FASTQ"
              }],
              "comment": ["This concept may be used for non-standard FASTQ short read-like formats."],
              "data": {
                "uri": "http://edamontology.org/format_2182"
              },
              "definition": "A text format resembling FASTQ short read format.",
              "text": "FASTQ-like format (text)"
            }],
            "comment": ["This concept may be used for non-standard FASTQ short read-like formats."],
            "data": {
              "uri": "http://edamontology.org/format_2545"
            },
            "definition": "A format resembling FASTQ short read format.",
            "text": "FASTQ-like format"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1629"
            },
            "definition": "Format of MIRA sequence trace information file.",
            "text": "mira"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1633"
            },
            "definition": "PHD sequence trace format to store serialised chromatogram data (reads).",
            "text": "PHD"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1632"
            },
            "definition": "Staden Chromatogram Files format (SCF) of base-called sequence reads, qualities, and other metadata.",
            "text": "SCF"
          }],
          "data": {
            "uri": "http://edamontology.org/format_2057"
          },
          "definition": "Format for sequence trace data (i.e. including base call information).",
          "is_format_of": ["http://edamontology.org/data_0924"],
          "text": "Sequence trace format"
        }, {
          "children": [{
            "children": [{
              "data": {
                "uri": "http://edamontology.org/format_1927"
              },
              "definition": "EMBL entry format.",
              "exact_synonyms": ["EMBL", "EMBL sequence format"],
              "text": "EMBL format"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_2186"
              },
              "definition": "Geneseq sequence format.",
              "text": "geneseq"
            }],
            "comment": ["This concept may be used for the many non-standard EMBL-like text formats."],
            "data": {
              "uri": "http://edamontology.org/format_2181"
            },
            "definition": "A text format resembling EMBL entry format.",
            "text": "EMBL-like (text)"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_2311"
            },
            "definition": "EMBL entry format wrapped in HTML elements.",
            "text": "EMBL-HTML"
          }, {
            "children": [{
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/format_2185"
                },
                "definition": "XML format for EMBL entries.",
                "text": "insdxml"
              }, {
                "data": {
                  "uri": "http://edamontology.org/format_2184"
                },
                "definition": "XML format for EMBL entries.",
                "text": "cdsxml"
              }, {
                "data": {
                  "uri": "http://edamontology.org/format_2183"
                },
                "definition": "XML format for EMBL entries.",
                "text": "EMBLXML"
              }],
              "comment": ["This is a placeholder for other more specific concepts. It should not normally be used for annotation."],
              "data": {
                "uri": "http://edamontology.org/format_2204"
              },
              "definition": "An XML format for EMBL entries.",
              "text": "EMBL format (XML)"
            }],
            "comment": ["This concept may be used for the any non-standard EMBL-like XML formats."],
            "data": {
              "uri": "http://edamontology.org/format_2558"
            },
            "definition": "An XML format resembling EMBL entry format.",
            "text": "EMBL-like (XML)"
          }],
          "comment": ["This concept may be used for the many non-standard EMBL-like formats."],
          "data": {
            "uri": "http://edamontology.org/format_2543"
          },
          "definition": "A format resembling EMBL entry (plain text) format.",
          "text": "EMBL-like format"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3773"
          },
          "definition": "BioYAML is a BioXSD-schema-based YAML format of sequence-based data and some other common data - sequence records, alignments, feature records, references to resources, and more - optimised for integrative bioinformatics, web APIs, human readability and editting, and object-oriented programming.",
          "exact_synonyms": ["BioYAML format", "BioXSD YAML format", "BioYAML format (BioXSD)", "BioXSD in YAML format", "BioXSD BioYAML format", "BioYAML (BioXSD data model)", "BioXSD|BioJSON|BioYAML BioYAML", "BioXSD YAML", "BioXSD|GTrack BioYAML", "BioXSD/GTrack BioYAML", "BioXSD in YAML", "BioXSD BioYAML", "BioYAML (BioXSD)", "BioXSD+YAML"],
          "is_format_of": ["http://edamontology.org/data_0863", "http://edamontology.org/data_1255", "http://edamontology.org/data_1772", "http://edamontology.org/data_3108", "http://edamontology.org/data_2044"],
          "text": "BioYAML"
        }, {
          "children": [{
            "children": [{
              "data": {
                "uri": "http://edamontology.org/format_1963"
              },
              "definition": "UniProtKB entry sequence format.",
              "exact_synonyms": ["SwissProt format", "UniProt format"],
              "text": "UniProtKB format"
            }],
            "data": {
              "uri": "http://edamontology.org/format_2187"
            },
            "definition": "A text sequence format resembling uniprotkb entry format.",
            "text": "UniProt-like (text)"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3770"
            },
            "definition": "UniProtKB XML sequence features format is an XML format available for downloading UniProt entries.",
            "exact_synonyms": ["UniProtKB XML format", "UniProt XML format", "UniProt XML"],
            "text": "UniProtKB XML"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3771"
            },
            "definition": "UniProtKB RDF sequence features format is an RDF format available for downloading UniProt entries (in RDF/XML).",
            "exact_synonyms": ["UniProt RDF format", "UniProtKB RDF format", "UniProt RDF"],
            "narrow_synonyms": ["UniProt RDF/XML", "UniProtKB RDF/XML format", "UniProtKB RDF/XML", "UniProt RDF/XML format"],
            "text": "UniProtKB RDF"
          }],
          "data": {
            "uri": "http://edamontology.org/format_2547"
          },
          "definition": "A sequence format resembling uniprotkb entry format.",
          "text": "uniprotkb-like format"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_2310"
            },
            "definition": "FASTA format wrapped in HTML elements.",
            "text": "FASTA-HTML"
          }, {
            "children": [{
              "comment": ["There are several variants of this."],
              "data": {
                "uri": "http://edamontology.org/format_1972"
              },
              "definition": "NCBI FASTA sequence format with NCBI-style IDs.",
              "text": "NCBI format"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_1926"
              },
              "definition": "Fasta format variant with database name before ID.",
              "text": "dbid"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_1954"
              },
              "definition": "Plain old FASTA sequence format (unspecified format for IDs).",
              "text": "Pearson format"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_3281"
              },
              "definition": "The A2M format is used as the primary format for multiple alignments of protein or nucleic-acid sequences in the SAM suite of tools. It is a small modification of FASTA format for sequences and is compatible with most tools that read FASTA.",
              "text": "A2M"
            }, {
              "comment": ["FASTA format extended for color space information."],
              "data": {
                "uri": "http://edamontology.org/format_3589"
              },
              "definition": "Color space FASTA format sequence variant.",
              "text": "csfasta"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_1940"
              },
              "definition": "FASTA sequence format including NCBI-style GIs.",
              "text": "giFASTA format"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_1929"
              },
              "definition": "FASTA format including NCBI-style IDs.",
              "exact_synonyms": ["FASTA sequence format", "FASTA format"],
              "text": "FASTA"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_1391"
              },
              "definition": "FASTA-style format for multiple sequences aligned by HMMER package to an HMM.",
              "text": "HMMER-aln"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_1984"
              },
              "definition": "Fasta format for (aligned) sequences.",
              "text": "FASTA-aln"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_3811"
              },
              "definition": "The A2M format is used as the primary format for multiple alignments of protein or nucleic-acid sequences in the SAM suite of tools. It is a small modification of FASTA format for sequences and is compatible with most tools that read FASTA.",
              "exact_synonyms": ["eXtended Multi-FastA format", "alignment format"],
              "text": "XMFA"
            }],
            "comment": ["This concept may also be used for the many non-standard FASTA-like formats."],
            "data": {
              "uri": "http://edamontology.org/format_2200"
            },
            "definition": "A text format resembling FASTA format.",
            "text": "FASTA-like (text)"
          }],
          "comment": ["This concept may be used for the many non-standard FASTA-like formats."],
          "data": {
            "uri": "http://edamontology.org/format_2546"
          },
          "definition": "A format resembling FASTA format.",
          "text": "FASTA-like"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_3844"
            },
            "definition": "Chado-XML format is a direct mapping of the Chado relational schema into XML.",
            "text": "Chado-XML"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3843"
            },
            "definition": "XML input file format for BEAST Software (Bayesian Evolutionary Analysis Sampling Trees).",
            "text": "BEAST"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3852"
            },
            "definition": "SeqXML is an XML Schema to describe biological sequences, developed by the Stockholm Bioinformatics Centre.",
            "text": "SeqXML"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3850"
            },
            "definition": "OrthoXML is designed broadly to allow the storage and comparison of orthology data from any ortholog database. It establishes a structure for describing orthology relationships while still allowing flexibility for database-specific information to be encapsulated in the same format.",
            "text": "OrthoXML"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1967"
            },
            "definition": "DAS sequence (XML) format (any type).",
            "exact_synonyms": ["das sequence format"],
            "text": "DAS format"
          }, {
            "comment": ["The use of this format is deprecated."],
            "data": {
              "uri": "http://edamontology.org/format_1968"
            },
            "definition": "DAS sequence (XML) format (nucleotide-only).",
            "text": "dasdna"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3770"
            },
            "definition": "UniProtKB XML sequence features format is an XML format available for downloading UniProt entries.",
            "exact_synonyms": ["UniProtKB XML format", "UniProt XML format", "UniProt XML"],
            "text": "UniProtKB XML"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3487"
            },
            "definition": "Bioinformatics Sequence Markup Language format.",
            "text": "BSML"
          }],
          "data": {
            "uri": "http://edamontology.org/format_2552"
          },
          "definition": "Data format for a molecular sequence record.",
          "text": "Sequence record format (XML)"
        }, {
          "children": [{
            "comment": ["pdbnuc format in EMBOSS."],
            "data": {
              "uri": "http://edamontology.org/format_1951"
            },
            "definition": "PDB nucleotide sequence format (ATOM lines).",
            "text": "pdbatomnuc"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1946"
            },
            "definition": "Mega interleaved and non-interleaved sequence format.",
            "text": "mega-seq"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1969"
            },
            "definition": "EMBOSS debugging trace sequence format of full internal data content.",
            "text": "debug-seq"
          }, {
            "comment": ["pdbseq format in EMBOSS."],
            "data": {
              "uri": "http://edamontology.org/format_1953"
            },
            "definition": "PDB sequence format (SEQRES lines).",
            "text": "pdbseqres"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/format_1991"
              },
              "definition": "Mega format for (typically aligned) sequences.",
              "text": "mega"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_1992"
              },
              "definition": "Mega non-interleaved format for (typically aligned) sequences.",
              "text": "meganon"
            }],
            "data": {
              "uri": "http://edamontology.org/format_2923"
            },
            "definition": "Some variant of Mega format for (typically aligned) sequences.",
            "text": "mega variant"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1966"
            },
            "definition": "NCBI ASN.1-based sequence format.",
            "text": "ASN.1 sequence format"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_2005"
            },
            "definition": "Treecon format for (aligned) sequences.",
            "text": "TreeCon-seq"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3312"
            },
            "definition": "Format for the Genetic Data Environment (GDE).",
            "text": "GDE"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1945"
            },
            "definition": "Mase program sequence format.",
            "text": "mase format"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1928"
            },
            "definition": "Staden experiment file format.",
            "text": "Staden experiment format"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1938"
            },
            "definition": "GFF feature file format with sequence in the header.",
            "text": "GFF2-seq"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1939"
            },
            "definition": "GFF3 feature file format with sequence.",
            "text": "GFF3-seq"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1970"
            },
            "definition": "Jackknifer output sequence non-interleaved format.",
            "text": "jackknifernon"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1943"
            },
            "definition": "Intelligenetics sequence format (strict version).",
            "text": "igstrict"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1925"
            },
            "definition": "Codata entry format.",
            "text": "codata"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3978"
            },
            "definition": "The CONTIG format used for output of the SOAPdenovo alignment program. It contains contig sequences generated without using mate pair information.",
            "text": "CONTIG"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1941"
            },
            "definition": "Hennig86 output sequence format.",
            "text": "hennig86"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1934"
            },
            "definition": "Fitch program format.",
            "text": "fitch program"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1960"
            },
            "definition": "Staden suite sequence format.",
            "text": "Staden format"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_2000"
            },
            "definition": "SELEX format for (aligned) sequences.",
            "text": "selex"
          }, {
            "children": [{
              "comment": ["GCG SSF (single sequence file) file format."],
              "data": {
                "uri": "http://edamontology.org/format_1935"
              },
              "definition": "GCG sequence file format.",
              "exact_synonyms": ["GCG SSF"],
              "text": "GCG"
            }, {
              "comment": ["RSF-format files contain one or more sequences that may or may not be related. In addition to the sequence data, each sequence can be annotated with descriptive sequence information (from the GCG manual)."],
              "data": {
                "uri": "http://edamontology.org/format_3485"
              },
              "definition": "Rich sequence format.",
              "exact_synonyms": ["GCG RSF"],
              "text": "RSF"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_1947"
              },
              "definition": "GCG MSF (multiple sequence file) file format.",
              "text": "GCG MSF"
            }],
            "data": {
              "uri": "http://edamontology.org/format_3486"
            },
            "definition": "Some format based on the GCG format.",
            "text": "GCG format variant"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1923"
            },
            "definition": "ACEDB sequence format.",
            "text": "acedb"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1973"
            },
            "definition": "Nexus/paup non-interleaved sequence format.",
            "text": "nexusnon"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1962"
            },
            "definition": "DNA strider output sequence format.",
            "text": "strider format"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1944"
            },
            "definition": "Jackknifer interleaved and non-interleaved sequence format.",
            "text": "jackknifer"
          }, {
            "comment": ["pdb format in EMBOSS."],
            "data": {
              "uri": "http://edamontology.org/format_1950"
            },
            "definition": "PDB sequence format (ATOM lines).",
            "text": "pdbatom"
          }, {
            "children": [{
              "comment": ["It differs from Phylip sequential format (format_1997) on length of the ID sequence. There no length restrictions on the ID, but whitespaces aren't allowed in the sequence ID/Name because one space separates the longest ID and the beginning of the sequence. Sequences IDs must be padded to the longest ID length."],
              "data": {
                "uri": "http://edamontology.org/format_3820"
              },
              "definition": "Phylip multiple alignment sequence format, less stringent than PHYLIP sequential format (format_1998).",
              "exact_synonyms": ["Relaxed PHYLIP sequential format", "Relaxed PHYLIP non-interleaved", "Relaxed PHYLIP non-interleaved format"],
              "text": "Relaxed PHYLIP Sequential"
            }, {
              "comment": ["It differs from Phylip Format (format_1997) on length of the ID sequence. There no length restrictions on the ID, but whitespaces aren't allowed in the sequence ID/Name because one space separates the longest ID and the beginning of the sequence. Sequences IDs must be padded to the longest ID length."],
              "data": {
                "uri": "http://edamontology.org/format_3819"
              },
              "definition": "Phylip multiple alignment sequence format, less stringent than PHYLIP format.",
              "exact_synonyms": ["PHYLIP Interleaved format"],
              "text": "Relaxed PHYLIP Interleaved"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_1997"
              },
              "definition": "Phylip format for (aligned) sequences.",
              "exact_synonyms": ["PHYLIP", "phy", "PHYLIP interleaved format", "ph"],
              "text": "PHYLIP format"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_1998"
              },
              "definition": "Phylip non-interleaved format for (aligned) sequences.",
              "exact_synonyms": ["PHYLIP sequential format", "phylipnon"],
              "text": "PHYLIP sequential"
            }],
            "data": {
              "uri": "http://edamontology.org/format_2924"
            },
            "definition": "Some variant of Phylip format for (aligned) sequences.",
            "text": "Phylip format variant"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1942"
            },
            "definition": "Intelligenetics sequence format.",
            "text": "ig"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1949"
            },
            "definition": "Nexus/paup interleaved sequence format.",
            "text": "nexus-seq"
          }, {
            "comment": ["Currently identical to genpept format"],
            "data": {
              "uri": "http://edamontology.org/format_1958"
            },
            "definition": "Refseq protein entry sequence format.",
            "text": "refseqp"
          }, {
            "comment": ["pdbnucseq format in EMBOSS."],
            "data": {
              "uri": "http://edamontology.org/format_1952"
            },
            "definition": "PDB nucleotide sequence format (SEQRES lines).",
            "text": "pdbseqresnuc"
          }],
          "data": {
            "uri": "http://edamontology.org/format_2551"
          },
          "definition": "Data format for a molecular sequence record.",
          "text": "Sequence record format (text)"
        }, {
          "children": [{
            "children": [{
              "data": {
                "uri": "http://edamontology.org/format_1936"
              },
              "definition": "Genbank entry format.",
              "exact_synonyms": ["GenBank"],
              "text": "GenBank format"
            }, {
              "comment": ["Currently identical to refseqp format"],
              "data": {
                "uri": "http://edamontology.org/format_1937"
              },
              "definition": "Genpept protein entry format.",
              "text": "genpept"
            }],
            "comment": ["This concept may be used for the non-standard GenBank-like text formats."],
            "data": {
              "uri": "http://edamontology.org/format_2205"
            },
            "definition": "A text format resembling GenBank entry (plain text) format.",
            "text": "GenBank-like format (text)"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_2532"
            },
            "definition": "Genbank entry format wrapped in HTML elements.",
            "text": "GenBank-HTML"
          }],
          "comment": ["This concept may be used for the non-standard GenBank-like formats."],
          "data": {
            "uri": "http://edamontology.org/format_2559"
          },
          "definition": "A format resembling GenBank entry (plain text) format.",
          "text": "GenBank-like format"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3772"
          },
          "definition": "BioJSON is a BioXSD-schema-based JSON format of sequence-based data and some other common data - sequence records, alignments, feature records, references to resources, and more - optimised for integrative bioinformatics, web applications and APIs, and object-oriented programming.",
          "exact_synonyms": ["BioXSD BioJSON", "BioXSD+JSON", "BioXSD BioJSON format", "BioXSD in JSON", "BioXSD in JSON format", "BioXSD|GTrack BioJSON", "BioXSD JSON", "BioJSON format (BioXSD)", "BioXSD|BioJSON|BioYAML BioJSON", "BioJSON (BioXSD data model)", "BioXSD/GTrack BioJSON", "BioXSD JSON format"],
          "is_format_of": ["http://edamontology.org/data_2044", "http://edamontology.org/data_1772", "http://edamontology.org/data_0863", "http://edamontology.org/data_3108", "http://edamontology.org/data_1255"],
          "text": "BioJSON (BioXSD)"
        }],
        "data": {
          "uri": "http://edamontology.org/format_1919"
        },
        "definition": "Data format for a molecular sequence record.",
        "is_format_of": ["http://edamontology.org/data_0849"],
        "text": "Sequence record format"
      }, {
        "children": [{
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_3784"
            },
            "definition": "A format of text annotation using the linked-data Open Annotation Data Model, serialised typically in RDF or JSON-LD.",
            "text": "Open Annotation format"
          }],
          "data": {
            "uri": "http://edamontology.org/format_3749"
          },
          "definition": "JSON-LD, or JavaScript Object Notation for Linked Data, is a method of encoding Linked Data using JSON.",
          "exact_synonyms": ["JavaScript Object Notation for Linked Data"],
          "text": "JSON-LD"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_3784"
            },
            "definition": "A format of text annotation using the linked-data Open Annotation Data Model, serialised typically in RDF or JSON-LD.",
            "text": "Open Annotation format"
          }, {
            "comment": ["RDF/XML is a serialisation syntax for OWL DL, but not for OWL Full."],
            "data": {
              "uri": "http://edamontology.org/format_3261"
            },
            "definition": "Resource Description Framework (RDF) XML format.",
            "text": "RDF/XML"
          }, {
            "comment": ["The SPARQL Query Language incorporates a very similar syntax."],
            "data": {
              "uri": "http://edamontology.org/format_3255"
            },
            "definition": "The Terse RDF Triple Language (Turtle) is a human-friendly serialisation format for RDF (Resource Description Framework) graphs.",
            "text": "Turtle"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3257"
            },
            "definition": "A shorthand non-XML serialisation of Resource Description Framework model, designed with human-readability in mind.",
            "exact_synonyms": ["N3"],
            "text": "Notation3"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/format_3262"
              },
              "definition": "OWL ontology XML serialisation format.",
              "narrow_synonyms": ["OWL"],
              "text": "OWL/XML"
            }, {
              "comment": ["This format was influenced by the OWL Abstract Syntax and the DL style syntax."],
              "data": {
                "uri": "http://edamontology.org/format_3253"
              },
              "definition": "A syntax for writing OWL class expressions.",
              "text": "Manchester OWL Syntax"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_3252"
              },
              "definition": "A human-readable encoding for the Web Ontology Language (OWL).",
              "text": "OWL Functional Syntax"
            }],
            "data": {
              "uri": "http://edamontology.org/format_2197"
            },
            "definition": "A serialisation format conforming to the Web Ontology Language (OWL) model.",
            "text": "OWL format"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/format_3784"
              },
              "definition": "A format of text annotation using the linked-data Open Annotation Data Model, serialised typically in RDF or JSON-LD.",
              "text": "Open Annotation format"
            }],
            "data": {
              "uri": "http://edamontology.org/format_3749"
            },
            "definition": "JSON-LD, or JavaScript Object Notation for Linked Data, is a method of encoding Linked Data using JSON.",
            "exact_synonyms": ["JavaScript Object Notation for Linked Data"],
            "text": "JSON-LD"
          }, {
            "comment": ["N-Triples should not be confused with Notation 3 which is a superset of Turtle."],
            "data": {
              "uri": "http://edamontology.org/format_3256"
            },
            "definition": "A plain text serialisation format for RDF (Resource Description Framework) graphs, and a subset of the Turtle (Terse RDF Triple Language) format.",
            "text": "N-Triples"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3771"
            },
            "definition": "UniProtKB RDF sequence features format is an RDF format available for downloading UniProt entries (in RDF/XML).",
            "exact_synonyms": ["UniProt RDF format", "UniProtKB RDF format", "UniProt RDF"],
            "narrow_synonyms": ["UniProt RDF/XML", "UniProtKB RDF/XML format", "UniProtKB RDF/XML", "UniProt RDF/XML format"],
            "text": "UniProtKB RDF"
          }, {
            "comment": ["N-Quads should not be confused with N-Triples which does not contain graph information."],
            "data": {
              "uri": "http://edamontology.org/format_3956"
            },
            "definition": "N-Quads is a line-based, plain text format for encoding an RDF dataset. It includes information about the graph each triple belongs to.",
            "text": "N-Quads"
          }],
          "data": {
            "uri": "http://edamontology.org/format_2376"
          },
          "definition": "A serialisation format conforming to the Resource Description Framework (RDF) model.",
          "exact_synonyms": ["Resource Description Framework format"],
          "text": "RDF format"
        }],
        "data": {
          "uri": "http://edamontology.org/format_3748"
        },
        "definition": "A linked data format enables publishing structured data as linked data (Linked Data), so that the data can be interlinked and become more useful through semantic queries.",
        "text": "Linked data format"
      }, {
        "children": [{
          "comment": ["Pcons ranks protein models by assessing their quality based on the occurrence of recurring common three-dimensional structural patterns. Pcons returns a score reflecting the overall global quality and a score for each individual residue in the protein reflecting the local residue quality."],
          "data": {
            "uri": "http://edamontology.org/format_1551"
          },
          "definition": "Format of output of the Pcons Model Quality Assessment Program (MQAP).",
          "text": "Pcons report format"
        }, {
          "comment": ["ProQ is a neural network-based predictor that predicts the quality of a protein model based on the number of structural features."],
          "data": {
            "uri": "http://edamontology.org/format_1552"
          },
          "definition": "Format of output of the ProQ protein model quality predictor.",
          "text": "ProQ report format"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2065"
        },
        "definition": "Format of a report on the quality of a protein three-dimensional model.",
        "is_format_of": ["http://edamontology.org/data_1539"],
        "text": "Protein structure report (quality evaluation) format"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_3240"
          },
          "definition": "CellML, the format for mathematical models of biological and other networks.",
          "text": "CellML"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3156"
          },
          "definition": "BioPAX is an exchange format for pathway data, with its data model defined in OWL.",
          "text": "BioPAX"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3688"
          },
          "definition": "SBtab is a tabular format for biochemical network models.",
          "text": "SBtab"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3239"
          },
          "definition": "CopasiML, the native format of COPASI.",
          "text": "CopasiML"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3619"
          },
          "definition": "SIF (simple interaction file) Format - a network/pathway format used for instance in cytoscape.",
          "text": "sif"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3971"
          },
          "definition": "A model description language for computational neuroscience.",
          "is_format_of": ["http://edamontology.org/data_3241"],
          "text": "NeuroML"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3692"
          },
          "definition": "SBGN-ML is an XML format for Systems Biology Graphical Notation (SBGN) diagrams of biological pathways or networks.",
          "text": "SBGN-ML"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_2585"
          },
          "definition": "Systems Biology Markup Language (SBML), the standard XML format for models of biological processes such as for example metabolism, cell signaling, and gene regulation.",
          "text": "SBML"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3822"
          },
          "definition": "GML (Graph Modeling Language) is a text file format supporting network data with a very easy syntax. It is used by Graphlet, Pajek, yEd, LEDA and NetworkX.",
          "exact_synonyms": ["GML format"],
          "text": "GML"
        }, {
          "comment": ["An OMEX file is a ZIP container that includes a manifest file, listing the content of the archive, an optional metadata file adding information about the archive and its content, and the files describing the model. OMEX is one of the standardised formats within COMBINE (Computational Modeling in Biology Network)."],
          "data": {
            "uri": "http://edamontology.org/format_3686"
          },
          "definition": "Open Modeling EXchange format (OMEX) is a ZIPped format for encapsulating all information necessary for a modeling and simulation project in systems biology.",
          "text": "COMBINE OMEX"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3657"
          },
          "definition": "Graphical Pathway Markup Language (GPML) is an XML format used for exchanging biological pathways.",
          "text": "GPML"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3972"
          },
          "definition": "BioNetGen is a format for the specification and simulation of rule-based models of biochemical systems, including signal transduction, metabolic, and genetic regulatory networks.",
          "exact_synonyms": ["BioNetGen Language"],
          "is_format_of": ["http://edamontology.org/data_3241"],
          "text": "BNGL"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3847"
          },
          "definition": "The KEGG Markup Language (KGML) is an exchange format of the KEGG pathway maps, which is converted from internally used KGML+ (KGML+SVG) format.",
          "exact_synonyms": ["KEGG Markup Language"],
          "text": "KGML"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3821"
          },
          "definition": "Default XML format of VisANT, containing all the network information.",
          "exact_synonyms": ["VisANT xml format", "VisANT xml"],
          "text": "VisML"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3689"
          },
          "definition": "Biological Connection Markup Language (BCML) is an XML format for biological pathways.",
          "text": "BCML"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2013"
        },
        "definition": "Data format for a biological pathway or network.",
        "is_format_of": ["http://edamontology.org/data_2600"],
        "text": "Biological pathway or network format"
      }, {
        "children": [{
          "comment": ["The DSSP database is built using the DSSP application which defines secondary structure, geometrical features and solvent exposure of proteins, given atomic coordinates in PDB format."],
          "data": {
            "uri": "http://edamontology.org/format_1454"
          },
          "definition": "Format of an entry from the DSSP database (Dictionary of Secondary Structure in Proteins).",
          "text": "dssp"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1455"
          },
          "definition": "Entry format of the HSSP database (Homology-derived Secondary Structure in Proteins).",
          "text": "hssp"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2077"
        },
        "definition": "Format for secondary structure (predicted or real) of a protein molecule.",
        "text": "Protein secondary structure format"
      }, {
        "children": [{
          "comment": ["This includes (typically) score data, alignment data and a histogram (of observed and expected distribution of E values.)"],
          "data": {
            "uri": "http://edamontology.org/format_1332"
          },
          "definition": "Format of results of a sequence database search using FASTA.",
          "text": "FASTA search results format"
        }, {
          "comment": ["The hits are relatives to a SCOP or CATH family and are found from a search of a sequence database."],
          "data": {
            "uri": "http://edamontology.org/format_1336"
          },
          "definition": "Format of EMBASSY domain hits file (DHF) of hits (sequences) with domain classification information.",
          "text": "dhf"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1335"
          },
          "definition": "Format of results of a sequence database search using some variant of Smith Waterman.",
          "text": "Smith-Waterman format"
        }, {
          "comment": ["The hits are putative ligand-binding sequences and are found from a search of a sequence database."],
          "data": {
            "uri": "http://edamontology.org/format_1337"
          },
          "definition": "Format of EMBASSY ligand hits file (LHF) of database hits (sequences) with ligand classification information.",
          "text": "lhf"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1334"
          },
          "definition": "Format of results of a sequence database search using some variant of MSPCrunch.",
          "text": "mspcrunch"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3157"
          },
          "definition": "EBI Application Result XML is a format returned by sequence similarity search Web services at EBI.",
          "text": "EBI Application Result XML"
        }, {
          "children": [{
            "comment": ["The table presents matches between query proteins (rows) and signature methods (columns) for this entry. Alternatively the sequence(s) might be from from the InterPro entry itself. The match position in the protein sequence and match status (true positive, false positive etc) are indicated."],
            "data": {
              "uri": "http://edamontology.org/format_1343"
            },
            "definition": "Format of results of a search of the InterPro database showing matches between protein sequence(s) and signatures for an InterPro entry.",
            "text": "InterPro match table format"
          }, {
            "comment": ["The report includes a classification of regions in a query protein sequence which are assigned to a known InterPro protein family or group."],
            "data": {
              "uri": "http://edamontology.org/format_1342"
            },
            "definition": "Format of results of a search of the InterPro database showing matches of query protein sequence(s) to InterPro entries.",
            "text": "InterPro protein view report format"
          }],
          "data": {
            "uri": "http://edamontology.org/format_1341"
          },
          "definition": "Results format for searches of the InterPro database.",
          "text": "InterPro hits format"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_3331"
            },
            "definition": "XML format as produced by the NCBI Blast package",
            "text": "BLAST XML results format"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3836"
            },
            "definition": "XML format as produced by the NCBI Blast package v2.",
            "text": "BLAST XML v2 results format"
          }],
          "comment": ["This includes score data, alignment data and summary table."],
          "data": {
            "uri": "http://edamontology.org/format_1333"
          },
          "definition": "Format of results of a sequence database search using some variant of BLAST.",
          "text": "BLAST results"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2066"
        },
        "definition": "Format of a report on sequence hits and associated data from searching a sequence database.",
        "is_format_of": ["http://edamontology.org/data_0857"],
        "text": "Database hits (sequence) format"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_1351"
          },
          "definition": "Format of a report from the HMMER package on the emission and transition counts of a hidden Markov model.",
          "text": "HMMER emission and transition"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2075"
        },
        "definition": "Data format for the emission and transition counts of a hidden Markov model.",
        "is_format_of": ["http://edamontology.org/data_3355", "http://edamontology.org/data_3354"],
        "text": "HMM emission and transition counts format"
      }, {
        "children": [{
          "comment": ["Differ from .dta only in subtleties of the header line format and content and support the added feature of being able to."],
          "data": {
            "uri": "http://edamontology.org/format_3653"
          },
          "definition": "Spectral data file similar to dta.",
          "text": "pkl"
        }, {
          "comment": ["This format corresponds to an SQLite database, and you can look into the files with e.g. SQLiteStudio3. There are also some readers (http://doi.org/10.1021/pr2005154) and converters (http://doi.org/10.1016/j.jprot.2015.06.015) for this format available, which re-engineered the database schema, but there is no official DB schema specification of Thermo Scientific for the format."],
          "data": {
            "uri": "http://edamontology.org/format_3702"
          },
          "definition": "Proprietary mass-spectrometry format of Thermo Scientific's ProteomeDiscoverer software.",
          "exact_synonyms": ["Magellan storage file format"],
          "text": "MSF"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3835"
          },
          "definition": "Format supported by the Tide tool for identifying peptides from tandem mass spectra.",
          "text": "TIDE TXT"
        }, {
          "comment": ["The focus of qcML is towards mass spectrometry based proteomics, but the format is suitable for metabolomics and sequencing as well."],
          "data": {
            "uri": "http://edamontology.org/format_3683"
          },
          "definition": "qcML is an XML format for quality-related data of mass spectrometry and other high-throughput measurements.",
          "text": "qcML"
        }, {
          "comment": ["imzML data is recorded in 2 files: '.imzXML' is a metadata XML file based on mzML by HUPO-PSI, and '.ibd' is a binary file containing the mass spectra."],
          "data": {
            "uri": "http://edamontology.org/format_3839"
          },
          "definition": "ibd is a data format for mass spectrometry imaging data.",
          "text": "ibd"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3654"
          },
          "definition": "Common file format for proteomics mass spectrometric data developed at the Seattle Proteome Center/Institute for Systems Biology.",
          "text": "mzXML"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3714"
          },
          "definition": "Format of peak list files from Andromeda search engine (MaxQuant) that consist of arbitrarily many spectra.",
          "exact_synonyms": ["MaxQuant APL"],
          "text": "MaxQuant APL peaklist format"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3248"
          },
          "definition": "mzQuantML is the format for quantitation values associated with peptides, proteins and small molecules from mass spectra, standardised by HUPO PSI PI. It can be used for outputs of quantitation software for proteomics.",
          "text": "mzQuantML"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3710"
          },
          "definition": "Mass spectrum file format from QSTAR and QTRAP instruments (ABI/Sciex).",
          "exact_synonyms": ["wiff"],
          "text": "WIFF format"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3764"
          },
          "definition": "XML file format for files containing information about peptide identifications from mass spectrometry data analysis carried out with OpenMS.",
          "text": "idXML"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3681"
          },
          "definition": "mzTab is a tab-delimited format for mass spectrometry-based proteomics and metabolomics results.",
          "text": "mzTab"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3655"
          },
          "definition": "Open data format for the storage, exchange, and processing of peptide sequence assignments of MS/MS scans, intended to provide a common data output format for many different MS/MS search engines and subsequent peptide-level analyses.",
          "text": "pepXML"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3758"
          },
          "definition": "\"Raw\" result file from SEQUEST database search.",
          "text": "SEQUEST .out file"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3713"
          },
          "definition": "\"Raw\" result file from Mascot database search.",
          "text": "Mascot .dat file"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3711"
          },
          "definition": "Output format used by X! series search engines that is based on the XML language BIOML.",
          "text": "X!Tandem XML"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3684"
          },
          "definition": "PRIDE XML is an XML format for mass spectra, peptide and protein identifications, and metadata about a corresponding measurement, sample, experiment.",
          "text": "PRIDE XML"
        }, {
          "comment": ["Each file contains one header line for the known or assumed charge and the mass of the precursor peptide ion, calculated from the measured *m*/*z* and the charge. This one line was then followed by all the *m*/*z*, intensity pairs that represent the spectrum."],
          "data": {
            "uri": "http://edamontology.org/format_3652"
          },
          "definition": "Spectral data format file where each spectrum is written to a separate file.",
          "text": "dta"
        }, {
          "comment": ["No human-consumable information about this format is available (see http://tools.proteomecenter.org/wiki/index.php?title=Formats:protXML)."],
          "data": {
            "uri": "http://edamontology.org/format_3747"
          },
          "definition": "A format for storage, exchange, and processing of protein identifications created from ms/ms-derived peptide sequence data.",
          "text": "protXML"
        }, {
          "comment": ["imzML data are recorded in 2 files: '.imzXML' is a metadata XML file based on mzML by HUPO-PSI, and '.ibd' is a binary file containing the mass spectra. This entry is for the metadata XML file"],
          "data": {
            "uri": "http://edamontology.org/format_3682"
          },
          "definition": "imzML metadata is a data format for mass spectrometry imaging metadata.",
          "text": "imzML metadata file"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3834"
          },
          "definition": "Now deprecated data format of the HUPO Proteomics Standards Initiative.  Replaced by mzML (format_3244).",
          "text": "mzData"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3833"
          },
          "definition": "OpenMS format for quantitation results (LC/MS features).",
          "text": "featureXML"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3247"
          },
          "definition": "mzIdentML is the exchange format for peptides and proteins identified from mass spectra, standardised by HUPO PSI PI. It can be used for outputs of proteomics search engines.",
          "text": "mzIdentML"
        }, {
          "comment": ["Proprietary format for which documentation is not available."],
          "data": {
            "uri": "http://edamontology.org/format_3712"
          },
          "definition": "Proprietary file format for mass spectrometry data from Thermo Scientific.",
          "text": "Thermo RAW"
        }, {
          "comment": ["JCAMP-DX is an ASCII based format and therefore not very compact even though it includes standards for file compression."],
          "data": {
            "uri": "http://edamontology.org/format_3859"
          },
          "definition": "A standardized file format for data exchange in mass spectrometry, initially developed for infrared spectrometry.",
          "text": "JCAMP-DX"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3650"
          },
          "definition": "Format used by netCDF software  library for writing and reading chromatography-MS data files.  Also used to store trajectory atom coordinates information, such as the ones obtained by Molecular Dynamics simulations.",
          "exact_synonyms": ["ANDI-MS"],
          "text": "netCDF"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3246"
          },
          "definition": "TraML (Transition Markup Language) is the format for mass spectrometry transitions, standardised by HUPO PSI MSS.",
          "text": "TraML"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3832"
          },
          "definition": "OpenMS format for grouping features in one map or across several maps.",
          "text": "consensusXML"
        }, {
          "comment": ["Files includes *m*/*z*, intensity pairs separated by headers; headers can contain a bit more information, including search engine instructions."],
          "data": {
            "uri": "http://edamontology.org/format_3651"
          },
          "definition": "Mascot Generic Format.  Encodes multiple MS/MS spectra in a single file.",
          "text": "MGF"
        }, {
          "comment": ["Proprietary format for which documentation is not available, but used by multiple tools."],
          "data": {
            "uri": "http://edamontology.org/format_3858"
          },
          "definition": "Proprietary file format for mass spectrometry data from Waters.",
          "text": "Waters RAW"
        }, {
          "comment": ["mzML is the successor and unifier of the mzData format developed by PSI and mzXML developed at the Seattle Proteome Center."],
          "data": {
            "uri": "http://edamontology.org/format_3244"
          },
          "definition": "mzML format for raw spectrometer output data, standardised by HUPO PSI MSS.",
          "text": "mzML"
        }],
        "data": {
          "uri": "http://edamontology.org/format_3245"
        },
        "definition": "Format for mass pectra and derived data, include peptide sequences etc.",
        "is_format_of": ["http://edamontology.org/data_2536"],
        "text": "Mass spectrometry data format"
      }, {
        "children": [{
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_2004"
            },
            "definition": "T-Coffee program alignment format.",
            "text": "T-Coffee format"
          }, {
            "comment": ["Typically generated by Multiz and TBA aligners; can be displayed in a genome browser like a sequence annotation track. This should not be confused with MIRA Assembly Format or Mutation Annotation Format."],
            "data": {
              "uri": "http://edamontology.org/format_3008"
            },
            "definition": "Multiple Alignment Format (MAF) supporting alignments of whole genomes with rearrangements, directions, multiple pieces to the alignment, and so forth.",
            "text": "MAF"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/format_1991"
              },
              "definition": "Mega format for (typically aligned) sequences.",
              "text": "mega"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_1992"
              },
              "definition": "Mega non-interleaved format for (typically aligned) sequences.",
              "text": "meganon"
            }],
            "data": {
              "uri": "http://edamontology.org/format_2923"
            },
            "definition": "Some variant of Mega format for (typically aligned) sequences.",
            "text": "mega variant"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1392"
            },
            "definition": "Format of multiple sequences aligned by DIALIGN package.",
            "text": "DIALIGN format"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_2005"
            },
            "definition": "Treecon format for (aligned) sequences.",
            "text": "TreeCon-seq"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3281"
            },
            "definition": "The A2M format is used as the primary format for multiple alignments of protein or nucleic-acid sequences in the SAM suite of tools. It is a small modification of FASTA format for sequences and is compatible with most tools that read FASTA.",
            "text": "A2M"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/format_1987"
              },
              "definition": "Pearson MARKX10 alignment format.",
              "text": "markx10"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_1989"
              },
              "definition": "Pearson MARKX3 alignment format.",
              "text": "markx3"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_1988"
              },
              "definition": "Pearson MARKX2 alignment format.",
              "text": "markx2"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_1985"
              },
              "definition": "Pearson MARKX0 alignment format.",
              "text": "markx0"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_1986"
              },
              "definition": "Pearson MARKX1 alignment format.",
              "text": "markx1"
            }],
            "data": {
              "uri": "http://edamontology.org/format_2922"
            },
            "definition": "Some variant of Pearson MARKX alignment format.",
            "text": "markx0 variant"
          }, {
            "comment": ["FASTA format extended for color space information."],
            "data": {
              "uri": "http://edamontology.org/format_3589"
            },
            "definition": "Color space FASTA format sequence variant.",
            "text": "csfasta"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_2000"
            },
            "definition": "SELEX format for (aligned) sequences.",
            "text": "selex"
          }, {
            "children": [{
              "comment": ["GCG SSF (single sequence file) file format."],
              "data": {
                "uri": "http://edamontology.org/format_1935"
              },
              "definition": "GCG sequence file format.",
              "exact_synonyms": ["GCG SSF"],
              "text": "GCG"
            }, {
              "comment": ["RSF-format files contain one or more sequences that may or may not be related. In addition to the sequence data, each sequence can be annotated with descriptive sequence information (from the GCG manual)."],
              "data": {
                "uri": "http://edamontology.org/format_3485"
              },
              "definition": "Rich sequence format.",
              "exact_synonyms": ["GCG RSF"],
              "text": "RSF"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_1947"
              },
              "definition": "GCG MSF (multiple sequence file) file format.",
              "text": "GCG MSF"
            }],
            "data": {
              "uri": "http://edamontology.org/format_3486"
            },
            "definition": "Some format based on the GCG format.",
            "text": "GCG format variant"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1929"
            },
            "definition": "FASTA format including NCBI-style IDs.",
            "exact_synonyms": ["FASTA sequence format", "FASTA format"],
            "text": "FASTA"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1999"
            },
            "definition": "Alignment format for score values for pairs of sequences.",
            "text": "scores format"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_2002"
            },
            "definition": "Simple multiple sequence (alignment) format for SRS.",
            "text": "srs format"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1973"
            },
            "definition": "Nexus/paup non-interleaved sequence format.",
            "text": "nexusnon"
          }, {
            "comment": ["The format is clustal-like and includes annotation of domain family classification information."],
            "data": {
              "uri": "http://edamontology.org/format_1393"
            },
            "definition": "EMBASSY 'domain alignment file' (DAF) format, containing a sequence alignment of protein domains belonging to the same SCOP or CATH family.",
            "text": "daf"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1391"
            },
            "definition": "FASTA-style format for multiple sequences aligned by HMMER package to an HMM.",
            "text": "HMMER-aln"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1982"
            },
            "definition": "ClustalW format for (aligned) sequences.",
            "exact_synonyms": ["clustal"],
            "text": "ClustalW format"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1984"
            },
            "definition": "Fasta format for (aligned) sequences.",
            "text": "FASTA-aln"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1990"
            },
            "definition": "Alignment format for start and end of matches between sequence pairs.",
            "text": "match"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3330"
            },
            "definition": "EMBOSS simple sequence pair alignment format.",
            "text": "PO"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3313"
            },
            "definition": "A multiple alignment in vertical format, as used in the AMPS (Alignment of Multiple Protein Sequences) pacakge.",
            "exact_synonyms": ["Block file format"],
            "text": "BLC"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1961"
            },
            "definition": "Stockholm multiple sequence alignment format (used by Pfam and Rfam).",
            "text": "Stockholm format"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_2001"
            },
            "definition": "EMBOSS simple multiple alignment format.",
            "text": "EMBOSS simple format"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1996"
            },
            "definition": "EMBOSS simple sequence pair alignment format.",
            "text": "pair"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1983"
            },
            "definition": "EMBOSS alignment format for debugging trace of full internal data content.",
            "text": "debug"
          }, {
            "children": [{
              "comment": ["It differs from Phylip sequential format (format_1997) on length of the ID sequence. There no length restrictions on the ID, but whitespaces aren't allowed in the sequence ID/Name because one space separates the longest ID and the beginning of the sequence. Sequences IDs must be padded to the longest ID length."],
              "data": {
                "uri": "http://edamontology.org/format_3820"
              },
              "definition": "Phylip multiple alignment sequence format, less stringent than PHYLIP sequential format (format_1998).",
              "exact_synonyms": ["Relaxed PHYLIP sequential format", "Relaxed PHYLIP non-interleaved", "Relaxed PHYLIP non-interleaved format"],
              "text": "Relaxed PHYLIP Sequential"
            }, {
              "comment": ["It differs from Phylip Format (format_1997) on length of the ID sequence. There no length restrictions on the ID, but whitespaces aren't allowed in the sequence ID/Name because one space separates the longest ID and the beginning of the sequence. Sequences IDs must be padded to the longest ID length."],
              "data": {
                "uri": "http://edamontology.org/format_3819"
              },
              "definition": "Phylip multiple alignment sequence format, less stringent than PHYLIP format.",
              "exact_synonyms": ["PHYLIP Interleaved format"],
              "text": "Relaxed PHYLIP Interleaved"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_1997"
              },
              "definition": "Phylip format for (aligned) sequences.",
              "exact_synonyms": ["PHYLIP", "phy", "PHYLIP interleaved format", "ph"],
              "text": "PHYLIP format"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_1998"
              },
              "definition": "Phylip non-interleaved format for (aligned) sequences.",
              "exact_synonyms": ["PHYLIP sequential format", "phylipnon"],
              "text": "PHYLIP sequential"
            }],
            "data": {
              "uri": "http://edamontology.org/format_2924"
            },
            "definition": "Some variant of Phylip format for (aligned) sequences.",
            "text": "Phylip format variant"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1949"
            },
            "definition": "Nexus/paup interleaved sequence format.",
            "text": "nexus-seq"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3811"
            },
            "definition": "The A2M format is used as the primary format for multiple alignments of protein or nucleic-acid sequences in the SAM suite of tools. It is a small modification of FASTA format for sequences and is compatible with most tools that read FASTA.",
            "exact_synonyms": ["eXtended Multi-FastA format", "alignment format"],
            "text": "XMFA"
          }],
          "data": {
            "uri": "http://edamontology.org/format_2554"
          },
          "definition": "Text format for molecular sequence alignment information.",
          "text": "Alignment format (text)"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_2352"
            },
            "definition": "BioXSD-schema-based XML format of sequence-based data and some other common data - sequence records, alignments, feature records, references to resources, and more - optimised for integrative bioinformatics, Web services, and object-oriented programming.",
            "exact_synonyms": ["BioXSD XML", "BioXSD+XML", "BioXSD XML format", "BioXSD in XML", "BioXSD in XML format"],
            "is_format_of": ["http://edamontology.org/data_1772", "http://edamontology.org/data_1255", "http://edamontology.org/data_3108", "http://edamontology.org/data_0863", "http://edamontology.org/data_2044"],
            "text": "BioXSD (XML)"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3845"
            },
            "definition": "An alignment format generated by PRANK/PRANKSTER consisting of four elements: newick, nodes, selection and model.",
            "text": "HSAML"
          }],
          "data": {
            "uri": "http://edamontology.org/format_2555"
          },
          "definition": "XML format for molecular sequence alignment information.",
          "text": "Alignment format (XML)"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3773"
          },
          "definition": "BioYAML is a BioXSD-schema-based YAML format of sequence-based data and some other common data - sequence records, alignments, feature records, references to resources, and more - optimised for integrative bioinformatics, web APIs, human readability and editting, and object-oriented programming.",
          "exact_synonyms": ["BioYAML format", "BioXSD YAML format", "BioYAML format (BioXSD)", "BioXSD in YAML format", "BioXSD BioYAML format", "BioYAML (BioXSD data model)", "BioXSD|BioJSON|BioYAML BioYAML", "BioXSD YAML", "BioXSD|GTrack BioYAML", "BioXSD/GTrack BioYAML", "BioXSD in YAML", "BioXSD BioYAML", "BioYAML (BioXSD)", "BioXSD+YAML"],
          "is_format_of": ["http://edamontology.org/data_0863", "http://edamontology.org/data_1255", "http://edamontology.org/data_1772", "http://edamontology.org/data_3108", "http://edamontology.org/data_2044"],
          "text": "BioYAML"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3849"
          },
          "definition": "A set of XML compliant markup components for describing multiple sequence alignments.",
          "text": "MSAML"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3774"
          },
          "definition": "BioJSON is a JSON format of single multiple sequence alignments, with their annotations, features, and custom visualisation and application settings for the Jalview workbench.",
          "exact_synonyms": ["JSON (Jalview)", "Jalview JSON", "JSON format (Jalview)", "Jalview JSON format", "Jalview BioJSON format", "BioJSON format (Jalview)", "Jalview BioJSON"],
          "is_format_of": ["http://edamontology.org/data_1255", "http://edamontology.org/data_0863"],
          "text": "BioJSON (Jalview)"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3311"
          },
          "definition": "RNA Markup Language.",
          "text": "RNAML"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_3826"
            },
            "definition": ". proBAM is an adaptation of BAM (format_2572), which was extended to meet specific requirements entailed by proteomics data.",
            "text": "proBAM"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3462"
            },
            "definition": "Reference-based compression of alignment format",
            "text": "CRAM"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3015"
            },
            "definition": "Pileup format of alignment of sequences (e.g. sequencing reads) to (a) reference sequence(s). Contains aligned bases per base of the reference sequence(s).",
            "text": "Pileup"
          }, {
            "comment": ["The format supports short and long reads (up to 128Mbp) produced by different sequencing platforms and is used to hold mapped data within the GATK and across the Broad Institute, the Sanger Centre, and throughout the 1000 Genomes project."],
            "data": {
              "uri": "http://edamontology.org/format_2573"
            },
            "definition": "Sequence Alignment/Map (SAM) format for alignment of nucleotide sequences (e.g. sequencing reads) to (a) reference sequence(s). May contain base-call and alignment qualities and other data.",
            "text": "SAM"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3007"
            },
            "definition": "PSL format of alignments, typically generated by BLAT or psLayout. Can be displayed in a genome browser like a sequence annotation track.",
            "text": "PSL"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3013"
            },
            "definition": "axt format of alignments, typically produced from BLASTZ.",
            "text": "axt"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3982"
            },
            "definition": "The CHAIN format describes a pairwise alignment that allow gaps in both sequences simultaneously and is used by the UCSC Genome Browser.",
            "text": "CHAIN"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3157"
            },
            "definition": "EBI Application Result XML is a format returned by sequence similarity search Web services at EBI.",
            "text": "EBI Application Result XML"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_2572"
            },
            "definition": "BAM format, the binary, BGZF-formatted compressed version of SAM format for alignment of nucleotide sequences (e.g. sequencing reads) to (a) reference sequence(s). May contain base-call and alignment qualities and other data.",
            "text": "BAM"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3014"
            },
            "definition": "LAV format of alignments generated by BLASTZ and LASTZ.",
            "text": "LAV"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3992"
            },
            "definition": "Compact Idiosyncratic Gapped Alignment Report format is a compressed (run-length encoded) pairwise alignment format. It is useful for representing long (e.g. genomic) pairwise alignments.",
            "exact_synonyms": ["CIGAR"],
            "text": "CIGAR format"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_2003"
            },
            "definition": "Simple sequence pair (alignment) format for SRS.",
            "text": "srspair"
          }],
          "data": {
            "uri": "http://edamontology.org/format_2920"
          },
          "definition": "Data format for molecular sequence alignment information that can hold sequence alignment(s) of only 2 sequences.",
          "is_format_of": ["http://edamontology.org/data_1381"],
          "text": "Alignment format (pair only)"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3830"
          },
          "definition": "Binary format used by the ARB software suite",
          "exact_synonyms": ["ARB binary format"],
          "text": "ARB"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3772"
          },
          "definition": "BioJSON is a BioXSD-schema-based JSON format of sequence-based data and some other common data - sequence records, alignments, feature records, references to resources, and more - optimised for integrative bioinformatics, web applications and APIs, and object-oriented programming.",
          "exact_synonyms": ["BioXSD BioJSON", "BioXSD+JSON", "BioXSD BioJSON format", "BioXSD in JSON", "BioXSD in JSON format", "BioXSD|GTrack BioJSON", "BioXSD JSON", "BioJSON format (BioXSD)", "BioXSD|BioJSON|BioYAML BioJSON", "BioJSON (BioXSD data model)", "BioXSD/GTrack BioJSON", "BioXSD JSON format"],
          "is_format_of": ["http://edamontology.org/data_2044", "http://edamontology.org/data_1772", "http://edamontology.org/data_0863", "http://edamontology.org/data_3108", "http://edamontology.org/data_1255"],
          "text": "BioJSON (BioXSD)"
        }],
        "data": {
          "uri": "http://edamontology.org/format_1921"
        },
        "definition": "Data format for molecular sequence alignment information.",
        "is_format_of": ["http://edamontology.org/data_0863"],
        "text": "Alignment format"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_3785"
          },
          "definition": "A family of similar formats of text annotation, used by BRAT and other tools, known as BioNLP Shared Task format (BioNLP 2009 Shared Task on Event Extraction, BioNLP Shared Task 2011, BioNLP Shared Task 2013), BRAT format, BRAT standoff format, and similar.",
          "exact_synonyms": ["BRAT standoff format", "BRAT format"],
          "text": "BioNLP Shared Task format"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3783"
          },
          "definition": "Native textual export format of annotated scientific text from PubTator.",
          "text": "PubTator format"
        }, {
          "comment": ["OSCAR (Open-Source Chemistry Analysis Routines) software performs chemistry-specific parsing of chemical documents. It attempts to identify chemical names, ontology concepts, and chemical data from a document."],
          "data": {
            "uri": "http://edamontology.org/format_1741"
          },
          "definition": "OSCAR format of annotated chemical text.",
          "text": "OSCAR format"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3784"
          },
          "definition": "A format of text annotation using the linked-data Open Annotation Data Model, serialised typically in RDF or JSON-LD.",
          "text": "Open Annotation format"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3782"
          },
          "definition": "BioC is a standardised XML format for sharing and integrating text data and annotations.",
          "text": "BioC"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3781"
          },
          "definition": "JSON format of annotated scientific text used by PubAnnotations and other tools.",
          "text": "PubAnnotation format"
        }],
        "data": {
          "uri": "http://edamontology.org/format_3780"
        },
        "definition": "Data format of an annotated text, e.g. with recognised entities, concepts, and relations.",
        "is_format_of": ["http://edamontology.org/data_3779"],
        "text": "Annotated text format"
      }, {
        "children": [{
          "comment": ["BcForms is related to http://edamontology.org/format_3909. (BcForms uses BpForms to describe subunits which are DNA, RNA, or protein polymers.) However, that format isn't the parent of BcForms. BcForms is similarly related to SMILES (http://edamontology.org/data_2301)."],
          "data": {
            "uri": "http://edamontology.org/format_3951"
          },
          "definition": "BcForms is a format for abstractly describing the molecular structure (atoms and bonds) of macromolecular complexes as a collection of subunits and crosslinks. Each subunit can be described with BpForms (http://edamontology.org/format_3909) or SMILES (http://edamontology.org/data_2301). BcForms uses an ontology of crosslinks to abstract the chemical details of crosslinks from the descriptions of complexes (see https://bpforms.org/crosslink.html).",
          "text": "BcForms"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2062"
        },
        "definition": "Format of a report of general information about a specific protein.",
        "is_format_of": ["http://edamontology.org/data_0896"],
        "text": "Protein report format"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_1445"
          },
          "definition": "Format for distances, such as Branch Score distance, between two or more phylogenetic trees as used by the Phylip package.",
          "text": "Phylip tree distance format"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2049"
        },
        "definition": "Format for phylogenetic tree distance data.",
        "is_format_of": ["http://edamontology.org/data_1442"],
        "text": "Phylogenetic tree report (tree distances) format"
      }, {
        "children": [{
          "comment": ["This format is used in Protege 4."],
          "data": {
            "uri": "http://edamontology.org/format_3254"
          },
          "definition": "A superset of the \"Description-Logic Knowledge Representation System Specification from the KRSS Group of the ARPA Knowledge Sharing Effort\".",
          "text": "KRSS2 Syntax"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_2549"
            },
            "definition": "OBO ontology text format.",
            "text": "OBO"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_2550"
            },
            "definition": "OBO ontology XML format.",
            "text": "OBO-XML"
          }],
          "data": {
            "uri": "http://edamontology.org/format_2196"
          },
          "definition": "A serialisation format conforming to the Open Biomedical Ontologies (OBO) model.",
          "text": "OBO format"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_3262"
            },
            "definition": "OWL ontology XML serialisation format.",
            "narrow_synonyms": ["OWL"],
            "text": "OWL/XML"
          }, {
            "comment": ["This format was influenced by the OWL Abstract Syntax and the DL style syntax."],
            "data": {
              "uri": "http://edamontology.org/format_3253"
            },
            "definition": "A syntax for writing OWL class expressions.",
            "text": "Manchester OWL Syntax"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3252"
            },
            "definition": "A human-readable encoding for the Web Ontology Language (OWL).",
            "text": "OWL Functional Syntax"
          }],
          "data": {
            "uri": "http://edamontology.org/format_2197"
          },
          "definition": "A serialisation format conforming to the Web Ontology Language (OWL) model.",
          "text": "OWL format"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_3784"
            },
            "definition": "A format of text annotation using the linked-data Open Annotation Data Model, serialised typically in RDF or JSON-LD.",
            "text": "Open Annotation format"
          }, {
            "comment": ["RDF/XML is a serialisation syntax for OWL DL, but not for OWL Full."],
            "data": {
              "uri": "http://edamontology.org/format_3261"
            },
            "definition": "Resource Description Framework (RDF) XML format.",
            "text": "RDF/XML"
          }, {
            "comment": ["The SPARQL Query Language incorporates a very similar syntax."],
            "data": {
              "uri": "http://edamontology.org/format_3255"
            },
            "definition": "The Terse RDF Triple Language (Turtle) is a human-friendly serialisation format for RDF (Resource Description Framework) graphs.",
            "text": "Turtle"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3257"
            },
            "definition": "A shorthand non-XML serialisation of Resource Description Framework model, designed with human-readability in mind.",
            "exact_synonyms": ["N3"],
            "text": "Notation3"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/format_3262"
              },
              "definition": "OWL ontology XML serialisation format.",
              "narrow_synonyms": ["OWL"],
              "text": "OWL/XML"
            }, {
              "comment": ["This format was influenced by the OWL Abstract Syntax and the DL style syntax."],
              "data": {
                "uri": "http://edamontology.org/format_3253"
              },
              "definition": "A syntax for writing OWL class expressions.",
              "text": "Manchester OWL Syntax"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_3252"
              },
              "definition": "A human-readable encoding for the Web Ontology Language (OWL).",
              "text": "OWL Functional Syntax"
            }],
            "data": {
              "uri": "http://edamontology.org/format_2197"
            },
            "definition": "A serialisation format conforming to the Web Ontology Language (OWL) model.",
            "text": "OWL format"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/format_3784"
              },
              "definition": "A format of text annotation using the linked-data Open Annotation Data Model, serialised typically in RDF or JSON-LD.",
              "text": "Open Annotation format"
            }],
            "data": {
              "uri": "http://edamontology.org/format_3749"
            },
            "definition": "JSON-LD, or JavaScript Object Notation for Linked Data, is a method of encoding Linked Data using JSON.",
            "exact_synonyms": ["JavaScript Object Notation for Linked Data"],
            "text": "JSON-LD"
          }, {
            "comment": ["N-Triples should not be confused with Notation 3 which is a superset of Turtle."],
            "data": {
              "uri": "http://edamontology.org/format_3256"
            },
            "definition": "A plain text serialisation format for RDF (Resource Description Framework) graphs, and a subset of the Turtle (Terse RDF Triple Language) format.",
            "text": "N-Triples"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3771"
            },
            "definition": "UniProtKB RDF sequence features format is an RDF format available for downloading UniProt entries (in RDF/XML).",
            "exact_synonyms": ["UniProt RDF format", "UniProtKB RDF format", "UniProt RDF"],
            "narrow_synonyms": ["UniProt RDF/XML", "UniProtKB RDF/XML format", "UniProtKB RDF/XML", "UniProt RDF/XML format"],
            "text": "UniProtKB RDF"
          }, {
            "comment": ["N-Quads should not be confused with N-Triples which does not contain graph information."],
            "data": {
              "uri": "http://edamontology.org/format_3956"
            },
            "definition": "N-Quads is a line-based, plain text format for encoding an RDF dataset. It includes information about the graph each triple belongs to.",
            "text": "N-Quads"
          }],
          "data": {
            "uri": "http://edamontology.org/format_2376"
          },
          "definition": "A serialisation format conforming to the Resource Description Framework (RDF) model.",
          "exact_synonyms": ["Resource Description Framework format"],
          "text": "RDF format"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2195"
        },
        "definition": "Format used for ontologies.",
        "is_format_of": ["http://edamontology.org/data_0582"],
        "text": "Ontology format"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_1367"
          },
          "definition": "A profile (sequence classifier) in the format used in the JASPAR database.",
          "text": "JASPAR format"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_1369"
            },
            "definition": "Format of the model of random sequences used by MEME.",
            "text": "MEME background Markov model"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/format_3328"
              },
              "definition": "HMMER profile HMM file for HMMER versions 2.x",
              "text": "HMMER2"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_3329"
              },
              "definition": "HMMER profile HMM file for HMMER versions 3.x",
              "text": "HMMER3"
            }],
            "data": {
              "uri": "http://edamontology.org/format_1370"
            },
            "definition": "Format of a hidden Markov model representation used by the HMMER package.",
            "text": "HMMER format"
          }],
          "data": {
            "uri": "http://edamontology.org/format_2072"
          },
          "definition": "Format of a hidden Markov model.",
          "is_format_of": ["http://edamontology.org/data_1364"],
          "text": "Hidden Markov model format"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1366"
          },
          "definition": "Sequence profile (sequence classifier) format used in the PROSITE database.",
          "text": "prosite-profile"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2069"
        },
        "definition": "Format of a sequence profile.",
        "is_format_of": ["http://edamontology.org/data_1354"],
        "text": "Sequence profile format"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_1419"
          },
          "definition": "Format for alignment of molecular sequences to MEME profiles (position-dependent scoring matrices) as generated by the MAST tool from the MEME package.",
          "text": "Sequence-MEME profile alignment"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1422"
          },
          "definition": "Format used by the HMMER package for of an alignment of a hidden Markov model against a sequence database.",
          "text": "HMMER profile alignment (HMM versus sequences)"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1421"
          },
          "definition": "Format used by the HMMER package for an alignment of a sequence against a hidden Markov model database.",
          "text": "HMMER profile alignment (sequences versus HMMs)"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2014"
        },
        "definition": "Data format for a sequence-profile alignment.",
        "is_format_of": ["http://edamontology.org/data_0858"],
        "text": "Sequence-profile alignment format"
      }, {
        "children": [{
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_1218"
            },
            "definition": "Alphabet for any protein sequence with possible unknown positions but without ambiguity or non-sequence characters.",
            "text": "unambiguous pure protein"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_2607"
            },
            "definition": "Alphabet for any protein sequence without unknown positions, ambiguity or non-sequence characters.",
            "text": "completely unambiguous pure protein"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1219"
            },
            "definition": "Alphabet for any protein sequence with possible ambiguity and unknown positions but without non-sequence characters.",
            "text": "pure protein"
          }],
          "comment": ["Non-sequence characters may be used for gaps and translation stop."],
          "data": {
            "uri": "http://edamontology.org/format_1208"
          },
          "definition": "Alphabet for a protein sequence with possible ambiguity, unknown positions and non-sequence characters.",
          "text": "protein"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_2352"
          },
          "definition": "BioXSD-schema-based XML format of sequence-based data and some other common data - sequence records, alignments, feature records, references to resources, and more - optimised for integrative bioinformatics, Web services, and object-oriented programming.",
          "exact_synonyms": ["BioXSD XML", "BioXSD+XML", "BioXSD XML format", "BioXSD in XML", "BioXSD in XML format"],
          "is_format_of": ["http://edamontology.org/data_1772", "http://edamontology.org/data_1255", "http://edamontology.org/data_3108", "http://edamontology.org/data_0863", "http://edamontology.org/data_2044"],
          "text": "BioXSD (XML)"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3010"
          },
          "definition": ".nib (nibble) binary format of a nucleotide sequence using 4 bits per nucleotide (including unknown) and its lower-case 'masking'.",
          "text": ".nib"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_1209"
            },
            "definition": "Alphabet for the consensus of two or more molecular sequences.",
            "text": "consensus"
          }],
          "data": {
            "uri": "http://edamontology.org/format_2095"
          },
          "definition": "Alphabet for a molecular sequence with possible unknown positions but possibly with non-sequence characters.",
          "text": "unpure"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3773"
          },
          "definition": "BioYAML is a BioXSD-schema-based YAML format of sequence-based data and some other common data - sequence records, alignments, feature records, references to resources, and more - optimised for integrative bioinformatics, web APIs, human readability and editting, and object-oriented programming.",
          "exact_synonyms": ["BioYAML format", "BioXSD YAML format", "BioYAML format (BioXSD)", "BioXSD in YAML format", "BioXSD BioYAML format", "BioYAML (BioXSD data model)", "BioXSD|BioJSON|BioYAML BioYAML", "BioXSD YAML", "BioXSD|GTrack BioYAML", "BioXSD/GTrack BioYAML", "BioXSD in YAML", "BioXSD BioYAML", "BioYAML (BioXSD)", "BioXSD+YAML"],
          "is_format_of": ["http://edamontology.org/data_0863", "http://edamontology.org/data_1255", "http://edamontology.org/data_1772", "http://edamontology.org/data_3108", "http://edamontology.org/data_2044"],
          "text": "BioYAML"
        }, {
          "children": [{
            "children": [{
              "data": {
                "uri": "http://edamontology.org/format_1215"
              },
              "definition": "Alphabet for a DNA sequence with possible ambiguity and unknown positions but without non-sequence characters.",
              "text": "pure dna"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_1217"
              },
              "definition": "Alphabet for an RNA sequence with possible ambiguity and unknown positions but without non-sequence characters.",
              "text": "pure rna"
            }],
            "data": {
              "uri": "http://edamontology.org/format_1210"
            },
            "definition": "Alphabet for a nucleotide sequence with possible ambiguity and unknown positions but without non-sequence characters.",
            "text": "pure nucleotide"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_2568"
            },
            "definition": "Alphabet for a nucleotide sequence (characters ACGTU only) without unknown positions, ambiguity or non-sequence characters .",
            "text": "completely unambiguous pure nucleotide"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1211"
            },
            "definition": "Alphabet for a nucleotide sequence (characters ACGTU only) with possible unknown positions but without ambiguity or non-sequence characters .",
            "text": "unambiguous pure nucleotide"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/format_2569"
              },
              "definition": "Alphabet for a DNA sequence (characters ACGT only) without unknown positions, ambiguity or non-sequence characters.",
              "text": "completely unambiguous pure dna"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_1215"
              },
              "definition": "Alphabet for a DNA sequence with possible ambiguity and unknown positions but without non-sequence characters.",
              "text": "pure dna"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_1214"
              },
              "definition": "Alphabet for a DNA sequence (characters ACGT only) with possible unknown positions but without ambiguity or non-sequence characters.",
              "text": "unambiguous pure dna"
            }],
            "data": {
              "uri": "http://edamontology.org/format_1212"
            },
            "definition": "Alphabet for a DNA sequence with possible ambiguity, unknown positions and non-sequence characters.",
            "text": "dna"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/format_2570"
              },
              "definition": "Alphabet for an RNA sequence (characters ACGU only) without unknown positions, ambiguity or non-sequence characters.",
              "text": "completely unambiguous pure rna sequence"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_1216"
              },
              "definition": "Alphabet for an RNA sequence (characters ACGU only) with possible unknown positions but without ambiguity or non-sequence characters.",
              "text": "unambiguous pure rna sequence"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_1217"
              },
              "definition": "Alphabet for an RNA sequence with possible ambiguity and unknown positions but without non-sequence characters.",
              "text": "pure rna"
            }],
            "data": {
              "uri": "http://edamontology.org/format_1213"
            },
            "definition": "Alphabet for an RNA sequence with possible ambiguity, unknown positions and non-sequence characters.",
            "text": "rna"
          }],
          "comment": ["Non-sequence characters may be used for example for gaps."],
          "data": {
            "uri": "http://edamontology.org/format_1207"
          },
          "definition": "Alphabet for a nucleotide sequence with possible ambiguity, unknown positions and non-sequence characters.",
          "text": "nucleotide"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3973"
          },
          "definition": "A Docker image is a file, comprised of multiple layers, that is used to execute code in a Docker container. An image is essentially built from the instructions for a complete and executable version of an application, which relies on the host OS kernel.",
          "text": "Docker image format"
        }, {
          "children": [{
            "children": [{
              "data": {
                "uri": "http://edamontology.org/format_2569"
              },
              "definition": "Alphabet for a DNA sequence (characters ACGT only) without unknown positions, ambiguity or non-sequence characters.",
              "text": "completely unambiguous pure dna"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_2568"
              },
              "definition": "Alphabet for a nucleotide sequence (characters ACGTU only) without unknown positions, ambiguity or non-sequence characters .",
              "text": "completely unambiguous pure nucleotide"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_2607"
              },
              "definition": "Alphabet for any protein sequence without unknown positions, ambiguity or non-sequence characters.",
              "text": "completely unambiguous pure protein"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_2570"
              },
              "definition": "Alphabet for an RNA sequence (characters ACGU only) without unknown positions, ambiguity or non-sequence characters.",
              "text": "completely unambiguous pure rna sequence"
            }],
            "data": {
              "uri": "http://edamontology.org/format_2567"
            },
            "definition": "Alphabet for a molecular sequence without unknown positions, ambiguity or non-sequence characters.",
            "text": "completely unambiguous pure"
          }],
          "data": {
            "uri": "http://edamontology.org/format_2566"
          },
          "definition": "Alphabet for a molecular sequence without any unknown positions or ambiguity characters.",
          "text": "completely unambiguous"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3911"
          },
          "definition": "Mash sketch is a format for sequence / sequence checksum information. To make a sketch, each k-mer in a sequence is hashed, which creates a pseudo-random identifier. By sorting these hashes, a small subset from the top of the sorted list can represent the entire sequence.",
          "exact_synonyms": ["min-hash sketch", "Mash sketch"],
          "is_format_of": ["http://edamontology.org/data_2190"],
          "text": "msh"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_1209"
            },
            "definition": "Alphabet for the consensus of two or more molecular sequences.",
            "text": "consensus"
          }],
          "data": {
            "uri": "http://edamontology.org/format_2097"
          },
          "definition": "Alphabet for a molecular sequence with possible unknown positions and possible ambiguity characters.",
          "text": "ambiguous"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1957"
          },
          "definition": "Raw sequence format with no non-sequence characters.",
          "text": "raw"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3009"
          },
          "definition": "2bit binary format of nucleotide sequences using 2 bits per nucleotide. In addition encodes unknown nucleotides and lower-case 'masking'.",
          "text": "2bit"
        }, {
          "children": [{
            "children": [{
              "data": {
                "uri": "http://edamontology.org/format_1215"
              },
              "definition": "Alphabet for a DNA sequence with possible ambiguity and unknown positions but without non-sequence characters.",
              "text": "pure dna"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_1217"
              },
              "definition": "Alphabet for an RNA sequence with possible ambiguity and unknown positions but without non-sequence characters.",
              "text": "pure rna"
            }],
            "data": {
              "uri": "http://edamontology.org/format_1210"
            },
            "definition": "Alphabet for a nucleotide sequence with possible ambiguity and unknown positions but without non-sequence characters.",
            "text": "pure nucleotide"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/format_2569"
              },
              "definition": "Alphabet for a DNA sequence (characters ACGT only) without unknown positions, ambiguity or non-sequence characters.",
              "text": "completely unambiguous pure dna"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_2568"
              },
              "definition": "Alphabet for a nucleotide sequence (characters ACGTU only) without unknown positions, ambiguity or non-sequence characters .",
              "text": "completely unambiguous pure nucleotide"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_2607"
              },
              "definition": "Alphabet for any protein sequence without unknown positions, ambiguity or non-sequence characters.",
              "text": "completely unambiguous pure protein"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_2570"
              },
              "definition": "Alphabet for an RNA sequence (characters ACGU only) without unknown positions, ambiguity or non-sequence characters.",
              "text": "completely unambiguous pure rna sequence"
            }],
            "data": {
              "uri": "http://edamontology.org/format_2567"
            },
            "definition": "Alphabet for a molecular sequence without unknown positions, ambiguity or non-sequence characters.",
            "text": "completely unambiguous pure"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1219"
            },
            "definition": "Alphabet for any protein sequence with possible ambiguity and unknown positions but without non-sequence characters.",
            "text": "pure protein"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/format_1218"
              },
              "definition": "Alphabet for any protein sequence with possible unknown positions but without ambiguity or non-sequence characters.",
              "text": "unambiguous pure protein"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_1211"
              },
              "definition": "Alphabet for a nucleotide sequence (characters ACGTU only) with possible unknown positions but without ambiguity or non-sequence characters .",
              "text": "unambiguous pure nucleotide"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_1216"
              },
              "definition": "Alphabet for an RNA sequence (characters ACGU only) with possible unknown positions but without ambiguity or non-sequence characters.",
              "text": "unambiguous pure rna sequence"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_1214"
              },
              "definition": "Alphabet for a DNA sequence (characters ACGT only) with possible unknown positions but without ambiguity or non-sequence characters.",
              "text": "unambiguous pure dna"
            }],
            "data": {
              "uri": "http://edamontology.org/format_1206"
            },
            "definition": "Alphabet for a molecular sequence with possible unknown positions but without ambiguity or non-sequence characters.",
            "text": "unambiguous pure"
          }],
          "data": {
            "uri": "http://edamontology.org/format_2094"
          },
          "definition": "Alphabet for molecular sequence with possible unknown positions but without non-sequence characters.",
          "text": "pure"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3772"
          },
          "definition": "BioJSON is a BioXSD-schema-based JSON format of sequence-based data and some other common data - sequence records, alignments, feature records, references to resources, and more - optimised for integrative bioinformatics, web applications and APIs, and object-oriented programming.",
          "exact_synonyms": ["BioXSD BioJSON", "BioXSD+JSON", "BioXSD BioJSON format", "BioXSD in JSON", "BioXSD in JSON format", "BioXSD|GTrack BioJSON", "BioXSD JSON", "BioJSON format (BioXSD)", "BioXSD|BioJSON|BioYAML BioJSON", "BioJSON (BioXSD data model)", "BioXSD/GTrack BioJSON", "BioXSD JSON format"],
          "is_format_of": ["http://edamontology.org/data_2044", "http://edamontology.org/data_1772", "http://edamontology.org/data_0863", "http://edamontology.org/data_3108", "http://edamontology.org/data_1255"],
          "text": "BioJSON (BioXSD)"
        }, {
          "children": [{
            "children": [{
              "data": {
                "uri": "http://edamontology.org/format_1218"
              },
              "definition": "Alphabet for any protein sequence with possible unknown positions but without ambiguity or non-sequence characters.",
              "text": "unambiguous pure protein"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_1211"
              },
              "definition": "Alphabet for a nucleotide sequence (characters ACGTU only) with possible unknown positions but without ambiguity or non-sequence characters .",
              "text": "unambiguous pure nucleotide"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_1216"
              },
              "definition": "Alphabet for an RNA sequence (characters ACGU only) with possible unknown positions but without ambiguity or non-sequence characters.",
              "text": "unambiguous pure rna sequence"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_1214"
              },
              "definition": "Alphabet for a DNA sequence (characters ACGT only) with possible unknown positions but without ambiguity or non-sequence characters.",
              "text": "unambiguous pure dna"
            }],
            "data": {
              "uri": "http://edamontology.org/format_1206"
            },
            "definition": "Alphabet for a molecular sequence with possible unknown positions but without ambiguity or non-sequence characters.",
            "text": "unambiguous pure"
          }],
          "data": {
            "uri": "http://edamontology.org/format_2096"
          },
          "definition": "Alphabet for a molecular sequence with possible unknown positions but without ambiguity characters.",
          "text": "unambiguous sequence"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3909"
          },
          "definition": "BpForms is a string format for concretely representing the primary structures of biopolymers, including DNA, RNA, and proteins that include non-canonical nucleic and amino acids. See https://www.bpforms.org for more information.",
          "is_format_of": ["http://edamontology.org/data_1255"],
          "text": "BpForms"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2571"
        },
        "definition": "Format of a raw molecular sequence (i.e. the alphabet used).",
        "is_format_of": ["http://edamontology.org/data_2044"],
        "text": "Raw sequence format"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_3985"
          },
          "definition": "An emerging format for high-level Galaxy workflow description.",
          "exact_synonyms": ["Galaxy workflow format", "GalaxyWF"],
          "text": "gxformat2"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3996"
          },
          "definition": "Format for scripts writtenin Python - a widely used high-level programming language for general-purpose programming.",
          "exact_synonyms": ["Python program", "Python"],
          "text": "Python script"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3765"
          },
          "definition": "Data table formatted such that it can be passed/streamed within the KNIME platform.",
          "text": "KNIME datatable format"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_4007"
          },
          "definition": "The file format for MATLAB scripts or functions.",
          "exact_synonyms": ["MATLAB"],
          "text": "MATLAB script"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_4000"
          },
          "definition": "A file format for making dynamic documents (R Markdown scripts) with the R language.",
          "text": "R markdown"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3999"
          },
          "definition": "Format for scripts written in the R language - an open source programming language and software environment for statistical computing and graphics that is supported by the R Foundation for Statistical Computing.",
          "exact_synonyms": ["R program", "R"],
          "text": "R script"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3998"
          },
          "definition": "Format for scripts written in Perl - a family of high-level, general-purpose, interpreted, dynamic programming languages.",
          "exact_synonyms": ["Perl", "Perl program"],
          "text": "Perl script"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3857"
          },
          "definition": "Common Workflow Language (CWL) format for description of command-line tools and workflows.",
          "exact_synonyms": ["CommonWL", "Common Workflow Language"],
          "text": "CWL"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1665"
          },
          "definition": "Format of Taverna workflows.",
          "text": "Taverna workflow format"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2032"
        },
        "definition": "Format of a workflow.",
        "text": "Workflow format"
      }, {
        "children": [{
          "comment": ["NMReData is a text based data standard for processed NMR data. It is relying on SDF molecule data and allows to store assignments of NMR peaks to molecule features. The NMR-extracted data (or \"NMReDATA\") includes: Chemical shift,scalar coupling, 2D correlation, assignment, etc. Find more in the paper at D. Jeannerat, Magn. Reson. in Chem., 2017, 55, 7-14."],
          "data": {
            "uri": "http://edamontology.org/format_3906"
          },
          "definition": "MReData is a text based data standard for processed NMR data. It is relying on SDF molecule data and allows to store assignments of NMR peaks to molecule features.  The NMR-extracted data (or \"NMReDATA\") includes: Chemical shift,scalar coupling, 2D correlation, assignment, etc.",
          "text": "NMReDATA"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3825"
          },
          "definition": "nmrML is an MSI supported XML-based open access format for metabolomics NMR raw and processed spectral data. It is accompanies by an nmrCV (controlled vocabulary) to allow ontology-based annotations.",
          "text": "nmrML"
        }],
        "data": {
          "uri": "http://edamontology.org/format_3824"
        },
        "definition": "Data format for raw data from a nuclear magnetic resonance (NMR) spectroscopy experiment.",
        "exact_synonyms": ["Nuclear magnetic resonance spectroscopy data format"],
        "is_format_of": ["http://edamontology.org/data_3488"],
        "narrow_synonyms": ["NMR peak assignment data", "Raw NMR data format", "NMR processed data format", "Processed NMR data format", "NMR raw data format"],
        "text": "NMR data format"
      }, {
        "children": [{
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_3286"
            },
            "definition": "The PED file describes individuals and genetic data and is used by the Plink package.",
            "exact_synonyms": ["Plink PED"],
            "text": "PED"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3285"
            },
            "definition": "The MAP file describes SNPs and is used by the Plink package.",
            "exact_synonyms": ["Plink MAP"],
            "text": "MAP"
          }],
          "data": {
            "uri": "http://edamontology.org/format_3288"
          },
          "definition": "The PED/MAP file describes data used by the Plink package.",
          "exact_synonyms": ["Plink PED/MAP"],
          "text": "PED/MAP"
        }],
        "data": {
          "uri": "http://edamontology.org/format_3287"
        },
        "definition": "Data format for a metadata on an individual and their genetic data.",
        "text": "Individual genetic data format"
      }, {
        "children": [{
          "comment": ["GROMACS itp files are used also to define position restrictions on the molecule, or to define the force field parameters for a particular ligand."],
          "data": {
            "uri": "http://edamontology.org/format_3883"
          },
          "definition": "GROMACS itp files (include topology) contain structure topology information, and are tipically included in GROMACS topology files (GROMACS top). Itp files are used to define individual (or multiple) components of a topology as a separate file. This is particularly useful if there is a molecule that is used frequently, and also reduces the size of the system topology file, splitting it in different parts.",
          "text": "GROMACS itp"
        }, {
          "comment": ["The high similarity in the functional form of the two potential energy functions used by AMBER and CHARMM force-fields gives rise to the possible use of one force-field within the other MD engine. Therefore, the conversion of PSF files to AMBER Prmtop format is possible with the use of AMBER chamber (CHARMM - AMBER) program."],
          "data": {
            "uri": "http://edamontology.org/format_3882"
          },
          "definition": "X-Plor Protein Structure Files (PSF) are structure topology files used by NAMD and CHARMM molecular simulations programs. PSF files contain six main sections of interest: atoms, bonds, angles, dihedrals, improper dihedrals (force terms used to maintain planarity) and cross-terms.",
          "text": "PSF"
        }, {
          "comment": ["version 7 is written to distinguish it from old versions of AMBER Prmtop. Similarly to HDF5, it is a completely different format, according to AMBER group: a drastic change to the file format occurred with the 2004 release of Amber 7 (http://ambermd.org/prmtop.pdf)", "It can be modified manually, but as the size of the system increases, the hand-editing becomes increasingly complex. AMBER Parameter-Topology file format is used extensively by the AMBER software suite and is referred to as the Prmtop file for short."],
          "data": {
            "uri": "http://edamontology.org/format_3881"
          },
          "definition": "AMBER Prmtop file (version 7) is a structure topology text file divided in several sections designed to be parsed easily using simple Fortran code. Each section contains particular topology information, such as atom name, charge, mass, angles, dihedrals, etc.",
          "exact_synonyms": ["Prmtop", "AMBER Parm7", "Prmtop7", "AMBER Parm", "Parm7"],
          "text": "AMBER top"
        }, {
          "comment": ["There is currently no tool available for conversion between GROMACS topology format and other formats, due to the internal differences in both approaches. There is, however, a method to convert small molecules parameterized with AMBER force-field into GROMACS format, allowing simulations of these systems with GROMACS MD package."],
          "data": {
            "uri": "http://edamontology.org/format_3887"
          },
          "definition": "Format of CHARMM Residue Topology Files (RTF), which define groups by including the atoms, the properties of the group, and bond and charge information.",
          "text": "CHARMM rtf"
        }, {
          "comment": ["There is currently no tool available for conversion between GROMACS topology format and other formats, due to the internal differences in both approaches. There is, however, a method to convert small molecules parameterized with AMBER force-field into GROMACS format, allowing simulations of these systems with GROMACS MD package."],
          "data": {
            "uri": "http://edamontology.org/format_3880"
          },
          "definition": "GROMACS MD package top textual files define an entire structure system topology, either directly, or by including itp files.",
          "text": "GROMACS top"
        }],
        "comment": ["Many different file formats exist describing structural molecular topology. Tipically, each MD package or simulation software works with their own implementation (e.g. GROMACS top, CHARMM psf, AMBER prmtop)."],
        "data": {
          "uri": "http://edamontology.org/format_3879"
        },
        "definition": "Format of topology files; containing the static information of a structure molecular system that is needed for a molecular simulation.",
        "is_format_of": ["http://edamontology.org/data_3872"],
        "narrow_synonyms": ["NA topology format", "CG topology format", "MD topology format", "Protein topology format"],
        "text": "Topology format"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_2352"
          },
          "definition": "BioXSD-schema-based XML format of sequence-based data and some other common data - sequence records, alignments, feature records, references to resources, and more - optimised for integrative bioinformatics, Web services, and object-oriented programming.",
          "exact_synonyms": ["BioXSD XML", "BioXSD+XML", "BioXSD XML format", "BioXSD in XML", "BioXSD in XML format"],
          "is_format_of": ["http://edamontology.org/data_1772", "http://edamontology.org/data_1255", "http://edamontology.org/data_3108", "http://edamontology.org/data_0863", "http://edamontology.org/data_2044"],
          "text": "BioXSD (XML)"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3853"
          },
          "definition": "XML format for the UniParc database.",
          "text": "UniParc XML"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3773"
          },
          "definition": "BioYAML is a BioXSD-schema-based YAML format of sequence-based data and some other common data - sequence records, alignments, feature records, references to resources, and more - optimised for integrative bioinformatics, web APIs, human readability and editting, and object-oriented programming.",
          "exact_synonyms": ["BioYAML format", "BioXSD YAML format", "BioYAML format (BioXSD)", "BioXSD in YAML format", "BioXSD BioYAML format", "BioYAML (BioXSD data model)", "BioXSD|BioJSON|BioYAML BioYAML", "BioXSD YAML", "BioXSD|GTrack BioYAML", "BioXSD/GTrack BioYAML", "BioXSD in YAML", "BioXSD BioYAML", "BioYAML (BioXSD)", "BioXSD+YAML"],
          "is_format_of": ["http://edamontology.org/data_0863", "http://edamontology.org/data_1255", "http://edamontology.org/data_1772", "http://edamontology.org/data_3108", "http://edamontology.org/data_2044"],
          "text": "BioYAML"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3984"
          },
          "definition": "Format of QMAP files generated for methylation data from an internal BGI pipeline.",
          "text": "QMAP"
        }, {
          "children": [{
            "children": [{
              "children": [{
                "data": {
                  "uri": "http://edamontology.org/format_1963"
                },
                "definition": "UniProtKB entry sequence format.",
                "exact_synonyms": ["SwissProt format", "UniProt format"],
                "text": "UniProtKB format"
              }],
              "data": {
                "uri": "http://edamontology.org/format_2187"
              },
              "definition": "A text sequence format resembling uniprotkb entry format.",
              "text": "UniProt-like (text)"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_3770"
              },
              "definition": "UniProtKB XML sequence features format is an XML format available for downloading UniProt entries.",
              "exact_synonyms": ["UniProtKB XML format", "UniProt XML format", "UniProt XML"],
              "text": "UniProtKB XML"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_3771"
              },
              "definition": "UniProtKB RDF sequence features format is an RDF format available for downloading UniProt entries (in RDF/XML).",
              "exact_synonyms": ["UniProt RDF format", "UniProtKB RDF format", "UniProt RDF"],
              "narrow_synonyms": ["UniProt RDF/XML", "UniProtKB RDF/XML format", "UniProtKB RDF/XML", "UniProt RDF/XML format"],
              "text": "UniProtKB RDF"
            }],
            "data": {
              "uri": "http://edamontology.org/format_2547"
            },
            "definition": "A sequence format resembling uniprotkb entry format.",
            "text": "uniprotkb-like format"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3776"
            },
            "definition": "BTrack is an HDF5-based binary format for genome or sequence feature tracks and their collections, suitable for integrative multi-track analysis. BTrack is a binary, compressed alternative to the GTrack and GSuite formats.",
            "exact_synonyms": ["GTrack|BTrack|GSuite BTrack", "BTrack (GTrack ecosystem of formats)", "BioXSD|GTrack BTrack", "GTrack|GSuite|BTrack BTrack", "BTrack format", "BioXSD/GTrack BTrack"],
            "text": "BTrack"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/format_1927"
              },
              "definition": "EMBL entry format.",
              "exact_synonyms": ["EMBL", "EMBL sequence format"],
              "text": "EMBL format"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_1936"
              },
              "definition": "Genbank entry format.",
              "exact_synonyms": ["GenBank"],
              "text": "GenBank format"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_3164"
              },
              "definition": "GTrack is a generic and optimised tabular format for genome or sequence feature tracks. GTrack unifies the power of other track formats (e.g. GFF3, BED, WIG), and while optimised in size, adds more flexibility, customisation, and automation (\"machine understandability\").",
              "exact_synonyms": ["GTrack|GSuite|BTrack GTrack", "GTrack|BTrack|GSuite GTrack", "BioXSD/GTrack GTrack", "BioXSD|GTrack GTrack", "GTrack format"],
              "text": "GTrack"
            }, {
              "children": [{
                "children": [{
                  "data": {
                    "uri": "http://edamontology.org/format_1938"
                  },
                  "definition": "GFF feature file format with sequence in the header.",
                  "text": "GFF2-seq"
                }],
                "data": {
                  "uri": "http://edamontology.org/format_1974"
                },
                "definition": "General Feature Format (GFF) of sequence features.",
                "text": "GFF2"
              }, {
                "data": {
                  "uri": "http://edamontology.org/format_2306"
                },
                "definition": "Gene Transfer Format (GTF), a restricted version of GFF.",
                "text": "GTF"
              }, {
                "children": [{
                  "data": {
                    "uri": "http://edamontology.org/format_1939"
                  },
                  "definition": "GFF3 feature file format with sequence.",
                  "text": "GFF3-seq"
                }, {
                  "data": {
                    "uri": "http://edamontology.org/format_3019"
                  },
                  "definition": "Genome Variation Format (GVF). A GFF3-compatible format with defined header and attribute tags for sequence variation.",
                  "text": "GVF"
                }, {
                  "comment": ["mirGFF3 is a specialisation of GFF3; produced by small-RNA-Seq analysis workflows, usable and convertible with the miRTop API (https://mirtop.readthedocs.io/en/latest/), and consumable by tools for downstream analysis."],
                  "data": {
                    "uri": "http://edamontology.org/format_3864"
                  },
                  "definition": "mirGFF3 is a common format for microRNA data resulting from small-RNA RNA-Seq workflows.",
                  "exact_synonyms": ["miRTop format"],
                  "text": "mirGFF3"
                }],
                "data": {
                  "uri": "http://edamontology.org/format_1975"
                },
                "definition": "Generic Feature Format version 3 (GFF3) of sequence features.",
                "text": "GFF3"
              }],
              "data": {
                "uri": "http://edamontology.org/format_2305"
              },
              "definition": "GFF feature format (of indeterminate version).",
              "text": "GFF"
            }, {
              "data": {
                "uri": "http://edamontology.org/format_3701"
              },
              "definition": "A five-column, tab-delimited table of feature locations and qualifiers for importing annotation into an existing Sequin submission (an NCBI tool for submitting and updating GenBank entries).",
              "text": "Sequin format"
            }],
            "data": {
              "uri": "http://edamontology.org/format_2206"
            },
            "definition": "Text format for a sequence feature table.",
            "text": "Sequence feature table format (text)"
          }, {
            "children": [{
              "data": {
                "uri": "http://edamontology.org/format_1978"
              },
              "definition": "DAS GFF (XML) feature format.",
              "exact_synonyms": ["das feature", "DASGFF feature"],
              "text": "DASGFF"
            }],
            "data": {
              "uri": "http://edamontology.org/format_2553"
            },
            "definition": "XML format for a sequence feature table.",
            "text": "Sequence feature table format (XML)"
          }],
          "data": {
            "uri": "http://edamontology.org/format_2548"
          },
          "definition": "Format for a sequence feature table.",
          "is_format_of": ["http://edamontology.org/data_1255"],
          "text": "Sequence feature table format"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3851"
          },
          "definition": "Tree structure of Protein Sequence Database Markup Language generated using Matra software.",
          "text": "PSDML"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3774"
          },
          "definition": "BioJSON is a JSON format of single multiple sequence alignments, with their annotations, features, and custom visualisation and application settings for the Jalview workbench.",
          "exact_synonyms": ["JSON (Jalview)", "Jalview JSON", "JSON format (Jalview)", "Jalview JSON format", "Jalview BioJSON format", "BioJSON format (Jalview)", "Jalview BioJSON"],
          "is_format_of": ["http://edamontology.org/data_1255", "http://edamontology.org/data_0863"],
          "text": "BioJSON (Jalview)"
        }, {
          "children": [{
            "comment": ["Holds a tab-delimited chromosome /start /end / datavalue dataset."],
            "data": {
              "uri": "http://edamontology.org/format_3583"
            },
            "definition": "The bedGraph format allows display of continuous-valued data in track format. This display type is useful for probability scores and transcriptome data",
            "text": "bedgraph"
          }, {
            "comment": ["Typically generated by Multiz and TBA aligners; can be displayed in a genome browser like a sequence annotation track. This should not be confused with MIRA Assembly Format or Mutation Annotation Format."],
            "data": {
              "uri": "http://edamontology.org/format_3008"
            },
            "definition": "Multiple Alignment Format (MAF) supporting alignments of whole genomes with rearrangements, directions, multiple pieces to the alignment, and so forth.",
            "text": "MAF"
          }, {
            "children": [{
              "comment": ["Galaxy allows BED files to contain non-standard fields beyond the first 3 columns, some other implementations do not."],
              "data": {
                "uri": "http://edamontology.org/format_3587"
              },
              "definition": "Tabular format of chromosome names and sizes used by Galaxy.",
              "text": "chrominfo"
            }, {
              "children": [{
                "children": [{
                  "children": [{
                    "comment": ["Format that covers both the broad peak format and narrow peak format from ENCODE."],
                    "data": {
                      "uri": "http://edamontology.org/format_3613"
                    },
                    "definition": "Human ENCODE narrow peak format.",
                    "text": "ENCODE narrow peak format"
                  }, {
                    "data": {
                      "uri": "http://edamontology.org/format_3614"
                    },
                    "definition": "Human ENCODE broad peak format.",
                    "text": "ENCODE broad peak format"
                  }],
                  "comment": ["Format that covers both the broad peak format and narrow peak format from ENCODE."],
                  "data": {
                    "uri": "http://edamontology.org/format_3612"
                  },
                  "definition": "Human ENCODE peak format.",
                  "text": "ENCODE peak format"
                }],
                "comment": ["Tab delimited data in strict BED format - no non-standard columns allowed; column count forced to 6"],
                "data": {
                  "uri": "http://edamontology.org/format_3585"
                },
                "definition": "BED file format where each feature is described by chromosome, start, end, name, score, and strand.",
                "text": "bed6"
              }, {
                "comment": ["Tab delimited data in strict BED format - no non-standard columns allowed; column count forced to 12"],
                "data": {
                  "uri": "http://edamontology.org/format_3586"
                },
                "definition": "A BED file where each feature is described by all twelve columns.",
                "text": "bed12"
              }],
              "comment": ["Galaxy allows BED files to contain non-standard fields beyond the first 3 columns, some other implementations do not."],
              "data": {
                "uri": "http://edamontology.org/format_3584"
              },
              "definition": "Browser Extensible Data (BED) format of sequence annotation track that strictly does not contain non-standard fields beyond the first 3 columns.",
              "text": "bedstrict"
            }],
            "comment": ["BED detail format includes 2 additional columns (http://genome.ucsc.edu/FAQ/FAQformat#format1.7) and BED 15 includes 3 additional columns for experiment scores (http://genomewiki.ucsc.edu/index.php/Microarray_track)."],
            "data": {
              "uri": "http://edamontology.org/format_3003"
            },
            "definition": "Browser Extensible Data (BED) format of sequence annotation track, typically to be displayed in a genome browser.",
            "text": "BED"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3004"
            },
            "definition": "bigBed format for large sequence annotation tracks, similar to textual BED format.",
            "text": "bigBed"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3012"
            },
            "definition": "Personal Genome SNP (pgSnp) format for sequence variation tracks (indels and polymorphisms), supported by the UCSC Genome Browser.",
            "text": "pgSnp"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3812"
            },
            "definition": "The GEN file format contains genetic data and describes SNPs.",
            "exact_synonyms": ["Genotype file format"],
            "text": "GEN"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3991"
            },
            "definition": "A declaration file format for UCSC browsers track dataset display charateristics.",
            "text": "TrackDB"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3164"
            },
            "definition": "GTrack is a generic and optimised tabular format for genome or sequence feature tracks. GTrack unifies the power of other track formats (e.g. GFF3, BED, WIG), and while optimised in size, adds more flexibility, customisation, and automation (\"machine understandability\").",
            "exact_synonyms": ["GTrack|GSuite|BTrack GTrack", "GTrack|BTrack|GSuite GTrack", "BioXSD/GTrack GTrack", "BioXSD|GTrack GTrack", "GTrack format"],
            "text": "GTrack"
          }, {
            "comment": ["Used for tracks/track views within galaxy."],
            "data": {
              "uri": "http://edamontology.org/format_3588"
            },
            "definition": "Custom Sequence annotation track format used by Galaxy.",
            "text": "customtrack"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3006"
            },
            "definition": "bigWig format for large sequence annotation tracks that consist of a value for each sequence position. Similar to textual WIG format.",
            "text": "bigWig"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3007"
            },
            "definition": "PSL format of alignments, typically generated by BLAT or psLayout. Can be displayed in a genome browser like a sequence annotation track.",
            "text": "PSL"
          }, {
            "comment": ["genePred format has 3 main variations (http://genome.ucsc.edu/FAQ/FAQformat#format9 http://www.broadinstitute.org/software/igv/genePred). They reflect UCSC Browser DB tables."],
            "data": {
              "uri": "http://edamontology.org/format_3011"
            },
            "definition": "genePred table format for gene prediction tracks.",
            "text": "genePred"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3776"
            },
            "definition": "BTrack is an HDF5-based binary format for genome or sequence feature tracks and their collections, suitable for integrative multi-track analysis. BTrack is a binary, compressed alternative to the GTrack and GSuite formats.",
            "exact_synonyms": ["GTrack|BTrack|GSuite BTrack", "BTrack (GTrack ecosystem of formats)", "BioXSD|GTrack BTrack", "GTrack|GSuite|BTrack BTrack", "BTrack format", "BioXSD/GTrack BTrack"],
            "text": "BTrack"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3827"
            },
            "definition": ". proBED is an adaptation of BED (format_3003), which was extended to meet specific requirements entailed by proteomics data.",
            "text": "proBED"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3005"
            },
            "definition": "Wiggle format (WIG) of a sequence annotation track that consists of a value for each sequence position. Typically to be displayed in a genome browser.",
            "text": "WIG"
          }],
          "data": {
            "uri": "http://edamontology.org/format_2919"
          },
          "definition": "Format of a sequence annotation track.",
          "is_format_of": ["http://edamontology.org/data_3002"],
          "text": "Sequence annotation track format"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3775"
          },
          "definition": "GSuite is a tabular format for collections of genome or sequence feature tracks, suitable for integrative multi-track analysis. GSuite contains links to genome/sequence tracks, with additional metadata.",
          "exact_synonyms": ["BioXSD|GTrack GSuite", "GSuite (GTrack ecosystem of formats)", "BioXSD/GTrack GSuite", "GSuite format", "GTrack|BTrack|GSuite GSuite", "GTrack|GSuite|BTrack GSuite"],
          "text": "GSuite"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3983"
          },
          "definition": "The NET file format is used to describe the data that underlie the net alignment annotations in the UCSC Genome Browser.",
          "text": "NET"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1979"
          },
          "definition": "EMBOSS debugging trace feature format of full internal data content.",
          "text": "debug-feat"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3776"
          },
          "definition": "BTrack is an HDF5-based binary format for genome or sequence feature tracks and their collections, suitable for integrative multi-track analysis. BTrack is a binary, compressed alternative to the GTrack and GSuite formats.",
          "exact_synonyms": ["GTrack|BTrack|GSuite BTrack", "BTrack (GTrack ecosystem of formats)", "BioXSD|GTrack BTrack", "GTrack|GSuite|BTrack BTrack", "BTrack format", "BioXSD/GTrack BTrack"],
          "text": "BTrack"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3772"
          },
          "definition": "BioJSON is a BioXSD-schema-based JSON format of sequence-based data and some other common data - sequence records, alignments, feature records, references to resources, and more - optimised for integrative bioinformatics, web applications and APIs, and object-oriented programming.",
          "exact_synonyms": ["BioXSD BioJSON", "BioXSD+JSON", "BioXSD BioJSON format", "BioXSD in JSON", "BioXSD in JSON format", "BioXSD|GTrack BioJSON", "BioXSD JSON", "BioJSON format (BioXSD)", "BioXSD|BioJSON|BioYAML BioJSON", "BioJSON (BioXSD data model)", "BioXSD/GTrack BioJSON", "BioXSD JSON format"],
          "is_format_of": ["http://edamontology.org/data_2044", "http://edamontology.org/data_1772", "http://edamontology.org/data_0863", "http://edamontology.org/data_3108", "http://edamontology.org/data_1255"],
          "text": "BioJSON (BioXSD)"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3854"
          },
          "definition": "XML format for the UniRef reference clusters.",
          "text": "UniRef XML"
        }],
        "data": {
          "uri": "http://edamontology.org/format_1920"
        },
        "definition": "Data format for molecular sequence feature information.",
        "is_format_of": ["http://edamontology.org/data_1255"],
        "text": "Sequence feature annotation format"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_1295"
          },
          "definition": "Report format for tandem repeats in a nucleotide sequence (format generated by the Sanger Centre quicktandem program).",
          "text": "quicktandem"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1297"
          },
          "definition": "Report format for tandem repeats in a sequence (an EMBOSS report format).",
          "text": "EMBOSS repeat"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1296"
          },
          "definition": "Report format for inverted repeats in a nucleotide sequence (format generated by the Sanger Centre inverted program).",
          "text": "Sanger inverted repeats"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2155"
        },
        "definition": "Format used for map of repeats in molecular (typically nucleotide) sequences.",
        "text": "Sequence features (repeats) format"
      }, {
        "children": [{
          "comment": ["GROMACS itp files are used also to define position restrictions on the molecule, or to define the force field parameters for a particular ligand."],
          "data": {
            "uri": "http://edamontology.org/format_3883"
          },
          "definition": "GROMACS itp files (include topology) contain structure topology information, and are tipically included in GROMACS topology files (GROMACS top). Itp files are used to define individual (or multiple) components of a topology as a separate file. This is particularly useful if there is a molecule that is used frequently, and also reduces the size of the system topology file, splitting it in different parts.",
          "text": "GROMACS itp"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3910"
          },
          "definition": "Format of trr files that contain the trajectory of a simulation experiment used by GROMACS.",
          "text": "trr"
        }, {
          "comment": ["The high similarity in the functional form of the two potential energy functions used by AMBER and CHARMM force-fields gives rise to the possible use of one force-field within the other MD engine. Therefore, the conversion of PSF files to AMBER Prmtop format is possible with the use of AMBER chamber (CHARMM - AMBER) program."],
          "data": {
            "uri": "http://edamontology.org/format_3882"
          },
          "definition": "X-Plor Protein Structure Files (PSF) are structure topology files used by NAMD and CHARMM molecular simulations programs. PSF files contain six main sections of interest: atoms, bonds, angles, dihedrals, improper dihedrals (force terms used to maintain planarity) and cross-terms.",
          "text": "PSF"
        }, {
          "comment": ["version 7 is written to distinguish it from old versions of AMBER Prmtop. Similarly to HDF5, it is a completely different format, according to AMBER group: a drastic change to the file format occurred with the 2004 release of Amber 7 (http://ambermd.org/prmtop.pdf)", "It can be modified manually, but as the size of the system increases, the hand-editing becomes increasingly complex. AMBER Parameter-Topology file format is used extensively by the AMBER software suite and is referred to as the Prmtop file for short."],
          "data": {
            "uri": "http://edamontology.org/format_3881"
          },
          "definition": "AMBER Prmtop file (version 7) is a structure topology text file divided in several sections designed to be parsed easily using simple Fortran code. Each section contains particular topology information, such as atom name, charge, mass, angles, dihedrals, etc.",
          "exact_synonyms": ["Prmtop", "AMBER Parm7", "Prmtop7", "AMBER Parm", "Parm7"],
          "text": "AMBER top"
        }, {
          "children": [{
            "comment": ["pdbnuc format in EMBOSS."],
            "data": {
              "uri": "http://edamontology.org/format_1951"
            },
            "definition": "PDB nucleotide sequence format (ATOM lines).",
            "text": "pdbatomnuc"
          }, {
            "comment": ["pdbseq format in EMBOSS."],
            "data": {
              "uri": "http://edamontology.org/format_1953"
            },
            "definition": "PDB sequence format (SEQRES lines).",
            "text": "pdbseqres"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1478"
            },
            "definition": "Entry format of PDB database in PDBML (XML) format.",
            "text": "PDBML"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1477"
            },
            "definition": "Entry format of PDB database in mmCIF format.",
            "text": "mmCIF"
          }, {
            "comment": ["pdb format in EMBOSS."],
            "data": {
              "uri": "http://edamontology.org/format_1950"
            },
            "definition": "PDB sequence format (ATOM lines).",
            "text": "pdbatom"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1476"
            },
            "definition": "Entry format of PDB database in PDB format.",
            "exact_synonyms": ["PDB format"],
            "text": "PDB"
          }, {
            "comment": ["pdbnucseq format in EMBOSS."],
            "data": {
              "uri": "http://edamontology.org/format_1952"
            },
            "definition": "PDB nucleotide sequence format (SEQRES lines).",
            "text": "pdbseqresnuc"
          }],
          "data": {
            "uri": "http://edamontology.org/format_1475"
          },
          "definition": "Format of an entry (or part of an entry) from the PDB database.",
          "exact_synonyms": ["PDB entry format"],
          "is_format_of": ["http://edamontology.org/data_3870", "http://edamontology.org/data_0883"],
          "text": "PDB database entry format"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3886"
          },
          "definition": "AMBER coordinate/restart file with 6 coordinates per line and decimal format F12.7 (fixed point notation with field width 12 and 7 decimal places)",
          "exact_synonyms": ["restrt", "rst7"],
          "text": "RST"
        }, {
          "comment": ["There is currently no tool available for conversion between GROMACS topology format and other formats, due to the internal differences in both approaches. There is, however, a method to convert small molecules parameterized with AMBER force-field into GROMACS format, allowing simulations of these systems with GROMACS MD package."],
          "data": {
            "uri": "http://edamontology.org/format_3887"
          },
          "definition": "Format of CHARMM Residue Topology Files (RTF), which define groups by including the atoms, the properties of the group, and bond and charge information.",
          "text": "CHARMM rtf"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3878"
          },
          "definition": "AMBER trajectory (also called mdcrd), with 10 coordinates per line and format F8.3 (fixed point notation with field width 8 and 3 decimal places).",
          "exact_synonyms": ["inpcrd", "AMBER trajectory format"],
          "text": "mdcrd"
        }, {
          "comment": ["There is currently no tool available for conversion between GROMACS topology format and other formats, due to the internal differences in both approaches. There is, however, a method to convert small molecules parameterized with AMBER force-field into GROMACS format, allowing simulations of these systems with GROMACS MD package."],
          "data": {
            "uri": "http://edamontology.org/format_3880"
          },
          "definition": "GROMACS MD package top textual files define an entire structure system topology, either directly, or by including itp files.",
          "text": "GROMACS top"
        }, {
          "comment": ["XYZ files are structured in this way:  First line contains the number of atoms in the file.  Second line contains a title, comment, or filename. Remaining lines contain atom information. Each line starts with the element symbol, followed by x, y and z coordinates in angstroms separated by whitespace. Multiple molecules or frames can be contained within one file, so it supports trajectory storage. XYZ files can be directly represented by a molecular viewer, as they contain all the basic information needed to build the 3D model."],
          "data": {
            "uri": "http://edamontology.org/format_3877"
          },
          "definition": "The XYZ chemical file format is widely supported by many programs, although many slightly different XYZ file formats coexist (Tinker XYZ, UniChem XYZ, etc.). Basic information stored for each atom in the system are x, y and z coordinates and atom element/atomic number.",
          "text": "XYZ"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2033"
        },
        "definition": "Data format for a molecular tertiary structure.",
        "text": "Tertiary structure format"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_3915"
          },
          "definition": "The Zarr format is an implementation of chunked, compressed, N-dimensional arrays for storing data.",
          "is_format_of": ["http://edamontology.org/data_2535", "http://edamontology.org/data_3112"],
          "text": "Zarr"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3913"
          },
          "definition": "The Loom file format is based on HDF5, a standard for storing large numerical datasets. The Loom format is designed to efficiently hold large omics datasets. Typically, such data takes the form of a large matrix of numbers, along with metadata for the rows and columns.",
          "is_format_of": ["http://edamontology.org/data_2535", "http://edamontology.org/data_3112"],
          "text": "Loom"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3709"
          },
          "definition": "Tab-delimited text files of GenePattern that contain a column for each sample, a row for each gene, and an expression value for each gene in each sample.",
          "exact_synonyms": ["GCT format", "Res format"],
          "text": "GCT/Res format"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3578"
          },
          "definition": "Proprietary file format for (raw) BeadArray data used by genomewide profiling platforms from Illumina Inc. This format is output directly from the scanner and stores summary intensities for each probe-type on an array.",
          "is_format_of": ["http://edamontology.org/data_3110"],
          "text": "IDAT"
        }, {
          "comment": ["For example a 1kb transcript with 1000 alignments in a sample of 10 million reads (out of which 8 million reads can be mapped) will have RPKM = 1000/(1 * 8) = 125"],
          "data": {
            "uri": "http://edamontology.org/format_3980"
          },
          "definition": "Tab-delimited format for gene expression levels table, calculated as Reads Per Kilobase per Million (RPKM) mapped reads.",
          "exact_synonyms": ["Gene expression levels table format"],
          "text": "RPKM"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3477"
          },
          "definition": "Format of the cytoscape input file of gene expression ratios or values are specified over one or more experiments.",
          "text": "Cytoscape input file format"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1637"
          },
          "definition": "Format of Affymetrix data file of raw image data.",
          "exact_synonyms": ["Affymetrix image data file format"],
          "is_format_of": ["http://edamontology.org/data_1714"],
          "text": "dat"
        }, {
          "comment": ["ISA-TAB is based on MAGE-TAB. Other than tabular, the ISA model can also be represented in RDF, and in JSON (compliable with a set of defined JSON Schemata)."],
          "data": {
            "uri": "http://edamontology.org/format_3687"
          },
          "definition": "The Investigation / Study / Assay (ISA) tab-delimited (TAB) format incorporates metadata from\nexperiments employing a combination of technologies.",
          "text": "ISA-TAB"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3580"
          },
          "definition": "Reporter Code Count-A data file (.csv) output by the Nanostring nCounter Digital Analyzer, which contains gene sample information, probe information and probe counts.",
          "text": "rcc"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3162"
          },
          "definition": "MAGE-TAB textual format for microarray expression data, standardised by MGED (now FGED).",
          "is_format_of": ["http://edamontology.org/data_3111"],
          "text": "MAGE-TAB"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3161"
          },
          "definition": "MAGE-ML XML format for microarray expression data, standardised by MGED (now FGED).",
          "is_format_of": ["http://edamontology.org/data_3111"],
          "text": "MAGE-ML"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1638"
          },
          "definition": "Format of Affymetrix data file of information about (raw) expression levels of the individual probes.",
          "exact_synonyms": ["Affymetrix probe raw data format"],
          "is_format_of": ["http://edamontology.org/data_3110"],
          "text": "cel"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1644"
          },
          "definition": "Format of Affymetrix data file of information about (normalised) expression levels of the individual probes.",
          "exact_synonyms": ["Affymetrix probe normalised data format"],
          "is_format_of": ["http://edamontology.org/data_3111"],
          "text": "CHP"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3916"
          },
          "definition": "The Matrix Market matrix (MTX) format stores numerical or pattern matrices in a dense (array format) or sparse (coordinate format) representation.",
          "is_format_of": ["http://edamontology.org/data_3112", "http://edamontology.org/data_2535"],
          "text": "MTX"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2058"
        },
        "definition": "Format of a file of gene expression data, e.g. a gene expression matrix or profile.",
        "exact_synonyms": ["Gene expression data format"],
        "is_format_of": ["http://edamontology.org/data_2603"],
        "text": "Gene expression report format"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_3665"
          },
          "definition": "A list of k-mers and their occurences in a dataset. Can also be used as an implicit De Bruijn graph.",
          "text": "K-mer countgraph"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3618"
          },
          "definition": "XML-based format used to store graph descriptions within Galaxy.",
          "text": "xgmml"
        }],
        "data": {
          "uri": "http://edamontology.org/format_3617"
        },
        "definition": "Data format for graph data.",
        "text": "Graph format"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_1740"
          },
          "definition": "The format of iHOP (Information Hyperlinked over Proteins) text-mining result.",
          "text": "iHOP format"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2021"
        },
        "definition": "Data format of a report from text mining.",
        "is_format_of": ["http://edamontology.org/data_0972"],
        "text": "Text mining report format"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_1861"
          },
          "definition": "Map of a plasmid (circular DNA) in PlasMapper TextMap format.",
          "text": "PlasMapper TextMap"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2060"
        },
        "definition": "Format of a map of (typically one) molecular sequence annotated with features.",
        "is_format_of": ["http://edamontology.org/data_1274"],
        "text": "Map format"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_3250"
          },
          "definition": "spML is the format for describing proteomics sample processing, other than using gels, prior to mass spectrometric protein identification, standardised by HUPO PSI PS. It may also be applicable for metabolomics.",
          "text": "spML"
        }, {
          "comment": ["The focus of qcML is towards mass spectrometry based proteomics, but the format is suitable for metabolomics and sequencing as well."],
          "data": {
            "uri": "http://edamontology.org/format_3683"
          },
          "definition": "qcML is an XML format for quality-related data of mass spectrometry and other high-throughput measurements.",
          "text": "qcML"
        }, {
          "comment": ["ISA-TAB is based on MAGE-TAB. Other than tabular, the ISA model can also be represented in RDF, and in JSON (compliable with a set of defined JSON Schemata)."],
          "data": {
            "uri": "http://edamontology.org/format_3687"
          },
          "definition": "The Investigation / Study / Assay (ISA) tab-delimited (TAB) format incorporates metadata from\nexperiments employing a combination of technologies.",
          "text": "ISA-TAB"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3685"
          },
          "definition": "Simulation Experiment Description Markup Language (SED-ML) is an XML format for encoding simulation setups, according to the MIASE (Minimum Information About a Simulation Experiment) requirements.",
          "text": "SED-ML"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3684"
          },
          "definition": "PRIDE XML is an XML format for mass spectra, peptide and protein identifications, and metadata about a corresponding measurement, sample, experiment.",
          "text": "PRIDE XML"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3163"
          },
          "definition": "GCDML XML format for genome and metagenome metadata according to MIGS/MIMS/MIMARKS information standards, standardised by the Genomic Standards Consortium (GSC).",
          "text": "GCDML"
        }, {
          "comment": ["An OMEX file is a ZIP container that includes a manifest file, listing the content of the archive, an optional metadata file adding information about the archive and its content, and the files describing the model. OMEX is one of the standardised formats within COMBINE (Computational Modeling in Biology Network)."],
          "data": {
            "uri": "http://edamontology.org/format_3686"
          },
          "definition": "Open Modeling EXchange format (OMEX) is a ZIPped format for encapsulating all information necessary for a modeling and simulation project in systems biology.",
          "text": "COMBINE OMEX"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_1641"
            },
            "definition": "Affymetrix data file format for information about experimental conditions and protocols.",
            "exact_synonyms": ["Affymetrix experimental conditions data file format"],
            "text": "affymetrix-exp"
          }],
          "data": {
            "uri": "http://edamontology.org/format_2056"
          },
          "definition": "Format for information about a microarray experimental per se (not the data generated from that experiment).",
          "text": "Microarray experiment data format"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3249"
          },
          "definition": "GelML is the format for describing the process of gel electrophoresis, standardised by HUPO PSI PS.",
          "text": "GelML"
        }],
        "data": {
          "uri": "http://edamontology.org/format_3167"
        },
        "definition": "Data format for annotation on a laboratory experiment.",
        "is_format_of": ["http://edamontology.org/data_2531"],
        "text": "Experiment annotation format"
      }, {
        "children": [{
          "comment": ["The report (for example http://www.cathdb.info/domain/1cukA01) includes CATH codes for levels in the hierarchy for the domain, level descriptions and relevant data and links."],
          "data": {
            "uri": "http://edamontology.org/format_3100"
          },
          "definition": "Format of summary of domain classification information for a CATH domain.",
          "text": "CATH domain report format"
        }, {
          "comment": ["These are the parsable data files provided by SCOP."],
          "data": {
            "uri": "http://edamontology.org/format_3098"
          },
          "definition": "Format of raw SCOP domain classification data files.",
          "text": "Raw SCOP domain classification format"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3846"
          },
          "definition": "Output xml file from the InterProScan sequence analysis application.",
          "text": "InterProScan XML"
        }, {
          "comment": ["These are the parsable data files provided by CATH."],
          "data": {
            "uri": "http://edamontology.org/format_3099"
          },
          "definition": "Format of raw CATH domain classification data files.",
          "text": "Raw CATH domain classification format"
        }],
        "data": {
          "uri": "http://edamontology.org/format_3097"
        },
        "definition": "Format of data concerning the classification of the sequences and/or structures of protein structural domain(s).",
        "is_format_of": ["http://edamontology.org/data_0907"],
        "text": "Protein domain classification format"
      }, {
        "children": [{
          "comment": ["The general MF query format consists of a series of valid atomic symbols, with an optional number or range."],
          "data": {
            "uri": "http://edamontology.org/format_1198"
          },
          "definition": "Chemical structure specified by Molecular Formula (MF), including a count of each element in a compound.",
          "text": "mf"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1197"
          },
          "definition": "Chemical structure specified in IUPAC International Chemical Identifier (InChI) line notation.",
          "text": "InChI"
        }, {
          "comment": ["An InChIKey identifier is not human- nor machine-readable but is more suitable for web searches than an InChI chemical structure specification."],
          "data": {
            "uri": "http://edamontology.org/format_1199"
          },
          "definition": "The InChIKey (hashed InChI) is a fixed length (25 character) condensed digital representation of an InChI chemical structure specification. It uniquely identifies a chemical compound.",
          "text": "InChIKey"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_1200"
            },
            "definition": "SMILES ARbitrary Target Specification (SMARTS) format for chemical structure specification, which is a subset of the SMILES line notation.",
            "text": "smarts"
          }],
          "data": {
            "uri": "http://edamontology.org/format_1196"
          },
          "definition": "Chemical structure specified in Simplified Molecular Input Line Entry System (SMILES) line notation.",
          "text": "SMILES"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3909"
          },
          "definition": "BpForms is a string format for concretely representing the primary structures of biopolymers, including DNA, RNA, and proteins that include non-canonical nucleic and amino acids. See https://www.bpforms.org for more information.",
          "is_format_of": ["http://edamontology.org/data_1255"],
          "text": "BpForms"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2035"
        },
        "definition": "Text format of a chemical formula.",
        "is_format_of": ["http://edamontology.org/data_0846"],
        "text": "Chemical formula format"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_1357"
          },
          "definition": "Format of an EMBOSS sequence pattern.",
          "text": "EMBOSS sequence pattern"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1360"
          },
          "definition": "A motif in the format generated by the MEME program.",
          "text": "meme-motif"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1356"
          },
          "definition": "Format of a regular expression pattern from the Prosite database.",
          "text": "prosite-pattern"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2068"
        },
        "definition": "Format of a sequence motif.",
        "is_format_of": ["http://edamontology.org/data_1353"],
        "text": "Sequence motif format"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_3242"
          },
          "definition": "Tabular Molecular Interaction format (MITAB), standardised by HUPO PSI MI.",
          "text": "PSI MI TAB (MITAB)"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_2304"
          },
          "definition": "Entry format (XML) for the STRING database of protein interaction.",
          "text": "STRING entry format (XML)"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_3243"
            },
            "definition": "Protein affinity format (PSI-PAR), standardised by HUPO PSI MI. It is compatible with PSI MI XML (MIF) and uses the same XML Schema.",
            "text": "PSI-PAR"
          }],
          "data": {
            "uri": "http://edamontology.org/format_3158"
          },
          "definition": "XML Molecular Interaction Format (MIF), standardised by HUPO PSI MI.",
          "exact_synonyms": ["MIF"],
          "text": "PSI MI XML (MIF)"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2054"
        },
        "definition": "Format for molecular interaction data.",
        "is_format_of": ["http://edamontology.org/data_0906"],
        "text": "Protein interaction format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_2052"
        },
        "definition": "Format for reports on a protein family.",
        "is_format_of": ["http://edamontology.org/data_0907"],
        "text": "Protein family report format"
      }, {
        "children": [{
          "comment": ["Data Type must include the distance matrix, probably as pairs of sequence identifiers with a distance (integer or float)."],
          "data": {
            "uri": "http://edamontology.org/format_1423"
          },
          "definition": "Format of PHYLIP phylogenetic distance matrix data.",
          "text": "Phylip distance matrix"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2067"
        },
        "definition": "Format of a matrix of genetic distances between molecular sequences.",
        "is_format_of": ["http://edamontology.org/data_0870"],
        "text": "Sequence distance matrix format"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_3311"
          },
          "definition": "RNA Markup Language.",
          "text": "RNAML"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_1458"
            },
            "definition": "Format of local RNA secondary structure components with free energy values, generated by the Vienna RNA package/server.",
            "text": "Vienna local RNA secondary structure format"
          }],
          "data": {
            "uri": "http://edamontology.org/format_1457"
          },
          "definition": "Format of RNA secondary structure in dot-bracket notation, originally generated by the Vienna RNA package/server.",
          "exact_synonyms": ["Vienna RNA secondary structure format", "Vienna RNA format"],
          "text": "Dot-bracket format"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3310"
          },
          "definition": "XRNA old input style format.",
          "text": "SS"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3309"
          },
          "definition": "File format of a CT (Connectivity Table) file from the RNAstructure package.",
          "exact_synonyms": ["Connect format", "Connectivity Table file format"],
          "text": "CT"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2076"
        },
        "definition": "Format for secondary structure (predicted or real) of an RNA molecule.",
        "is_format_of": ["http://edamontology.org/data_0880"],
        "text": "RNA secondary structure format"
      }, {
        "children": [{
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_1437"
            },
            "definition": "The format of an entry from the TreeFam database of phylogenetic data.",
            "text": "TreeFam format"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1912"
            },
            "definition": "Phylogenetic tree Nexus (text) format.",
            "text": "Nexus format"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1424"
            },
            "definition": "Dendrogram (tree file) format generated by ClustalW.",
            "text": "ClustalW dendrogram"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1911"
            },
            "definition": "Phylogenetic tree TreeCon (text) format.",
            "text": "TreeCon format"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1910"
            },
            "definition": "Phylogenetic tree Newick (text) format.",
            "exact_synonyms": ["nh"],
            "text": "newick"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1435"
            },
            "definition": "Phylogenetic tree data format used by the PHYLIP program.",
            "text": "Phylip tree format"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1436"
            },
            "definition": "The format of an entry from the TreeBASE database of phylogenetic data.",
            "text": "TreeBASE format"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1425"
            },
            "definition": "Raw data file format used by Phylip from which a phylogenetic tree is directly generated or plotted.",
            "text": "Phylip tree raw"
          }],
          "data": {
            "uri": "http://edamontology.org/format_2556"
          },
          "definition": "Text format for a phylogenetic tree.",
          "text": "Phylogenetic tree format (text)"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_3159"
            },
            "definition": "phyloXML is a standardised XML format for phylogenetic trees, networks, and associated data.",
            "text": "phyloXML"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3160"
            },
            "definition": "NeXML is a standardised XML format for rich phyloinformatic data.",
            "text": "NeXML"
          }],
          "data": {
            "uri": "http://edamontology.org/format_2557"
          },
          "definition": "XML format for a phylogenetic tree.",
          "text": "Phylogenetic tree format (XML)"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2006"
        },
        "definition": "Data format for a phylogenetic tree.",
        "is_format_of": ["http://edamontology.org/data_0872"],
        "text": "Phylogenetic tree format"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_3596"
          },
          "definition": "The PPM format is a lowest common denominator color image file format.",
          "text": "ppm"
        }, {
          "comment": ["LSM files are the default data export for the Zeiss LSM series confocal microscopes (e.g. LSM 510, LSM 710). In addition to the image data, LSM files contain most imaging settings."],
          "data": {
            "uri": "http://edamontology.org/format_3988"
          },
          "definition": "Zeiss' proprietary image format based on TIFF.",
          "text": "LSM"
        }, {
          "comment": ["It is designed to be extremely easy to learn and write programs for."],
          "data": {
            "uri": "http://edamontology.org/format_3602"
          },
          "definition": "The PGM format is a lowest common denominator grayscale file format.",
          "text": "pgm"
        }, {
          "comment": ["The SVG specification is an open standard developed by the World Wide Web Consortium (W3C) since 1999."],
          "data": {
            "uri": "http://edamontology.org/format_3604"
          },
          "definition": "Scalable Vector Graphics (SVG) is an XML-based vector image format for two-dimensional graphics with support for interactivity and animation.",
          "exact_synonyms": ["Scalable Vector Graphics"],
          "text": "SVG"
        }, {
          "comment": ["Sequence of segments with markers. Begins with byte of 0xFF and follows by marker type."],
          "data": {
            "uri": "http://edamontology.org/format_3599"
          },
          "definition": "X PixMap (XPM) is an image file format used by the X Window System, it is intended primarily for creating icon pixmaps, and supports transparent pixels.",
          "text": "xpm"
        }, {
          "comment": ["IFUNC library reads and writes most uncompressed interchange versions of this format."],
          "data": {
            "uri": "http://edamontology.org/format_3593"
          },
          "definition": "IM is a format used by LabEye and other applications based on the IFUNC image processing library.",
          "text": "im"
        }, {
          "comment": ["PCD was developed by Kodak. A PCD file contains five different resolution (ranging from low to high) of a slide or film negative. Due to it PCD is often used by many photographers and graphics professionals for high-end printed applications."],
          "data": {
            "uri": "http://edamontology.org/format_3594"
          },
          "definition": "Photo CD format, which is the highest resolution format for images on a CD.",
          "text": "pcd"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3550"
          },
          "definition": "Text-based tagged file format for medical images generated using the MetaImage software package.",
          "exact_synonyms": ["Metalmage format"],
          "text": "mhd"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3600"
          },
          "definition": "RGB file format is the native raster graphics file format for Silicon Graphics workstations.",
          "text": "rgb"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3616"
          },
          "definition": "TAB-delimited genome position file index format.",
          "text": "tabix"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3838"
          },
          "definition": "Microsoft Powerpoint format.",
          "text": "pptx"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3990"
          },
          "definition": "Audio Video Interleaved (AVI) format is a multimedia container format for AVI files, that allows synchronous audio-with-video playback.",
          "exact_synonyms": ["Audio Video Interleaved"],
          "text": "AVI"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3595"
          },
          "definition": "PCX is an image file format that uses a simple form of run-length encoding. It is lossless.",
          "text": "pcx"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3597"
          },
          "definition": "PSD (Photoshop Document) is a proprietary file that allows the user to work with the images' individual layers even after the file has been saved.",
          "text": "psd"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3969"
          },
          "definition": "Vega is a visualization grammar, a declarative language for creating, saving, and sharing interactive visualization designs. With Vega, you can describe the visual appearance and interactive behavior of a visualization in a JSON format, and generate web-based views using Canvas or SVG.",
          "text": "Vega"
        }, {
          "comment": ["Texture files can create the appearance of different surfaces and can be applied to both 2D and 3D objects. Note the file extension .tex is also used for LaTex documents which are a completely different format and they are NOT interchangable."],
          "data": {
            "uri": "http://edamontology.org/format_3995"
          },
          "definition": "Bitmap image format used for storing textures.",
          "text": "Texture file format"
        }, {
          "comment": ["It iis expected to replace the Graphics Interchange Format (GIF)."],
          "data": {
            "uri": "http://edamontology.org/format_3603"
          },
          "definition": "PNG is a file format for image compression.",
          "text": "PNG"
        }, {
          "comment": ["The XBM format was replaced by XPM for X11 in 1989."],
          "data": {
            "uri": "http://edamontology.org/format_3598"
          },
          "definition": "X BitMap is a plain text binary image format used by the X Window System used for storing cursor and icon bitmaps used in the X GUI.",
          "text": "xbm"
        }, {
          "comment": ["The TIFF format is perhaps the most versatile and diverse bitmap format in existence. Its extensible nature and support for numerous data compression schemes allow developers to customize the TIFF format to fit any peculiar data storage needs."],
          "data": {
            "uri": "http://edamontology.org/format_3591"
          },
          "definition": "A versatile bitmap format.",
          "exact_synonyms": ["tiff"],
          "text": "TIFF"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3994"
          },
          "definition": "U3D (Universal 3D) is a compressed file format and data structure for 3D computer graphics. It contains 3D model information such as triangle meshes, lighting, shading, motion data, lines and points with color and structure.",
          "exact_synonyms": ["Universal 3D", "Universal 3D format"],
          "text": "U3D"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_4001"
          },
          "definition": "An open file format from the Neuroimaging Informatics Technology Initiative (NIfTI) commonly used to store brain imaging data obtained using Magnetic Resonance Imaging (MRI) methods.",
          "exact_synonyms": ["NIFTI"],
          "text": "NIFTI format"
        }, {
          "comment": ["OME develops open-source software and data format standards for the storage and manipulation of biological microscopy data. It is a joint project between universities, research establishments, industry and the software development community.", "An OME-TIFF dataset consists of one or more files in standard TIFF or BigTIFF format, with the file extension .ome.tif or .ome.tiff, and an identical (or in the case of multiple files, nearly identical) string of OME-XML metadata embedded in the ImageDescription tag of each file's first IFD (Image File Directory). BigTIFF file extensions are also permitted, with the file extension .ome.tf2, .ome.tf8 or .ome.btf, but note these file extensions are an addition to the original specification, and software using an older version of the specification may not be able to handle these file extensions."],
          "data": {
            "uri": "http://edamontology.org/format_3727"
          },
          "definition": "Image file format used by the Open Microscopy Environment (OME).",
          "text": "OME-TIFF"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3549"
          },
          "definition": "Medical image and metadata format of the Neuroimaging Informatics Technology Initiative.",
          "exact_synonyms": ["NIfTI-1 format"],
          "text": "nii"
        }, {
          "comment": ["Although it is based on Windows internal bitmap data structures, it is supported by many non-Windows and non-PC applications."],
          "data": {
            "uri": "http://edamontology.org/format_3592"
          },
          "definition": "Standard bitmap storage format in the Microsoft Windows environment.",
          "exact_synonyms": ["bmp"],
          "text": "BMP"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3548"
          },
          "definition": "Medical image format corresponding to the Digital Imaging and Communications in Medicine (DICOM) standard.",
          "text": "DICOM format"
        }, {
          "comment": ["Sequence of segments with markers. Begins with byte of 0xFF and follows by marker type."],
          "data": {
            "uri": "http://edamontology.org/format_3579"
          },
          "definition": "Joint Picture Group file format for lossy graphics file.",
          "exact_synonyms": ["jpeg", "JPEG"],
          "text": "JPG"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3986"
          },
          "definition": "The proprietary native video format of various Microsoft programs such as Windows Media Player.",
          "exact_synonyms": ["Windows Media Video format", "Windows movie file format"],
          "text": "WMV"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3551"
          },
          "definition": "Nearly Raw Rasta Data format designed to support scientific visualisation and image processing involving N-dimensional raster data.",
          "text": "nrrd"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3997"
          },
          "definition": "A digital multimedia container format most commonly used to store video and audio.",
          "exact_synonyms": ["MP4"],
          "text": "MPEG-4"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3970"
          },
          "definition": "Vega-Lite is a high-level grammar of interactive graphics. It provides a concise JSON syntax for rapidly generating visualizations to support analysis. Vega-Lite specifications can be compiled to Vega specifications.",
          "text": "Vega-lite"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3993"
          },
          "definition": "STL is a file format native to the stereolithography CAD software created by 3D Systems.  The format is used to save and share surface-rendered 3D images and also for 3D printing.",
          "exact_synonyms": ["stl"],
          "text": "Stereolithography format"
        }, {
          "comment": ["The SVG specification is an open standard developed by the World Wide Web Consortium (W3C) since 1999."],
          "data": {
            "uri": "http://edamontology.org/format_3605"
          },
          "definition": "Sun Raster is a raster graphics file format used on SunOS by Sun Microsystems",
          "text": "rast"
        }, {
          "comment": ["BAM files are compressed using a variant of GZIP (GNU ZIP), into a format called BGZF (Blocked GNU Zip Format)."],
          "data": {
            "uri": "http://edamontology.org/format_3615"
          },
          "definition": "Blocked GNU Zip format.",
          "text": "bgzip"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3601"
          },
          "definition": "The PBM format is a lowest common denominator monochrome file format. It serves as the common language of a large family of bitmap image conversion filters.",
          "text": "pbm"
        }],
        "data": {
          "uri": "http://edamontology.org/format_3547"
        },
        "definition": "Format used for images and image metadata.",
        "is_format_of": ["http://edamontology.org/data_2968"],
        "text": "Image format"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_1319"
          },
          "definition": "Report format for restriction enzyme recognition sites used by EMBOSS restover program.",
          "text": "restover format"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1318"
          },
          "definition": "Report format for restriction enzyme recognition sites used by EMBOSS restrict program.",
          "text": "restrict format"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1320"
          },
          "definition": "Report format for restriction enzyme recognition sites used by REBASE database.",
          "text": "REBASE restriction sites"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2158"
        },
        "definition": "Format used for report on restriction enzyme recognition sites in nucleotide sequences.",
        "text": "Nucleic acid features (restriction sites) format"
      }, {
        "children": [{
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_3863"
            },
            "definition": "NLP format used by a specific type of corpus (collection of texts).",
            "text": "NLP corpus format"
          }],
          "data": {
            "uri": "http://edamontology.org/format_3862"
          },
          "definition": "An NLP format used for annotated textual documents.",
          "text": "NLP annotation format"
        }],
        "data": {
          "uri": "http://edamontology.org/format_3841"
        },
        "definition": "Data format used in Natural Language Processing.",
        "exact_synonyms": ["Natural Language Processing format"],
        "text": "NLP format"
      }],
      "comment": ["This concept exists only to assist EDAM maintenance and navigation in graphical browsers.  It does not add semantic information. The concept branch under 'Format (typed)' provides an alternative organisation of the concepts nested under the other top-level branches ('Binary', 'HTML', 'RDF', 'Text' and 'XML'. All concepts under here are already included under those branches."],
      "data": {
        "uri": "http://edamontology.org/format_2350"
      },
      "definition": "A placeholder concept for visual navigation by dividing data formats by the content of the data that is represented.",
      "exact_synonyms": ["Format (typed)"],
      "text": "Format (by type of data)"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/format_3596"
        },
        "definition": "The PPM format is a lowest common denominator color image file format.",
        "text": "ppm"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3665"
        },
        "definition": "A list of k-mers and their occurences in a dataset. Can also be used as an implicit De Bruijn graph.",
        "text": "K-mer countgraph"
      }, {
        "comment": ["LSM files are the default data export for the Zeiss LSM series confocal microscopes (e.g. LSM 510, LSM 710). In addition to the image data, LSM files contain most imaging settings."],
        "data": {
          "uri": "http://edamontology.org/format_3988"
        },
        "definition": "Zeiss' proprietary image format based on TIFF.",
        "text": "LSM"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3826"
        },
        "definition": ". proBAM is an adaptation of BAM (format_2572), which was extended to meet specific requirements entailed by proteomics data.",
        "text": "proBAM"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3491"
        },
        "definition": "Bowtie format for indexed reference genome for \"large\" genomes.",
        "exact_synonyms": ["Bowtie long index format"],
        "is_format_of": ["http://edamontology.org/data_3210"],
        "text": "ebwtl"
      }, {
        "comment": ["It is designed to be extremely easy to learn and write programs for."],
        "data": {
          "uri": "http://edamontology.org/format_3602"
        },
        "definition": "The PGM format is a lowest common denominator grayscale file format.",
        "text": "pgm"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3462"
        },
        "definition": "Reference-based compression of alignment format",
        "text": "CRAM"
      }, {
        "comment": ["imzML data is recorded in 2 files: '.imzXML' is a metadata XML file based on mzML by HUPO-PSI, and '.ibd' is a binary file containing the mass spectra."],
        "data": {
          "uri": "http://edamontology.org/format_3839"
        },
        "definition": "ibd is a data format for mass spectrometry imaging data.",
        "text": "ibd"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3327"
        },
        "definition": "BAM indexing format",
        "is_format_of": ["http://edamontology.org/data_0955"],
        "text": "BAI"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3004"
        },
        "definition": "bigBed format for large sequence annotation tracks, similar to textual BED format.",
        "text": "bigBed"
      }, {
        "comment": ["Sequence of segments with markers. Begins with byte of 0xFF and follows by marker type."],
        "data": {
          "uri": "http://edamontology.org/format_3599"
        },
        "definition": "X PixMap (XPM) is an image file format used by the X Window System, it is intended primarily for creating icon pixmaps, and supports transparent pixels.",
        "text": "xpm"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1628"
        },
        "definition": "A format of raw sequence read data from an Applied Biosystems sequencing machine.",
        "text": "ABI"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3915"
        },
        "definition": "The Zarr format is an implementation of chunked, compressed, N-dimensional arrays for storing data.",
        "is_format_of": ["http://edamontology.org/data_2535", "http://edamontology.org/data_3112"],
        "text": "Zarr"
      }, {
        "comment": ["IFUNC library reads and writes most uncompressed interchange versions of this format."],
        "data": {
          "uri": "http://edamontology.org/format_3593"
        },
        "definition": "IM is a format used by LabEye and other applications based on the IFUNC image processing library.",
        "text": "im"
      }, {
        "comment": ["It is basically a translation of the ASCII atom coordinate format to binary code. The only additional information stored is a magic number that identifies the BinPos format and the number of atoms per snapshot. The remainder is the chain of coordinates binary encoded. A drawback of this format is its architecture dependency. Integers and floats codification depends on the architecture, thus it needs to be converted if working in different platforms (little endian, big endian)."],
        "data": {
          "uri": "http://edamontology.org/format_3885"
        },
        "definition": "Scripps Research Institute BinPos format is a binary formatted file to store atom coordinates.",
        "exact_synonyms": ["Scripps Research Institute BinPos"],
        "text": "BinPos"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3699"
        },
        "definition": "VDB ('vertical database') is the native format used for export from the NCBI Sequence Read Archive.",
        "exact_synonyms": ["SRA native format"],
        "text": "VDB"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3710"
        },
        "definition": "Mass spectrum file format from QSTAR and QTRAP instruments (ABI/Sciex).",
        "exact_synonyms": ["wiff"],
        "text": "WIFF format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3991"
        },
        "definition": "A declaration file format for UCSC browsers track dataset display charateristics.",
        "text": "TrackDB"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3010"
        },
        "definition": ".nib (nibble) binary format of a nucleotide sequence using 4 bits per nucleotide (including unknown) and its lower-case 'masking'.",
        "text": ".nib"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3017"
        },
        "definition": "Sequence Read Format (SRF) of sequence trace data. Supports submission to the NCBI Short Read Archive.",
        "text": "SRF"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_3977"
          },
          "definition": "ObjTables is a toolkit for creating re-usable datasets that are both human and machine-readable, combining the ease of spreadsheets (e.g., Excel workbooks) with the rigor of schemas (classes, their attributes, the type of each attribute, and the possible relationships between instances of classes). ObjTables consists of a format for describing schemas for spreadsheets, numerous data types for science, a syntax for indicating the class and attribute represented by each table and column in a workbook, and software for using schemas to rigorously validate, merge, split, compare, and revision datasets.",
          "is_format_of": ["http://edamontology.org/data_0006"],
          "text": "ObjTables"
        }],
        "data": {
          "uri": "http://edamontology.org/format_3620"
        },
        "definition": "MS Excel spreadsheet format consisting of a set of XML documents stored in a ZIP-compressed file.",
        "text": "xlsx"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_3622"
          },
          "definition": "Data format used by the SQLite database conformant to the Gemini schema.",
          "text": "Gemini SQLite format"
        }],
        "data": {
          "uri": "http://edamontology.org/format_3621"
        },
        "definition": "Data format used by the SQLite database.",
        "text": "SQLite format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3284"
        },
        "definition": "Standard flowgram format (SFF) is a binary file format used to encode results of pyrosequencing from the 454 Life Sciences platform for high-throughput sequencing.",
        "exact_synonyms": ["Standard flowgram format"],
        "text": "SFF"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3578"
        },
        "definition": "Proprietary file format for (raw) BeadArray data used by genomewide profiling platforms from Illumina Inc. This format is output directly from the scanner and stores summary intensities for each probe-type on an array.",
        "is_format_of": ["http://edamontology.org/data_3110"],
        "text": "IDAT"
      }, {
        "comment": ["Fully architecture-independent format, regarding both endianness and the ability to mix single/double precision trajectories and I/O libraries. Self-sufficient, it should not require any other files for reading, and all the data should be contained in a single file for easy transport. Temporal compression of data, improving the compression rate of the previous XTC format. Possibility to store meta-data with information about the simulation. Direct access to a particular frame. Efficient parallel I/O."],
        "data": {
          "uri": "http://edamontology.org/format_3876"
        },
        "definition": "Trajectory Next Generation (TNG) is a format for storage of molecular simulation data. It is designed and implemented by the GROMACS development group, and it is called to be the substitute of the XTC format.",
        "exact_synonyms": ["Trajectory Next Generation format"],
        "text": "TNG"
      }, {
        "comment": ["The compression is made projecting the Cartesian snapshots collected along the trajectory into an orthogonal space defined by the most relevant eigenvectors obtained by diagonalization of the covariance matrix (PCA). In the compression/decompression process, part of the original information is lost, depending on the final number of eigenvectors chosen. However, with a reasonable choice of the set of eigenvectors the compression typically reduces the trajectory file to less than one tenth of their original size with very acceptable loss of information. Compression with PCAZip can only be applied to unsolvated structures."],
        "data": {
          "uri": "http://edamontology.org/format_3874"
        },
        "definition": "PCAZip format is a binary compressed file to store atom coordinates based on Essential Dynamics (ED) and Principal Component Analysis (PCA).",
        "text": "PCAzip"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3006"
        },
        "definition": "bigWig format for large sequence annotation tracks that consist of a value for each sequence position. Similar to textual WIG format.",
        "text": "bigWig"
      }, {
        "comment": ["PCD was developed by Kodak. A PCD file contains five different resolution (ranging from low to high) of a slide or film negative. Due to it PCD is often used by many photographers and graphics professionals for high-end printed applications."],
        "data": {
          "uri": "http://edamontology.org/format_3594"
        },
        "definition": "Photo CD format, which is the highest resolution format for images on a CD.",
        "text": "pcd"
      }, {
        "comment": ["AB1 uses the generic binary Applied Biosystems, Inc. Format (ABIF)."],
        "data": {
          "uri": "http://edamontology.org/format_3000"
        },
        "definition": "AB1 binary format of raw DNA sequence reads (output of Applied Biosystems' sequencing analysis software). Contains an electropherogram and the DNA base sequence.",
        "text": "AB1"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3624"
        },
        "definition": "An index of a genome database, indexed for use by the snpeff tool.",
        "text": "snpeffdb"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_4003"
        },
        "definition": "The standard binary file format used by NumPy - a fundamental package for scientific computing with Python - for persisting a single arbitrary NumPy array on disk. The format stores all of the shape and dtype information necessary to reconstruct the array correctly.",
        "exact_synonyms": ["NumPy"],
        "is_format_of": ["http://edamontology.org/data_0006"],
        "text": "NumPy format"
      }, {
        "comment": ["HDF is currently supported by many commercial and non-commercial software platforms such as Java, MATLAB/Scilab, Octave, Python and R."],
        "data": {
          "uri": "http://edamontology.org/format_3873"
        },
        "definition": "HDF is the name of a set of file formats and libraries designed to store and organize large amounts of numerical data, originally developed at the National Center for Supercomputing Applications at the University of Illinois.",
        "text": "HDF"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3600"
        },
        "definition": "RGB file format is the native raster graphics file format for Silicon Graphics workstations.",
        "text": "rgb"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3616"
        },
        "definition": "TAB-delimited genome position file index format.",
        "text": "tabix"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3990"
        },
        "definition": "Audio Video Interleaved (AVI) format is a multimedia container format for AVI files, that allows synchronous audio-with-video playback.",
        "exact_synonyms": ["Audio Video Interleaved"],
        "text": "AVI"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_4004"
        },
        "definition": "Format of repertoire (archive) files that can be read by SimToolbox (a MATLAB toolbox for structured illumination fluorescence microscopy) or alternatively extracted with zip file archiver software.",
        "is_format_of": ["http://edamontology.org/data_0006"],
        "text": "SimTools repertoire file format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3698"
        },
        "definition": "SRA archive format (SRA) is the archive format used for input to the NCBI Sequence Read Archive.",
        "exact_synonyms": ["SRA", "SRA archive format"],
        "text": "SRA format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3973"
        },
        "definition": "A Docker image is a file, comprised of multiple layers, that is used to execute code in a Docker container. An image is essentially built from the instructions for a complete and executable version of an application, which relies on the host OS kernel.",
        "text": "Docker image format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3018"
        },
        "definition": "ZTR format for storing chromatogram data from DNA sequencing instruments.",
        "text": "ZTR"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3849"
        },
        "definition": "A set of XML compliant markup components for describing multiple sequence alignments.",
        "text": "MSAML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_2572"
        },
        "definition": "BAM format, the binary, BGZF-formatted compressed version of SAM format for alignment of nucleotide sequences (e.g. sequencing reads) to (a) reference sequence(s). May contain base-call and alignment qualities and other data.",
        "text": "BAM"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3911"
        },
        "definition": "Mash sketch is a format for sequence / sequence checksum information. To make a sketch, each k-mer in a sequence is hashed, which creates a pseudo-random identifier. By sorting these hashes, a small subset from the top of the sorted list can represent the entire sequence.",
        "exact_synonyms": ["min-hash sketch", "Mash sketch"],
        "is_format_of": ["http://edamontology.org/data_2190"],
        "text": "msh"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3595"
        },
        "definition": "PCX is an image file format that uses a simple form of run-length encoding. It is lossless.",
        "text": "pcx"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_4006"
        },
        "definition": "Format used by the Zstandard real-time compression algorith.",
        "exact_synonyms": ["Zstandard-compressed file format", "Zstandard compression format"],
        "is_format_of": ["http://edamontology.org/data_0006"],
        "text": "Zstandard format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3597"
        },
        "definition": "PSD (Photoshop Document) is a proprietary file that allows the user to work with the images' individual layers even after the file has been saved.",
        "text": "psd"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3776"
        },
        "definition": "BTrack is an HDF5-based binary format for genome or sequence feature tracks and their collections, suitable for integrative multi-track analysis. BTrack is a binary, compressed alternative to the GTrack and GSuite formats.",
        "exact_synonyms": ["GTrack|BTrack|GSuite BTrack", "BTrack (GTrack ecosystem of formats)", "BioXSD|GTrack BTrack", "GTrack|GSuite|BTrack BTrack", "BTrack format", "BioXSD/GTrack BTrack"],
        "text": "BTrack"
      }, {
        "comment": ["Texture files can create the appearance of different surfaces and can be applied to both 2D and 3D objects. Note the file extension .tex is also used for LaTex documents which are a completely different format and they are NOT interchangable."],
        "data": {
          "uri": "http://edamontology.org/format_3995"
        },
        "definition": "Bitmap image format used for storing textures.",
        "text": "Texture file format"
      }, {
        "comment": ["It iis expected to replace the Graphics Interchange Format (GIF)."],
        "data": {
          "uri": "http://edamontology.org/format_3603"
        },
        "definition": "PNG is a file format for image compression.",
        "text": "PNG"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3508"
        },
        "definition": "Portable Document Format",
        "text": "PDF"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3830"
        },
        "definition": "Binary format used by the ARB software suite",
        "exact_synonyms": ["ARB binary format"],
        "text": "ARB"
      }, {
        "comment": ["The XBM format was replaced by XPM for X11 in 1989."],
        "data": {
          "uri": "http://edamontology.org/format_3598"
        },
        "definition": "X BitMap is a plain text binary image format used by the X Window System used for storing cursor and icon bitmaps used in the X GUI.",
        "text": "xbm"
      }, {
        "comment": ["The TIFF format is perhaps the most versatile and diverse bitmap format in existence. Its extensible nature and support for numerous data compression schemes allow developers to customize the TIFF format to fit any peculiar data storage needs."],
        "data": {
          "uri": "http://edamontology.org/format_3591"
        },
        "definition": "A versatile bitmap format.",
        "exact_synonyms": ["tiff"],
        "text": "TIFF"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3994"
        },
        "definition": "U3D (Universal 3D) is a compressed file format and data structure for 3D computer graphics. It contains 3D model information such as triangle meshes, lighting, shading, motion data, lines and points with color and structure.",
        "exact_synonyms": ["Universal 3D", "Universal 3D format"],
        "text": "U3D"
      }, {
        "comment": ["A ZIP file may contain one or more files or directories that may have been compressed."],
        "data": {
          "uri": "http://edamontology.org/format_3987"
        },
        "definition": "ZIP is an archive file format that supports lossless data compression.",
        "exact_synonyms": ["ZIP"],
        "is_format_of": ["http://edamontology.org/data_0006"],
        "text": "ZIP format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_4001"
        },
        "definition": "An open file format from the Neuroimaging Informatics Technology Initiative (NIfTI) commonly used to store brain imaging data obtained using Magnetic Resonance Imaging (MRI) methods.",
        "exact_synonyms": ["NIFTI"],
        "text": "NIFTI format"
      }, {
        "comment": ["XTC uses the External Data Representation (xdr) routines for writing and reading data which were created for the Unix Network File System (NFS). XTC files use a reduced precision (lossy) algorithm which works multiplying the coordinates by a scaling factor (typically 1000), so converting them to pm (GROMACS standard distance unit is nm). This allows an integer rounding of the values. Several other tricks are performed, such as making use of atom proximity information: atoms close in sequence are usually close in space (e.g. water molecules). That makes XTC format the most efficient in terms of disk usage, in most cases reducing by a factor of 2 the size of any other binary trajectory format."],
        "data": {
          "uri": "http://edamontology.org/format_3875"
        },
        "definition": "Portable binary format for trajectories produced by GROMACS package.",
        "text": "XTC"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3467"
        },
        "definition": "Graphics Interchange Format.",
        "text": "GIF"
      }, {
        "comment": ["An OMEX file is a ZIP container that includes a manifest file, listing the content of the archive, an optional metadata file adding information about the archive and its content, and the files describing the model. OMEX is one of the standardised formats within COMBINE (Computational Modeling in Biology Network)."],
        "data": {
          "uri": "http://edamontology.org/format_3686"
        },
        "definition": "Open Modeling EXchange format (OMEX) is a ZIPped format for encapsulating all information necessary for a modeling and simulation project in systems biology.",
        "text": "COMBINE OMEX"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_3913"
          },
          "definition": "The Loom file format is based on HDF5, a standard for storing large numerical datasets. The Loom format is designed to efficiently hold large omics datasets. Typically, such data takes the form of a large matrix of numbers, along with metadata for the rows and columns.",
          "is_format_of": ["http://edamontology.org/data_2535", "http://edamontology.org/data_3112"],
          "text": "Loom"
        }],
        "comment": ["HDF5 is the new version, according to the HDF group, a completely different technology (https://support.hdfgroup.org/products/hdf4/ compared to HDF.", "An HDF5 file appears to the user as a directed graph. The nodes of this graph are the higher-level HDF5 objects that are exposed by the HDF5 APIs: Groups, Datasets, Named datatypes. Currently supported by the Python MDTraj package."],
        "data": {
          "uri": "http://edamontology.org/format_3590"
        },
        "definition": "HDF5 is a data model, library, and file format for storing and managing data, based on Hierarchical Data Format (HDF).",
        "exact_synonyms": ["h5"],
        "text": "HDF5"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3009"
        },
        "definition": "2bit binary format of nucleotide sequences using 2 bits per nucleotide. In addition encodes unknown nucleotides and lower-case 'masking'.",
        "text": "2bit"
      }, {
        "comment": ["OME develops open-source software and data format standards for the storage and manipulation of biological microscopy data. It is a joint project between universities, research establishments, industry and the software development community.", "An OME-TIFF dataset consists of one or more files in standard TIFF or BigTIFF format, with the file extension .ome.tif or .ome.tiff, and an identical (or in the case of multiple files, nearly identical) string of OME-XML metadata embedded in the ImageDescription tag of each file's first IFD (Image File Directory). BigTIFF file extensions are also permitted, with the file extension .ome.tf2, .ome.tf8 or .ome.btf, but note these file extensions are an addition to the original specification, and software using an older version of the specification may not be able to handle these file extensions."],
        "data": {
          "uri": "http://edamontology.org/format_3727"
        },
        "definition": "Image file format used by the Open Microscopy Environment (OME).",
        "text": "OME-TIFF"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3549"
        },
        "definition": "Medical image and metadata format of the Neuroimaging Informatics Technology Initiative.",
        "exact_synonyms": ["NIfTI-1 format"],
        "text": "nii"
      }, {
        "comment": ["Proprietary format for which documentation is not available."],
        "data": {
          "uri": "http://edamontology.org/format_3712"
        },
        "definition": "Proprietary file format for mass spectrometry data from Thermo Scientific.",
        "text": "Thermo RAW"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3650"
        },
        "definition": "Format used by netCDF software  library for writing and reading chromatography-MS data files.  Also used to store trajectory atom coordinates information, such as the ones obtained by Molecular Dynamics simulations.",
        "exact_synonyms": ["ANDI-MS"],
        "text": "netCDF"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3484"
        },
        "definition": "Bowtie format for indexed reference genome for \"small\" genomes.",
        "exact_synonyms": ["Bowtie index format"],
        "is_format_of": ["http://edamontology.org/data_3210"],
        "text": "ebwt"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_4002"
        },
        "definition": "Format used by Python pickle module for serializing and de-serializing a Python object structure.",
        "is_format_of": ["http://edamontology.org/data_0006"],
        "text": "pickle"
      }, {
        "comment": ["Although it is based on Windows internal bitmap data structures, it is supported by many non-Windows and non-PC applications."],
        "data": {
          "uri": "http://edamontology.org/format_3592"
        },
        "definition": "Standard bitmap storage format in the Microsoft Windows environment.",
        "exact_synonyms": ["bmp"],
        "text": "BMP"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3700"
        },
        "definition": "Index file format used by the samtools package to index TAB-delimited genome position files.",
        "is_format_of": ["http://edamontology.org/data_0955"],
        "text": "Tabix index file format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3548"
        },
        "definition": "Medical image format corresponding to the Digital Imaging and Communications in Medicine (DICOM) standard.",
        "text": "DICOM format"
      }, {
        "comment": ["Sequence of segments with markers. Begins with byte of 0xFF and follows by marker type."],
        "data": {
          "uri": "http://edamontology.org/format_3579"
        },
        "definition": "Joint Picture Group file format for lossy graphics file.",
        "exact_synonyms": ["jpeg", "JPEG"],
        "text": "JPG"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3986"
        },
        "definition": "The proprietary native video format of various Microsoft programs such as Windows Media Player.",
        "exact_synonyms": ["Windows Media Video format", "Windows movie file format"],
        "text": "WMV"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3997"
        },
        "definition": "A digital multimedia container format most commonly used to store video and audio.",
        "exact_synonyms": ["MP4"],
        "text": "MPEG-4"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3993"
        },
        "definition": "STL is a file format native to the stereolithography CAD software created by 3D Systems.  The format is used to save and share surface-rendered 3D images and also for 3D printing.",
        "exact_synonyms": ["stl"],
        "text": "Stereolithography format"
      }, {
        "comment": ["The SVG specification is an open standard developed by the World Wide Web Consortium (W3C) since 1999."],
        "data": {
          "uri": "http://edamontology.org/format_3605"
        },
        "definition": "Sun Raster is a raster graphics file format used on SunOS by Sun Microsystems",
        "text": "rast"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3020"
        },
        "definition": "BCF, the binary version of Variant Call Format (VCF) for sequence variation (indels, polymorphisms, structural variation).",
        "text": "BCF"
      }, {
        "comment": ["BAM files are compressed using a variant of GZIP (GNU ZIP), into a format called BGZF (Blocked GNU Zip Format)."],
        "data": {
          "uri": "http://edamontology.org/format_3615"
        },
        "definition": "Blocked GNU Zip format.",
        "text": "bgzip"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1632"
        },
        "definition": "Staden Chromatogram Files format (SCF) of base-called sequence reads, qualities, and other metadata.",
        "text": "SCF"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3601"
        },
        "definition": "The PBM format is a lowest common denominator monochrome file format. It serves as the common language of a large family of bitmap image conversion filters.",
        "text": "pbm"
      }, {
        "comment": ["Proprietary format for which documentation is not available, but used by multiple tools."],
        "data": {
          "uri": "http://edamontology.org/format_3858"
        },
        "definition": "Proprietary file format for mass spectrometry data from Waters.",
        "text": "Waters RAW"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3989"
        },
        "definition": "GNU zip compressed file format common to Unix-based operating systems.",
        "exact_synonyms": ["GNU Zip"],
        "is_format_of": ["http://edamontology.org/data_0006"],
        "text": "GZIP format"
      }, {
        "comment": ["For example a 1kb transcript with 1000 alignments in a sample of 10 million reads (out of which 8 million reads can be mapped) will have RPKM = 1000/(1 * 8) = 125"],
        "data": {
          "uri": "http://edamontology.org/format_3981"
        },
        "definition": "TAR archive file format generated by the Unix-based utility tar.",
        "exact_synonyms": ["TAR", "Tarball"],
        "is_format_of": ["http://edamontology.org/data_0006"],
        "text": "TAR format"
      }],
      "comment": ["Only specific native binary formats are listed under 'Binary format' in EDAM. Generic binary formats - such as any data being zipped, or any XML data being serialised into the Efficient XML Interchange (EXI) format - are not modelled in EDAM. Refer to http://wsio.org/compression_004."],
      "data": {
        "uri": "http://edamontology.org/format_2333"
      },
      "definition": "Binary format.",
      "text": "Binary format"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/format_2310"
        },
        "definition": "FASTA format wrapped in HTML elements.",
        "text": "FASTA-HTML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_2311"
        },
        "definition": "EMBL entry format wrapped in HTML elements.",
        "text": "EMBL-HTML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1740"
        },
        "definition": "The format of iHOP (Information Hyperlinked over Proteins) text-mining result.",
        "text": "iHOP format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_2532"
        },
        "definition": "Genbank entry format wrapped in HTML elements.",
        "text": "GenBank-HTML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3556"
        },
        "definition": "MIME  HTML format for Web pages, which can include external resources, including images, Flash animations and so on.",
        "exact_synonyms": ["MIME  HTML", "MHTML format", "MHT", "HTML email message format", "HTML email format", "MIME  HTML format", "MHT format"],
        "text": "MHTML"
      }],
      "data": {
        "uri": "http://edamontology.org/format_2331"
      },
      "definition": "HTML format.",
      "exact_synonyms": ["Hypertext Markup Language"],
      "is_format_of": ["http://edamontology.org/data_2048"],
      "text": "HTML"
    }, {
      "children": [{
        "comment": ["This includes (typically) score data, alignment data and a histogram (of observed and expected distribution of E values.)"],
        "data": {
          "uri": "http://edamontology.org/format_1332"
        },
        "definition": "Format of results of a sequence database search using FASTA.",
        "text": "FASTA search results format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1432"
        },
        "definition": "PHYLIP file format for phylogenetics character frequency data.",
        "text": "Phylip character frequencies format"
      }, {
        "comment": ["GROMACS itp files are used also to define position restrictions on the molecule, or to define the force field parameters for a particular ligand."],
        "data": {
          "uri": "http://edamontology.org/format_3883"
        },
        "definition": "GROMACS itp files (include topology) contain structure topology information, and are tipically included in GROMACS topology files (GROMACS top). Itp files are used to define individual (or multiple) components of a topology as a separate file. This is particularly useful if there is a molecule that is used frequently, and also reduces the size of the system topology file, splitting it in different parts.",
        "text": "GROMACS itp"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_2004"
        },
        "definition": "T-Coffee program alignment format.",
        "text": "T-Coffee format"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_1218"
          },
          "definition": "Alphabet for any protein sequence with possible unknown positions but without ambiguity or non-sequence characters.",
          "text": "unambiguous pure protein"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_2607"
          },
          "definition": "Alphabet for any protein sequence without unknown positions, ambiguity or non-sequence characters.",
          "text": "completely unambiguous pure protein"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1219"
          },
          "definition": "Alphabet for any protein sequence with possible ambiguity and unknown positions but without non-sequence characters.",
          "text": "pure protein"
        }],
        "comment": ["Non-sequence characters may be used for gaps and translation stop."],
        "data": {
          "uri": "http://edamontology.org/format_1208"
        },
        "definition": "Alphabet for a protein sequence with possible ambiguity, unknown positions and non-sequence characters.",
        "text": "protein"
      }, {
        "comment": ["The hits are relatives to a SCOP or CATH family and are found from a search of a sequence database."],
        "data": {
          "uri": "http://edamontology.org/format_1336"
        },
        "definition": "Format of EMBASSY domain hits file (DHF) of hits (sequences) with domain classification information.",
        "text": "dhf"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_1963"
          },
          "definition": "UniProtKB entry sequence format.",
          "exact_synonyms": ["SwissProt format", "UniProt format"],
          "text": "UniProtKB format"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2187"
        },
        "definition": "A text sequence format resembling uniprotkb entry format.",
        "text": "UniProt-like (text)"
      }, {
        "comment": ["Holds a tab-delimited chromosome /start /end / datavalue dataset."],
        "data": {
          "uri": "http://edamontology.org/format_3583"
        },
        "definition": "The bedGraph format allows display of continuous-valued data in track format. This display type is useful for probability scores and transcriptome data",
        "text": "bedgraph"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3789"
        },
        "definition": "XQuery (XML Query) is a query language (format of queries) for querying and manipulating structured and unstructured data, usually in the form of XML, text, and with vendor-specific extensions for other data formats (JSON, binary, etc.).",
        "exact_synonyms": ["XML Query"],
        "text": "XQuery"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1504"
        },
        "definition": "Amino acid index format used by the AAindex database.",
        "text": "aaindex"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3976"
        },
        "definition": "Graphical Fragment Assembly captures sequence graphs as the product of an assembly, a representation of variation in genomes, splice graphs in genes, or even overlap between reads from long-read sequencing technology.",
        "text": "GFA 2"
      }, {
        "comment": ["This format is used in Protege 4."],
        "data": {
          "uri": "http://edamontology.org/format_3254"
        },
        "definition": "A superset of the \"Description-Logic Knowledge Representation System Specification from the KRSS Group of the ARPA Knowledge Sharing Effort\".",
        "text": "KRSS2 Syntax"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_1927"
          },
          "definition": "EMBL entry format.",
          "exact_synonyms": ["EMBL", "EMBL sequence format"],
          "text": "EMBL format"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_2186"
          },
          "definition": "Geneseq sequence format.",
          "text": "geneseq"
        }],
        "comment": ["This concept may be used for the many non-standard EMBL-like text formats."],
        "data": {
          "uri": "http://edamontology.org/format_2181"
        },
        "definition": "A text format resembling EMBL entry format.",
        "text": "EMBL-like (text)"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1437"
        },
        "definition": "The format of an entry from the TreeFam database of phylogenetic data.",
        "text": "TreeFam format"
      }, {
        "comment": ["Typically generated by Multiz and TBA aligners; can be displayed in a genome browser like a sequence annotation track. This should not be confused with MIRA Assembly Format or Mutation Annotation Format."],
        "data": {
          "uri": "http://edamontology.org/format_3008"
        },
        "definition": "Multiple Alignment Format (MAF) supporting alignments of whole genomes with rearrangements, directions, multiple pieces to the alignment, and so forth.",
        "text": "MAF"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1912"
        },
        "definition": "Phylogenetic tree Nexus (text) format.",
        "text": "Nexus format"
      }, {
        "children": [{
          "comment": ["Galaxy allows BED files to contain non-standard fields beyond the first 3 columns, some other implementations do not."],
          "data": {
            "uri": "http://edamontology.org/format_3587"
          },
          "definition": "Tabular format of chromosome names and sizes used by Galaxy.",
          "text": "chrominfo"
        }, {
          "children": [{
            "children": [{
              "children": [{
                "comment": ["Format that covers both the broad peak format and narrow peak format from ENCODE."],
                "data": {
                  "uri": "http://edamontology.org/format_3613"
                },
                "definition": "Human ENCODE narrow peak format.",
                "text": "ENCODE narrow peak format"
              }, {
                "data": {
                  "uri": "http://edamontology.org/format_3614"
                },
                "definition": "Human ENCODE broad peak format.",
                "text": "ENCODE broad peak format"
              }],
              "comment": ["Format that covers both the broad peak format and narrow peak format from ENCODE."],
              "data": {
                "uri": "http://edamontology.org/format_3612"
              },
              "definition": "Human ENCODE peak format.",
              "text": "ENCODE peak format"
            }],
            "comment": ["Tab delimited data in strict BED format - no non-standard columns allowed; column count forced to 6"],
            "data": {
              "uri": "http://edamontology.org/format_3585"
            },
            "definition": "BED file format where each feature is described by chromosome, start, end, name, score, and strand.",
            "text": "bed6"
          }, {
            "comment": ["Tab delimited data in strict BED format - no non-standard columns allowed; column count forced to 12"],
            "data": {
              "uri": "http://edamontology.org/format_3586"
            },
            "definition": "A BED file where each feature is described by all twelve columns.",
            "text": "bed12"
          }],
          "comment": ["Galaxy allows BED files to contain non-standard fields beyond the first 3 columns, some other implementations do not."],
          "data": {
            "uri": "http://edamontology.org/format_3584"
          },
          "definition": "Browser Extensible Data (BED) format of sequence annotation track that strictly does not contain non-standard fields beyond the first 3 columns.",
          "text": "bedstrict"
        }],
        "comment": ["BED detail format includes 2 additional columns (http://genome.ucsc.edu/FAQ/FAQformat#format1.7) and BED 15 includes 3 additional columns for experiment scores (http://genomewiki.ucsc.edu/index.php/Microarray_track)."],
        "data": {
          "uri": "http://edamontology.org/format_3003"
        },
        "definition": "Browser Extensible Data (BED) format of sequence annotation track, typically to be displayed in a genome browser.",
        "text": "BED"
      }, {
        "comment": ["Galaxy allows BED files to contain non-standard fields beyond the first 3 columns, some other implementations do not."],
        "data": {
          "uri": "http://edamontology.org/format_3587"
        },
        "definition": "Tabular format of chromosome names and sizes used by Galaxy.",
        "text": "chrominfo"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3785"
        },
        "definition": "A family of similar formats of text annotation, used by BRAT and other tools, known as BioNLP Shared Task format (BioNLP 2009 Shared Task on Event Extraction, BioNLP Shared Task 2011, BioNLP Shared Task 2013), BRAT format, BRAT standoff format, and similar.",
        "exact_synonyms": ["BRAT standoff format", "BRAT format"],
        "text": "BioNLP Shared Task format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1430"
        },
        "definition": "PHYLIP file format for continuous quantitative character data.",
        "text": "Phylip continuous quantitative characters"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3582"
        },
        "definition": "AFG is a single text-based file assembly format  that holds read and consensus information together",
        "text": "afg"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3783"
        },
        "definition": "Native textual export format of annotated scientific text from PubTator.",
        "text": "PubTator format"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_3286"
          },
          "definition": "The PED file describes individuals and genetic data and is used by the Plink package.",
          "exact_synonyms": ["Plink PED"],
          "text": "PED"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3285"
          },
          "definition": "The MAP file describes SNPs and is used by the Plink package.",
          "exact_synonyms": ["Plink MAP"],
          "text": "MAP"
        }],
        "data": {
          "uri": "http://edamontology.org/format_3288"
        },
        "definition": "The PED/MAP file describes data used by the Plink package.",
        "exact_synonyms": ["Plink PED/MAP"],
        "text": "PED/MAP"
      }, {
        "comment": ["pdbnuc format in EMBOSS."],
        "data": {
          "uri": "http://edamontology.org/format_1951"
        },
        "definition": "PDB nucleotide sequence format (ATOM lines).",
        "text": "pdbatomnuc"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1946"
        },
        "definition": "Mega interleaved and non-interleaved sequence format.",
        "text": "mega-seq"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1969"
        },
        "definition": "EMBOSS debugging trace sequence format of full internal data content.",
        "text": "debug-seq"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_2549"
        },
        "definition": "OBO ontology text format.",
        "text": "OBO"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3910"
        },
        "definition": "Format of trr files that contain the trajectory of a simulation experiment used by GROMACS.",
        "text": "trr"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3813"
        },
        "definition": "The SAMPLE file format contains information about each individual i.e. individual IDs, covariates, phenotypes and missing data proportions, from a GWAS study.",
        "text": "SAMPLE file format"
      }, {
        "comment": ["pdbseq format in EMBOSS."],
        "data": {
          "uri": "http://edamontology.org/format_1953"
        },
        "definition": "PDB sequence format (SEQRES lines).",
        "text": "pdbseqres"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3012"
        },
        "definition": "Personal Genome SNP (pgSnp) format for sequence variation tracks (indels and polymorphisms), supported by the UCSC Genome Browser.",
        "text": "pgSnp"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_1991"
          },
          "definition": "Mega format for (typically aligned) sequences.",
          "text": "mega"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1992"
          },
          "definition": "Mega non-interleaved format for (typically aligned) sequences.",
          "text": "meganon"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2923"
        },
        "definition": "Some variant of Mega format for (typically aligned) sequences.",
        "text": "mega variant"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3693"
        },
        "definition": "AGP is a tabular format for a sequence assembly (a contig, a scaffold/supercontig, or a chromosome).",
        "text": "AGP"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1966"
        },
        "definition": "NCBI ASN.1-based sequence format.",
        "text": "ASN.1 sequence format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3985"
        },
        "definition": "An emerging format for high-level Galaxy workflow description.",
        "exact_synonyms": ["Galaxy workflow format", "GalaxyWF"],
        "text": "gxformat2"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3812"
        },
        "definition": "The GEN file format contains genetic data and describes SNPs.",
        "exact_synonyms": ["Genotype file format"],
        "text": "GEN"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3714"
        },
        "definition": "Format of peak list files from Andromeda search engine (MaxQuant) that consist of arbitrarily many spectra.",
        "exact_synonyms": ["MaxQuant APL"],
        "text": "MaxQuant APL peaklist format"
      }, {
        "comment": ["BcForms is related to http://edamontology.org/format_3909. (BcForms uses BpForms to describe subunits which are DNA, RNA, or protein polymers.) However, that format isn't the parent of BcForms. BcForms is similarly related to SMILES (http://edamontology.org/data_2301)."],
        "data": {
          "uri": "http://edamontology.org/format_3951"
        },
        "definition": "BcForms is a format for abstractly describing the molecular structure (atoms and bonds) of macromolecular complexes as a collection of subunits and crosslinks. Each subunit can be described with BpForms (http://edamontology.org/format_3909) or SMILES (http://edamontology.org/data_2301). BcForms uses an ontology of crosslinks to abstract the chemical details of crosslinks from the descriptions of complexes (see https://bpforms.org/crosslink.html).",
        "text": "BcForms"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3709"
        },
        "definition": "Tab-delimited text files of GenePattern that contain a column for each sample, a row for each gene, and an expression value for each gene in each sample.",
        "exact_synonyms": ["GCT format", "Res format"],
        "text": "GCT/Res format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3996"
        },
        "definition": "Format for scripts writtenin Python - a widely used high-level programming language for general-purpose programming.",
        "exact_synonyms": ["Python program", "Python"],
        "text": "Python script"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1736"
        },
        "definition": "CiteXplore 'core' citation format including title, journal, authors and abstract.",
        "text": "CiteXplore-core"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1419"
        },
        "definition": "Format for alignment of molecular sequences to MEME profiles (position-dependent scoring matrices) as generated by the MAST tool from the MEME package.",
        "text": "Sequence-MEME profile alignment"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3016"
        },
        "definition": "Variant Call Format (VCF) for sequence variation (indels, polymorphisms, structural variation).",
        "text": "VCF"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3777"
        },
        "definition": "The FAO/Bioversity/IPGRI Multi-Crop Passport Descriptors (MCPD) is an international standard format for exchange of germplasm information.",
        "exact_synonyms": ["MCPD format", "Bioversity MCPD", "Multi-Crop Passport Descriptors", "FAO MCPD", "Multi-Crop Passport Descriptors format"],
        "is_format_of": ["http://edamontology.org/data_2530", "http://edamontology.org/data_3113", "http://edamontology.org/data_3567"],
        "narrow_synonyms": ["IPGRI MCPD", "MCPD V.1", "MCPD V.2"],
        "text": "MCPD"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3015"
        },
        "definition": "Pileup format of alignment of sequences (e.g. sequencing reads) to (a) reference sequence(s). Contains aligned bases per base of the reference sequence(s).",
        "text": "Pileup"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1424"
        },
        "definition": "Dendrogram (tree file) format generated by ClustalW.",
        "text": "ClustalW dendrogram"
      }, {
        "comment": ["OSCAR (Open-Source Chemistry Analysis Routines) software performs chemistry-specific parsing of chemical documents. It attempts to identify chemical names, ontology concepts, and chemical data from a document."],
        "data": {
          "uri": "http://edamontology.org/format_1741"
        },
        "definition": "OSCAR format of annotated chemical text.",
        "text": "OSCAR format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1392"
        },
        "definition": "Format of multiple sequences aligned by DIALIGN package.",
        "text": "DIALIGN format"
      }, {
        "comment": ["The format supports short and long reads (up to 128Mbp) produced by different sequencing platforms and is used to hold mapped data within the GATK and across the Broad Institute, the Sanger Centre, and throughout the 1000 Genomes project."],
        "data": {
          "uri": "http://edamontology.org/format_2573"
        },
        "definition": "Sequence Alignment/Map (SAM) format for alignment of nucleotide sequences (e.g. sequencing reads) to (a) reference sequence(s). May contain base-call and alignment qualities and other data.",
        "text": "SAM"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1861"
        },
        "definition": "Map of a plasmid (circular DNA) in PlasMapper TextMap format.",
        "text": "PlasMapper TextMap"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3164"
        },
        "definition": "GTrack is a generic and optimised tabular format for genome or sequence feature tracks. GTrack unifies the power of other track formats (e.g. GFF3, BED, WIG), and while optimised in size, adds more flexibility, customisation, and automation (\"machine understandability\").",
        "exact_synonyms": ["GTrack|GSuite|BTrack GTrack", "GTrack|BTrack|GSuite GTrack", "BioXSD/GTrack GTrack", "BioXSD|GTrack GTrack", "GTrack format"],
        "text": "GTrack"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3816"
        },
        "definition": "Complete, portable representation of a SYBYL molecule. ASCII file which contains all the information needed to reconstruct a SYBYL molecule.",
        "text": "Mol2"
      }, {
        "comment": ["The DSSP database is built using the DSSP application which defines secondary structure, geometrical features and solvent exposure of proteins, given atomic coordinates in PDB format."],
        "data": {
          "uri": "http://edamontology.org/format_1454"
        },
        "definition": "Format of an entry from the DSSP database (Dictionary of Secondary Structure in Proteins).",
        "text": "dssp"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1948"
        },
        "definition": "NBRF/PIR entry sequence format.",
        "exact_synonyms": ["nbrf", "pir"],
        "text": "nbrf/pir"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3691"
        },
        "definition": "Biological Expression Language (BEL) is a textual format for representing scientific findings in life sciences in a computable form.",
        "text": "BEL"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1335"
        },
        "definition": "Format of results of a sequence database search using some variant of Smith Waterman.",
        "text": "Smith-Waterman format"
      }, {
        "comment": ["The hits are putative ligand-binding sequences and are found from a search of a sequence database."],
        "data": {
          "uri": "http://edamontology.org/format_1337"
        },
        "definition": "Format of EMBASSY ligand hits file (LHF) of database hits (sequences) with ligand classification information.",
        "text": "lhf"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_2005"
        },
        "definition": "Treecon format for (aligned) sequences.",
        "text": "TreeCon-seq"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_4005"
        },
        "definition": "A configuration file used by various programs to store settings that are specific to their respective software.",
        "is_format_of": ["http://edamontology.org/data_0006"],
        "text": "Configuration file format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3312"
        },
        "definition": "Format for the Genetic Data Environment (GDE).",
        "text": "GDE"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1367"
        },
        "definition": "A profile (sequence classifier) in the format used in the JASPAR database.",
        "text": "JASPAR format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1316"
        },
        "definition": "Format of a report on exon-intron structure generated by EMBOSS est2genome.",
        "text": "est2genome format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1945"
        },
        "definition": "Mase program sequence format.",
        "text": "mase format"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_1209"
          },
          "definition": "Alphabet for the consensus of two or more molecular sequences.",
          "text": "consensus"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2095"
        },
        "definition": "Alphabet for a molecular sequence with possible unknown positions but possibly with non-sequence characters.",
        "text": "unpure"
      }, {
        "comment": ["The high similarity in the functional form of the two potential energy functions used by AMBER and CHARMM force-fields gives rise to the possible use of one force-field within the other MD engine. Therefore, the conversion of PSF files to AMBER Prmtop format is possible with the use of AMBER chamber (CHARMM - AMBER) program."],
        "data": {
          "uri": "http://edamontology.org/format_3882"
        },
        "definition": "X-Plor Protein Structure Files (PSF) are structure topology files used by NAMD and CHARMM molecular simulations programs. PSF files contain six main sections of interest: atoms, bonds, angles, dihedrals, improper dihedrals (force terms used to maintain planarity) and cross-terms.",
        "text": "PSF"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1627"
        },
        "definition": "Report format on PCR primers and hybridisation oligos as generated by Whitehead primer3 program.",
        "text": "Primer3 primer"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1445"
        },
        "definition": "Format for distances, such as Branch Score distance, between two or more phylogenetic trees as used by the Phylip package.",
        "text": "Phylip tree distance format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3688"
        },
        "definition": "SBtab is a tabular format for biochemical network models.",
        "text": "SBtab"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1928"
        },
        "definition": "Staden experiment file format.",
        "text": "Staden experiment format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1911"
        },
        "definition": "Phylogenetic tree TreeCon (text) format.",
        "text": "TreeCon format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1350"
        },
        "definition": "Dirichlet distribution MEME format.",
        "text": "MEME Dirichlet prior"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_1932"
          },
          "definition": "FASTQ short read format with phred quality.",
          "text": "FASTQ-sanger"
        }, {
          "children": [{
            "comment": ["Solexa/Illumina 1.0 format can encode a Solexa/Illumina quality score from -5 to 62 using ASCII 59 to 126 (although in raw read data Solexa scores from -5 to 40 only are expected)"],
            "data": {
              "uri": "http://edamontology.org/format_3608"
            },
            "definition": "FASTQ format subset for Phred sequencing quality score data only (no sequences) for Solexa/Illumina 1.0 format.",
            "text": "qualsolexa"
          }],
          "data": {
            "uri": "http://edamontology.org/format_1933"
          },
          "definition": "FASTQ Solexa/Illumina 1.0 short read format.",
          "text": "FASTQ-solexa"
        }, {
          "children": [{
            "comment": ["For SOLiD data, the sequence is in color space, except the first position. The quality values are those of the Sanger format."],
            "data": {
              "uri": "http://edamontology.org/format_3610"
            },
            "definition": "FASTQ format subset for Phred sequencing quality score data only (no sequences) for SOLiD data.",
            "text": "qualsolid"
          }, {
            "comment": ["Starting in Illumina 1.5 and before Illumina 1.8, the Phred scores 0 to 2 have a slightly different meaning. The values 0 and 1 are no longer used and the value 2, encoded by ASCII 66 \"B\", is used also at the end of reads as a Read Segment Quality Control Indicator."],
            "data": {
              "uri": "http://edamontology.org/format_3609"
            },
            "definition": "FASTQ format subset for Phred sequencing quality score data only (no sequences) from Illumina 1.5 and before Illumina 1.8.",
            "text": "qualillumina"
          }, {
            "comment": ["Solexa/Illumina 1.0 format can encode a Solexa/Illumina quality score from -5 to 62 using ASCII 59 to 126 (although in raw read data Solexa scores from -5 to 40 only are expected)"],
            "data": {
              "uri": "http://edamontology.org/format_3608"
            },
            "definition": "FASTQ format subset for Phred sequencing quality score data only (no sequences) for Solexa/Illumina 1.0 format.",
            "text": "qualsolexa"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3611"
            },
            "definition": "FASTQ format subset for Phred sequencing quality score data only (no sequences) from 454 sequencers.",
            "text": "qual454"
          }],
          "comment": ["Phred quality scores  are defined as a property which is logarithmically related to the base-calling error probabilities."],
          "data": {
            "uri": "http://edamontology.org/format_3607"
          },
          "definition": "FASTQ format subset for Phred sequencing quality score data only (no sequences).",
          "text": "qual"
        }, {
          "children": [{
            "comment": ["Starting in Illumina 1.5 and before Illumina 1.8, the Phred scores 0 to 2 have a slightly different meaning. The values 0 and 1 are no longer used and the value 2, encoded by ASCII 66 \"B\", is used also at the end of reads as a Read Segment Quality Control Indicator."],
            "data": {
              "uri": "http://edamontology.org/format_3609"
            },
            "definition": "FASTQ format subset for Phred sequencing quality score data only (no sequences) from Illumina 1.5 and before Illumina 1.8.",
            "text": "qualillumina"
          }],
          "data": {
            "uri": "http://edamontology.org/format_1931"
          },
          "definition": "FASTQ Illumina 1.3 short read format.",
          "text": "FASTQ-illumina"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1930"
          },
          "definition": "FASTQ short read format ignoring quality scores.",
          "exact_synonyms": ["FASTAQ", "fq"],
          "text": "FASTQ"
        }],
        "comment": ["This concept may be used for non-standard FASTQ short read-like formats."],
        "data": {
          "uri": "http://edamontology.org/format_2182"
        },
        "definition": "A text format resembling FASTQ short read format.",
        "text": "FASTQ-like format (text)"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1705"
        },
        "definition": "The format of an entry from the HET group dictionary (HET groups from PDB files).",
        "text": "HET group dictionary entry format"
      }, {
        "children": [{
          "comment": ["For SOLiD data, the sequence is in color space, except the first position. The quality values are those of the Sanger format."],
          "data": {
            "uri": "http://edamontology.org/format_3610"
          },
          "definition": "FASTQ format subset for Phred sequencing quality score data only (no sequences) for SOLiD data.",
          "text": "qualsolid"
        }, {
          "comment": ["Starting in Illumina 1.5 and before Illumina 1.8, the Phred scores 0 to 2 have a slightly different meaning. The values 0 and 1 are no longer used and the value 2, encoded by ASCII 66 \"B\", is used also at the end of reads as a Read Segment Quality Control Indicator."],
          "data": {
            "uri": "http://edamontology.org/format_3609"
          },
          "definition": "FASTQ format subset for Phred sequencing quality score data only (no sequences) from Illumina 1.5 and before Illumina 1.8.",
          "text": "qualillumina"
        }, {
          "comment": ["Solexa/Illumina 1.0 format can encode a Solexa/Illumina quality score from -5 to 62 using ASCII 59 to 126 (although in raw read data Solexa scores from -5 to 40 only are expected)"],
          "data": {
            "uri": "http://edamontology.org/format_3608"
          },
          "definition": "FASTQ format subset for Phred sequencing quality score data only (no sequences) for Solexa/Illumina 1.0 format.",
          "text": "qualsolexa"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3611"
          },
          "definition": "FASTQ format subset for Phred sequencing quality score data only (no sequences) from 454 sequencers.",
          "text": "qual454"
        }],
        "comment": ["Phred quality scores  are defined as a property which is logarithmically related to the base-calling error probabilities."],
        "data": {
          "uri": "http://edamontology.org/format_3607"
        },
        "definition": "FASTQ format subset for Phred sequencing quality score data only (no sequences).",
        "text": "qual"
      }, {
        "comment": ["The SPARQL Query Language incorporates a very similar syntax."],
        "data": {
          "uri": "http://edamontology.org/format_3255"
        },
        "definition": "The Terse RDF Triple Language (Turtle) is a human-friendly serialisation format for RDF (Resource Description Framework) graphs.",
        "text": "Turtle"
      }, {
        "children": [{
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_1215"
            },
            "definition": "Alphabet for a DNA sequence with possible ambiguity and unknown positions but without non-sequence characters.",
            "text": "pure dna"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1217"
            },
            "definition": "Alphabet for an RNA sequence with possible ambiguity and unknown positions but without non-sequence characters.",
            "text": "pure rna"
          }],
          "data": {
            "uri": "http://edamontology.org/format_1210"
          },
          "definition": "Alphabet for a nucleotide sequence with possible ambiguity and unknown positions but without non-sequence characters.",
          "text": "pure nucleotide"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_2568"
          },
          "definition": "Alphabet for a nucleotide sequence (characters ACGTU only) without unknown positions, ambiguity or non-sequence characters .",
          "text": "completely unambiguous pure nucleotide"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1211"
          },
          "definition": "Alphabet for a nucleotide sequence (characters ACGTU only) with possible unknown positions but without ambiguity or non-sequence characters .",
          "text": "unambiguous pure nucleotide"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_2569"
            },
            "definition": "Alphabet for a DNA sequence (characters ACGT only) without unknown positions, ambiguity or non-sequence characters.",
            "text": "completely unambiguous pure dna"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1215"
            },
            "definition": "Alphabet for a DNA sequence with possible ambiguity and unknown positions but without non-sequence characters.",
            "text": "pure dna"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1214"
            },
            "definition": "Alphabet for a DNA sequence (characters ACGT only) with possible unknown positions but without ambiguity or non-sequence characters.",
            "text": "unambiguous pure dna"
          }],
          "data": {
            "uri": "http://edamontology.org/format_1212"
          },
          "definition": "Alphabet for a DNA sequence with possible ambiguity, unknown positions and non-sequence characters.",
          "text": "dna"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_2570"
            },
            "definition": "Alphabet for an RNA sequence (characters ACGU only) without unknown positions, ambiguity or non-sequence characters.",
            "text": "completely unambiguous pure rna sequence"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1216"
            },
            "definition": "Alphabet for an RNA sequence (characters ACGU only) with possible unknown positions but without ambiguity or non-sequence characters.",
            "text": "unambiguous pure rna sequence"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1217"
            },
            "definition": "Alphabet for an RNA sequence with possible ambiguity and unknown positions but without non-sequence characters.",
            "text": "pure rna"
          }],
          "data": {
            "uri": "http://edamontology.org/format_1213"
          },
          "definition": "Alphabet for an RNA sequence with possible ambiguity, unknown positions and non-sequence characters.",
          "text": "rna"
        }],
        "comment": ["Non-sequence characters may be used for example for gaps."],
        "data": {
          "uri": "http://edamontology.org/format_1207"
        },
        "definition": "Alphabet for a nucleotide sequence with possible ambiguity, unknown positions and non-sequence characters.",
        "text": "nucleotide"
      }, {
        "comment": ["Used for tracks/track views within galaxy."],
        "data": {
          "uri": "http://edamontology.org/format_3588"
        },
        "definition": "Custom Sequence annotation track format used by Galaxy.",
        "text": "customtrack"
      }, {
        "comment": ["NMReData is a text based data standard for processed NMR data. It is relying on SDF molecule data and allows to store assignments of NMR peaks to molecule features. The NMR-extracted data (or \"NMReDATA\") includes: Chemical shift,scalar coupling, 2D correlation, assignment, etc. Find more in the paper at D. Jeannerat, Magn. Reson. in Chem., 2017, 55, 7-14."],
        "data": {
          "uri": "http://edamontology.org/format_3906"
        },
        "definition": "MReData is a text based data standard for processed NMR data. It is relying on SDF molecule data and allows to store assignments of NMR peaks to molecule features.  The NMR-extracted data (or \"NMReDATA\") includes: Chemical shift,scalar coupling, 2D correlation, assignment, etc.",
        "text": "NMReDATA"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1334"
        },
        "definition": "Format of results of a sequence database search using some variant of MSPCrunch.",
        "text": "mspcrunch"
      }, {
        "children": [{
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_3979"
            },
            "definition": "WEGO native format used by the Web Gene Ontology Annotation Plot application.   Tab-delimited format with gene names and others GO IDs (columns) with one annotation record per line.",
            "text": "WEGO"
          }, {
            "comment": ["For example a 1kb transcript with 1000 alignments in a sample of 10 million reads (out of which 8 million reads can be mapped) will have RPKM = 1000/(1 * 8) = 125"],
            "data": {
              "uri": "http://edamontology.org/format_3980"
            },
            "definition": "Tab-delimited format for gene expression levels table, calculated as Reads Per Kilobase per Million (RPKM) mapped reads.",
            "exact_synonyms": ["Gene expression levels table format"],
            "text": "RPKM"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3162"
            },
            "definition": "MAGE-TAB textual format for microarray expression data, standardised by MGED (now FGED).",
            "is_format_of": ["http://edamontology.org/data_3111"],
            "text": "MAGE-TAB"
          }],
          "data": {
            "uri": "http://edamontology.org/format_3475"
          },
          "definition": "Tabular data represented as tab-separated values in a text file.",
          "exact_synonyms": ["Tab-delimited", "Tab-separated values"],
          "text": "TSV"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3752"
          },
          "definition": "Tabular data represented as comma-separated values in a text file.",
          "exact_synonyms": ["Comma-separated values"],
          "text": "CSV"
        }],
        "data": {
          "uri": "http://edamontology.org/format_3751"
        },
        "definition": "Tabular data represented as values in a text file delimited by some character.",
        "exact_synonyms": ["Delimiter-separated values"],
        "text": "DSV"
      }, {
        "comment": ["version 7 is written to distinguish it from old versions of AMBER Prmtop. Similarly to HDF5, it is a completely different format, according to AMBER group: a drastic change to the file format occurred with the 2004 release of Amber 7 (http://ambermd.org/prmtop.pdf)", "It can be modified manually, but as the size of the system increases, the hand-editing becomes increasingly complex. AMBER Parameter-Topology file format is used extensively by the AMBER software suite and is referred to as the Prmtop file for short."],
        "data": {
          "uri": "http://edamontology.org/format_3881"
        },
        "definition": "AMBER Prmtop file (version 7) is a structure topology text file divided in several sections designed to be parsed easily using simple Fortran code. Each section contains particular topology information, such as atom name, charge, mass, angles, dihedrals, etc.",
        "exact_synonyms": ["Prmtop", "AMBER Parm7", "Prmtop7", "AMBER Parm", "Parm7"],
        "text": "AMBER top"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3242"
        },
        "definition": "Tabular Molecular Interaction format (MITAB), standardised by HUPO PSI MI.",
        "text": "PSI MI TAB (MITAB)"
      }, {
        "comment": ["Pcons ranks protein models by assessing their quality based on the occurrence of recurring common three-dimensional structural patterns. Pcons returns a score reflecting the overall global quality and a score for each individual residue in the protein reflecting the local residue quality."],
        "data": {
          "uri": "http://edamontology.org/format_1551"
        },
        "definition": "Format of output of the Pcons Model Quality Assessment Program (MQAP).",
        "text": "Pcons report format"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_1987"
          },
          "definition": "Pearson MARKX10 alignment format.",
          "text": "markx10"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1989"
          },
          "definition": "Pearson MARKX3 alignment format.",
          "text": "markx3"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1988"
          },
          "definition": "Pearson MARKX2 alignment format.",
          "text": "markx2"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1985"
          },
          "definition": "Pearson MARKX0 alignment format.",
          "text": "markx0"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1986"
          },
          "definition": "Pearson MARKX1 alignment format.",
          "text": "markx1"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2922"
        },
        "definition": "Some variant of Pearson MARKX alignment format.",
        "text": "markx0 variant"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3681"
        },
        "definition": "mzTab is a tab-delimited format for mass spectrometry-based proteomics and metabolomics results.",
        "text": "mzTab"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3007"
        },
        "definition": "PSL format of alignments, typically generated by BLAT or psLayout. Can be displayed in a genome browser like a sequence annotation track.",
        "text": "PSL"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3550"
        },
        "definition": "Text-based tagged file format for medical images generated using the MetaImage software package.",
        "exact_synonyms": ["Metalmage format"],
        "text": "mhd"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1295"
        },
        "definition": "Report format for tandem repeats in a nucleotide sequence (format generated by the Sanger Centre quicktandem program).",
        "text": "quicktandem"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1434"
        },
        "definition": "Format of PHYLIP cliques data.",
        "text": "Phylip cliques format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3257"
        },
        "definition": "A shorthand non-XML serialisation of Resource Description Framework model, designed with human-readability in mind.",
        "exact_synonyms": ["N3"],
        "text": "Notation3"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3984"
        },
        "definition": "Format of QMAP files generated for methylation data from an internal BGI pipeline.",
        "text": "QMAP"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3013"
        },
        "definition": "axt format of alignments, typically produced from BLASTZ.",
        "text": "axt"
      }, {
        "comment": ["BIOM is a recognised standard for the Earth Microbiome Project, and is a project supported by Genomics Standards Consortium. Supported in QIIME, Mothur, MEGAN, etc."],
        "data": {
          "uri": "http://edamontology.org/format_3746"
        },
        "definition": "The BIological Observation Matrix (BIOM) is a format for representing biological sample by observation contingency tables in broad areas of comparative omics. The primary use of this format is to represent OTU tables and metagenome tables.",
        "exact_synonyms": ["BIological Observation Matrix format"],
        "text": "BIOM format"
      }, {
        "children": [{
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_1938"
            },
            "definition": "GFF feature file format with sequence in the header.",
            "text": "GFF2-seq"
          }],
          "data": {
            "uri": "http://edamontology.org/format_1974"
          },
          "definition": "General Feature Format (GFF) of sequence features.",
          "text": "GFF2"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_2306"
          },
          "definition": "Gene Transfer Format (GTF), a restricted version of GFF.",
          "text": "GTF"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_1939"
            },
            "definition": "GFF3 feature file format with sequence.",
            "text": "GFF3-seq"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_3019"
            },
            "definition": "Genome Variation Format (GVF). A GFF3-compatible format with defined header and attribute tags for sequence variation.",
            "text": "GVF"
          }, {
            "comment": ["mirGFF3 is a specialisation of GFF3; produced by small-RNA-Seq analysis workflows, usable and convertible with the miRTop API (https://mirtop.readthedocs.io/en/latest/), and consumable by tools for downstream analysis."],
            "data": {
              "uri": "http://edamontology.org/format_3864"
            },
            "definition": "mirGFF3 is a common format for microRNA data resulting from small-RNA RNA-Seq workflows.",
            "exact_synonyms": ["miRTop format"],
            "text": "mirGFF3"
          }],
          "data": {
            "uri": "http://edamontology.org/format_1975"
          },
          "definition": "Generic Feature Format version 3 (GFF3) of sequence features.",
          "text": "GFF3"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2305"
        },
        "definition": "GFF feature format (of indeterminate version).",
        "text": "GFF"
      }, {
        "comment": ["genePred format has 3 main variations (http://genome.ucsc.edu/FAQ/FAQformat#format9 http://www.broadinstitute.org/software/igv/genePred). They reflect UCSC Browser DB tables."],
        "data": {
          "uri": "http://edamontology.org/format_3011"
        },
        "definition": "genePred table format for gene prediction tracks.",
        "text": "genePred"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3477"
        },
        "definition": "Format of the cytoscape input file of gene expression ratios or values are specified over one or more experiments.",
        "text": "Cytoscape input file format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1910"
        },
        "definition": "Phylogenetic tree Newick (text) format.",
        "exact_synonyms": ["nh"],
        "text": "newick"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1737"
        },
        "definition": "CiteXplore 'all' citation format includes all known details such as Mesh terms and cross-references.",
        "text": "CiteXplore-all"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1357"
        },
        "definition": "Format of an EMBOSS sequence pattern.",
        "text": "EMBOSS sequence pattern"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1970"
        },
        "definition": "Jackknifer output sequence non-interleaved format.",
        "text": "jackknifernon"
      }, {
        "comment": ["This format was influenced by the OWL Abstract Syntax and the DL style syntax."],
        "data": {
          "uri": "http://edamontology.org/format_3253"
        },
        "definition": "A syntax for writing OWL class expressions.",
        "text": "Manchester OWL Syntax"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1435"
        },
        "definition": "Phylogenetic tree data format used by the PHYLIP program.",
        "text": "Phylip tree format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1436"
        },
        "definition": "The format of an entry from the TreeBASE database of phylogenetic data.",
        "text": "TreeBASE format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3790"
        },
        "definition": "SPARQL (SPARQL Protocol and RDF Query Language) is a semantic query language for querying and manipulating data stored in Resource Description Framework (RDF) format.",
        "exact_synonyms": ["SPARQL Protocol and RDF Query Language"],
        "text": "SPARQL"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1631"
        },
        "definition": "Sequence assembly project file EXP format.",
        "exact_synonyms": ["EXP", "Affymetrix EXP format"],
        "text": "EXP"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1943"
        },
        "definition": "Intelligenetics sequence format (strict version).",
        "text": "igstrict"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3982"
        },
        "definition": "The CHAIN format describes a pairwise alignment that allow gaps in both sequences simultaneously and is used by the UCSC Genome Browser.",
        "text": "CHAIN"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_3466"
          },
          "definition": "Encapsulated PostScript format",
          "text": "EPS"
        }],
        "data": {
          "uri": "http://edamontology.org/format_3696"
        },
        "definition": "PostScript format",
        "exact_synonyms": ["PostScript"],
        "text": "PS"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_4007"
        },
        "definition": "The file format for MATLAB scripts or functions.",
        "exact_synonyms": ["MATLAB"],
        "text": "MATLAB script"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1637"
        },
        "definition": "Format of Affymetrix data file of raw image data.",
        "exact_synonyms": ["Affymetrix image data file format"],
        "is_format_of": ["http://edamontology.org/data_1714"],
        "text": "dat"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_4000"
        },
        "definition": "A file format for making dynamic documents (R Markdown scripts) with the R language.",
        "text": "R markdown"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3758"
        },
        "definition": "\"Raw\" result file from SEQUEST database search.",
        "text": "SEQUEST .out file"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1925"
        },
        "definition": "Codata entry format.",
        "text": "codata"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3978"
        },
        "definition": "The CONTIG format used for output of the SOAPdenovo alignment program. It contains contig sequences generated without using mate pair information.",
        "text": "CONTIG"
      }, {
        "comment": ["ISA-TAB is based on MAGE-TAB. Other than tabular, the ISA model can also be represented in RDF, and in JSON (compliable with a set of defined JSON Schemata)."],
        "data": {
          "uri": "http://edamontology.org/format_3687"
        },
        "definition": "The Investigation / Study / Assay (ISA) tab-delimited (TAB) format incorporates metadata from\nexperiments employing a combination of technologies.",
        "text": "ISA-TAB"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1349"
        },
        "definition": "Dirichlet distribution HMMER format.",
        "text": "HMMER Dirichlet prior"
      }, {
        "children": [{
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_2569"
            },
            "definition": "Alphabet for a DNA sequence (characters ACGT only) without unknown positions, ambiguity or non-sequence characters.",
            "text": "completely unambiguous pure dna"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_2568"
            },
            "definition": "Alphabet for a nucleotide sequence (characters ACGTU only) without unknown positions, ambiguity or non-sequence characters .",
            "text": "completely unambiguous pure nucleotide"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_2607"
            },
            "definition": "Alphabet for any protein sequence without unknown positions, ambiguity or non-sequence characters.",
            "text": "completely unambiguous pure protein"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_2570"
            },
            "definition": "Alphabet for an RNA sequence (characters ACGU only) without unknown positions, ambiguity or non-sequence characters.",
            "text": "completely unambiguous pure rna sequence"
          }],
          "data": {
            "uri": "http://edamontology.org/format_2567"
          },
          "definition": "Alphabet for a molecular sequence without unknown positions, ambiguity or non-sequence characters.",
          "text": "completely unambiguous pure"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2566"
        },
        "definition": "Alphabet for a molecular sequence without any unknown positions or ambiguity characters.",
        "text": "completely unambiguous"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1941"
        },
        "definition": "Hennig86 output sequence format.",
        "text": "hennig86"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1458"
        },
        "definition": "Format of local RNA secondary structure components with free energy values, generated by the Vienna RNA package/server.",
        "text": "Vienna local RNA secondary structure format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1297"
        },
        "definition": "Report format for tandem repeats in a sequence (an EMBOSS report format).",
        "text": "EMBOSS repeat"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1630"
        },
        "definition": "Common Assembly Format (CAF). A sequence assembly format including contigs, base-call qualities, and other metadata.",
        "text": "CAF"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3888"
        },
        "definition": "AMBER frcmod (Force field Modification) is a file format to store any modification to the standard force field needed for a particular molecule to be properly represented in the simulation.",
        "text": "AMBER frcmod"
      }, {
        "comment": ["This file format is for machine learning."],
        "data": {
          "uri": "http://edamontology.org/format_3581"
        },
        "definition": "ARFF (Attribute-Relation File Format) is an ASCII text file format that describes a list of instances sharing a set of attributes.",
        "text": "arff"
      }, {
        "comment": ["The general MF query format consists of a series of valid atomic symbols, with an optional number or range."],
        "data": {
          "uri": "http://edamontology.org/format_1198"
        },
        "definition": "Chemical structure specified by Molecular Formula (MF), including a count of each element in a compound.",
        "text": "mf"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1197"
        },
        "definition": "Chemical structure specified in IUPAC International Chemical Identifier (InChI) line notation.",
        "text": "InChI"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1248"
        },
        "definition": "Format for sequence positions (feature location) as used in DDBJ/EMBL/GenBank database.",
        "exact_synonyms": ["Feature location"],
        "text": "EMBL feature location"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3999"
        },
        "definition": "Format for scripts written in the R language - an open source programming language and software environment for statistical computing and graphics that is supported by the R Foundation for Statistical Computing.",
        "exact_synonyms": ["R program", "R"],
        "text": "R script"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3713"
        },
        "definition": "\"Raw\" result file from Mascot database search.",
        "text": "Mascot .dat file"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3886"
        },
        "definition": "AMBER coordinate/restart file with 6 coordinates per line and decimal format F12.7 (fixed point notation with field width 12 and 7 decimal places)",
        "exact_synonyms": ["restrt", "rst7"],
        "text": "RST"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1934"
        },
        "definition": "Fitch program format.",
        "text": "fitch program"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1319"
        },
        "definition": "Report format for restriction enzyme recognition sites used by EMBOSS restover program.",
        "text": "restover format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3499"
        },
        "definition": "Ensembl standard format for variation data.",
        "text": "Ensembl variation file format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1960"
        },
        "definition": "Staden suite sequence format.",
        "text": "Staden format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3975"
        },
        "definition": "Graphical Fragment Assembly captures sequence graphs as the product of an assembly, a representation of variation in genomes, splice graphs in genes, or even overlap between reads from long-read sequencing technology.",
        "text": "GFA 1"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_2000"
        },
        "definition": "SELEX format for (aligned) sequences.",
        "text": "selex"
      }, {
        "comment": ["GCG SSF (single sequence file) file format."],
        "data": {
          "uri": "http://edamontology.org/format_1935"
        },
        "definition": "GCG sequence file format.",
        "exact_synonyms": ["GCG SSF"],
        "text": "GCG"
      }, {
        "children": [{
          "comment": ["GCG SSF (single sequence file) file format."],
          "data": {
            "uri": "http://edamontology.org/format_1935"
          },
          "definition": "GCG sequence file format.",
          "exact_synonyms": ["GCG SSF"],
          "text": "GCG"
        }, {
          "comment": ["RSF-format files contain one or more sequences that may or may not be related. In addition to the sequence data, each sequence can be annotated with descriptive sequence information (from the GCG manual)."],
          "data": {
            "uri": "http://edamontology.org/format_3485"
          },
          "definition": "Rich sequence format.",
          "exact_synonyms": ["GCG RSF"],
          "text": "RSF"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1947"
          },
          "definition": "GCG MSF (multiple sequence file) file format.",
          "text": "GCG MSF"
        }],
        "data": {
          "uri": "http://edamontology.org/format_3486"
        },
        "definition": "Some format based on the GCG format.",
        "text": "GCG format variant"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3775"
        },
        "definition": "GSuite is a tabular format for collections of genome or sequence feature tracks, suitable for integrative multi-track analysis. GSuite contains links to genome/sequence tracks, with additional metadata.",
        "exact_synonyms": ["BioXSD|GTrack GSuite", "GSuite (GTrack ecosystem of formats)", "BioXSD/GTrack GSuite", "GSuite format", "GTrack|BTrack|GSuite GSuite", "GTrack|GSuite|BTrack GSuite"],
        "text": "GSuite"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1477"
        },
        "definition": "Entry format of PDB database in mmCIF format.",
        "text": "mmCIF"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3983"
        },
        "definition": "The NET file format is used to describe the data that underlie the net alignment annotations in the UCSC Genome Browser.",
        "text": "NET"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1979"
        },
        "definition": "EMBOSS debugging trace feature format of full internal data content.",
        "text": "debug-feat"
      }, {
        "comment": ["There is currently no tool available for conversion between GROMACS topology format and other formats, due to the internal differences in both approaches. There is, however, a method to convert small molecules parameterized with AMBER force-field into GROMACS format, allowing simulations of these systems with GROMACS MD package."],
        "data": {
          "uri": "http://edamontology.org/format_3887"
        },
        "definition": "Format of CHARMM Residue Topology Files (RTF), which define groups by including the atoms, the properties of the group, and bond and charge information.",
        "text": "CHARMM rtf"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1964"
        },
        "definition": "Plain text sequence format (essentially unformatted).",
        "text": "plain text format (unformatted)"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1923"
        },
        "definition": "ACEDB sequence format.",
        "text": "acedb"
      }, {
        "comment": ["N-Triples should not be confused with Notation 3 which is a superset of Turtle."],
        "data": {
          "uri": "http://edamontology.org/format_3256"
        },
        "definition": "A plain text serialisation format for RDF (Resource Description Framework) graphs, and a subset of the Turtle (Terse RDF Triple Language) format.",
        "text": "N-Triples"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1369"
        },
        "definition": "Format of the model of random sequences used by MEME.",
        "text": "MEME background Markov model"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_1936"
          },
          "definition": "Genbank entry format.",
          "exact_synonyms": ["GenBank"],
          "text": "GenBank format"
        }, {
          "comment": ["Currently identical to refseqp format"],
          "data": {
            "uri": "http://edamontology.org/format_1937"
          },
          "definition": "Genpept protein entry format.",
          "text": "genpept"
        }],
        "comment": ["This concept may be used for the non-standard GenBank-like text formats."],
        "data": {
          "uri": "http://edamontology.org/format_2205"
        },
        "definition": "A text format resembling GenBank entry (plain text) format.",
        "text": "GenBank-like format (text)"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3580"
        },
        "definition": "Reporter Code Count-A data file (.csv) output by the Nanostring nCounter Digital Analyzer, which contains gene sample information, probe information and probe counts.",
        "text": "rcc"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3822"
        },
        "definition": "GML (Graph Modeling Language) is a text file format supporting network data with a very easy syntax. It is used by Graphlet, Pajek, yEd, LEDA and NetworkX.",
        "exact_synonyms": ["GML format"],
        "text": "GML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1582"
        },
        "definition": "A report format for the kinetics of enzyme-catalysed reaction(s) in a format generated by EMBOSS findkm. This includes Michaelis Menten plot, Hanes Woolf plot, Michaelis Menten constant (Km) and maximum velocity (Vmax).",
        "text": "findkm"
      }, {
        "children": [{
          "comment": ["The table presents matches between query proteins (rows) and signature methods (columns) for this entry. Alternatively the sequence(s) might be from from the InterPro entry itself. The match position in the protein sequence and match status (true positive, false positive etc) are indicated."],
          "data": {
            "uri": "http://edamontology.org/format_1343"
          },
          "definition": "Format of results of a search of the InterPro database showing matches between protein sequence(s) and signatures for an InterPro entry.",
          "text": "InterPro match table format"
        }, {
          "comment": ["The report includes a classification of regions in a query protein sequence which are assigned to a known InterPro protein family or group."],
          "data": {
            "uri": "http://edamontology.org/format_1342"
          },
          "definition": "Format of results of a search of the InterPro database showing matches of query protein sequence(s) to InterPro entries.",
          "text": "InterPro protein view report format"
        }],
        "data": {
          "uri": "http://edamontology.org/format_1341"
        },
        "definition": "Results format for searches of the InterPro database.",
        "text": "InterPro hits format"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_1209"
          },
          "definition": "Alphabet for the consensus of two or more molecular sequences.",
          "text": "consensus"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2097"
        },
        "definition": "Alphabet for a molecular sequence with possible unknown positions and possible ambiguity characters.",
        "text": "ambiguous"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3554"
        },
        "definition": "File format used for scripts written in the R programming language for execution within the R software environment, typically for statistical computation and graphics.",
        "text": "R file format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1999"
        },
        "definition": "Alignment format for score values for pairs of sequences.",
        "text": "scores format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1351"
        },
        "definition": "Format of a report from the HMMER package on the emission and transition counts of a hidden Markov model.",
        "text": "HMMER emission and transition"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_2194"
        },
        "definition": "Abstract format used by MedLine database.",
        "text": "medline"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_2002"
        },
        "definition": "Simple multiple sequence (alignment) format for SRS.",
        "text": "srs format"
      }, {
        "comment": ["An InChIKey identifier is not human- nor machine-readable but is more suitable for web searches than an InChI chemical structure specification."],
        "data": {
          "uri": "http://edamontology.org/format_1199"
        },
        "definition": "The InChIKey (hashed InChI) is a fixed length (25 character) condensed digital representation of an InChI chemical structure specification. It uniquely identifies a chemical compound.",
        "text": "InChIKey"
      }, {
        "comment": ["Format for multiple aligned or single sequences together with the probabilistic description of the (consensus) RNA secondary structure ensemble by probabilities of base pairs, base pair stackings, and base pairs and unpaired bases in the loop of base pairs."],
        "data": {
          "uri": "http://edamontology.org/format_3728"
        },
        "definition": "The LocARNA PP format combines sequence or alignment information and (respectively, single or consensus) ensemble probabilities into an PP 2.0 record.",
        "text": "LocARNA PP"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3878"
        },
        "definition": "AMBER trajectory (also called mdcrd), with 10 coordinates per line and format F8.3 (fixed point notation with field width 8 and 3 decimal places).",
        "exact_synonyms": ["inpcrd", "AMBER trajectory format"],
        "text": "mdcrd"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1957"
        },
        "definition": "Raw sequence format with no non-sequence characters.",
        "text": "raw"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_1458"
          },
          "definition": "Format of local RNA secondary structure components with free energy values, generated by the Vienna RNA package/server.",
          "text": "Vienna local RNA secondary structure format"
        }],
        "data": {
          "uri": "http://edamontology.org/format_1457"
        },
        "definition": "Format of RNA secondary structure in dot-bracket notation, originally generated by the Vienna RNA package/server.",
        "exact_synonyms": ["Vienna RNA secondary structure format", "Vienna RNA format"],
        "text": "Dot-bracket format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3014"
        },
        "definition": "LAV format of alignments generated by BLASTZ and LASTZ.",
        "text": "LAV"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_3328"
          },
          "definition": "HMMER profile HMM file for HMMER versions 2.x",
          "text": "HMMER2"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3329"
          },
          "definition": "HMMER profile HMM file for HMMER versions 3.x",
          "text": "HMMER3"
        }],
        "data": {
          "uri": "http://edamontology.org/format_1370"
        },
        "definition": "Format of a hidden Markov model representation used by the HMMER package.",
        "text": "HMMER format"
      }, {
        "comment": ["ProQ is a neural network-based predictor that predicts the quality of a protein model based on the number of structural features."],
        "data": {
          "uri": "http://edamontology.org/format_1552"
        },
        "definition": "Format of output of the ProQ protein model quality predictor.",
        "text": "ProQ report format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1973"
        },
        "definition": "Nexus/paup non-interleaved sequence format.",
        "text": "nexusnon"
      }, {
        "comment": ["The format is clustal-like and includes annotation of domain family classification information."],
        "data": {
          "uri": "http://edamontology.org/format_1393"
        },
        "definition": "EMBASSY 'domain alignment file' (DAF) format, containing a sequence alignment of protein domains belonging to the same SCOP or CATH family.",
        "text": "daf"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1391"
        },
        "definition": "FASTA-style format for multiple sequences aligned by HMMER package to an HMM.",
        "text": "HMMER-aln"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3829"
        },
        "definition": "GenePix Results (GPR) text file format developed by Axon Instruments that is used to save GenePix Results data.",
        "text": "GPR"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3992"
        },
        "definition": "Compact Idiosyncratic Gapped Alignment Report format is a compressed (run-length encoded) pairwise alignment format. It is useful for representing long (e.g. genomic) pairwise alignments.",
        "exact_synonyms": ["CIGAR"],
        "text": "CIGAR format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1962"
        },
        "definition": "DNA strider output sequence format.",
        "text": "strider format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1982"
        },
        "definition": "ClustalW format for (aligned) sequences.",
        "exact_synonyms": ["clustal"],
        "text": "ClustalW format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1739"
        },
        "definition": "Article format of the PubMed Central database.",
        "text": "pmc"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_3331"
          },
          "definition": "XML format as produced by the NCBI Blast package",
          "text": "BLAST XML results format"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3836"
          },
          "definition": "XML format as produced by the NCBI Blast package v2.",
          "text": "BLAST XML v2 results format"
        }],
        "comment": ["This includes score data, alignment data and summary table."],
        "data": {
          "uri": "http://edamontology.org/format_1333"
        },
        "definition": "Format of results of a sequence database search using some variant of BLAST.",
        "text": "BLAST results"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_1200"
          },
          "definition": "SMILES ARbitrary Target Specification (SMARTS) format for chemical structure specification, which is a subset of the SMILES line notation.",
          "text": "smarts"
        }],
        "data": {
          "uri": "http://edamontology.org/format_1196"
        },
        "definition": "Chemical structure specified in Simplified Molecular Input Line Entry System (SMILES) line notation.",
        "text": "SMILES"
      }, {
        "comment": ["Data Type must include the distance matrix, probably as pairs of sequence identifiers with a distance (integer or float)."],
        "data": {
          "uri": "http://edamontology.org/format_1423"
        },
        "definition": "Format of PHYLIP phylogenetic distance matrix data.",
        "text": "Phylip distance matrix"
      }, {
        "comment": ["Bibliographic reference information including citation information is included"],
        "data": {
          "uri": "http://edamontology.org/format_1735"
        },
        "definition": "Format for abstracts of scientific articles from the Medline database.",
        "text": "Medline Display Format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1433"
        },
        "definition": "Format of PHYLIP discrete states data.",
        "text": "Phylip discrete states format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1638"
        },
        "definition": "Format of Affymetrix data file of information about (raw) expression levels of the individual probes.",
        "exact_synonyms": ["Affymetrix probe raw data format"],
        "is_format_of": ["http://edamontology.org/data_3110"],
        "text": "cel"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1944"
        },
        "definition": "Jackknifer interleaved and non-interleaved sequence format.",
        "text": "jackknifer"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1422"
        },
        "definition": "Format used by the HMMER package for of an alignment of a hidden Markov model against a sequence database.",
        "text": "HMMER profile alignment (HMM versus sequences)"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1990"
        },
        "definition": "Alignment format for start and end of matches between sequence pairs.",
        "text": "match"
      }, {
        "comment": ["JCAMP-DX is an ASCII based format and therefore not very compact even though it includes standards for file compression."],
        "data": {
          "uri": "http://edamontology.org/format_3859"
        },
        "definition": "A standardized file format for data exchange in mass spectrometry, initially developed for infrared spectrometry.",
        "text": "JCAMP-DX"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1425"
        },
        "definition": "Raw data file format used by Phylip from which a phylogenetic tree is directly generated or plotted.",
        "text": "Phylip tree raw"
      }, {
        "children": [{
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_1215"
            },
            "definition": "Alphabet for a DNA sequence with possible ambiguity and unknown positions but without non-sequence characters.",
            "text": "pure dna"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1217"
            },
            "definition": "Alphabet for an RNA sequence with possible ambiguity and unknown positions but without non-sequence characters.",
            "text": "pure rna"
          }],
          "data": {
            "uri": "http://edamontology.org/format_1210"
          },
          "definition": "Alphabet for a nucleotide sequence with possible ambiguity and unknown positions but without non-sequence characters.",
          "text": "pure nucleotide"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_2569"
            },
            "definition": "Alphabet for a DNA sequence (characters ACGT only) without unknown positions, ambiguity or non-sequence characters.",
            "text": "completely unambiguous pure dna"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_2568"
            },
            "definition": "Alphabet for a nucleotide sequence (characters ACGTU only) without unknown positions, ambiguity or non-sequence characters .",
            "text": "completely unambiguous pure nucleotide"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_2607"
            },
            "definition": "Alphabet for any protein sequence without unknown positions, ambiguity or non-sequence characters.",
            "text": "completely unambiguous pure protein"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_2570"
            },
            "definition": "Alphabet for an RNA sequence (characters ACGU only) without unknown positions, ambiguity or non-sequence characters.",
            "text": "completely unambiguous pure rna sequence"
          }],
          "data": {
            "uri": "http://edamontology.org/format_2567"
          },
          "definition": "Alphabet for a molecular sequence without unknown positions, ambiguity or non-sequence characters.",
          "text": "completely unambiguous pure"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1219"
          },
          "definition": "Alphabet for any protein sequence with possible ambiguity and unknown positions but without non-sequence characters.",
          "text": "pure protein"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_1218"
            },
            "definition": "Alphabet for any protein sequence with possible unknown positions but without ambiguity or non-sequence characters.",
            "text": "unambiguous pure protein"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1211"
            },
            "definition": "Alphabet for a nucleotide sequence (characters ACGTU only) with possible unknown positions but without ambiguity or non-sequence characters .",
            "text": "unambiguous pure nucleotide"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1216"
            },
            "definition": "Alphabet for an RNA sequence (characters ACGU only) with possible unknown positions but without ambiguity or non-sequence characters.",
            "text": "unambiguous pure rna sequence"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1214"
            },
            "definition": "Alphabet for a DNA sequence (characters ACGT only) with possible unknown positions but without ambiguity or non-sequence characters.",
            "text": "unambiguous pure dna"
          }],
          "data": {
            "uri": "http://edamontology.org/format_1206"
          },
          "definition": "Alphabet for a molecular sequence with possible unknown positions but without ambiguity or non-sequence characters.",
          "text": "unambiguous pure"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2094"
        },
        "definition": "Alphabet for molecular sequence with possible unknown positions but without non-sequence characters.",
        "text": "pure"
      }, {
        "comment": ["pdb format in EMBOSS."],
        "data": {
          "uri": "http://edamontology.org/format_1950"
        },
        "definition": "PDB sequence format (ATOM lines).",
        "text": "pdbatom"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3972"
        },
        "definition": "BioNetGen is a format for the specification and simulation of rule-based models of biochemical systems, including signal transduction, metabolic, and genetic regulatory networks.",
        "exact_synonyms": ["BioNetGen Language"],
        "is_format_of": ["http://edamontology.org/data_3241"],
        "text": "BNGL"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1961"
        },
        "definition": "Stockholm multiple sequence alignment format (used by Pfam and Rfam).",
        "text": "Stockholm format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3998"
        },
        "definition": "Format for scripts written in Perl - a family of high-level, general-purpose, interpreted, dynamic programming languages.",
        "exact_synonyms": ["Perl", "Perl program"],
        "text": "Perl script"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3310"
        },
        "definition": "XRNA old input style format.",
        "text": "SS"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_2001"
        },
        "definition": "EMBOSS simple multiple alignment format.",
        "text": "EMBOSS simple format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1421"
        },
        "definition": "Format used by the HMMER package for an alignment of a sequence against a hidden Markov model database.",
        "text": "HMMER profile alignment (sequences versus HMMs)"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3827"
        },
        "definition": ". proBED is an adaptation of BED (format_3003), which was extended to meet specific requirements entailed by proteomics data.",
        "text": "proBED"
      }, {
        "comment": ["The Database of Genotypes and Phenotypes (dbGaP) is a National Institutes of Health (NIH) sponsored repository charged to archive, curate and distribute information produced by studies investigating the interaction of genotype and phenotype."],
        "data": {
          "uri": "http://edamontology.org/format_3729"
        },
        "definition": "Input format used by the Database of Genotypes and Phenotypes (dbGaP).",
        "text": "dbGaP format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3815"
        },
        "definition": "An MDL Molfile is a file format for holding information about the atoms, bonds, connectivity and coordinates of a molecule.",
        "text": "Molfile"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1641"
        },
        "definition": "Affymetrix data file format for information about experimental conditions and protocols.",
        "exact_synonyms": ["Affymetrix experimental conditions data file format"],
        "text": "affymetrix-exp"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1629"
        },
        "definition": "Format of MIRA sequence trace information file.",
        "text": "mira"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1983"
        },
        "definition": "EMBOSS alignment format for debugging trace of full internal data content.",
        "text": "debug"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3788"
        },
        "definition": "SQL (Structured Query Language) is the de-facto standard query language (format of queries) for querying and manipulating data in relational databases.",
        "exact_synonyms": ["Structured Query Language"],
        "text": "SQL"
      }, {
        "children": [{
          "comment": ["It differs from Phylip sequential format (format_1997) on length of the ID sequence. There no length restrictions on the ID, but whitespaces aren't allowed in the sequence ID/Name because one space separates the longest ID and the beginning of the sequence. Sequences IDs must be padded to the longest ID length."],
          "data": {
            "uri": "http://edamontology.org/format_3820"
          },
          "definition": "Phylip multiple alignment sequence format, less stringent than PHYLIP sequential format (format_1998).",
          "exact_synonyms": ["Relaxed PHYLIP sequential format", "Relaxed PHYLIP non-interleaved", "Relaxed PHYLIP non-interleaved format"],
          "text": "Relaxed PHYLIP Sequential"
        }, {
          "comment": ["It differs from Phylip Format (format_1997) on length of the ID sequence. There no length restrictions on the ID, but whitespaces aren't allowed in the sequence ID/Name because one space separates the longest ID and the beginning of the sequence. Sequences IDs must be padded to the longest ID length."],
          "data": {
            "uri": "http://edamontology.org/format_3819"
          },
          "definition": "Phylip multiple alignment sequence format, less stringent than PHYLIP format.",
          "exact_synonyms": ["PHYLIP Interleaved format"],
          "text": "Relaxed PHYLIP Interleaved"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1997"
          },
          "definition": "Phylip format for (aligned) sequences.",
          "exact_synonyms": ["PHYLIP", "phy", "PHYLIP interleaved format", "ph"],
          "text": "PHYLIP format"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1998"
          },
          "definition": "Phylip non-interleaved format for (aligned) sequences.",
          "exact_synonyms": ["PHYLIP sequential format", "phylipnon"],
          "text": "PHYLIP sequential"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2924"
        },
        "definition": "Some variant of Phylip format for (aligned) sequences.",
        "text": "Phylip format variant"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3814"
        },
        "definition": "SDF is one of a family of chemical-data file formats developed by MDL Information Systems; it is intended especially for structural information.",
        "text": "SDF"
      }, {
        "children": [{
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_1218"
            },
            "definition": "Alphabet for any protein sequence with possible unknown positions but without ambiguity or non-sequence characters.",
            "text": "unambiguous pure protein"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1211"
            },
            "definition": "Alphabet for a nucleotide sequence (characters ACGTU only) with possible unknown positions but without ambiguity or non-sequence characters .",
            "text": "unambiguous pure nucleotide"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1216"
            },
            "definition": "Alphabet for an RNA sequence (characters ACGU only) with possible unknown positions but without ambiguity or non-sequence characters.",
            "text": "unambiguous pure rna sequence"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_1214"
            },
            "definition": "Alphabet for a DNA sequence (characters ACGT only) with possible unknown positions but without ambiguity or non-sequence characters.",
            "text": "unambiguous pure dna"
          }],
          "data": {
            "uri": "http://edamontology.org/format_1206"
          },
          "definition": "Alphabet for a molecular sequence with possible unknown positions but without ambiguity or non-sequence characters.",
          "text": "unambiguous pure"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2096"
        },
        "definition": "Alphabet for a molecular sequence with possible unknown positions but without ambiguity characters.",
        "text": "unambiguous sequence"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1455"
        },
        "definition": "Entry format of the HSSP database (Homology-derived Secondary Structure in Proteins).",
        "text": "hssp"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1644"
        },
        "definition": "Format of Affymetrix data file of information about (normalised) expression levels of the individual probes.",
        "exact_synonyms": ["Affymetrix probe normalised data format"],
        "is_format_of": ["http://edamontology.org/data_3111"],
        "text": "CHP"
      }, {
        "comment": ["uses the TeX typesetting program format"],
        "data": {
          "uri": "http://edamontology.org/format_3817"
        },
        "definition": "format for the LaTeX document preparation system",
        "exact_synonyms": ["LaTeX format"],
        "text": "latex"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3551"
        },
        "definition": "Nearly Raw Rasta Data format designed to support scientific visualisation and image processing involving N-dimensional raster data.",
        "text": "nrrd"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3309"
        },
        "definition": "File format of a CT (Connectivity Table) file from the RNAstructure package.",
        "exact_synonyms": ["Connect format", "Connectivity Table file format"],
        "text": "CT"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1633"
        },
        "definition": "PHD sequence trace format to store serialised chromatogram data (reads).",
        "text": "PHD"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3916"
        },
        "definition": "The Matrix Market matrix (MTX) format stores numerical or pattern matrices in a dense (array format) or sparse (coordinate format) representation.",
        "is_format_of": ["http://edamontology.org/data_3112", "http://edamontology.org/data_2535"],
        "text": "MTX"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1366"
        },
        "definition": "Sequence profile (sequence classifier) format used in the PROSITE database.",
        "text": "prosite-profile"
      }, {
        "comment": ["There is currently no tool available for conversion between GROMACS topology format and other formats, due to the internal differences in both approaches. There is, however, a method to convert small molecules parameterized with AMBER force-field into GROMACS format, allowing simulations of these systems with GROMACS MD package."],
        "data": {
          "uri": "http://edamontology.org/format_3880"
        },
        "definition": "GROMACS MD package top textual files define an entire structure system topology, either directly, or by including itp files.",
        "text": "GROMACS top"
      }, {
        "comment": ["XYZ files are structured in this way:  First line contains the number of atoms in the file.  Second line contains a title, comment, or filename. Remaining lines contain atom information. Each line starts with the element symbol, followed by x, y and z coordinates in angstroms separated by whitespace. Multiple molecules or frames can be contained within one file, so it supports trajectory storage. XYZ files can be directly represented by a molecular viewer, as they contain all the basic information needed to build the 3D model."],
        "data": {
          "uri": "http://edamontology.org/format_3877"
        },
        "definition": "The XYZ chemical file format is widely supported by many programs, although many slightly different XYZ file formats coexist (Tinker XYZ, UniChem XYZ, etc.). Basic information stored for each atom in the system are x, y and z coordinates and atom element/atomic number.",
        "text": "XYZ"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3889"
        },
        "definition": "AMBER Object File Format library files (OFF library files) store residue libraries (forcefield residue parameters).",
        "exact_synonyms": ["AMBER Object File Format", "AMBER lib"],
        "text": "AMBER off"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1296"
        },
        "definition": "Report format for inverted repeats in a nucleotide sequence (format generated by the Sanger Centre inverted program).",
        "text": "Sanger inverted repeats"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1942"
        },
        "definition": "Intelligenetics sequence format.",
        "text": "ig"
      }, {
        "comment": ["It is called FASTG, like FASTA, but the G stands for \"graph\"."],
        "data": {
          "uri": "http://edamontology.org/format_3823"
        },
        "definition": "FASTG is a format for faithfully representing genome assemblies in the face of allelic polymorphism and assembly uncertainty.",
        "exact_synonyms": ["FASTG assembly graph format"],
        "text": "FASTG"
      }, {
        "comment": ["Reflects a UCSC Browser DB table."],
        "data": {
          "uri": "http://edamontology.org/format_3235"
        },
        "definition": "Cytoband format for chromosome cytobands.",
        "is_format_of": ["http://edamontology.org/data_3236"],
        "text": "Cytoband format"
      }, {
        "comment": ["N-Quads should not be confused with N-Triples which does not contain graph information."],
        "data": {
          "uri": "http://edamontology.org/format_3956"
        },
        "definition": "N-Quads is a line-based, plain text format for encoding an RDF dataset. It includes information about the graph each triple belongs to.",
        "text": "N-Quads"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_2003"
        },
        "definition": "Simple sequence pair (alignment) format for SRS.",
        "text": "srspair"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3001"
        },
        "definition": "ACE sequence assembly format including contigs, base-call qualities, and other metadata (version Aug 1998 and onwards).",
        "text": "ACE"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1949"
        },
        "definition": "Nexus/paup interleaved sequence format.",
        "text": "nexus-seq"
      }, {
        "comment": ["Currently identical to genpept format"],
        "data": {
          "uri": "http://edamontology.org/format_1958"
        },
        "definition": "Refseq protein entry sequence format.",
        "text": "refseqp"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3818"
        },
        "definition": "Tab-delimited text file format used by Eland - the read-mapping program distributed by Illumina with its sequencing analysis pipeline - which maps short Solexa sequence reads to the human reference genome.",
        "exact_synonyms": ["ELAND", "eland"],
        "text": "ELAND format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1360"
        },
        "definition": "A motif in the format generated by the MEME program.",
        "text": "meme-motif"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3555"
        },
        "definition": "File format used for scripts for the Statistical Package for the Social Sciences.",
        "text": "SPSS"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1476"
        },
        "definition": "Entry format of PDB database in PDB format.",
        "exact_synonyms": ["PDB format"],
        "text": "PDB"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1734"
        },
        "definition": "Format of bibliographic reference as used by the PubMed database.",
        "text": "PubMed citation"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1639"
        },
        "definition": "Format of affymetrix gene cluster files (hc-genes.txt, hc-chips.txt) from hierarchical clustering.",
        "text": "affymetrix"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1356"
        },
        "definition": "Format of a regular expression pattern from the Prosite database.",
        "text": "prosite-pattern"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3252"
        },
        "definition": "A human-readable encoding for the Web Ontology Language (OWL).",
        "text": "OWL Functional Syntax"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3909"
        },
        "definition": "BpForms is a string format for concretely representing the primary structures of biopolymers, including DNA, RNA, and proteins that include non-canonical nucleic and amino acids. See https://www.bpforms.org for more information.",
        "is_format_of": ["http://edamontology.org/data_1255"],
        "text": "BpForms"
      }, {
        "children": [{
          "comment": ["There are several variants of this."],
          "data": {
            "uri": "http://edamontology.org/format_1972"
          },
          "definition": "NCBI FASTA sequence format with NCBI-style IDs.",
          "text": "NCBI format"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1926"
          },
          "definition": "Fasta format variant with database name before ID.",
          "text": "dbid"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1954"
          },
          "definition": "Plain old FASTA sequence format (unspecified format for IDs).",
          "text": "Pearson format"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3281"
          },
          "definition": "The A2M format is used as the primary format for multiple alignments of protein or nucleic-acid sequences in the SAM suite of tools. It is a small modification of FASTA format for sequences and is compatible with most tools that read FASTA.",
          "text": "A2M"
        }, {
          "comment": ["FASTA format extended for color space information."],
          "data": {
            "uri": "http://edamontology.org/format_3589"
          },
          "definition": "Color space FASTA format sequence variant.",
          "text": "csfasta"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1940"
          },
          "definition": "FASTA sequence format including NCBI-style GIs.",
          "text": "giFASTA format"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1929"
          },
          "definition": "FASTA format including NCBI-style IDs.",
          "exact_synonyms": ["FASTA sequence format", "FASTA format"],
          "text": "FASTA"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1391"
          },
          "definition": "FASTA-style format for multiple sequences aligned by HMMER package to an HMM.",
          "text": "HMMER-aln"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_1984"
          },
          "definition": "Fasta format for (aligned) sequences.",
          "text": "FASTA-aln"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3811"
          },
          "definition": "The A2M format is used as the primary format for multiple alignments of protein or nucleic-acid sequences in the SAM suite of tools. It is a small modification of FASTA format for sequences and is compatible with most tools that read FASTA.",
          "exact_synonyms": ["eXtended Multi-FastA format", "alignment format"],
          "text": "XMFA"
        }],
        "comment": ["This concept may also be used for the many non-standard FASTA-like formats."],
        "data": {
          "uri": "http://edamontology.org/format_2200"
        },
        "definition": "A text format resembling FASTA format.",
        "text": "FASTA-like (text)"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1318"
        },
        "definition": "Report format for restriction enzyme recognition sites used by EMBOSS restrict program.",
        "text": "restrict format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1320"
        },
        "definition": "Report format for restriction enzyme recognition sites used by REBASE database.",
        "text": "REBASE restriction sites"
      }, {
        "comment": ["pdbnucseq format in EMBOSS."],
        "data": {
          "uri": "http://edamontology.org/format_1952"
        },
        "definition": "PDB nucleotide sequence format (SEQRES lines).",
        "text": "pdbseqresnuc"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3005"
        },
        "definition": "Wiggle format (WIG) of a sequence annotation track that consists of a value for each sequence position. Typically to be displayed in a genome browser.",
        "text": "WIG"
      }],
      "comment": ["Data in text format can be compressed into binary format, or can be a value of an XML element or attribute. Markup formats are not considered textual (or more precisely, not plain-textual)."],
      "data": {
        "uri": "http://edamontology.org/format_2330"
      },
      "definition": "Textual format.",
      "narrow_synonyms": ["Plain text format", "txt"],
      "text": "Textual format"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/format_3773"
        },
        "definition": "BioYAML is a BioXSD-schema-based YAML format of sequence-based data and some other common data - sequence records, alignments, feature records, references to resources, and more - optimised for integrative bioinformatics, web APIs, human readability and editting, and object-oriented programming.",
        "exact_synonyms": ["BioYAML format", "BioXSD YAML format", "BioYAML format (BioXSD)", "BioXSD in YAML format", "BioXSD BioYAML format", "BioYAML (BioXSD data model)", "BioXSD|BioJSON|BioYAML BioYAML", "BioXSD YAML", "BioXSD|GTrack BioYAML", "BioXSD/GTrack BioYAML", "BioXSD in YAML", "BioXSD BioYAML", "BioYAML (BioXSD)", "BioXSD+YAML"],
        "is_format_of": ["http://edamontology.org/data_0863", "http://edamontology.org/data_1255", "http://edamontology.org/data_1772", "http://edamontology.org/data_3108", "http://edamontology.org/data_2044"],
        "text": "BioYAML"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_3774"
          },
          "definition": "BioJSON is a JSON format of single multiple sequence alignments, with their annotations, features, and custom visualisation and application settings for the Jalview workbench.",
          "exact_synonyms": ["JSON (Jalview)", "Jalview JSON", "JSON format (Jalview)", "Jalview JSON format", "Jalview BioJSON format", "BioJSON format (Jalview)", "Jalview BioJSON"],
          "is_format_of": ["http://edamontology.org/data_1255", "http://edamontology.org/data_0863"],
          "text": "BioJSON (Jalview)"
        }, {
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_3784"
            },
            "definition": "A format of text annotation using the linked-data Open Annotation Data Model, serialised typically in RDF or JSON-LD.",
            "text": "Open Annotation format"
          }],
          "data": {
            "uri": "http://edamontology.org/format_3749"
          },
          "definition": "JSON-LD, or JavaScript Object Notation for Linked Data, is a method of encoding Linked Data using JSON.",
          "exact_synonyms": ["JavaScript Object Notation for Linked Data"],
          "text": "JSON-LD"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3969"
          },
          "definition": "Vega is a visualization grammar, a declarative language for creating, saving, and sharing interactive visualization designs. With Vega, you can describe the visual appearance and interactive behavior of a visualization in a JSON format, and generate web-based views using Canvas or SVG.",
          "text": "Vega"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3781"
          },
          "definition": "JSON format of annotated scientific text used by PubAnnotations and other tools.",
          "text": "PubAnnotation format"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3772"
          },
          "definition": "BioJSON is a BioXSD-schema-based JSON format of sequence-based data and some other common data - sequence records, alignments, feature records, references to resources, and more - optimised for integrative bioinformatics, web applications and APIs, and object-oriented programming.",
          "exact_synonyms": ["BioXSD BioJSON", "BioXSD+JSON", "BioXSD BioJSON format", "BioXSD in JSON", "BioXSD in JSON format", "BioXSD|GTrack BioJSON", "BioXSD JSON", "BioJSON format (BioXSD)", "BioXSD|BioJSON|BioYAML BioJSON", "BioJSON (BioXSD data model)", "BioXSD/GTrack BioJSON", "BioXSD JSON format"],
          "is_format_of": ["http://edamontology.org/data_2044", "http://edamontology.org/data_1772", "http://edamontology.org/data_0863", "http://edamontology.org/data_3108", "http://edamontology.org/data_1255"],
          "text": "BioJSON (BioXSD)"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3970"
          },
          "definition": "Vega-Lite is a high-level grammar of interactive graphics. It provides a concise JSON syntax for rapidly generating visualizations to support analysis. Vega-Lite specifications can be compiled to Vega specifications.",
          "text": "Vega-lite"
        }],
        "data": {
          "uri": "http://edamontology.org/format_3464"
        },
        "definition": "JavaScript Object Notation format; a lightweight, text-based format to represent tree-structured data using key-value pairs.",
        "exact_synonyms": ["JavaScript Object Notation"],
        "text": "JSON"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3857"
        },
        "definition": "Common Workflow Language (CWL) format for description of command-line tools and workflows.",
        "exact_synonyms": ["CommonWL", "Common Workflow Language"],
        "text": "CWL"
      }],
      "comment": ["Data in YAML format can be serialised into text, or binary format.", "YAML version 1.2 is a superset of JSON; prior versions were \"not strictly compatible\"."],
      "data": {
        "uri": "http://edamontology.org/format_3750"
      },
      "definition": "YAML (YAML Ain't Markup Language) is a human-readable tree-structured data serialisation language.",
      "exact_synonyms": ["YAML Ain't Markup Language"],
      "text": "YAML"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/format_3774"
        },
        "definition": "BioJSON is a JSON format of single multiple sequence alignments, with their annotations, features, and custom visualisation and application settings for the Jalview workbench.",
        "exact_synonyms": ["JSON (Jalview)", "Jalview JSON", "JSON format (Jalview)", "Jalview JSON format", "Jalview BioJSON format", "BioJSON format (Jalview)", "Jalview BioJSON"],
        "is_format_of": ["http://edamontology.org/data_1255", "http://edamontology.org/data_0863"],
        "text": "BioJSON (Jalview)"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_3784"
          },
          "definition": "A format of text annotation using the linked-data Open Annotation Data Model, serialised typically in RDF or JSON-LD.",
          "text": "Open Annotation format"
        }],
        "data": {
          "uri": "http://edamontology.org/format_3749"
        },
        "definition": "JSON-LD, or JavaScript Object Notation for Linked Data, is a method of encoding Linked Data using JSON.",
        "exact_synonyms": ["JavaScript Object Notation for Linked Data"],
        "text": "JSON-LD"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3969"
        },
        "definition": "Vega is a visualization grammar, a declarative language for creating, saving, and sharing interactive visualization designs. With Vega, you can describe the visual appearance and interactive behavior of a visualization in a JSON format, and generate web-based views using Canvas or SVG.",
        "text": "Vega"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3781"
        },
        "definition": "JSON format of annotated scientific text used by PubAnnotations and other tools.",
        "text": "PubAnnotation format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3772"
        },
        "definition": "BioJSON is a BioXSD-schema-based JSON format of sequence-based data and some other common data - sequence records, alignments, feature records, references to resources, and more - optimised for integrative bioinformatics, web applications and APIs, and object-oriented programming.",
        "exact_synonyms": ["BioXSD BioJSON", "BioXSD+JSON", "BioXSD BioJSON format", "BioXSD in JSON", "BioXSD in JSON format", "BioXSD|GTrack BioJSON", "BioXSD JSON", "BioJSON format (BioXSD)", "BioXSD|BioJSON|BioYAML BioJSON", "BioJSON (BioXSD data model)", "BioXSD/GTrack BioJSON", "BioXSD JSON format"],
        "is_format_of": ["http://edamontology.org/data_2044", "http://edamontology.org/data_1772", "http://edamontology.org/data_0863", "http://edamontology.org/data_3108", "http://edamontology.org/data_1255"],
        "text": "BioJSON (BioXSD)"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3970"
        },
        "definition": "Vega-Lite is a high-level grammar of interactive graphics. It provides a concise JSON syntax for rapidly generating visualizations to support analysis. Vega-Lite specifications can be compiled to Vega specifications.",
        "text": "Vega-lite"
      }],
      "data": {
        "uri": "http://edamontology.org/format_3464"
      },
      "definition": "JavaScript Object Notation format; a lightweight, text-based format to represent tree-structured data using key-value pairs.",
      "exact_synonyms": ["JavaScript Object Notation"],
      "text": "JSON"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/format_3784"
        },
        "definition": "A format of text annotation using the linked-data Open Annotation Data Model, serialised typically in RDF or JSON-LD.",
        "text": "Open Annotation format"
      }, {
        "comment": ["RDF/XML is a serialisation syntax for OWL DL, but not for OWL Full."],
        "data": {
          "uri": "http://edamontology.org/format_3261"
        },
        "definition": "Resource Description Framework (RDF) XML format.",
        "text": "RDF/XML"
      }, {
        "comment": ["The SPARQL Query Language incorporates a very similar syntax."],
        "data": {
          "uri": "http://edamontology.org/format_3255"
        },
        "definition": "The Terse RDF Triple Language (Turtle) is a human-friendly serialisation format for RDF (Resource Description Framework) graphs.",
        "text": "Turtle"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3257"
        },
        "definition": "A shorthand non-XML serialisation of Resource Description Framework model, designed with human-readability in mind.",
        "exact_synonyms": ["N3"],
        "text": "Notation3"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_3262"
          },
          "definition": "OWL ontology XML serialisation format.",
          "narrow_synonyms": ["OWL"],
          "text": "OWL/XML"
        }, {
          "comment": ["This format was influenced by the OWL Abstract Syntax and the DL style syntax."],
          "data": {
            "uri": "http://edamontology.org/format_3253"
          },
          "definition": "A syntax for writing OWL class expressions.",
          "text": "Manchester OWL Syntax"
        }, {
          "data": {
            "uri": "http://edamontology.org/format_3252"
          },
          "definition": "A human-readable encoding for the Web Ontology Language (OWL).",
          "text": "OWL Functional Syntax"
        }],
        "data": {
          "uri": "http://edamontology.org/format_2197"
        },
        "definition": "A serialisation format conforming to the Web Ontology Language (OWL) model.",
        "text": "OWL format"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_3784"
          },
          "definition": "A format of text annotation using the linked-data Open Annotation Data Model, serialised typically in RDF or JSON-LD.",
          "text": "Open Annotation format"
        }],
        "data": {
          "uri": "http://edamontology.org/format_3749"
        },
        "definition": "JSON-LD, or JavaScript Object Notation for Linked Data, is a method of encoding Linked Data using JSON.",
        "exact_synonyms": ["JavaScript Object Notation for Linked Data"],
        "text": "JSON-LD"
      }, {
        "comment": ["N-Triples should not be confused with Notation 3 which is a superset of Turtle."],
        "data": {
          "uri": "http://edamontology.org/format_3256"
        },
        "definition": "A plain text serialisation format for RDF (Resource Description Framework) graphs, and a subset of the Turtle (Terse RDF Triple Language) format.",
        "text": "N-Triples"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3771"
        },
        "definition": "UniProtKB RDF sequence features format is an RDF format available for downloading UniProt entries (in RDF/XML).",
        "exact_synonyms": ["UniProt RDF format", "UniProtKB RDF format", "UniProt RDF"],
        "narrow_synonyms": ["UniProt RDF/XML", "UniProtKB RDF/XML format", "UniProtKB RDF/XML", "UniProt RDF/XML format"],
        "text": "UniProtKB RDF"
      }, {
        "comment": ["N-Quads should not be confused with N-Triples which does not contain graph information."],
        "data": {
          "uri": "http://edamontology.org/format_3956"
        },
        "definition": "N-Quads is a line-based, plain text format for encoding an RDF dataset. It includes information about the graph each triple belongs to.",
        "text": "N-Quads"
      }],
      "data": {
        "uri": "http://edamontology.org/format_2376"
      },
      "definition": "A serialisation format conforming to the Resource Description Framework (RDF) model.",
      "exact_synonyms": ["Resource Description Framework format"],
      "text": "RDF format"
    }, {
      "children": [{
        "data": {
          "uri": "http://edamontology.org/format_3240"
        },
        "definition": "CellML, the format for mathematical models of biological and other networks.",
        "text": "CellML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3835"
        },
        "definition": "Format supported by the Tide tool for identifying peptides from tandem mass spectra.",
        "text": "TIDE TXT"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3690"
        },
        "definition": "Biological Dynamics Markup Language (BDML) is an XML format for quantitative data describing biological dynamics.",
        "text": "BDML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_2352"
        },
        "definition": "BioXSD-schema-based XML format of sequence-based data and some other common data - sequence records, alignments, feature records, references to resources, and more - optimised for integrative bioinformatics, Web services, and object-oriented programming.",
        "exact_synonyms": ["BioXSD XML", "BioXSD+XML", "BioXSD XML format", "BioXSD in XML", "BioXSD in XML format"],
        "is_format_of": ["http://edamontology.org/data_1772", "http://edamontology.org/data_1255", "http://edamontology.org/data_3108", "http://edamontology.org/data_0863", "http://edamontology.org/data_2044"],
        "text": "BioXSD (XML)"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3250"
        },
        "definition": "spML is the format for describing proteomics sample processing, other than using gels, prior to mass spectrometric protein identification, standardised by HUPO PSI PS. It may also be applicable for metabolomics.",
        "text": "spML"
      }, {
        "comment": ["The focus of qcML is towards mass spectrometry based proteomics, but the format is suitable for metabolomics and sequencing as well."],
        "data": {
          "uri": "http://edamontology.org/format_3683"
        },
        "definition": "qcML is an XML format for quality-related data of mass spectrometry and other high-throughput measurements.",
        "text": "qcML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3844"
        },
        "definition": "Chado-XML format is a direct mapping of the Chado relational schema into XML.",
        "text": "Chado-XML"
      }, {
        "comment": ["The SVG specification is an open standard developed by the World Wide Web Consortium (W3C) since 1999."],
        "data": {
          "uri": "http://edamontology.org/format_3604"
        },
        "definition": "Scalable Vector Graphics (SVG) is an XML-based vector image format for two-dimensional graphics with support for interactivity and animation.",
        "exact_synonyms": ["Scalable Vector Graphics"],
        "text": "SVG"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3331"
        },
        "definition": "XML format as produced by the NCBI Blast package",
        "text": "BLAST XML results format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3843"
        },
        "definition": "XML input file format for BEAST Software (Bayesian Evolutionary Analysis Sampling Trees).",
        "text": "BEAST"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3248"
        },
        "definition": "mzQuantML is the format for quantitation values associated with peptides, proteins and small molecules from mass spectra, standardised by HUPO PSI PI. It can be used for outputs of quantitation software for proteomics.",
        "text": "mzQuantML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3853"
        },
        "definition": "XML format for the UniParc database.",
        "text": "UniParc XML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3836"
        },
        "definition": "XML format as produced by the NCBI Blast package v2.",
        "text": "BLAST XML v2 results format"
      }, {
        "comment": ["OSCAR (Open-Source Chemistry Analysis Routines) software performs chemistry-specific parsing of chemical documents. It attempts to identify chemical names, ontology concepts, and chemical data from a document."],
        "data": {
          "uri": "http://edamontology.org/format_1741"
        },
        "definition": "OSCAR format of annotated chemical text.",
        "text": "OSCAR format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3262"
        },
        "definition": "OWL ontology XML serialisation format.",
        "narrow_synonyms": ["OWL"],
        "text": "OWL/XML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3468"
        },
        "definition": "Microsoft Excel spreadsheet format.",
        "exact_synonyms": ["Microsoft Excel format"],
        "text": "xls"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3852"
        },
        "definition": "SeqXML is an XML Schema to describe biological sequences, developed by the Stockholm Bioinformatics Centre.",
        "text": "SeqXML"
      }, {
        "comment": ["RDF/XML is a serialisation syntax for OWL DL, but not for OWL Full."],
        "data": {
          "uri": "http://edamontology.org/format_3261"
        },
        "definition": "Resource Description Framework (RDF) XML format.",
        "text": "RDF/XML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3506"
        },
        "definition": "Microsoft Word format.",
        "exact_synonyms": ["Microsoft Word format", "doc"],
        "text": "docx"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3764"
        },
        "definition": "XML file format for files containing information about peptide identifications from mass spectrometry data analysis carried out with OpenMS.",
        "text": "idXML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3239"
        },
        "definition": "CopasiML, the native format of COPASI.",
        "text": "CopasiML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_2550"
        },
        "definition": "OBO ontology XML format.",
        "text": "OBO-XML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3850"
        },
        "definition": "OrthoXML is designed broadly to allow the storage and comparison of orthology data from any ortholog database. It establishes a structure for describing orthology relationships while still allowing flexibility for database-specific information to be encapsulated in the same format.",
        "text": "OrthoXML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3971"
        },
        "definition": "A model description language for computational neuroscience.",
        "is_format_of": ["http://edamontology.org/data_3241"],
        "text": "NeuroML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3692"
        },
        "definition": "SBGN-ML is an XML format for Systems Biology Graphical Notation (SBGN) diagrams of biological pathways or networks.",
        "text": "SBGN-ML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3848"
        },
        "definition": "XML format for collected entries from biobliographic databases MEDLINE and PubMed.",
        "exact_synonyms": ["MEDLINE XML"],
        "text": "PubMed XML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3655"
        },
        "definition": "Open data format for the storage, exchange, and processing of peptide sequence assignments of MS/MS scans, intended to provide a common data output format for many different MS/MS search engines and subsequent peptide-level analyses.",
        "text": "pepXML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1478"
        },
        "definition": "Entry format of PDB database in PDBML (XML) format.",
        "text": "PDBML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3782"
        },
        "definition": "BioC is a standardised XML format for sharing and integrating text data and annotations.",
        "text": "BioC"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3838"
        },
        "definition": "Microsoft Powerpoint format.",
        "text": "pptx"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_2304"
        },
        "definition": "Entry format (XML) for the STRING database of protein interaction.",
        "text": "STRING entry format (XML)"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3846"
        },
        "definition": "Output xml file from the InterProScan sequence analysis application.",
        "text": "InterProScan XML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3685"
        },
        "definition": "Simulation Experiment Description Markup Language (SED-ML) is an XML format for encoding simulation setups, according to the MIASE (Minimum Information About a Simulation Experiment) requirements.",
        "text": "SED-ML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1967"
        },
        "definition": "DAS sequence (XML) format (any type).",
        "exact_synonyms": ["das sequence format"],
        "text": "DAS format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3157"
        },
        "definition": "EBI Application Result XML is a format returned by sequence similarity search Web services at EBI.",
        "text": "EBI Application Result XML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3711"
        },
        "definition": "Output format used by X! series search engines that is based on the XML language BIOML.",
        "text": "X!Tandem XML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3684"
        },
        "definition": "PRIDE XML is an XML format for mass spectra, peptide and protein identifications, and metadata about a corresponding measurement, sample, experiment.",
        "text": "PRIDE XML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3851"
        },
        "definition": "Tree structure of Protein Sequence Database Markup Language generated using Matra software.",
        "text": "PSDML"
      }, {
        "children": [{
          "data": {
            "uri": "http://edamontology.org/format_3243"
          },
          "definition": "Protein affinity format (PSI-PAR), standardised by HUPO PSI MI. It is compatible with PSI MI XML (MIF) and uses the same XML Schema.",
          "text": "PSI-PAR"
        }],
        "data": {
          "uri": "http://edamontology.org/format_3158"
        },
        "definition": "XML Molecular Interaction Format (MIF), standardised by HUPO PSI MI.",
        "exact_synonyms": ["MIF"],
        "text": "PSI MI XML (MIF)"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3311"
        },
        "definition": "RNA Markup Language.",
        "text": "RNAML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_2585"
        },
        "definition": "Systems Biology Markup Language (SBML), the standard XML format for models of biological processes such as for example metabolism, cell signaling, and gene regulation.",
        "text": "SBML"
      }, {
        "comment": ["No human-consumable information about this format is available (see http://tools.proteomecenter.org/wiki/index.php?title=Formats:protXML)."],
        "data": {
          "uri": "http://edamontology.org/format_3747"
        },
        "definition": "A format for storage, exchange, and processing of protein identifications created from ms/ms-derived peptide sequence data.",
        "text": "protXML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1978"
        },
        "definition": "DAS GFF (XML) feature format.",
        "exact_synonyms": ["das feature", "DASGFF feature"],
        "text": "DASGFF"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3159"
        },
        "definition": "phyloXML is a standardised XML format for phylogenetic trees, networks, and associated data.",
        "text": "phyloXML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3845"
        },
        "definition": "An alignment format generated by PRANK/PRANKSTER consisting of four elements: newick, nodes, selection and model.",
        "text": "HSAML"
      }, {
        "comment": ["The use of this format is deprecated."],
        "data": {
          "uri": "http://edamontology.org/format_1968"
        },
        "definition": "DAS sequence (XML) format (nucleotide-only).",
        "text": "dasdna"
      }, {
        "comment": ["imzML data are recorded in 2 files: '.imzXML' is a metadata XML file based on mzML by HUPO-PSI, and '.ibd' is a binary file containing the mass spectra. This entry is for the metadata XML file"],
        "data": {
          "uri": "http://edamontology.org/format_3682"
        },
        "definition": "imzML metadata is a data format for mass spectrometry imaging metadata.",
        "text": "imzML metadata file"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3163"
        },
        "definition": "GCDML XML format for genome and metagenome metadata according to MIGS/MIMS/MIMARKS information standards, standardised by the Genomic Standards Consortium (GSC).",
        "text": "GCDML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1740"
        },
        "definition": "The format of iHOP (Information Hyperlinked over Proteins) text-mining result.",
        "text": "iHOP format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3834"
        },
        "definition": "Now deprecated data format of the HUPO Proteomics Standards Initiative.  Replaced by mzML (format_3244).",
        "text": "mzData"
      }, {
        "children": [{
          "children": [{
            "data": {
              "uri": "http://edamontology.org/format_2185"
            },
            "definition": "XML format for EMBL entries.",
            "text": "insdxml"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_2184"
            },
            "definition": "XML format for EMBL entries.",
            "text": "cdsxml"
          }, {
            "data": {
              "uri": "http://edamontology.org/format_2183"
            },
            "definition": "XML format for EMBL entries.",
            "text": "EMBLXML"
          }],
          "comment": ["This is a placeholder for other more specific concepts. It should not normally be used for annotation."],
          "data": {
            "uri": "http://edamontology.org/format_2204"
          },
          "definition": "An XML format for EMBL entries.",
          "text": "EMBL format (XML)"
        }],
        "comment": ["This concept may be used for the any non-standard EMBL-like XML formats."],
        "data": {
          "uri": "http://edamontology.org/format_2558"
        },
        "definition": "An XML format resembling EMBL entry format.",
        "text": "EMBL-like (XML)"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3833"
        },
        "definition": "OpenMS format for quantitation results (LC/MS features).",
        "text": "featureXML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3161"
        },
        "definition": "MAGE-ML XML format for microarray expression data, standardised by MGED (now FGED).",
        "is_format_of": ["http://edamontology.org/data_3111"],
        "text": "MAGE-ML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3657"
        },
        "definition": "Graphical Pathway Markup Language (GPML) is an XML format used for exchanging biological pathways.",
        "text": "GPML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3770"
        },
        "definition": "UniProtKB XML sequence features format is an XML format available for downloading UniProt entries.",
        "exact_synonyms": ["UniProtKB XML format", "UniProt XML format", "UniProt XML"],
        "text": "UniProtKB XML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3487"
        },
        "definition": "Bioinformatics Sequence Markup Language format.",
        "text": "BSML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3804"
        },
        "definition": "XML format for XML Schema.",
        "text": "xsd"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3247"
        },
        "definition": "mzIdentML is the exchange format for peptides and proteins identified from mass spectra, standardised by HUPO PSI PI. It can be used for outputs of proteomics search engines.",
        "text": "mzIdentML"
      }, {
        "comment": ["One or more mining models can be contained in a PMML document."],
        "data": {
          "uri": "http://edamontology.org/format_3726"
        },
        "definition": "PMML uses XML to represent mining models. The structure of the models is described by an XML Schema.",
        "text": "PMML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3825"
        },
        "definition": "nmrML is an MSI supported XML-based open access format for metabolomics NMR raw and processed spectral data. It is accompanies by an nmrCV (controlled vocabulary) to allow ontology-based annotations.",
        "text": "nmrML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3246"
        },
        "definition": "TraML (Transition Markup Language) is the format for mass spectrometry transitions, standardised by HUPO PSI MSS.",
        "text": "TraML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3832"
        },
        "definition": "OpenMS format for grouping features in one map or across several maps.",
        "text": "consensusXML"
      }, {
        "comment": ["SBOL introduces a standardised format for the electronic exchange of information on the structural and functional aspects of biological designs."],
        "data": {
          "uri": "http://edamontology.org/format_3725"
        },
        "definition": "Synthetic Biology Open Language (SBOL) is an XML format for the specification and exchange of biological design information in synthetic biology.",
        "text": "SBOL"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3854"
        },
        "definition": "XML format for the UniRef reference clusters.",
        "text": "UniRef XML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3160"
        },
        "definition": "NeXML is a standardised XML format for rich phyloinformatic data.",
        "text": "NeXML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3847"
        },
        "definition": "The KEGG Markup Language (KGML) is an exchange format of the KEGG pathway maps, which is converted from internally used KGML+ (KGML+SVG) format.",
        "exact_synonyms": ["KEGG Markup Language"],
        "text": "KGML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3821"
        },
        "definition": "Default XML format of VisANT, containing all the network information.",
        "exact_synonyms": ["VisANT xml format", "VisANT xml"],
        "text": "VisML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3249"
        },
        "definition": "GelML is the format for describing the process of gel electrophoresis, standardised by HUPO PSI PS.",
        "text": "GelML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_1665"
        },
        "definition": "Format of Taverna workflows.",
        "text": "Taverna workflow format"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3155"
        },
        "definition": "Systems Biology Result Markup Language (SBRML), the standard XML format for simulated or calculated results (e.g. trajectories) of systems biology models.",
        "text": "SBRML"
      }, {
        "data": {
          "uri": "http://edamontology.org/format_3689"
        },
        "definition": "Biological Connection Markup Language (BCML) is an XML format for biological pathways.",
        "text": "BCML"
      }, {
        "comment": ["mzML is the successor and unifier of the mzData format developed by PSI and mzXML developed at the Seattle Proteome Center."],
        "data": {
          "uri": "http://edamontology.org/format_3244"
        },
        "definition": "mzML format for raw spectrometer output data, standardised by HUPO PSI MSS.",
        "text": "mzML"
      }],
      "comment": ["Data in XML format can be serialised into text, or binary format."],
      "data": {
        "uri": "http://edamontology.org/format_2332"
      },
      "definition": "eXtensible Markup Language (XML) format.",
      "exact_synonyms": ["eXtensible Markup Language"],
      "text": "XML"
    }],
    "comment": ["The main focus in EDAM lies on formats as means of structuring data exchanged between different tools or resources. The serialisation, compression, or encoding of concrete data formats/models is not in scope of EDAM. Format 'is format of' Data."],
    "data": {
      "uri": "http://edamontology.org/format_1915"
    },
    "definition": "A defined way or layout of representing and structuring data in a computer file, blob, string, message, or elsewhere.",
    "exact_synonyms": ["Exchange format", "Data format"],
    "narrow_synonyms": ["File format"],
    "text": "Format"
  }, {
    "children": [{
      "data": {
        "uri": "http://edamontology.org/topic_0184"
      },
      "definition": "The alignment of molecular sequences to structures, structural (3D) profiles or templates (representing a structure or structure alignment).",
      "replacedBy": ["http://edamontology.org/topic_0082"],
      "text": "Threading"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_3527"
      },
      "definition": "Cellular process pathways.",
      "replacedBy": ["http://edamontology.org/topic_0602"],
      "text": "Cellular process pathways"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_1323"
      },
      "definition": "cleavage sites (for a proteolytic enzyme or agent) in a protein sequence.",
      "replacedBy": ["http://edamontology.org/data_1277"],
      "text": "Protein features report (cleavage sites)"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_2960"
      },
      "definition": "A temperature profile of a double-stranded nucleic acid molecule (DNA or DNA/RNA).",
      "replacedBy": ["http://edamontology.org/data_1583"],
      "text": "Nucleic acid temperature profile"
    }, {
      "consider": ["http://edamontology.org/data_1249"],
      "data": {
        "uri": "http://edamontology.org/data_2141"
      },
      "definition": "Size of the incremental 'step' a sequence window is moved over a sequence.",
      "text": "Window step size"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1699"
      },
      "definition": "The format of an entry from the KEGG PLANT database.",
      "text": "KEGG PLANT entry format"
    }, {
      "consider": ["http://edamontology.org/data_2872"],
      "data": {
        "uri": "http://edamontology.org/data_1111"
      },
      "definition": "List of EMBOSS Uniform Sequence Addresses (EMBOSS listfile).",
      "text": "EMBOSS listfile"
    }, {
      "consider": ["http://edamontology.org/data_2534"],
      "data": {
        "uri": "http://edamontology.org/data_2023"
      },
      "definition": "Data used to replace (mask) characters in a molecular sequence.",
      "text": "Sequence mask parameter"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_1646"
      },
      "definition": "Standard protonated molecular masses from trypsin (modified porcine trypsin, Promega) and keratin peptides, used in EMBOSS.",
      "replacedBy": ["http://edamontology.org/data_0944"],
      "text": "Molecular weights standard fingerprint"
    }, {
      "comment": ["A sequence profile typically represents a sequence alignment."],
      "consider": ["http://edamontology.org/topic_0080"],
      "data": {
        "uri": "http://edamontology.org/topic_0741"
      },
      "definition": "Protein sequence alignments.",
      "text": "Protein sequence alignment"
    }, {
      "comment": ["This includes carbohydrate, energy, lipid, nucleotide, amino acid, glycan, PK/NRP, cofactor/vitamin, secondary metabolite, xenobiotics etc."],
      "data": {
        "uri": "http://edamontology.org/data_1656"
      },
      "definition": "A report typically including a map (diagram) of a metabolic pathway.",
      "replacedBy": ["http://edamontology.org/data_2984"],
      "text": "Metabolic pathway report"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_0112"
      },
      "definition": "The folding (in 3D space) of nucleic acid molecules.",
      "replacedBy": ["http://edamontology.org/topic_0097"],
      "text": "Nucleic acid folding"
    }, {
      "consider": ["http://edamontology.org/data_2048"],
      "data": {
        "uri": "http://edamontology.org/data_2250"
      },
      "definition": "An XML Schema.",
      "text": "XML Schema"
    }, {
      "consider": ["http://edamontology.org/data_0897"],
      "data": {
        "uri": "http://edamontology.org/data_1257"
      },
      "definition": "A report of general sequence properties derived from protein sequence data.",
      "text": "Sequence property (protein)"
    }, {
      "consider": ["http://edamontology.org/data_1353"],
      "data": {
        "uri": "http://edamontology.org/data_1358"
      },
      "definition": "A nucleotide regular expression pattern from the Prosite database.",
      "text": "Prosite nucleotide pattern"
    }, {
      "consider": ["http://edamontology.org/operation_0292"],
      "data": {
        "uri": "http://edamontology.org/operation_2463"
      },
      "definition": "Process (read and / or write) a molecular sequence alignment.",
      "text": "Sequence alignment processing"
    }, {
      "consider": ["http://edamontology.org/topic_0820"],
      "data": {
        "uri": "http://edamontology.org/topic_2232"
      },
      "definition": "Lipoproteins (protein-lipid assemblies).",
      "text": "Lipoproteins"
    }, {
      "comment": ["Data Type is an enumerated string."],
      "consider": ["http://edamontology.org/data_2858"],
      "data": {
        "uri": "http://edamontology.org/data_1728"
      },
      "definition": "A term definition for a molecular function from the Gene Ontology (GO).",
      "text": "GO (molecular function)"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_2936"
      },
      "definition": "Generate a dendrograph of raw, preprocessed or clustered expression (e.g. microarray) data.",
      "replacedBy": ["http://edamontology.org/operation_2938"],
      "text": "Dendrograph plotting"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_0173"
      },
      "definition": "The folding of nucleic acid molecules and the prediction or design of nucleic acid (typically RNA) sequences with specific conformations.",
      "replacedBy": ["http://edamontology.org/topic_0097"],
      "text": "Nucleic acid structure prediction"
    }, {
      "consider": ["http://edamontology.org/data_1397"],
      "data": {
        "uri": "http://edamontology.org/data_1404"
      },
      "definition": "A simple floating point number defining the penalty for opening a gap in an alignment.",
      "text": "Gap opening penalty (integer)"
    }, {
      "consider": ["http://edamontology.org/data_1399"],
      "data": {
        "uri": "http://edamontology.org/data_1408"
      },
      "definition": "A simple floating point number defining the penalty for gaps that are close together in an alignment.",
      "text": "Gap separation penalty (integer)"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_0936"
      },
      "definition": "Tag to gene assignments (tag mapping) of SAGE, MPSS and SBS data. Typically this is the sequencing-based expression profile annotated with gene identifiers.",
      "replacedBy": ["http://edamontology.org/data_2535"],
      "text": "Sequence tag profile (with gene assignment)"
    }, {
      "comment": ["Methods use some type of mapping between sequence and fold, for example secondary structure prediction and alignment, profile comparison, sequence properties, homologous sequence search, kernel machines etc. Domains and folds might be taken from SCOP or CATH."],
      "consider": ["http://edamontology.org/data_1277"],
      "data": {
        "uri": "http://edamontology.org/data_1564"
      },
      "definition": "A report on known protein structural domains or folds that are recognised (identified) in protein sequence(s).",
      "text": "Protein fold recognition report"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_0613"
      },
      "definition": "The physicochemical, biochemical or structural properties of amino acids or peptides.",
      "replacedBy": ["http://edamontology.org/topic_0154"],
      "text": "Peptides and amino acids"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_1587"
      },
      "definition": "Stitch profile of hybridised or double stranded nucleic acid (DNA or RNA/DNA).",
      "replacedBy": ["http://edamontology.org/data_1583"],
      "text": "Nucleic acid stitch profile"
    }, {
      "consider": ["http://edamontology.org/data_3021"],
      "data": {
        "uri": "http://edamontology.org/data_1099"
      },
      "definition": "Accession number of a UniProt (protein sequence) database entry. May contain version or isoform number.",
      "text": "UniProt accession (extended)"
    }, {
      "comment": ["Notions of pathway and network were mixed up, EDAM 1.24 disentangles them."],
      "consider": ["http://edamontology.org/operation_3928", "http://edamontology.org/operation_3927"],
      "data": {
        "uri": "http://edamontology.org/operation_3562"
      },
      "definition": "Simulate the bevaviour of a biological pathway or network.",
      "text": "Network simulation"
    }, {
      "consider": ["http://edamontology.org/data_0968"],
      "data": {
        "uri": "http://edamontology.org/data_1879"
      },
      "definition": "An abbreviation of a phrase or word.",
      "text": "Acronym"
    }, {
      "consider": ["http://edamontology.org/operation_0292"],
      "data": {
        "uri": "http://edamontology.org/operation_0293"
      },
      "definition": "Align two or more molecular sequences of different types (for example genomic DNA to EST, cDNA or mRNA).",
      "text": "Hybrid sequence alignment construction"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_0740"
      },
      "definition": "Nucleotide sequence alignments.",
      "replacedBy": ["http://edamontology.org/topic_0080"],
      "text": "Nucleic acid sequence alignment"
    }, {
      "consider": ["http://edamontology.org/data_0957"],
      "data": {
        "uri": "http://edamontology.org/data_2735"
      },
      "definition": "The name of a SwissRegulon database.",
      "text": "Database name (SwissRegulon)"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_1298"
      },
      "definition": "Report on the location of matches to profiles, motifs (conserved or functional patterns) or other signatures in one or more sequences.",
      "replacedBy": ["http://edamontology.org/data_0858"],
      "text": "Sequence motif matches"
    }, {
      "comment": ["This includes tools based on the Smith-Waterman algorithm or FASTA."],
      "consider": ["http://edamontology.org/operation_0346"],
      "data": {
        "uri": "http://edamontology.org/operation_0352"
      },
      "definition": "Search a sequence database for sequences that are similar to a query sequence using a local alignment-based method.",
      "text": "Sequence database search (by sequence using local alignment-based methods)"
    }, {
      "consider": ["http://edamontology.org/topic_0821"],
      "data": {
        "uri": "http://edamontology.org/topic_0100"
      },
      "definition": "Topic for the study of restriction enzymes, their cleavage sites and the restriction of nucleic acids.",
      "text": "Nucleic acid restriction"
    }, {
      "consider": ["http://edamontology.org/data_2530"],
      "data": {
        "uri": "http://edamontology.org/data_2395"
      },
      "definition": "An informative report on a specific fungus.",
      "text": "Fungi annotation"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1578"
      },
      "definition": "Entry format for the Superfamily protein secondary database.",
      "text": "Superfamily entry format"
    }, {
      "comment": ["A genetic marker is any DNA sequence of known chromosomal location that is associated with and specific to a particular gene or trait. This includes short sequences surrounding a SNP, Sequence-Tagged Sites (STS) which are well suited for PCR amplification, a longer minisatellites sequence etc."],
      "consider": ["http://edamontology.org/operation_0415"],
      "data": {
        "uri": "http://edamontology.org/operation_0281"
      },
      "definition": "Identify genetic markers in DNA sequences.",
      "text": "Genetic marker identification"
    }, {
      "consider": ["http://edamontology.org/data_0858"],
      "data": {
        "uri": "http://edamontology.org/data_1417"
      },
      "definition": "Alignment of molecular sequences to a Domainatrix signature (representing a sequence alignment).",
      "text": "Sequence-profile alignment (Domainatrix signature)"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1649"
      },
      "definition": "The format of a report from the HumanCyc metabolic pathways database.",
      "text": "HumanCyc entry format"
    }, {
      "consider": ["http://edamontology.org/format_2172"],
      "data": {
        "uri": "http://edamontology.org/format_2175"
      },
      "definition": "Format used for clusters of genes.",
      "text": "Gene cluster format"
    }, {
      "consider": ["http://edamontology.org/operation_2422"],
      "data": {
        "uri": "http://edamontology.org/operation_0229"
      },
      "definition": "Retrieve basic information about a molecular sequence.",
      "text": "Annotation retrieval (sequence)"
    }, {
      "consider": ["http://edamontology.org/operation_3926", "http://edamontology.org/operation_3925"],
      "data": {
        "uri": "http://edamontology.org/operation_3083"
      },
      "definition": "Render (visualise) a biological pathway or network.",
      "text": "Pathway or network visualisation"
    }, {
      "consider": ["http://edamontology.org/data_1234"],
      "data": {
        "uri": "http://edamontology.org/data_2874"
      },
      "definition": "A set of sub-sequences displaying some type of polymorphism, typically indicating the sequence in which they occur, their position and other metadata.",
      "text": "Sequence set (polymorphic)"
    }, {
      "comment": ["This is a broad data type and is used a placeholder for other, more specific types."],
      "consider": ["http://edamontology.org/data_0907"],
      "data": {
        "uri": "http://edamontology.org/data_2980"
      },
      "definition": "An informative report concerning the classification of protein sequences or structures.",
      "text": "Protein classification"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_3205"
      },
      "definition": "Determine cytosine methylation status of specific positions in a nucleic acid sequences.",
      "replacedBy": ["http://edamontology.org/operation_3204"],
      "text": "Methylation calling"
    }, {
      "consider": ["http://edamontology.org/operation_0573"],
      "data": {
        "uri": "http://edamontology.org/operation_0577"
      },
      "definition": "Draw a linear maps of DNA.",
      "text": "DNA linear map rendering"
    }, {
      "consider": ["http://edamontology.org/data_0006"],
      "data": {
        "uri": "http://edamontology.org/data_2152"
      },
      "definition": "A parameter that is used to control rendering (drawing) to a device or image.",
      "text": "Rendering parameter"
    }, {
      "data": {
        "uri": "http://edamontology.org/format_1500"
      },
      "definition": "Format of a matrix of 3D-1D scores used by the EMBOSS Domainatrix applications.",
      "replacedBy": ["http://edamontology.org/format_2064"],
      "text": "Domainatrix 3D-1D scoring matrix format"
    }, {
      "consider": ["http://edamontology.org/data_2337"],
      "data": {
        "uri": "http://edamontology.org/data_2178"
      },
      "definition": "One or more things.",
      "text": "1 or more"
    }, {
      "consider": ["http://edamontology.org/data_0950"],
      "data": {
        "uri": "http://edamontology.org/data_1345"
      },
      "definition": "MEME background frequencies file.",
      "text": "MEME background frequencies file"
    }, {
      "consider": ["http://edamontology.org/topic_0219"],
      "data": {
        "uri": "http://edamontology.org/topic_0221"
      },
      "definition": "Annotation of a molecular sequence.",
      "text": "Sequence annotation"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_2974"
      },
      "definition": "A raw protein sequence (string of characters).",
      "exact_synonyms": ["Raw sequence (protein)", "Raw amino acid sequences", "Raw protein sequence", "Raw amino acid sequence"],
      "replacedBy": ["http://edamontology.org/data_2976"],
      "text": "Protein sequence (raw)"
    }, {
      "consider": ["http://edamontology.org/data_2048"],
      "data": {
        "uri": "http://edamontology.org/data_2249"
      },
      "definition": "A DTD (document type definition).",
      "text": "DTD"
    }, {
      "consider": ["http://edamontology.org/topic_0084"],
      "data": {
        "uri": "http://edamontology.org/topic_2257"
      },
      "definition": "Visualise a phylogeny, for example, render a phylogenetic tree.",
      "text": "Phylogeny visualisation"
    }, {
      "consider": ["http://edamontology.org/data_2891"],
      "data": {
        "uri": "http://edamontology.org/data_2590"
      },
      "definition": "Identifier of an entry from a database of biological hierarchies.",
      "text": "Hierarchy identifier"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_3470"
      },
      "definition": "Predict RNA secondary structure by analysis, e.g. probabilistic analysis, of the shape of RNA folds.",
      "replacedBy": ["http://edamontology.org/operation_0278"],
      "text": "RNA secondary structure prediction (shape-based)"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_3413"
      },
      "definition": "The branch of medicine that deals with the infectious diseases of the tropics.",
      "replacedBy": ["http://edamontology.org/topic_3324"],
      "text": "Infectious tropical disease"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_2191"
      },
      "definition": "chemical modification of a protein.",
      "replacedBy": ["http://edamontology.org/data_1277"],
      "text": "Protein features report (chemical modifications)"
    }, {
      "consider": ["http://edamontology.org/data_1047"],
      "data": {
        "uri": "http://edamontology.org/format_2334"
      },
      "definition": "Typical textual representation of a URI.",
      "text": "URI format"
    }, {
      "consider": ["http://edamontology.org/topic_0623"],
      "data": {
        "uri": "http://edamontology.org/topic_0722"
      },
      "definition": "Classification of nucleic acid sequences and structures.",
      "text": "Nucleic acid classification"
    }, {
      "comment": ["This includes direct retrieval methods that retrieve a profile by, e.g. the profile name."],
      "consider": ["http://edamontology.org/operation_2422"],
      "data": {
        "uri": "http://edamontology.org/operation_2237"
      },
      "definition": "Query a profile data resource and retrieve one or more profile(s) and / or associated annotation.",
      "text": "Data retrieval (sequence profile)"
    }, {
      "comment": ["This is a broad data type and is used a placeholder for other, more specific types.  It is primarily intended to help navigation of EDAM and would not typically be used for annotation."],
      "consider": ["http://edamontology.org/data_1537"],
      "data": {
        "uri": "http://edamontology.org/data_1541"
      },
      "definition": "Informative report on flexibility or motion of a protein structure.",
      "text": "Protein flexibility or motion report"
    }, {
      "consider": ["http://edamontology.org/operation_3927", "http://edamontology.org/operation_3928"],
      "data": {
        "uri": "http://edamontology.org/operation_2438"
      },
      "definition": "Generate, analyse or handle a biological pathway or network.",
      "text": "Pathway or network processing"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_1322"
      },
      "definition": "signal peptides or signal peptide cleavage sites in protein sequences.",
      "replacedBy": ["http://edamontology.org/data_1277"],
      "text": "Protein features report (signal peptides)"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_2490"
      },
      "definition": "Calculate contacts between residues in a protein structure.",
      "replacedBy": ["http://edamontology.org/operation_2950"],
      "text": "Residue contact calculation (residue-residue)"
    }, {
      "consider": ["http://edamontology.org/operation_2478"],
      "data": {
        "uri": "http://edamontology.org/operation_2448"
      },
      "definition": "Process (read and / or write) a nucleotide sequence and associated annotation.",
      "text": "Sequence processing (nucleic acid)"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_2507"
      },
      "definition": "Analyse a protein sequence alignment, typically to detect features or make predictions.",
      "replacedBy": ["http://edamontology.org/operation_2478"],
      "text": "Nucleic acid sequence alignment analysis"
    }, {
      "comment": ["Data Type is an enumerated string."],
      "consider": ["http://edamontology.org/data_2858"],
      "data": {
        "uri": "http://edamontology.org/data_1729"
      },
      "definition": "A term definition for a cellular component from the Gene Ontology (GO).",
      "text": "GO (cellular component)"
    }, {
      "consider": ["http://edamontology.org/format_1998"],
      "data": {
        "uri": "http://edamontology.org/format_1956"
      },
      "definition": "PHYLIP non-interleaved sequence format.",
      "text": "phylipnon sequence format"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0299"
      },
      "definition": "Align structural (3D) profiles or templates (representing structures or structure alignments).",
      "replacedBy": ["http://edamontology.org/operation_0295"],
      "text": "3D profile-to-3D profile alignment"
    }, {
      "consider": ["http://edamontology.org/topic_2814"],
      "data": {
        "uri": "http://edamontology.org/topic_2826"
      },
      "definition": "Protein secondary or tertiary structure alignments.",
      "text": "Protein structure alignment"
    }, {
      "consider": ["http://edamontology.org/data_0966"],
      "data": {
        "uri": "http://edamontology.org/data_1716"
      },
      "definition": "A term definition from The Gene Ontology (GO).",
      "text": "GO"
    }, {
      "consider": ["http://edamontology.org/data_0916"],
      "data": {
        "uri": "http://edamontology.org/data_1300"
      },
      "definition": "A report on predicted or actual gene structure, regions which make an RNA product and features such as promoters, coding regions, splice sites etc.",
      "text": "Gene and transcript structure (report)"
    }, {
      "consider": ["http://edamontology.org/data_2610"],
      "data": {
        "uri": "http://edamontology.org/data_2699"
      },
      "definition": "Identifier of an entry (exon, gene, transcript or protein) from the Ensembl 'core' database ('Xenopus tropicalis' division).",
      "text": "Ensembl ID ('Xenopus tropicalis')"
    }, {
      "consider": ["http://edamontology.org/data_0006"],
      "data": {
        "uri": "http://edamontology.org/data_2176"
      },
      "definition": "The number of a certain thing.",
      "text": "Cardinality"
    }, {
      "consider": ["http://edamontology.org/data_2534"],
      "data": {
        "uri": "http://edamontology.org/data_2126"
      },
      "definition": "Frame for translation of DNA (3 forward and 3 reverse frames relative to a chromosome).",
      "text": "Translation frame specification"
    }, {
      "consider": ["http://edamontology.org/topic_0128"],
      "data": {
        "uri": "http://edamontology.org/topic_0148"
      },
      "definition": "Protein-ligand (small molecule) interactions.",
      "text": "Protein-ligand interactions"
    }, {
      "comment": [{
        "@id": "http://edamontology.org/operation_2481"
      }],
      "data": {
        "uri": "http://edamontology.org/operation_2519"
      },
      "definition": "Process (read and / or write) nucleic acid tertiary structure data.",
      "replacedBy": ["http://edamontology.org/operation_2480"],
      "text": "Structure processing (nucleic acid)"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_3085"
      },
      "definition": "A report (typically a table) on character or word composition / frequency of protein sequence(s).",
      "replacedBy": ["http://edamontology.org/data_1261"],
      "text": "Protein sequence composition"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_0606"
      },
      "definition": "Data resources for the biological or biomedical literature, either a primary source of literature or some derivative.",
      "replacedBy": ["http://edamontology.org/topic_3068"],
      "text": "Literature data resources"
    }, {
      "data": {
        "uri": "http://edamontology.org/format_3623"
      },
      "definition": "Format of a data index of some type.",
      "replacedBy": ["http://edamontology.org/format_3326"],
      "text": "Index format"
    }, {
      "consider": ["http://edamontology.org/data_1277"],
      "data": {
        "uri": "http://edamontology.org/data_2401"
      },
      "definition": "An informative report on a membrane protein.",
      "text": "Protein report (membrane protein)"
    }, {
      "consider": ["http://edamontology.org/data_3106"],
      "data": {
        "uri": "http://edamontology.org/data_0583"
      },
      "definition": "A directory on disk from which files are read.",
      "text": "Directory metadata"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_3171"
      },
      "definition": "DNA methylation including bisulfite sequencing, methylation sites and analysis, for example of patterns and profiles of DNA methylation in a population, tissue etc.",
      "replacedBy": ["http://edamontology.org/topic_3295"],
      "text": "DNA methylation"
    }, {
      "consider": ["http://edamontology.org/data_1481"],
      "data": {
        "uri": "http://edamontology.org/data_1487"
      },
      "definition": "Alignment (superimposition) of exactly two protein tertiary (3D) structures (all atoms considered).",
      "text": "Pairwise protein tertiary structure alignment (all atoms)"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_3356"
      },
      "definition": "A statistical Markov model of a system which is assumed to be a Markov process with unobserved (hidden) states.",
      "replacedBy": ["http://edamontology.org/data_1364"],
      "text": {
        "@language": "en",
        "@value": "Hidden Markov model"
      }
    }, {
      "consider": ["http://edamontology.org/data_0907"],
      "data": {
        "uri": "http://edamontology.org/data_1558"
      },
      "definition": "Information on a protein 'topology' node from the CATH database.",
      "text": "CATH topology"
    }, {
      "comment": ["The query is a sequence-based entity such as another sequence, a motif or profile."],
      "consider": ["http://edamontology.org/topic_0080"],
      "data": {
        "uri": "http://edamontology.org/topic_0163"
      },
      "definition": "Search and retrieve molecular sequences that are similar to a sequence-based query (typically a simple sequence).",
      "text": "Sequence database search"
    }, {
      "consider": ["http://edamontology.org/topic_0080"],
      "data": {
        "uri": "http://edamontology.org/topic_0644"
      },
      "definition": "A specific proteome including protein sequences and annotation.",
      "text": "Proteome"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_3544"
      },
      "definition": "Signal peptides or signal peptide cleavage sites in protein sequences.",
      "replacedBy": ["http://edamontology.org/topic_3510"],
      "text": "Protein signal peptides"
    }, {
      "consider": ["http://edamontology.org/operation_2480"],
      "data": {
        "uri": "http://edamontology.org/operation_2123"
      },
      "definition": "Process (read and / or write) physicochemical property data for small molecules.",
      "text": "Small molecule data processing"
    }, {
      "consider": ["http://edamontology.org/data_1026"],
      "data": {
        "uri": "http://edamontology.org/data_1789"
      },
      "definition": "Name of a gene from Tetrahymena Genome Database.",
      "text": "Gene name (TGD)"
    }, {
      "consider": ["http://edamontology.org/data_0867"],
      "data": {
        "uri": "http://edamontology.org/data_0879"
      },
      "definition": "An informative report on protein secondary structure alignment-derived data or metadata.",
      "text": "Secondary structure alignment metadata (protein)"
    }, {
      "consider": ["http://edamontology.org/data_0863"],
      "data": {
        "uri": "http://edamontology.org/data_1390"
      },
      "definition": "Alignment of more than two protein sequences.",
      "text": "Multiple protein sequence alignment"
    }, {
      "consider": ["http://edamontology.org/data_0962"],
      "data": {
        "uri": "http://edamontology.org/data_0911"
      },
      "definition": "An informative report about a specific nucleotide base.",
      "text": "Nucleotide base annotation"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_3118"
      },
      "definition": "Topological domains such as cytoplasmic regions in a protein.",
      "replacedBy": ["http://edamontology.org/topic_0736"],
      "text": "Protein topological domains"
    }, {
      "comment": ["Solvent accessibility might be calculated for the backbone, sidechain and total (backbone plus sidechain)."],
      "data": {
        "uri": "http://edamontology.org/operation_1821"
      },
      "definition": "Calculate the solvent accessibility ('accessible molecular surface') for each residue in a structure.",
      "replacedBy": ["http://edamontology.org/operation_0387"],
      "text": "Protein residue surface calculation (accessible molecular)"
    }, {
      "consider": ["http://edamontology.org/operation_3928", "http://edamontology.org/operation_3927"],
      "data": {
        "uri": "http://edamontology.org/operation_0277"
      },
      "definition": "Compare two or more biological pathways or networks.",
      "text": "Pathway or network comparison"
    }, {
      "consider": ["http://edamontology.org/data_2610"],
      "data": {
        "uri": "http://edamontology.org/data_2673"
      },
      "definition": "Identifier of an entry (exon, gene, transcript or protein) from the Ensembl 'core' database ('Canis familiaris' division).",
      "text": "Ensembl ID ('Canis familiaris')"
    }, {
      "consider": ["http://edamontology.org/data_0907"],
      "data": {
        "uri": "http://edamontology.org/data_3145"
      },
      "definition": "Information on a 'protein' node from the SCOP database.",
      "text": "SCOP protein"
    }, {
      "consider": ["http://edamontology.org/data_0006"],
      "data": {
        "uri": "http://edamontology.org/data_1593"
      },
      "definition": "RNA concentration data used by the Vienna package.",
      "text": "Vienna RNA concentration data"
    }, {
      "consider": ["http://edamontology.org/data_2610"],
      "data": {
        "uri": "http://edamontology.org/data_2688"
      },
      "definition": "Identifier of an entry (exon, gene, transcript or protein) from the Ensembl 'core' database ('Mus musculus' division).",
      "text": "Ensembl ID ('Mus musculus')"
    }, {
      "consider": ["http://edamontology.org/topic_0089"],
      "data": {
        "uri": "http://edamontology.org/topic_2811"
      },
      "definition": "Biological nomenclature (naming), symbols and terminology.",
      "text": "Nomenclature"
    }, {
      "consider": ["http://edamontology.org/data_1276"],
      "data": {
        "uri": "http://edamontology.org/data_2214"
      },
      "definition": "An informative report on mutation prognostic data, such as information on patient cohort, the study settings and the results of the study.",
      "text": "Mutation annotation (prognostic)"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0498"
      },
      "definition": "Align two or more molecular sequences using multiple methods to achieve higher quality.",
      "replacedBy": ["http://edamontology.org/operation_0292"],
      "text": "Consensus-based sequence alignment"
    }, {
      "consider": ["http://edamontology.org/data_2523"],
      "data": {
        "uri": "http://edamontology.org/data_1441"
      },
      "definition": "Data on the confidence of a phylogenetic tree.",
      "text": "Phylogenetic tree report (tree evaluation)"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_1832"
      },
      "definition": "Calculate protein residue contacts with nucleic acids in a structure.",
      "replacedBy": ["http://edamontology.org/operation_2950"],
      "text": "Residue contact calculation (residue-nucleic acid)"
    }, {
      "consider": ["http://edamontology.org/data_2610"],
      "data": {
        "uri": "http://edamontology.org/data_2675"
      },
      "definition": "Identifier of an entry (exon, gene, transcript or protein) from the Ensembl 'core' database ('Ciona intestinalis' division).",
      "text": "Ensembl ID ('Ciona intestinalis')"
    }, {
      "consider": ["http://edamontology.org/data_2711"],
      "data": {
        "uri": "http://edamontology.org/data_2041"
      },
      "definition": "Information on a genome version.",
      "text": "Genome version information"
    }, {
      "comment": ["This is a broad data type and is used a placeholder for other, more specific types.  It is primarily intended to help navigation of EDAM and would not typically be used for annotation."],
      "consider": ["http://edamontology.org/data_3108", "http://edamontology.org/data_2531"],
      "data": {
        "uri": "http://edamontology.org/data_2028"
      },
      "definition": "Raw data from or annotation on laboratory experiments.",
      "text": "Experimental data"
    }, {
      "comment": ["This is a broad data type and is used a placeholder for other, more specific types.  It is primarily intended to help navigation of EDAM and would not typically be used for annotation."],
      "data": {
        "uri": "http://edamontology.org/data_2363"
      },
      "definition": "Data concerning two-dimensional polygel electrophoresis.",
      "replacedBy": ["http://edamontology.org/data_2531"],
      "text": "2D PAGE data"
    }, {
      "comment": ["The sequence(s) might be screened against InterPro, or be the sequences from the InterPro entry itself. Domain architecture is shown as a series of non-overlapping domains in the protein."],
      "data": {
        "uri": "http://edamontology.org/data_1292"
      },
      "definition": "Image showing the architecture of InterPro domains in a protein sequence.",
      "replacedBy": ["http://edamontology.org/data_2969"],
      "text": "InterPro architecture image"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0355"
      },
      "definition": "Search sequence(s) or a sequence database for sequences which match a set of peptide masses, for example a peptide mass fingerprint from mass spectrometry.",
      "replacedBy": ["http://edamontology.org/operation_2929"],
      "text": "Sequence database search (by molecular weight)"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_3129"
      },
      "definition": "short repetitive subsequences (repeat sequences) in a protein sequence.",
      "replacedBy": ["http://edamontology.org/data_1277"],
      "text": "Protein features report (repeats)"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1706"
      },
      "definition": "The format of an entry from the KEGG DRUG database.",
      "text": "KEGG DRUG entry format"
    }, {
      "comment": ["This includes the generation of alignments (the identification of equivalent sites), the analysis of alignments, editing, visualisation, alignment databases, the alignment (equivalence between sites) of sequence profiles (representing sequence alignments) and so on."],
      "data": {
        "uri": "http://edamontology.org/topic_0182"
      },
      "definition": "The alignment of molecular sequences or sequence profiles (representing sequence alignments).",
      "replacedBy": ["http://edamontology.org/topic_0080"],
      "text": "Sequence alignment"
    }, {
      "comment": ["Methods including sequence motifs, profile and other diagnostic elements which (typically) represent conserved patterns (of residues or properties) in molecular sequences."],
      "data": {
        "uri": "http://edamontology.org/topic_0594"
      },
      "definition": "The classification of molecular sequences based on some measure of their similarity.",
      "replacedBy": ["http://edamontology.org/topic_0080"],
      "text": "Sequence classification"
    }, {
      "comment": ["For example, 'Protein', 'DNA', 'RNA' etc."],
      "consider": ["http://edamontology.org/data_0842"],
      "data": {
        "uri": "http://edamontology.org/data_0985"
      },
      "definition": "A label (text token) describing the type a molecule.",
      "text": "Molecule type"
    }, {
      "consider": ["http://edamontology.org/data_2600"],
      "data": {
        "uri": "http://edamontology.org/data_1663"
      },
      "definition": "networks of protein interactions.",
      "text": "Protein interaction networks"
    }, {
      "consider": ["http://edamontology.org/data_0925"],
      "data": {
        "uri": "http://edamontology.org/data_1852"
      },
      "definition": "A component of a larger sequence assembly.",
      "text": "Sequence assembly component"
    }, {
      "consider": ["http://edamontology.org/operation_2422"],
      "data": {
        "uri": "http://edamontology.org/operation_2224"
      },
      "definition": "Query an ontology and retrieve concepts or relations.",
      "text": "Data retrieval (ontology concept)"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0520"
      },
      "definition": "Predict primers that are conserved across multiple genomes or species.",
      "replacedBy": ["http://edamontology.org/operation_0308"],
      "text": "PCR primer design (for conserved primers)"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1611"
      },
      "definition": "Entry format of the Maize genetics and genomics database (MaizeGDB).",
      "text": "MaizeGDB gene report format"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_3536"
      },
      "definition": "Cleavage sites (for a proteolytic enzyme or agent) in a protein sequence.",
      "replacedBy": ["http://edamontology.org/topic_3510"],
      "text": "Protein cleavage sites"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_3122"
      },
      "definition": "A report on features in a nucleic acid sequence that indicate changes to or differences between sequences.",
      "replacedBy": ["http://edamontology.org/data_1276"],
      "text": "Nucleic acid features (difference and change)"
    }, {
      "consider": ["http://edamontology.org/data_0912", "http://edamontology.org/data_3128"],
      "data": {
        "uri": "http://edamontology.org/data_2086"
      },
      "definition": "A report on nucleic acid structure-derived data, describing structural properties of a DNA molecule, or any other annotation or information about specific nucleic acid 3D structure(s).",
      "text": "Nucleic acid structure data"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1580"
      },
      "definition": "Entry format for the ProDom protein domain classification database.",
      "text": "ProDom entry format"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_3529"
      },
      "definition": "Environmental information processing pathways.",
      "replacedBy": ["http://edamontology.org/topic_0602"],
      "text": "Environmental information processing pathways"
    }, {
      "consider": ["http://edamontology.org/operation_0249"],
      "data": {
        "uri": "http://edamontology.org/operation_0395"
      },
      "definition": "Calculate non-canonical atomic interactions in protein structures.",
      "text": "Residue non-canonical interaction detection"
    }, {
      "comment": ["Methods will typically navigate a graph of protein families of known structure."],
      "consider": ["http://edamontology.org/operation_2406"],
      "data": {
        "uri": "http://edamontology.org/operation_0318"
      },
      "definition": "Identify and select targets for protein structural determination.",
      "text": "Structural genomics target selection"
    }, {
      "consider": ["http://edamontology.org/data_2610"],
      "data": {
        "uri": "http://edamontology.org/data_2679"
      },
      "definition": "Identifier of an entry (exon, gene, transcript or protein) from the Ensembl 'core' database ('Echinops telfairi' division).",
      "text": "Ensembl ID ('Echinops telfairi')"
    }, {
      "consider": ["http://edamontology.org/topic_0157"],
      "data": {
        "uri": "http://edamontology.org/topic_0642"
      },
      "definition": "The (character) complexity of molecular sequences, particularly regions of low complexity.",
      "text": "Low complexity sequences"
    }, {
      "consider": ["http://edamontology.org/data_0907"],
      "data": {
        "uri": "http://edamontology.org/data_3142"
      },
      "definition": "Information on a 'fold' node from the SCOP database.",
      "text": "SCOP fold"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_0179"
      },
      "definition": "The prediction of tertiary structure of protein sequences.",
      "replacedBy": ["http://edamontology.org/topic_0082"],
      "text": "Protein tertiary structure prediction"
    }, {
      "consider": ["http://edamontology.org/data_1276"],
      "data": {
        "uri": "http://edamontology.org/data_1310"
      },
      "definition": "A report on microRNA sequence (miRNA) or precursor, microRNA targets, miRNA binding sites in an RNA sequence etc.",
      "text": "Nucleic acid features (microRNA)"
    }, {
      "consider": ["http://edamontology.org/topic_3511"],
      "data": {
        "uri": "http://edamontology.org/topic_3073"
      },
      "definition": "The detection of positional features such as functional sites in nucleotide sequences.",
      "text": "Nucleic acid feature detection"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_2328"
      },
      "definition": "Format of a report on a gene from the PseudoCAP database.",
      "text": "PseudoCAP gene report format"
    }, {
      "consider": ["http://edamontology.org/topic_0634"],
      "data": {
        "uri": "http://edamontology.org/topic_2847"
      },
      "definition": "Informatics resources dedicated to one or more specific diseases (not diseases in general).",
      "text": "Disease (specific)"
    }, {
      "consider": ["http://edamontology.org/data_1026"],
      "data": {
        "uri": "http://edamontology.org/data_1889"
      },
      "definition": "The name of an Antirrhinum Gene from the DragonDB database.",
      "text": "Gene name (DragonDB)"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_1744"
      },
      "definition": "Cartesian x coordinate of an atom (in a molecular structure).",
      "exact_synonyms": ["Cartesian x coordinate"],
      "replacedBy": ["http://edamontology.org/data_1743"],
      "text": "Atomic x coordinate"
    }, {
      "data": {
        "uri": "http://edamontology.org/format_3476"
      },
      "definition": "Format of a file of gene expression data, e.g. a gene expression matrix or profile.",
      "replacedBy": ["http://edamontology.org/format_2058"],
      "text": "Gene expression data format"
    }, {
      "consider": ["http://edamontology.org/data_0582"],
      "data": {
        "uri": "http://edamontology.org/data_0831"
      },
      "definition": "Controlled vocabulary from National Library of Medicine. The MeSH thesaurus is used to index articles in biomedical journals for the Medline/PubMED databases.",
      "text": "MeSH vocabulary"
    }, {
      "consider": ["http://edamontology.org/data_2080"],
      "data": {
        "uri": "http://edamontology.org/data_0885"
      },
      "definition": "Results (hits) from searching a database of tertiary structure.",
      "text": "Structure database search results"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_1658"
      },
      "definition": "environmental information processing pathways.",
      "replacedBy": ["http://edamontology.org/data_2984"],
      "text": "Environmental information processing pathway report"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1247"
      },
      "definition": "Format of an entry from the COG database of clusters of (related) protein sequences.",
      "text": "COG sequence cluster format"
    }, {
      "consider": ["http://edamontology.org/data_2610"],
      "data": {
        "uri": "http://edamontology.org/data_2687"
      },
      "definition": "Identifier of an entry (exon, gene, transcript or protein) from the Ensembl 'core' database ('Monodelphis domestica' division).",
      "text": "Ensembl ID ('Monodelphis domestica')"
    }, {
      "consider": ["http://edamontology.org/operation_2422"],
      "data": {
        "uri": "http://edamontology.org/operation_2265"
      },
      "definition": "Query a database and retrieve one or more data identifiers.",
      "text": "Data retrieval (identifier)"
    }, {
      "consider": ["http://edamontology.org/topic_3047"],
      "data": {
        "uri": "http://edamontology.org/topic_2839"
      },
      "definition": "Specific molecules, including large molecules built from repeating subunits (macromolecules) and small molecules of biological significance.",
      "text": "Molecules"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_1302"
      },
      "definition": "Regions or sites in a eukaryotic and eukaryotic viral RNA sequence which directs endonuclease cleavage or polyadenylation of an RNA transcript.",
      "replacedBy": ["http://edamontology.org/topic_3512"],
      "text": "PolyA signal or sites"
    }, {
      "consider": ["http://edamontology.org/operation_2422"],
      "data": {
        "uri": "http://edamontology.org/operation_2407"
      },
      "definition": "Process (read and / or write) annotation of some type, typically annotation on an entry from a biological or biomedical database entity.",
      "text": "Annotation processing"
    }, {
      "consider": ["http://edamontology.org/format_2350"],
      "data": {
        "uri": "http://edamontology.org/format_2045"
      },
      "definition": "Annotation format for electron microscopy models.",
      "text": "Electron microscopy model format"
    }, {
      "consider": ["http://edamontology.org/data_0842"],
      "data": {
        "uri": "http://edamontology.org/data_0978"
      },
      "definition": "Name or other identifier of a discrete entity (any biological thing with a distinct, discrete physical existence).",
      "text": "Discrete entity identifier"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_1825"
      },
      "definition": "Calculate for each residue in a protein structure all its backbone torsion angles.",
      "replacedBy": ["http://edamontology.org/operation_0249"],
      "text": "Backbone torsion angle calculation"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0359"
      },
      "definition": "Search a tertiary structure database and retrieve structures with a sequence similar to a query sequence.",
      "replacedBy": ["http://edamontology.org/operation_0346"],
      "text": "Structure database search (by sequence)"
    }, {
      "comment": ["The resource may be specific to a prokaryote, a group of prokaryotes or all prokaryotes."],
      "consider": ["http://edamontology.org/topic_0621"],
      "data": {
        "uri": "http://edamontology.org/topic_1811"
      },
      "definition": "Specific bacteria or archaea, e.g. information on a specific prokaryote genome including molecular sequences, genes and annotation.",
      "text": "Prokaryotes and Archaea"
    }, {
      "consider": ["http://edamontology.org/data_1713"],
      "data": {
        "uri": "http://edamontology.org/data_2724"
      },
      "definition": "Annotation on an embryo or concerning embryological development.",
      "text": "Embryo report"
    }, {
      "consider": ["http://edamontology.org/data_2717"],
      "data": {
        "uri": "http://edamontology.org/data_1642"
      },
      "definition": "Affymetrix library file of information about which probes belong to which probe set.",
      "text": "Affymetrix probe sets library file"
    }, {
      "consider": ["http://edamontology.org/data_2048"],
      "data": {
        "uri": "http://edamontology.org/data_1686"
      },
      "definition": "EMBOSS megamerger log file.",
      "text": "EMBOSS megamerger log file"
    }, {
      "consider": ["http://edamontology.org/data_0842"],
      "data": {
        "uri": "http://edamontology.org/data_1677"
      },
      "definition": "A label (text token) describing the type of job, for example interactive or non-interactive.",
      "text": "Job type"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_1826"
      },
      "definition": "Calculate for each residue in a protein structure all its torsion angles.",
      "replacedBy": ["http://edamontology.org/operation_0249"],
      "text": "Full torsion angle calculation"
    }, {
      "consider": ["http://edamontology.org/operation_2422"],
      "data": {
        "uri": "http://edamontology.org/operation_0515"
      },
      "definition": "Search and retrieve names of or documentation on bioinformatics tools, for example by keyword or which perform a particular function.",
      "text": "Data retrieval (tool metadata)"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1609"
      },
      "definition": "Entry format of Gramene genome database.",
      "text": "Gramene gene report format"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0329"
      },
      "definition": "Predict the folding pathway(s) or non-native structural intermediates of a protein.",
      "replacedBy": ["http://edamontology.org/operation_0474"],
      "text": "Protein folding pathway prediction"
    }, {
      "consider": ["http://edamontology.org/data_1026"],
      "data": {
        "uri": "http://edamontology.org/data_2743"
      },
      "definition": "Name of an entry (gene) from the HUGO database.",
      "text": "Gene name (HUGO)"
    }, {
      "comment": ["This might describe e.g. the normalisation methods used to process the raw data."],
      "data": {
        "uri": "http://edamontology.org/data_3116"
      },
      "definition": "Annotation on laboratory and/or data processing protocols used in an microarray experiment.",
      "replacedBy": ["http://edamontology.org/data_2531"],
      "text": "Microarray protocol annotation"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1655"
      },
      "definition": "The format of an entry from the Panther Pathways database.",
      "text": "Panther Pathways entry format"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_3107"
      },
      "definition": "A name of a sequence feature, e.g. the name of a feature to be displayed to an end-user.",
      "replacedBy": ["http://edamontology.org/data_1022"],
      "text": "Sequence feature name"
    }, {
      "consider": ["http://edamontology.org/data_2337"],
      "data": {
        "uri": "http://edamontology.org/data_1672"
      },
      "definition": "Information on a version of the CATH database.",
      "text": "CATH version information"
    }, {
      "consider": ["http://edamontology.org/data_1398"],
      "data": {
        "uri": "http://edamontology.org/data_1406"
      },
      "definition": "A simple floating point number defining the penalty for extending a gap in an alignment.",
      "text": "Gap extension penalty (integer)"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1615"
      },
      "definition": "Entry format of the Sanger GeneDB genome database.",
      "text": "GeneDB gene report format"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0377"
      },
      "definition": "Calculate base frequency or word composition of a nucleotide sequence.",
      "replacedBy": ["http://edamontology.org/operation_0236"],
      "text": "Sequence composition calculation (nucleic acid)"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0378"
      },
      "definition": "Calculate amino acid frequency or word composition of a protein sequence.",
      "replacedBy": ["http://edamontology.org/operation_0236"],
      "text": "Sequence composition calculation (protein)"
    }, {
      "consider": ["http://edamontology.org/operation_2949"],
      "data": {
        "uri": "http://edamontology.org/operation_2405"
      },
      "definition": "Process (read and / or write) protein interaction data.",
      "text": "Protein interaction data processing"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_3541"
      },
      "definition": "Post-translation modifications in a protein sequence, typically describing the specific sites involved.",
      "replacedBy": ["http://edamontology.org/topic_0601"],
      "text": "Protein post-translational modifications"
    }, {
      "comment": ["The ontology is provided as two components, the service ontology and the domain ontology. The domain ontology acts provides concepts for core bioinformatics data types and their relations. The service ontology describes the physical and operational features of web services."],
      "consider": ["http://edamontology.org/data_0966"],
      "data": {
        "uri": "http://edamontology.org/data_1726"
      },
      "definition": "A term from the myGrid ontology.",
      "text": "myGrid"
    }, {
      "consider": ["http://edamontology.org/data_2600"],
      "data": {
        "uri": "http://edamontology.org/data_0947"
      },
      "definition": "A map (typically a diagram) of a biological pathway.",
      "text": "Biological pathway map"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_3135"
      },
      "definition": "Coding sequences for a signal or transit peptide.",
      "replacedBy": ["http://edamontology.org/topic_3512"],
      "text": "Signal or transit peptide"
    }, {
      "comment": ["Waters are not considered."],
      "data": {
        "uri": "http://edamontology.org/operation_2460"
      },
      "definition": "Calculate the solvent accessibility for each atom in a structure.",
      "replacedBy": ["http://edamontology.org/operation_0387"],
      "text": "Protein atom surface calculation"
    }, {
      "consider": ["http://edamontology.org/data_0916"],
      "data": {
        "uri": "http://edamontology.org/data_3140"
      },
      "definition": "A report on predicted or actual immunoglobulin gene structure including constant, switch and variable regions and diversity, joining and variable segments.",
      "text": "Nucleic acid features (immunoglobulin gene structure)"
    }, {
      "consider": ["http://edamontology.org/operation_0286"],
      "data": {
        "uri": "http://edamontology.org/operation_2493"
      },
      "definition": "Process (read and / or write) codon usage data.",
      "text": "Codon usage data processing"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_2364"
      },
      "definition": "two-dimensional gel electrophoresis experiments, gels or spots in a gel.",
      "replacedBy": ["http://edamontology.org/data_2531"],
      "text": "2D PAGE report"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0347"
      },
      "definition": "Search a sequence database and retrieve sequences matching a given sequence motif or pattern, such as a Prosite pattern or regular expression.",
      "replacedBy": ["http://edamontology.org/operation_0239"],
      "text": "Sequence database search (by motif or pattern)"
    }, {
      "consider": ["http://edamontology.org/data_0006"],
      "data": {
        "uri": "http://edamontology.org/data_2527"
      },
      "definition": "Typically a simple numerical or string value that controls the operation of a tool.",
      "text": "Parameter"
    }, {
      "consider": ["http://edamontology.org/data_2093"],
      "data": {
        "uri": "http://edamontology.org/data_1733"
      },
      "definition": "Reference for a concept from an ontology.",
      "text": "Ontology concept reference"
    }, {
      "consider": ["http://edamontology.org/operation_0276"],
      "data": {
        "uri": "http://edamontology.org/operation_2445"
      },
      "definition": "Process (read and / or write) a network of protein interactions.",
      "text": "Protein interaction network processing"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_2462"
      },
      "definition": "Calculate the solvent accessibility of a structure as a whole.",
      "replacedBy": ["http://edamontology.org/operation_0387"],
      "text": "Protein surface calculation"
    }, {
      "consider": ["http://edamontology.org/format_2014"],
      "data": {
        "uri": "http://edamontology.org/format_2015"
      },
      "definition": "Data format for a sequence-HMM profile alignment.",
      "text": "Sequence-profile alignment (HMM) format"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_1311"
      },
      "definition": "Operons (operators, promoters and genes) from a bacterial genome.",
      "replacedBy": ["http://edamontology.org/topic_0114"],
      "text": "Operon"
    }, {
      "consider": ["http://edamontology.org/data_1026"],
      "data": {
        "uri": "http://edamontology.org/data_1790"
      },
      "definition": "Symbol of a gene from E.coli Genetic Stock Center.",
      "text": "Gene name (CGSC)"
    }, {
      "consider": ["http://edamontology.org/data_1354"],
      "data": {
        "uri": "http://edamontology.org/data_1368"
      },
      "definition": "A protein signature of the type used in the EMBASSY Signature package.",
      "text": "Domainatrix signature"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_2889"
      },
      "definition": "A nucleic acid sequence and comprehensive metadata (such as a feature table), typically corresponding to a full entry from a molecular sequence database.",
      "replacedBy": ["http://edamontology.org/data_0849"],
      "text": "Nucleic acid sequence record (full)"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_2832"
      },
      "definition": "A web site providing data (web pages) on a common theme to a HTTP client.",
      "replacedBy": ["http://edamontology.org/data_0958"],
      "text": "Web portal"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1697"
      },
      "definition": "The format of an entry from the KEGG LIGAND chemical database.",
      "text": "KEGG LIGAND entry format"
    }, {
      "consider": ["http://edamontology.org/operation_2422"],
      "data": {
        "uri": "http://edamontology.org/operation_0257"
      },
      "definition": "Display basic information about a sequence alignment.",
      "text": "Data retrieval (sequence alignment)"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_1305"
      },
      "definition": "Restriction enzyme recognition sites (restriction sites) in a nucleic acid sequence.",
      "replacedBy": ["http://edamontology.org/topic_3125"],
      "text": "Restriction sites"
    }, {
      "consider": ["http://edamontology.org/data_2085"],
      "data": {
        "uri": "http://edamontology.org/data_2973"
      },
      "definition": "Data concerning molecular secondary structure data.",
      "text": "Secondary structure data"
    }, {
      "comment": ["This might include conformational or physicochemical properties, as well as sequence information for transcription factor(s) binding sites."],
      "consider": ["http://edamontology.org/data_0896"],
      "data": {
        "uri": "http://edamontology.org/data_2147"
      },
      "definition": "An informative report on a transcription factor protein.",
      "text": "Protein report (transcription factor)"
    }, {
      "consider": ["http://edamontology.org/operation_0292", "http://edamontology.org/operation_0295"],
      "data": {
        "uri": "http://edamontology.org/operation_2951"
      },
      "definition": "Process (read and / or write) an alignment of two or more molecular sequences, structures or derived data.",
      "text": "Alignment processing"
    }, {
      "consider": ["http://edamontology.org/data_1537"],
      "data": {
        "uri": "http://edamontology.org/data_0902"
      },
      "definition": "An informative report on architecture (spatial arrangement of secondary structure) of a protein structure.",
      "text": "Protein architecture report"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0301"
      },
      "definition": "Align molecular sequence(s) to structural (3D) profile(s) or template(s) (representing a structure or structure alignment).",
      "replacedBy": ["http://edamontology.org/operation_0303"],
      "text": "Sequence-to-3D-profile alignment"
    }, {
      "consider": ["http://edamontology.org/data_0958"],
      "data": {
        "uri": "http://edamontology.org/data_1671"
      },
      "definition": "Information on an application version, for example name, version number and release date.",
      "text": "Tool version information"
    }, {
      "consider": ["http://edamontology.org/topic_0601", "http://edamontology.org/topic_0748"],
      "data": {
        "uri": "http://edamontology.org/topic_0751"
      },
      "definition": "Protein phosphorylation and phosphorylation sites in protein sequences.",
      "text": "Phosphorylation sites"
    }, {
      "consider": ["http://edamontology.org/topic_0089"],
      "data": {
        "uri": "http://edamontology.org/topic_2829"
      },
      "definition": "Conceptualisation, categorisation and naming of entities or phenomena within biology or bioinformatics.",
      "text": "Ontologies, nomenclature and classification"
    }, {
      "consider": ["http://edamontology.org/data_0966"],
      "data": {
        "uri": "http://edamontology.org/data_1724"
      },
      "definition": "A term from the ChEBI ontology.",
      "text": "ChEBI"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_3201"
      },
      "definition": "Identify single nucleotide change in base positions in sequencing data that differ from a reference genome and which might, especially by reference to population frequency or functional data, indicate a polymorphism.",
      "replacedBy": ["http://edamontology.org/operation_0484"],
      "text": "SNP calling"
    }, {
      "consider": ["http://edamontology.org/topic_0659"],
      "data": {
        "uri": "http://edamontology.org/topic_0663"
      },
      "definition": "One or more transfer RNA (tRNA) sequences.",
      "text": "tRNA"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_2965"
      },
      "definition": "An informative report on a two-dimensional (2D PAGE) gel.",
      "replacedBy": ["http://edamontology.org/data_2531"],
      "text": "2D PAGE gel report"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_1315"
      },
      "definition": "transcription factor binding sites (TFBS) in a DNA sequence.",
      "replacedBy": ["http://edamontology.org/data_1276"],
      "text": "Transcription factor binding sites"
    }, {
      "consider": ["http://edamontology.org/topic_0203"],
      "data": {
        "uri": "http://edamontology.org/topic_0110"
      },
      "definition": "The transcription of DNA into mRNA.",
      "text": "Transcription"
    }, {
      "comment": ["Possible values include for example the EMBOSS alignment types, BLAST alignment types and so on."],
      "consider": ["http://edamontology.org/data_0842"],
      "data": {
        "uri": "http://edamontology.org/data_1120"
      },
      "definition": "A label (text token) describing the type of a sequence alignment.",
      "text": "Sequence alignment type"
    }, {
      "consider": ["http://edamontology.org/data_0863"],
      "data": {
        "uri": "http://edamontology.org/data_1382"
      },
      "definition": "Alignment of more than two molecular sequences.",
      "text": "Sequence alignment (multiple)"
    }, {
      "consider": ["http://edamontology.org/data_2534"],
      "data": {
        "uri": "http://edamontology.org/data_0851"
      },
      "definition": "A character used to replace (mask) other characters in a molecular sequence.",
      "text": "Sequence mask character"
    }, {
      "consider": ["http://edamontology.org/data_1096"],
      "data": {
        "uri": "http://edamontology.org/data_2288"
      },
      "definition": "An identifier of protein sequence(s) or protein sequence database entries.",
      "text": "Sequence identifier (protein)"
    }, {
      "consider": ["http://edamontology.org/data_1026"],
      "data": {
        "uri": "http://edamontology.org/data_2103"
      },
      "definition": "Name of an entry (gene) from the KEGG GENES database.",
      "text": "Gene name (KEGG GENES)"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0243"
      },
      "definition": "Extract, calculate or predict non-positional (physical or chemical) properties of a protein from processing a protein (3D) structure.",
      "replacedBy": ["http://edamontology.org/operation_0250"],
      "text": "Protein property calculation (from structure)"
    }, {
      "data": {
        "uri": "http://edamontology.org/format_2159"
      },
      "definition": "Format used for report on coding regions in nucleotide sequences.",
      "replacedBy": ["http://edamontology.org/format_2031"],
      "text": "Gene features (coding region) format"
    }, {
      "comment": ["These are the parsable data files provided by SCOP."],
      "consider": ["http://edamontology.org/data_0907"],
      "data": {
        "uri": "http://edamontology.org/data_2235"
      },
      "definition": "Raw SCOP domain classification data files.",
      "text": "Raw SCOP domain classification"
    }, {
      "consider": ["http://edamontology.org/data_0957"],
      "data": {
        "uri": "http://edamontology.org/data_2090"
      },
      "definition": "Information on a database (or ontology) entry version, such as name (or other identifier) or parent database, unique identifier of entry, data, author and so on.",
      "text": "Database entry version information"
    }, {
      "comment": ["The SMART output file includes data on genetically mobile domains / analysis of domain architectures, including phyletic distributions, functional class, tertiary structures and functionally important residues."],
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1563"
      },
      "definition": "Format of SMART domain assignment data.",
      "text": "SMART domain assignment report format"
    }, {
      "consider": ["http://edamontology.org/data_0957"],
      "data": {
        "uri": "http://edamontology.org/data_1670"
      },
      "definition": "Information on a database (or ontology) version, for example name, version number and release date.",
      "text": "Database version information"
    }, {
      "consider": ["http://edamontology.org/topic_0622", "http://edamontology.org/topic_0621", "http://edamontology.org/topic_0219"],
      "data": {
        "uri": "http://edamontology.org/topic_0222"
      },
      "definition": "Annotation of a genome.",
      "text": "Genome annotation"
    }, {
      "consider": ["http://edamontology.org/data_1026"],
      "data": {
        "uri": "http://edamontology.org/data_1791"
      },
      "definition": "Symbol of a gene approved by the HUGO Gene Nomenclature Committee.",
      "text": "Gene name (HGNC)"
    }, {
      "consider": ["http://edamontology.org/data_1397"],
      "data": {
        "uri": "http://edamontology.org/data_1405"
      },
      "definition": "A simple floating point number defining the penalty for opening a gap in an alignment.",
      "text": "Gap opening penalty (float)"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_2399"
      },
      "definition": "Transcription of DNA into RNA including the regulation of transcription.",
      "replacedBy": ["http://edamontology.org/topic_3512"],
      "text": "Gene transcription"
    }, {
      "consider": ["http://edamontology.org/data_1249"],
      "data": {
        "uri": "http://edamontology.org/data_2136"
      },
      "definition": "The width of an output sequence or alignment.",
      "text": "Sequence width"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_2958"
      },
      "definition": "A melting curve of a double-stranded nucleic acid molecule (DNA or DNA/RNA).",
      "replacedBy": ["http://edamontology.org/data_1583"],
      "text": "Nucleic acid melting curve"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_1845"
      },
      "definition": "Extract a molecular sequence from a PDB file.",
      "replacedBy": ["http://edamontology.org/operation_2422"],
      "text": "PDB file sequence retrieval"
    }, {
      "consider": ["http://edamontology.org/data_1276"],
      "data": {
        "uri": "http://edamontology.org/data_2215"
      },
      "definition": "An informative report on the functional properties of mutant proteins including transcriptional activities, promotion of cell growth and tumorigenicity, dominant negative effects, capacity to induce apoptosis, cell-cycle arrest or checkpoints in human cells and so on.",
      "text": "Mutation annotation (functional)"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_2496"
      },
      "definition": "Process (read and / or write) a network of gene regulation.",
      "replacedBy": ["http://edamontology.org/operation_1781"],
      "text": "Gene regulatory network processing"
    }, {
      "consider": ["http://edamontology.org/data_2610"],
      "data": {
        "uri": "http://edamontology.org/data_2689"
      },
      "definition": "Identifier of an entry (exon, gene, transcript or protein) from the Ensembl 'core' database ('Myotis lucifugus' division).",
      "text": "Ensembl ID ('Myotis lucifugus')"
    }, {
      "consider": ["http://edamontology.org/operation_2403"],
      "data": {
        "uri": "http://edamontology.org/operation_2453"
      },
      "definition": "Process (read and / or write) a sequence feature table.",
      "text": "Feature table processing"
    }, {
      "consider": ["http://edamontology.org/data_2610"],
      "data": {
        "uri": "http://edamontology.org/data_2683"
      },
      "definition": "Identifier of an entry (exon, gene, transcript or protein) from the Ensembl 'core' database ('Gasterosteus aculeatus' division).",
      "text": "Ensembl ID ('Gasterosteus aculeatus')"
    }, {
      "comment": ["C-beta atoms from amino acid side-chains may be included."],
      "consider": ["http://edamontology.org/data_1468"],
      "data": {
        "uri": "http://edamontology.org/data_1474"
      },
      "definition": "3D coordinate and associated data for a protein domain tertiary (3D) structure (typically C-alpha atoms only).",
      "text": "Protein domain (C-alpha atoms)"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_3346"
      },
      "definition": "The search and retrieval from a database on the basis of molecular sequence similarity.",
      "exact_synonyms": ["Sequence database search"],
      "replacedBy": ["http://edamontology.org/topic_0080"],
      "text": "Sequence search"
    }, {
      "consider": ["http://edamontology.org/data_0006"],
      "data": {
        "uri": "http://edamontology.org/data_2135"
      },
      "definition": "A simple parameter that is a toggle (boolean value), typically a control for a modal tool.",
      "text": "Toggle"
    }, {
      "comment": ["C-beta atoms from amino acid side-chains may be included."],
      "consider": ["http://edamontology.org/data_1481"],
      "data": {
        "uri": "http://edamontology.org/data_1488"
      },
      "definition": "Alignment (superimposition) of exactly two protein tertiary (3D) structures (typically C-alpha atoms only considered).",
      "text": "Pairwise protein tertiary structure alignment (C-alpha atoms)"
    }, {
      "consider": ["http://edamontology.org/data_0907"],
      "data": {
        "uri": "http://edamontology.org/data_3101"
      },
      "definition": "A node from a classification of protein structural domain(s).",
      "text": "Protein domain classification node"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_3353"
      },
      "definition": "Compare two or more ontologies, e.g. identify differences.",
      "replacedBy": ["http://edamontology.org/operation_3352"],
      "text": "Ontology comparison"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_2503"
      },
      "definition": "Process (read and / or write) molecular sequence data.",
      "replacedBy": ["http://edamontology.org/operation_2403"],
      "text": "Sequence data processing"
    }, {
      "consider": ["http://edamontology.org/operation_2495"],
      "data": {
        "uri": "http://edamontology.org/operation_2500"
      },
      "definition": "Analyse raw microarray data.",
      "text": "Microarray raw data analysis"
    }, {
      "consider": ["http://edamontology.org/data_2048"],
      "data": {
        "uri": "http://edamontology.org/data_1679"
      },
      "definition": "DaliLite log file describing all the steps taken by a DaliLite alignment of two protein structures.",
      "text": "DaliLite log file"
    }, {
      "consider": ["http://edamontology.org/data_3355", "http://edamontology.org/data_3354"],
      "data": {
        "uri": "http://edamontology.org/data_1348"
      },
      "definition": "Emission and transition counts of a hidden Markov model, generated once HMM has been determined, for example after residues/gaps have been assigned to match, delete and insert states.",
      "text": "HMM emission and transition counts"
    }, {
      "consider": ["http://edamontology.org/operation_3431"],
      "data": {
        "uri": "http://edamontology.org/operation_1780"
      },
      "definition": "Submit a molecular sequence to a database.",
      "text": "Sequence submission"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_2866"
      },
      "definition": "Northern Blot experiments.",
      "replacedBy": ["http://edamontology.org/data_2531"],
      "text": "Northern blot report"
    }, {
      "consider": ["http://edamontology.org/data_1026"],
      "data": {
        "uri": "http://edamontology.org/data_1785"
      },
      "definition": "Name of a gene from dictyBase database.",
      "text": "Gene name (dictyBase)"
    }, {
      "consider": ["http://edamontology.org/operation_2480"],
      "data": {
        "uri": "http://edamontology.org/operation_2504"
      },
      "definition": "Process (read and / or write) molecular structural data.",
      "text": "Structural data processing"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_3514"
      },
      "definition": "Protein-ligand (small molecule) interaction(s).",
      "narrow_synonyms": ["Protein-drug interactions"],
      "replacedBy": ["http://edamontology.org/topic_0128"],
      "text": "Protein-ligand interactions"
    }, {
      "consider": ["http://edamontology.org/data_0916"],
      "data": {
        "uri": "http://edamontology.org/data_2763"
      },
      "definition": "An informative report on a particular locus.",
      "exact_synonyms": ["Locus report"],
      "text": "Locus annotation"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_0941"
      },
      "definition": "Annotation on a structural 3D model (volume map) from electron microscopy.",
      "replacedBy": ["http://edamontology.org/data_3806"],
      "text": "Electron microscopy model"
    }, {
      "consider": ["http://edamontology.org/operation_2422"],
      "data": {
        "uri": "http://edamontology.org/operation_2473"
      },
      "definition": "Retrieve information on a specific genotype or phenotype.",
      "text": "Data retrieval (genotype and phenotype annotation)"
    }, {
      "consider": ["http://edamontology.org/topic_0749"],
      "data": {
        "uri": "http://edamontology.org/topic_0111"
      },
      "definition": "Promoters in DNA sequences (region of DNA that facilitates the transcription of a particular gene by binding RNA polymerase and transcription factor proteins).",
      "text": "Promoters"
    }, {
      "consider": ["http://edamontology.org/data_1277"],
      "data": {
        "uri": "http://edamontology.org/data_1330"
      },
      "definition": "A report on predicted epitopes that bind to MHC class II molecules.",
      "text": "MHC Class II epitopes report"
    }, {
      "consider": ["http://edamontology.org/data_1026"],
      "data": {
        "uri": "http://edamontology.org/data_1788"
      },
      "definition": "Name of a gene from Saccharomyces Genome Database.",
      "text": "Gene name (SGD)"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0411"
      },
      "definition": "Detect or predict signal peptides (and typically predict subcellular localisation) of eukaryotic proteins.",
      "replacedBy": ["http://edamontology.org/operation_0418"],
      "text": "Protein signal peptide detection (eukaryotes)"
    }, {
      "consider": ["http://edamontology.org/data_0006"],
      "data": {
        "uri": "http://edamontology.org/data_0843"
      },
      "definition": "An entry (retrievable via URL) from a biological database.",
      "text": "Database entry"
    }, {
      "consider": ["http://edamontology.org/topic_0097"],
      "data": {
        "uri": "http://edamontology.org/topic_0094"
      },
      "definition": "The study of the thermodynamic properties of a nucleic acid.",
      "text": "Nucleic acid thermodynamics"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0565"
      },
      "definition": "Visualise, format or print a molecular sequence alignment.",
      "replacedBy": ["http://edamontology.org/operation_0564"],
      "text": "Sequence alignment visualisation"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_2046"
      },
      "definition": "A nucleic acid sequence and minimal metadata, typically an identifier of the sequence and/or a comment.",
      "replacedBy": ["http://edamontology.org/data_0849"],
      "text": "Nucleic acid sequence record (lite)"
    }, {
      "consider": ["http://edamontology.org/data_1276"],
      "data": {
        "uri": "http://edamontology.org/data_1024"
      },
      "definition": "String of one or more ASCII characters representing a codon.",
      "text": "Codon name"
    }, {
      "consider": ["http://edamontology.org/topic_0080", "http://edamontology.org/topic_0091"],
      "data": {
        "uri": "http://edamontology.org/topic_0156"
      },
      "definition": "Edit, convert or otherwise change a molecular sequence, either randomly or specifically.",
      "text": "Sequence editing"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_3497"
      },
      "definition": "A raw DNA sequence.",
      "exact_synonyms": ["DNA raw sequence", "Raw DNA sequence", "Raw sequence (DNA)"],
      "replacedBy": ["http://edamontology.org/data_3494"],
      "text": "DNA sequence (raw)"
    }, {
      "consider": ["http://edamontology.org/data_0872"],
      "data": {
        "uri": "http://edamontology.org/data_2247"
      },
      "definition": "A consensus phylogenetic tree derived from comparison of multiple trees.",
      "text": "Phylogenetic consensus tree"
    }, {
      "consider": ["http://edamontology.org/data_0906"],
      "data": {
        "uri": "http://edamontology.org/data_2358"
      },
      "definition": "An informative report on protein domain-DNA/RNA interaction(s).",
      "text": "Domain-nucleic acid interaction report"
    }, {
      "consider": ["http://edamontology.org/topic_1775"],
      "data": {
        "uri": "http://edamontology.org/topic_2276"
      },
      "definition": "The prediction of functional properties of a protein.",
      "text": "Protein function prediction"
    }, {
      "consider": ["http://edamontology.org/data_0842"],
      "data": {
        "uri": "http://edamontology.org/data_2130"
      },
      "definition": "A label (text token) describing a type of sequence profile such as frequency matrix, Gribskov profile, hidden Markov model etc.",
      "text": "Sequence profile type"
    }, {
      "consider": ["http://edamontology.org/data_0966"],
      "data": {
        "uri": "http://edamontology.org/data_1719"
      },
      "definition": "A term from the NCBI taxonomy vocabulary.",
      "text": "NCBI taxonomy vocabulary"
    }, {
      "consider": ["http://edamontology.org/topic_0130"],
      "data": {
        "uri": "http://edamontology.org/topic_0150"
      },
      "definition": "The design of proteins with specific properties, typically by designing changes (via site-directed mutagenesis) to an existing protein.",
      "text": "Protein design"
    }, {
      "consider": ["http://edamontology.org/data_2339"],
      "data": {
        "uri": "http://edamontology.org/data_3026"
      },
      "definition": "The name of a concept for a biological process from the GO ontology.",
      "text": "GO concept name (biological process)"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_2440"
      },
      "definition": "Process (read and / or write) RNA tertiary structure data.",
      "replacedBy": ["http://edamontology.org/operation_2480"],
      "text": "Structure processing (RNA)"
    }, {
      "consider": ["http://edamontology.org/data_1235"],
      "data": {
        "uri": "http://edamontology.org/data_1765"
      },
      "definition": "FASTA sequence database (based on COMBS sequence data) for CATH domains (clustered at different levels of sequence identity).",
      "text": "CATH representative domain sequences (COMBS)"
    }, {
      "consider": ["http://edamontology.org/data_0968"],
      "data": {
        "uri": "http://edamontology.org/data_1880"
      },
      "definition": "A term which is likely to be misleading of its meaning.",
      "text": "Misnomer"
    }, {
      "consider": ["http://edamontology.org/data_1870"],
      "data": {
        "uri": "http://edamontology.org/data_2733"
      },
      "definition": "The name of a genus of viruses.",
      "text": "Genus name (virus)"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_2461"
      },
      "definition": "Calculate the solvent accessibility for each residue in a structure.",
      "replacedBy": ["http://edamontology.org/operation_0387"],
      "text": "Protein residue surface calculation"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1576"
      },
      "definition": "Entry format for the Pfam protein secondary database.",
      "text": "Pfam entry format"
    }, {
      "consider": ["http://edamontology.org/data_0962"],
      "data": {
        "uri": "http://edamontology.org/data_0894"
      },
      "definition": "An informative report about a specific amino acid.",
      "text": "Amino acid annotation"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_2722"
      },
      "definition": "disordered structure in a protein.",
      "replacedBy": ["http://edamontology.org/data_1277"],
      "text": "Protein features report (disordered structure)"
    }, {
      "comment": ["The resource may be specific to a unicellular eukaryote, a group of unicellular eukaryotes or all unicellular eukaryotes."],
      "consider": ["http://edamontology.org/topic_0621"],
      "data": {
        "uri": "http://edamontology.org/topic_2821"
      },
      "definition": "Unicellular eukaryotes, e.g. information on a unicellular eukaryote genome including molecular sequences, genes and annotation.",
      "text": "Unicellular eukaryotes"
    }, {
      "consider": ["http://edamontology.org/data_0842"],
      "data": {
        "uri": "http://edamontology.org/data_3268"
      },
      "definition": "A label (text token) describing a type of sequence feature such as gene, transcript, cds, exon, repeat, simple, misc, variation, somatic variation, structural variation, somatic structural variation, constrained or regulatory.",
      "text": "Sequence feature type"
    }, {
      "consider": ["http://edamontology.org/data_1249"],
      "data": {
        "uri": "http://edamontology.org/data_0854"
      },
      "definition": "A specification of sequence length(s).",
      "text": "Sequence length specification"
    }, {
      "consider": ["http://edamontology.org/data_1276"],
      "data": {
        "uri": "http://edamontology.org/data_2116"
      },
      "definition": "An informative report on a trinucleotide sequence that encodes an amino acid including the triplet sequence, the encoded amino acid or whether it is a start or stop codon.",
      "text": "Nucleic acid features (codon)"
    }, {
      "consider": ["http://edamontology.org/data_2048"],
      "data": {
        "uri": "http://edamontology.org/data_2248"
      },
      "definition": "A data schema for organising or transforming data of some type.",
      "text": "Schema"
    }, {
      "comment": ["Needed for conversion to the OBO format."],
      "data": {
        "uri": "oboInOwl:ObsoleteClass"
      },
      "definition": "An obsolete concept (redefined in EDAM).",
      "replacedBy": ["owl:DeprecatedClass"],
      "text": "Obsolete concept (EDAM)"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_2868"
      },
      "definition": "Microsatellite polymorphism in a DNA sequence.",
      "replacedBy": ["http://edamontology.org/topic_2885"],
      "text": "Microsatellites"
    }, {
      "consider": ["http://edamontology.org/data_0874"],
      "data": {
        "uri": "http://edamontology.org/data_1447"
      },
      "definition": "Matrix of floating point numbers for sequence comparison.",
      "text": "Comparison matrix (floats)"
    }, {
      "consider": ["http://edamontology.org/data_2872"],
      "data": {
        "uri": "http://edamontology.org/data_2579"
      },
      "definition": "A simple summary of expressed genes.",
      "text": "Expressed gene list"
    }, {
      "consider": ["http://edamontology.org/data_0842"],
      "data": {
        "uri": "http://edamontology.org/data_0981"
      },
      "definition": "Name or other identifier of a physical, observable biological occurrence or event.",
      "text": "Phenomenon identifier"
    }, {
      "consider": ["http://edamontology.org/data_0957"],
      "data": {
        "uri": "http://edamontology.org/data_2149"
      },
      "definition": "The name of a category of biological or bioinformatics database.",
      "text": "Database category name"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_2788"
      },
      "definition": "Data concerning, extracted from, or derived from the analysis of a sequence profile, such as its name, length, technical details about the profile or it's construction, the biological role or annotation, and so on.",
      "replacedBy": ["http://edamontology.org/data_0860"],
      "text": "Sequence profile data"
    }, {
      "comment": ["Currently too specific for the topic sub-ontology (but might be unobsoleted)."],
      "consider": ["http://edamontology.org/topic_3293"],
      "data": {
        "uri": "http://edamontology.org/topic_0191"
      },
      "definition": "The reconstruction of a phylogeny (evolutionary relatedness amongst organisms), for example, by building a phylogenetic tree.",
      "text": "Phylogeny reconstruction"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1573"
      },
      "definition": "Entry format for the PIRSF protein secondary database.",
      "text": "PIRSF entry format"
    }, {
      "comment": ["Map types may be based on Gramene's notion of a map type; see http://www.gramene.org/db/cmap/map_type_info."],
      "consider": ["http://edamontology.org/data_0842"],
      "data": {
        "uri": "http://edamontology.org/data_1866"
      },
      "definition": "A designation of the type of map (genetic map, physical map, sequence map etc) or map set.",
      "text": "Map type"
    }, {
      "consider": ["http://edamontology.org/format_2013"],
      "data": {
        "uri": "http://edamontology.org/format_2034"
      },
      "definition": "Data format for a biological model.",
      "text": "Biological model format"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_1827"
      },
      "definition": "Calculate for each cysteine (bridge) all its torsion angles.",
      "replacedBy": ["http://edamontology.org/operation_0249"],
      "text": "Cysteine torsion angle calculation"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_0090"
      },
      "definition": "The search and query of data sources (typically databases or ontologies) in order to retrieve entries or other information.",
      "replacedBy": ["http://edamontology.org/topic_3071"],
      "text": "Information retrieval"
    }, {
      "consider": ["http://edamontology.org/data_2048"],
      "data": {
        "uri": "http://edamontology.org/data_2143"
      },
      "definition": "An application report generated by the EMBOSS suite.",
      "text": "EMBOSS report"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_2447"
      },
      "definition": "Process (read and / or write) a protein sequence and associated annotation.",
      "replacedBy": ["http://edamontology.org/operation_2479"],
      "text": "Sequence processing (protein)"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_0899"
      },
      "definition": "3D structural motifs in a protein.",
      "replacedBy": ["http://edamontology.org/data_1277"],
      "text": "Protein structural motifs and surfaces"
    }, {
      "consider": ["http://edamontology.org/format_2350"],
      "data": {
        "uri": "http://edamontology.org/format_2063"
      },
      "definition": "Format of a report of general information about a specific enzyme.",
      "text": "Protein report (enzyme) format"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_0931"
      },
      "definition": "microarray experiments including conditions, protocol, sample:data relationships etc.",
      "replacedBy": ["http://edamontology.org/data_2531"],
      "text": "Microarray experiment report"
    }, {
      "consider": ["http://edamontology.org/data_0883"],
      "data": {
        "uri": "http://edamontology.org/data_0884"
      },
      "definition": "An entry from a molecular tertiary (3D) structure database.",
      "text": "Tertiary structure record"
    }, {
      "consider": ["http://edamontology.org/data_0006"],
      "data": {
        "uri": "http://edamontology.org/data_2079"
      },
      "definition": "Some simple value controlling a search operation, typically a search of a database.",
      "text": "Search parameter"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_3545"
      },
      "definition": "Model some biological system using mathematical techniques including  dynamical systems, statistical models, differential equations, and game theoretic models.",
      "replacedBy": ["http://edamontology.org/operation_2426"],
      "text": "Mathematical modelling"
    }, {
      "consider": ["http://edamontology.org/data_1026"],
      "data": {
        "uri": "http://edamontology.org/data_2296"
      },
      "definition": "Name of an entry (gene) from the AceView genes database.",
      "text": "Gene name (AceView)"
    }, {
      "comment": ["This includes documentation, general information and other metadata on entities such as databases, database entries and tools."],
      "data": {
        "uri": "http://edamontology.org/operation_0304"
      },
      "definition": "Search for and retrieve data concerning or describing some core data, as distinct from the primary data that is being described.",
      "replacedBy": ["http://edamontology.org/operation_2422"],
      "text": "Metadata retrieval"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0413"
      },
      "definition": "Predict MHC class I or class II binding peptides, promiscuous binding peptides, immunogenicity etc.",
      "replacedBy": ["http://edamontology.org/operation_0252"],
      "text": "MHC peptide immunogenicity prediction"
    }, {
      "comment": ["This is a broad data type and is used a placeholder for other, more specific types."],
      "consider": ["http://edamontology.org/data_2534"],
      "data": {
        "uri": "http://edamontology.org/data_2925"
      },
      "definition": "Data concerning, extracted from, or derived from the analysis of molecular sequence(s).",
      "text": "Sequence data"
    }, {
      "consider": ["http://edamontology.org/data_0968"],
      "data": {
        "uri": "http://edamontology.org/data_1877"
      },
      "definition": "An alternative for a word.",
      "text": "Synonym"
    }, {
      "consider": ["http://edamontology.org/data_1481", "http://edamontology.org/data_1384", "http://edamontology.org/data_0878"],
      "data": {
        "uri": "http://edamontology.org/data_3154"
      },
      "definition": "An alignment of protein sequences and/or structures.",
      "text": "Protein alignment"
    }, {
      "consider": ["http://edamontology.org/operation_0362"],
      "data": {
        "uri": "http://edamontology.org/operation_2466"
      },
      "definition": "Annotate a DNA map of some type with terms from a controlled vocabulary.",
      "text": "Map annotation"
    }, {
      "consider": ["http://edamontology.org/operation_2437", "http://edamontology.org/operation_3929", "http://edamontology.org/operation_3094"],
      "data": {
        "uri": "http://edamontology.org/operation_3439"
      },
      "definition": "Predict a molecular pathway or network.",
      "text": "Pathway or network prediction"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_1662"
      },
      "definition": "A report typically including a map (diagram) of drug structure relationships.",
      "replacedBy": ["http://edamontology.org/data_1696"],
      "text": "Drug structure relationship map"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1512"
      },
      "definition": "Format of an entry from the BRENDA enzyme database.",
      "text": "BRENDA enzyme report format"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1610"
      },
      "definition": "Entry format of KEGG GENES genome database.",
      "text": "KEGG GENES gene report format"
    }, {
      "comment": ["This includes comparison, discovery, recognition etc. of sequence motifs."],
      "consider": ["http://edamontology.org/topic_0160"],
      "data": {
        "uri": "http://edamontology.org/topic_0598"
      },
      "definition": "Sequence motifs, or sequence profiles derived from an alignment of molecular sequences of a particular type.",
      "text": "Sequence motif or profile"
    }, {
      "consider": ["http://edamontology.org/data_3106"],
      "data": {
        "uri": "http://edamontology.org/data_0959"
      },
      "definition": "Textual metadata on a submitted or completed job.",
      "text": "Job metadata"
    }, {
      "comment": ["The Burrows-Wheeler Transform (BWT) is a permutation of the genome based on a suffix array algorithm."],
      "data": {
        "uri": "http://edamontology.org/operation_3212"
      },
      "definition": "Generate an index of a genome sequence using the Burrows-Wheeler algorithm.",
      "replacedBy": ["http://edamontology.org/operation_3211"],
      "text": "Genome indexing (Burrows-Wheeler)"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_1555"
      },
      "definition": "An EMBASSY domain classification file (DCF) of classification and other data for domains from SCOP or CATH, in EMBL-like format.",
      "replacedBy": ["http://edamontology.org/data_0907"],
      "text": "EMBASSY domain classification"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_1325"
      },
      "definition": "catalytic residues (active site) of an enzyme.",
      "replacedBy": ["http://edamontology.org/data_1277"],
      "text": "Protein features report (active sites)"
    }, {
      "consider": ["http://edamontology.org/data_0962"],
      "data": {
        "uri": "http://edamontology.org/data_2726"
      },
      "definition": "An informative report on one or more small molecules that are enzyme inhibitors.",
      "text": "Inhibitor annotation"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1651"
      },
      "definition": "The format of an entry from the PATIKA biological pathways database.",
      "text": "PATIKA entry format"
    }, {
      "consider": ["http://edamontology.org/format_2036"],
      "data": {
        "uri": "http://edamontology.org/format_1431"
      },
      "definition": "Format of phylogenetic property data.",
      "text": "Phylogenetic property values format"
    }, {
      "consider": ["http://edamontology.org/data_2048"],
      "data": {
        "uri": "http://edamontology.org/data_2768"
      },
      "definition": "Annotation about a gene symbol.",
      "text": "Gene symbol annotation"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_3087"
      },
      "definition": "Predict, recognise and identify functional or other key sites within protein sequences, typically by scanning for known motifs, patterns and regular expressions.",
      "replacedBy": ["http://edamontology.org/operation_3092"],
      "text": "Protein sequence feature detection"
    }, {
      "consider": ["http://edamontology.org/operation_2422"],
      "data": {
        "uri": "http://edamontology.org/operation_0225"
      },
      "definition": "Search database to retrieve all relevant references to a particular entity or entry.",
      "text": "Data retrieval (database cross-reference)"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_3531"
      },
      "definition": "Super-secondary structure of protein sequence(s).",
      "replacedBy": ["http://edamontology.org/topic_3542"],
      "text": "Protein super-secondary structure"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1702"
      },
      "definition": "The format of an entry from a database of chemical structures and property predictions.",
      "text": "ChemSpider entry format"
    }, {
      "consider": ["http://edamontology.org/data_1537"],
      "data": {
        "uri": "http://edamontology.org/data_1550"
      },
      "definition": "Non-canonical atomic interactions in protein structures.",
      "text": "Protein non-canonical interactions"
    }, {
      "consider": ["http://edamontology.org/data_2865"],
      "data": {
        "uri": "http://edamontology.org/data_1599"
      },
      "definition": "A simple measure of synonymous codon usage bias often used to predict gene expression levels.",
      "text": "Codon adaptation index"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_1661"
      },
      "definition": "disease pathways, typically of human disease.",
      "replacedBy": ["http://edamontology.org/data_0906"],
      "text": "Disease pathway or network report"
    }, {
      "consider": ["http://edamontology.org/data_2610"],
      "data": {
        "uri": "http://edamontology.org/data_2696"
      },
      "definition": "Identifier of an entry (exon, gene, transcript or protein) from the Ensembl 'core' database ('Spermophilus tridecemlineatus' division).",
      "text": "Ensembl ID ('Spermophilus tridecemlineatus')"
    }, {
      "consider": ["http://edamontology.org/data_0916"],
      "data": {
        "uri": "http://edamontology.org/data_2883"
      },
      "definition": "Features concerning RNA or regions of DNA that encode an RNA molecule.",
      "text": "RNA features report"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_2277"
      },
      "definition": "Single nucleotide polymorphisms (SNP) and associated data, for example, the discovery and annotation of SNPs.",
      "replacedBy": ["http://edamontology.org/topic_2885"],
      "text": "SNP"
    }, {
      "comment": ["Use this concept for methods that are exclusively for protein structure."],
      "data": {
        "uri": "http://edamontology.org/topic_0143"
      },
      "definition": "The comparison of two or more protein structures.",
      "replacedBy": ["http://edamontology.org/topic_0081"],
      "text": "Protein structure comparison"
    }, {
      "consider": ["http://edamontology.org/data_0850"],
      "data": {
        "uri": "http://edamontology.org/data_1242"
      },
      "definition": "A library of nucleotide sequences to avoid during hybridisation events. Hybridisation of the internal oligo to sequences in this library is avoided, rather than priming from them. The file is in a restricted FASTA format.",
      "text": "Primer3 internal oligo mishybridizing library"
    }, {
      "consider": ["http://edamontology.org/operation_2495"],
      "data": {
        "uri": "http://edamontology.org/operation_0530"
      },
      "definition": "Process (read and / or write) sequencing by synthesis (SBS) data.",
      "text": "SBS data processing"
    }, {
      "consider": ["http://edamontology.org/operation_0319"],
      "data": {
        "uri": "http://edamontology.org/operation_1847"
      },
      "definition": "Determine for residue the DSSP determined secondary structure in three-state (HSC).",
      "text": "DSSP secondary structure assignment"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_0918"
      },
      "definition": "stable, naturally occuring mutations in a nucleotide sequence including alleles, naturally occurring mutations such as single base nucleotide substitutions, deletions and insertions, RFLPs and other polymorphisms.",
      "replacedBy": ["http://edamontology.org/data_1276"],
      "text": "DNA variation"
    }, {
      "consider": ["http://edamontology.org/format_2921"],
      "data": {
        "uri": "http://edamontology.org/format_2051"
      },
      "definition": "Format for sequence polymorphism data.",
      "text": "Polymorphism report format"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0273"
      },
      "definition": "Analyse experimental protein-protein interaction data from for example yeast two-hybrid analysis, protein microarrays, immunoaffinity chromatography followed by mass spectrometry, phage display etc.",
      "replacedBy": ["http://edamontology.org/operation_2949"],
      "text": "Protein interaction raw data analysis"
    }, {
      "consider": ["http://edamontology.org/topic_0121"],
      "data": {
        "uri": "http://edamontology.org/topic_0767"
      },
      "definition": "Protein and peptide identification",
      "text": "Protein and peptide identification"
    }, {
      "consider": ["http://edamontology.org/data_0907"],
      "data": {
        "uri": "http://edamontology.org/data_1560"
      },
      "definition": "Information on a protein 'structurally similar group' node from the CATH database.",
      "text": "CATH structurally similar group"
    }, {
      "consider": ["http://edamontology.org/data_2523"],
      "data": {
        "uri": "http://edamontology.org/data_1440"
      },
      "definition": "Data about the shape of a phylogenetic tree.",
      "text": "Phylogenetic tree report (tree shape)"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_0640"
      },
      "definition": "The archival, processing and analysis of nucleotide sequences and and sequence-based entities such as alignments, motifs and profiles.",
      "replacedBy": ["http://edamontology.org/topic_0080"],
      "text": "Nucleic acid sequence analysis"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_2869"
      },
      "definition": "Restriction fragment length polymorphisms (RFLP) in a DNA sequence.",
      "replacedBy": ["http://edamontology.org/topic_2885"],
      "text": "RFLP"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_2961"
      },
      "definition": "A report typically including a map (diagram) of a gene regulatory network.",
      "replacedBy": ["http://edamontology.org/data_2984"],
      "text": "Gene regulatory network report"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_1309"
      },
      "definition": "A report on exonic splicing enhancers (ESE) in an exon.",
      "replacedBy": ["http://edamontology.org/data_1276"],
      "text": "Gene features (exonic splicing enhancer)"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0561"
      },
      "definition": "Reformat (a file or other report of) molecular sequence(s).",
      "replacedBy": ["http://edamontology.org/operation_0335"],
      "text": "Sequence formatting"
    }, {
      "consider": ["http://edamontology.org/data_1449"],
      "data": {
        "uri": "http://edamontology.org/data_1452"
      },
      "definition": "Matrix of integer numbers for amino acid comparison.",
      "text": "Amino acid comparison matrix (integers)"
    }, {
      "consider": ["http://edamontology.org/data_0006"],
      "data": {
        "uri": "http://edamontology.org/data_2156"
      },
      "definition": "A temporal date.",
      "text": "Date"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0316"
      },
      "definition": "Interpret (in functional terms) and annotate gene expression data.",
      "replacedBy": ["http://edamontology.org/operation_2495"],
      "text": "Functional profiling"
    }, {
      "consider": ["http://edamontology.org/operation_2416"],
      "data": {
        "uri": "http://edamontology.org/operation_2444"
      },
      "definition": "Process (read and / or write) protein secondary structure data.",
      "text": "Protein secondary structure processing"
    }, {
      "comment": ["For example, identify full-length cDNAs from EST sequences or detect potential EST antisense transcripts."],
      "consider": ["http://edamontology.org/operation_2403"],
      "data": {
        "uri": "http://edamontology.org/operation_0317"
      },
      "definition": "Analyse EST or cDNA sequences.",
      "text": "EST and cDNA sequence analysis"
    }, {
      "comment": ["This is a broad data type and is used a placeholder for other, more specific types."],
      "consider": ["http://edamontology.org/data_3148"],
      "data": {
        "uri": "http://edamontology.org/data_2986"
      },
      "definition": "Data concerning the classification of nucleic acid sequences or structures.",
      "text": "Nucleic acid classification"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_2963"
      },
      "definition": "Generate a codon usage bias plot.",
      "replacedBy": ["http://edamontology.org/operation_2962"],
      "text": "Codon usage bias plotting"
    }, {
      "consider": ["http://edamontology.org/data_0006"],
      "data": {
        "uri": "http://edamontology.org/data_2151"
      },
      "definition": "Specification of one or more colors.",
      "text": "Color"
    }, {
      "consider": ["http://edamontology.org/operation_0292", "http://edamontology.org/operation_0300"],
      "data": {
        "uri": "http://edamontology.org/operation_0512"
      },
      "definition": "Align two or more molecular profiles.",
      "text": "Sequence alignment generation (multiple profile)"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_1835"
      },
      "definition": "Calculate ion contacts in a structure (all ions for all side chain atoms).",
      "replacedBy": ["http://edamontology.org/operation_2950"],
      "text": "Residue contact calculation (residue-negative ion)"
    }, {
      "consider": ["http://edamontology.org/operation_2409"],
      "data": {
        "uri": "http://edamontology.org/operation_2122"
      },
      "definition": "Perform basic (non-analytical) operations on a sequence alignment file, such as copying or removal and ordering of sequences.",
      "text": "Sequence alignment file processing"
    }, {
      "consider": ["http://edamontology.org/data_2534"],
      "data": {
        "uri": "http://edamontology.org/data_2336"
      },
      "definition": "Phase for translation of DNA (0, 1 or 2) relative to a fragment of the coding sequence.",
      "text": "Translation phase specification"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1608"
      },
      "definition": "Entry format of FlyBase genome database.",
      "text": "FlyBase gene report format"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_0901"
      },
      "definition": "structural domains or 3D folds in a protein or polypeptide chain.",
      "replacedBy": ["http://edamontology.org/data_1277"],
      "text": "Protein features report (domains)"
    }, {
      "consider": ["http://edamontology.org/topic_0128"],
      "data": {
        "uri": "http://edamontology.org/topic_0149"
      },
      "definition": "Protein-DNA/RNA interactions.",
      "text": "Protein-nucleic acid interactions"
    }, {
      "comment": ["Word size is used for example in word-based sequence database search methods."],
      "consider": ["http://edamontology.org/data_1249"],
      "data": {
        "uri": "http://edamontology.org/data_1250"
      },
      "definition": "Size of a sequence word.",
      "text": "Word size"
    }, {
      "consider": ["http://edamontology.org/data_1261"],
      "data": {
        "uri": "http://edamontology.org/data_1264"
      },
      "definition": "A table of character or word composition / frequency of a molecular sequence.",
      "text": "Sequence composition table"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_1313"
      },
      "definition": "protein-coding regions including coding sequences (CDS), exons, translation initiation sites and open reading frames.",
      "replacedBy": ["http://edamontology.org/data_1276"],
      "text": "Coding region"
    }, {
      "consider": ["http://edamontology.org/operation_0253"],
      "data": {
        "uri": "http://edamontology.org/operation_0341"
      },
      "definition": "Screen a sequence against a motif or pattern database.",
      "text": "Motif database search"
    }, {
      "consider": ["http://edamontology.org/topic_0621"],
      "data": {
        "uri": "http://edamontology.org/topic_0215"
      },
      "definition": "Information on a specific worm genome including molecular sequences, genes and annotation.",
      "text": "Worms"
    }, {
      "consider": ["http://edamontology.org/data_1086"],
      "data": {
        "uri": "http://edamontology.org/data_0986"
      },
      "definition": "Unique identifier of a chemical compound.",
      "text": "Chemical identifier"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_3289"
      },
      "definition": "Search for and retrieve a data identifier of some kind, e.g. a database entry accession.",
      "replacedBy": ["http://edamontology.org/operation_2422"],
      "text": "ID retrieval"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_0754"
      },
      "definition": "Signaling pathways.",
      "replacedBy": ["http://edamontology.org/topic_0602"],
      "text": "Signaling pathways"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1648"
      },
      "definition": "The format of an entry from the MetaCyc metabolic pathways database.",
      "text": "MetaCyc entry format"
    }, {
      "consider": ["http://edamontology.org/data_0850"],
      "data": {
        "uri": "http://edamontology.org/data_1244"
      },
      "definition": "File of one or more pairs of primer sequences, as used by EMBOSS primersearch application.",
      "text": "primersearch primer pairs sequence record"
    }, {
      "comment": ["This might involve comparison of secondary or tertiary (3D) structural information."],
      "data": {
        "uri": "http://edamontology.org/topic_1770"
      },
      "definition": "The comparison of two or more molecular structures, for example structure alignment and clustering.",
      "replacedBy": ["http://edamontology.org/topic_0081"],
      "text": "Structure comparison"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_2402"
      },
      "definition": "An informative report on tentative or known protein-drug interaction(s).",
      "replacedBy": ["http://edamontology.org/data_1566"],
      "text": "Protein-drug interaction report"
    }, {
      "comment": ["Global alignment methods identify similarity across the entire length of the sequences."],
      "consider": ["http://edamontology.org/operation_0496", "http://edamontology.org/operation_0491"],
      "data": {
        "uri": "http://edamontology.org/operation_0494"
      },
      "definition": "Globally align exactly two molecular sequences.",
      "text": "Pairwise sequence alignment generation (global)"
    }, {
      "consider": ["http://edamontology.org/data_2337"],
      "data": {
        "uri": "http://edamontology.org/data_0005"
      },
      "definition": "A type of computational resource used in bioinformatics.",
      "text": "Resource type"
    }, {
      "consider": ["http://edamontology.org/data_2610"],
      "data": {
        "uri": "http://edamontology.org/data_2693"
      },
      "definition": "Identifier of an entry (exon, gene, transcript or protein) from the Ensembl 'core' database ('Otolemur garnettii' division).",
      "text": "Ensembl ID ('Otolemur garnettii')"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_1101"
      },
      "definition": "Identifier of a TREMBL sequence database entry.",
      "replacedBy": ["http://edamontology.org/data_3021"],
      "text": "TREMBL accession"
    }, {
      "consider": ["http://edamontology.org/data_1027"],
      "data": {
        "uri": "http://edamontology.org/data_1030"
      },
      "definition": "An Entrez unique identifier of a gene.",
      "text": "Gene identifier (Entrez)"
    }, {
      "consider": ["http://edamontology.org/operation_0483"],
      "data": {
        "uri": "http://edamontology.org/operation_1768"
      },
      "definition": "Identify folding families of related RNAs.",
      "text": "Nucleic acid folding family identification"
    }, {
      "consider": ["http://edamontology.org/data_1246"],
      "data": {
        "uri": "http://edamontology.org/data_2198"
      },
      "definition": "A cluster of similar genes.",
      "text": "Gene cluster"
    }, {
      "consider": ["http://edamontology.org/data_1398"],
      "data": {
        "uri": "http://edamontology.org/data_1407"
      },
      "definition": "A simple floating point number defining the penalty for extending a gap in an alignment.",
      "text": "Gap extension penalty (float)"
    }, {
      "comment": ["Use this concepts for tools which retrieve pre-existing annotations, not for example prediction methods that might make annotations."],
      "consider": ["http://edamontology.org/operation_2422"],
      "data": {
        "uri": "http://edamontology.org/operation_1774"
      },
      "definition": "Retrieve existing annotation (or documentation), typically annotation on a database entity.",
      "text": "Annotation retrieval"
    }, {
      "comment": ["A QTL sometimes but does not necessarily correspond to a gene."],
      "consider": ["http://edamontology.org/data_2012"],
      "data": {
        "uri": "http://edamontology.org/data_1906"
      },
      "definition": "A stretch of DNA that is closely linked to the genes underlying a quantitative trait (a phenotype that varies in degree and depends upon the interactions between multiple genes and their environment).",
      "text": "Quantitative trait locus"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1619"
      },
      "definition": "Entry format of the TIGR genome database.",
      "text": "TIGR gene report format"
    }, {
      "comment": ["The resource may be specific to a vertebrate, a group of vertebrates or all vertebrates."],
      "consider": ["http://edamontology.org/topic_0621"],
      "data": {
        "uri": "http://edamontology.org/topic_2820"
      },
      "definition": "Vertebrates, e.g. information on a specific vertebrate genome including molecular sequences, genes and annotation.",
      "text": "Vertebrates"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0537"
      },
      "definition": "Assign a protein tertiary structure (3D coordinates) from raw NMR spectroscopy data.",
      "replacedBy": ["http://edamontology.org/operation_0320"],
      "text": "Protein structure assignment (from NMR data)"
    }, {
      "consider": ["http://edamontology.org/data_0858"],
      "data": {
        "uri": "http://edamontology.org/data_1420"
      },
      "definition": "Alignment of molecular sequences to a protein fingerprint from the PRINTS database.",
      "text": "Sequence-profile alignment (fingerprint)"
    }, {
      "comment": ["Waters are not considered."],
      "data": {
        "uri": "http://edamontology.org/operation_1818"
      },
      "definition": "Calculate the solvent accessibility ('accessible molecular surface') for each atom in a structure.",
      "replacedBy": ["http://edamontology.org/operation_0387"],
      "text": "Protein atom surface calculation (accessible molecular)"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0242"
      },
      "definition": "Identify common, conserved (homologous) or synonymous transcriptional regulatory motifs (transcription factor binding sites).",
      "replacedBy": ["http://edamontology.org/operation_0438"],
      "text": "Conserved transcription regulatory sequence identification"
    }, {
      "consider": ["http://edamontology.org/topic_3307"],
      "data": {
        "uri": "http://edamontology.org/topic_0771"
      },
      "definition": "Theoretical biology",
      "text": "Theoretical biology"
    }, {
      "comment": ["Data Type is an enumerated string."],
      "consider": ["http://edamontology.org/data_2858"],
      "data": {
        "uri": "http://edamontology.org/data_1727"
      },
      "definition": "A term definition for a biological process from the Gene Ontology (GO).",
      "text": "GO (biological process)"
    }, {
      "consider": ["http://edamontology.org/format_1949"],
      "data": {
        "uri": "http://edamontology.org/format_1994"
      },
      "definition": "Nexus/paup format for (aligned) sequences.",
      "text": "nexus alignment format"
    }, {
      "consider": ["http://edamontology.org/data_2337"],
      "data": {
        "uri": "http://edamontology.org/data_2177"
      },
      "definition": "A single thing.",
      "text": "Exactly 1"
    }, {
      "consider": ["http://edamontology.org/topic_2229"],
      "data": {
        "uri": "http://edamontology.org/topic_0612"
      },
      "definition": "The cell cycle including key genes and proteins.",
      "text": "Cell cycle"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_2989"
      },
      "definition": "key residues involved in protein folding.",
      "replacedBy": ["http://edamontology.org/data_1277"],
      "text": "Protein features report (key folding sites)"
    }, {
      "consider": ["http://edamontology.org/data_1482", "http://edamontology.org/data_1479"],
      "data": {
        "uri": "http://edamontology.org/data_1491"
      },
      "definition": "Alignment (superimposition) of exactly two nucleic acid tertiary (3D) structures.",
      "text": "Structure alignment (nucleic acid pair)"
    }, {
      "consider": ["http://edamontology.org/data_1276"],
      "data": {
        "uri": "http://edamontology.org/data_2212"
      },
      "definition": "Information describing the mutation itself, the organ site, tissue and type of lesion where the mutation has been identified, description of the patient origin and life-style.",
      "text": "Mutation annotation (basic)"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1574"
      },
      "definition": "Entry format for the PRINTS protein secondary database.",
      "text": "PRINTS entry format"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1647"
      },
      "definition": "The format of an entry from the KEGG PATHWAY database of pathway maps for molecular interactions and reaction networks.",
      "text": "KEGG PATHWAY entry format"
    }, {
      "consider": ["http://edamontology.org/topic_0097"],
      "data": {
        "uri": "http://edamontology.org/topic_3039"
      },
      "definition": "Nucleic acid (secondary or tertiary) structure, such as whole structures, structural features and associated annotation.",
      "text": "Nucleic acid structure"
    }, {
      "consider": ["http://edamontology.org/data_1026"],
      "data": {
        "uri": "http://edamontology.org/data_2300"
      },
      "definition": "Name of an entry (gene) from the NCBI genes database.",
      "exact_synonyms": ["NCBI gene name"],
      "text": "Gene name (NCBI)"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_0639"
      },
      "definition": "Archival, processing and analysis of protein sequences and sequence-based entities such as alignments, motifs and profiles.",
      "replacedBy": ["http://edamontology.org/topic_0080"],
      "text": "Protein sequence analysis"
    }, {
      "comment": ["The comparison might be on the basis of sequence, physico-chemical or some other properties of the sequences."],
      "data": {
        "uri": "http://edamontology.org/topic_0159"
      },
      "definition": "The comparison of two or more molecular sequences, for example sequence alignment and clustering.",
      "replacedBy": ["http://edamontology.org/topic_0080"],
      "text": "Sequence comparison"
    }, {
      "consider": ["http://edamontology.org/topic_2229"],
      "data": {
        "uri": "http://edamontology.org/topic_0779"
      },
      "definition": "Mitochondria, typically of mitochondrial genes and proteins.",
      "text": "Mitochondria"
    }, {
      "consider": ["http://edamontology.org/data_0858"],
      "data": {
        "uri": "http://edamontology.org/data_1418"
      },
      "definition": "Alignment of molecular sequence(s) to a hidden Markov model(s).",
      "text": "Sequence-profile alignment (HMM)"
    }, {
      "consider": ["http://edamontology.org/data_0920"],
      "data": {
        "uri": "http://edamontology.org/data_2602"
      },
      "definition": "Data concerning a particular genotype, phenotype or a genotype / phenotype relation.",
      "text": "Genotype and phenotype data"
    }, {
      "consider": ["http://edamontology.org/topic_0080"],
      "data": {
        "uri": "http://edamontology.org/topic_3042"
      },
      "definition": "Nucleotide sequences and associated concepts such as sequence sites, alignments, motifs and profiles.",
      "text": "Nucleic acid sequences"
    }, {
      "consider": ["http://edamontology.org/data_0907"],
      "data": {
        "uri": "http://edamontology.org/data_3144"
      },
      "definition": "Information on a 'family' node from the SCOP database.",
      "text": "SCOP family"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_3521"
      },
      "definition": "Two-dimensional gel electrophoresis experiments, gels or spots in a gel.",
      "replacedBy": ["http://edamontology.org/topic_3520"],
      "text": "2D PAGE experiment"
    }, {
      "consider": ["http://edamontology.org/operation_2495"],
      "data": {
        "uri": "http://edamontology.org/operation_2498"
      },
      "definition": "Analyse SAGE, MPSS or SBS experimental data, typically to identify or quantify mRNA transcripts.",
      "text": "Sequencing-based expression profile data analysis"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_3543"
      },
      "definition": "Short repetitive subsequences (repeat sequences) in a protein sequence.",
      "replacedBy": ["http://edamontology.org/topic_0157"],
      "text": "Protein sequence repeats"
    }, {
      "comment": ["For functional properties that are positional, use 'Protein site detection' instead."],
      "consider": ["http://edamontology.org/operation_1777"],
      "data": {
        "uri": "http://edamontology.org/operation_3084"
      },
      "definition": "Predict general (non-positional) functional properties of a protein from analysing its sequence.",
      "text": "Protein function prediction (from sequence)"
    }, {
      "consider": ["http://edamontology.org/data_1056"],
      "data": {
        "uri": "http://edamontology.org/data_1057"
      },
      "definition": "The name of a molecular sequence database.",
      "text": "Sequence database name"
    }, {
      "comment": ["The sequence(s) might be screened against InterPro, or be the sequences from the InterPro entry itself. Each protein is represented as a scaled horizontal line with colored bars indicating the position of the matches."],
      "data": {
        "uri": "http://edamontology.org/data_1290"
      },
      "definition": "Image showing matches between protein sequence(s) and InterPro Entries.",
      "replacedBy": ["http://edamontology.org/data_2969"],
      "text": "InterPro compact match image"
    }, {
      "comment": ["The resource may be specific to a pathogen, a group of pathogens or all pathogens."],
      "consider": ["http://edamontology.org/topic_0621"],
      "data": {
        "uri": "http://edamontology.org/topic_0783"
      },
      "definition": "Pathogens, e.g. information on a specific vertebrate genome including molecular sequences, genes and annotation.",
      "text": "Pathogens"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_2329"
      },
      "definition": "Format of a report on a gene from the GeneCards database.",
      "text": "GeneCards gene report format"
    }, {
      "consider": ["http://edamontology.org/data_1104"],
      "data": {
        "uri": "http://edamontology.org/data_1029"
      },
      "definition": "An NCBI UniGene unique identifier of a gene.",
      "text": "Gene identifier (NCBI UniGene)"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1645"
      },
      "definition": "Format of an entry from the Electron Microscopy DataBase (EMDB).",
      "text": "EMDB entry format"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1612"
      },
      "definition": "Entry format of the Mouse Genome Database (MGD).",
      "text": "MGD gene report format"
    }, {
      "consider": ["http://edamontology.org/data_1016"],
      "data": {
        "uri": "http://edamontology.org/data_1014"
      },
      "definition": "A specification (partial or complete) of one or more positions or regions of a molecular sequence or map.",
      "text": "Sequence position specification"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_1848"
      },
      "definition": "Reformat (a file or other report of) tertiary structure data.",
      "replacedBy": ["http://edamontology.org/operation_0335"],
      "text": "Structure formatting"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_1660"
      },
      "definition": "Topic concernning cellular process pathways.",
      "replacedBy": ["http://edamontology.org/data_2984"],
      "text": "Cellular process pathways report"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_3102"
      },
      "definition": "Unique numerical identifier of chemicals in the scientific literature, as assigned by the Chemical Abstracts Service.",
      "replacedBy": ["http://edamontology.org/data_1002"],
      "text": "CAS number"
    }, {
      "consider": ["http://edamontology.org/data_2610"],
      "data": {
        "uri": "http://edamontology.org/data_2692"
      },
      "definition": "Identifier of an entry (exon, gene, transcript or protein) from the Ensembl 'core' database ('Oryzias latipes' division).",
      "text": "Ensembl ID ('Oryzias latipes')"
    }, {
      "consider": ["http://edamontology.org/data_1115"],
      "data": {
        "uri": "http://edamontology.org/data_2150"
      },
      "definition": "Name of a sequence profile.",
      "text": "Sequence profile name"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_2508"
      },
      "definition": "Compare two or more nucleic acid sequences.",
      "replacedBy": ["http://edamontology.org/operation_2451"],
      "text": "Nucleic acid sequence comparison"
    }, {
      "consider": ["http://edamontology.org/data_2048"],
      "data": {
        "uri": "http://edamontology.org/data_1680"
      },
      "definition": "STRIDE log file.",
      "text": "STRIDE log file"
    }, {
      "consider": ["http://edamontology.org/data_0867"],
      "data": {
        "uri": "http://edamontology.org/data_1416"
      },
      "definition": "Data on correlations between sites in a molecular sequence alignment, typically to identify possible covarying positions and predict contacts or structural constraints in protein structures.",
      "text": "Sequence alignment report (site correlation)"
    }, {
      "comment": ["The sequence(s) might be screened against InterPro, or be the sequences from the InterPro entry itself."],
      "data": {
        "uri": "http://edamontology.org/data_1291"
      },
      "definition": "Image showing detailed information on matches between protein sequence(s) and InterPro Entries.",
      "replacedBy": ["http://edamontology.org/data_2969"],
      "text": "InterPro detailed match image"
    }, {
      "consider": ["http://edamontology.org/topic_0128"],
      "data": {
        "uri": "http://edamontology.org/topic_3044"
      },
      "definition": "Protein interaction networks",
      "text": "Protein interaction networks"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_2303"
      },
      "definition": "Entry format (HTML) for the STRING database of protein interaction.",
      "text": "STRING entry format (HTML)"
    }, {
      "consider": ["http://edamontology.org/operation_0295", "http://edamontology.org/operation_0294", "http://edamontology.org/operation_0504"],
      "data": {
        "uri": "http://edamontology.org/operation_0514"
      },
      "definition": "Align two or more molecular 3D profiles.",
      "text": "Structural profile alignment generation (multiple)"
    }, {
      "consider": ["http://edamontology.org/data_2865"],
      "data": {
        "uri": "http://edamontology.org/data_1601"
      },
      "definition": "The effective number of codons used in a gene sequence.  This reflects how far codon usage of a gene departs from equal usage of synonymous codons.",
      "text": "Nc statistic"
    }, {
      "consider": ["http://edamontology.org/data_0907"],
      "data": {
        "uri": "http://edamontology.org/data_1556"
      },
      "definition": "Information on a protein 'class' node from the CATH database.",
      "text": "CATH class"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0412"
      },
      "definition": "Detect or predict signal peptides (and typically predict subcellular localisation) of bacterial proteins.",
      "replacedBy": ["http://edamontology.org/operation_0418"],
      "text": "Protein signal peptide detection (bacteria)"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_0174"
      },
      "definition": "The prediction of three-dimensional structure of a (typically protein) sequence from first principles, using a physics-based or empirical scoring function and without using explicit structural templates.",
      "replacedBy": ["http://edamontology.org/topic_0082"],
      "text": "Ab initio structure prediction"
    }, {
      "consider": ["http://edamontology.org/data_0842"],
      "data": {
        "uri": "http://edamontology.org/data_2100"
      },
      "definition": "A label (text token) describing the type of a thing, typically an enumerated string (a string with one of a limited set of values).",
      "text": "Type"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_1565"
      },
      "definition": "protein-protein interaction(s), including interactions between protein domains.",
      "replacedBy": ["http://edamontology.org/data_0906"],
      "text": "Protein-protein interaction report"
    }, {
      "consider": ["http://edamontology.org/data_2535"],
      "data": {
        "uri": "http://edamontology.org/data_0935"
      },
      "definition": "Sequencing by synthesis (SBS) data.",
      "text": "SBS experimental data"
    }, {
      "consider": ["http://edamontology.org/format_1915"],
      "data": {
        "uri": "http://edamontology.org/format_2210"
      },
      "definition": "Format of a report on organism strain data / cell line.",
      "text": "Strain data format"
    }, {
      "data": {
        "uri": "http://edamontology.org/format_2202"
      },
      "definition": "Data format for a molecular sequence record, typically corresponding to a full entry from a molecular sequence database.",
      "replacedBy": ["http://edamontology.org/format_1919"],
      "text": "Sequence record full format"
    }, {
      "consider": ["http://edamontology.org/operation_2422"],
      "data": {
        "uri": "http://edamontology.org/operation_0516"
      },
      "definition": "Search and retrieve names of or documentation on bioinformatics databases or query terms, for example by keyword.",
      "text": "Data retrieval (database metadata)"
    }, {
      "consider": ["http://edamontology.org/data_1364"],
      "data": {
        "uri": "http://edamontology.org/data_1371"
      },
      "definition": "NULL hidden Markov model representation used by the HMMER package.",
      "text": "HMMER NULL hidden Markov model"
    }, {
      "consider": ["http://edamontology.org/topic_0114"],
      "data": {
        "uri": "http://edamontology.org/topic_3062"
      },
      "definition": "The structural and functional organisation of genes and other genetic elements.",
      "text": "Genetic organisation"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_2888"
      },
      "definition": "A protein sequence and comprehensive metadata (such as a feature table), typically corresponding to a full entry from a molecular sequence database.",
      "replacedBy": ["http://edamontology.org/data_0849"],
      "text": "Protein sequence record (full)"
    }, {
      "consider": ["http://edamontology.org/data_1035"],
      "data": {
        "uri": "http://edamontology.org/data_1800"
      },
      "definition": "Gene identifier from Schizosaccharomyces pombe GeneDB database.",
      "text": "Gene ID (GeneDB Schizosaccharomyces pombe)"
    }, {
      "comment": ["This is a broad data type and is used a placeholder for other, more specific types."],
      "consider": ["http://edamontology.org/data_2048"],
      "data": {
        "uri": "http://edamontology.org/data_2018"
      },
      "definition": "A human-readable collection of information which (typically) is generated or collated by hand and which describes a biological entity, phenomena or associated primary (e.g. sequence or structural) data, as distinct from the primary data itself and computer-generated reports derived from it.",
      "text": "Annotation"
    }, {
      "consider": ["http://edamontology.org/data_0886"],
      "data": {
        "uri": "http://edamontology.org/data_1480"
      },
      "definition": "Alignment (superimposition) of more than two molecular tertiary (3D) structures.",
      "text": "Structure alignment (multiple)"
    }, {
      "comment": ["The report (for example http://www.cathdb.info/domain/1cukA01) includes CATH codes for levels in the hierarchy for the domain, level descriptions and relevant data and links."],
      "consider": ["http://edamontology.org/data_0907"],
      "data": {
        "uri": "http://edamontology.org/data_1762"
      },
      "definition": "Summary of domain classification information for a CATH domain.",
      "text": "CATH domain report"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1568"
      },
      "definition": "Entry format for the BIND database of protein interaction.",
      "text": "BIND entry format"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_1301"
      },
      "definition": "regions of a nucleic acid sequence containing mobile genetic elements.",
      "replacedBy": ["http://edamontology.org/data_1276"],
      "text": "Mobile genetic elements"
    }, {
      "comment": ["A UniGene entry includes a set of transcript sequences assigned to the same transcription locus (gene or expressed pseudogene), with information on protein similarities, gene expression, cDNA clone reagents, and genomic location."],
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1228"
      },
      "definition": "Format of an entry from UniGene.",
      "text": "UniGene entry format"
    }, {
      "consider": ["http://edamontology.org/data_1097"],
      "data": {
        "uri": "http://edamontology.org/data_2289"
      },
      "definition": "An identifier of nucleotide sequence(s) or nucleotide sequence database entries.",
      "text": "Sequence identifier (nucleic acid)"
    }, {
      "consider": ["http://edamontology.org/data_2610"],
      "data": {
        "uri": "http://edamontology.org/data_2671"
      },
      "definition": "Identifier of an entry (exon, gene, transcript or protein) from the Ensembl 'core' database (Homo sapiens division).",
      "text": "Ensembl ID (Homo sapiens)"
    }, {
      "consider": ["http://edamontology.org/data_0966"],
      "data": {
        "uri": "http://edamontology.org/data_1717"
      },
      "definition": "A term from the MeSH vocabulary.",
      "text": "MeSH"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_0581"
      },
      "definition": "A digital data archive typically based around a relational model but sometimes using an object-oriented, tree or graph-based model.",
      "replacedBy": ["http://edamontology.org/data_0957"],
      "text": "Database"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_2809"
      },
      "definition": "A general area of bioinformatics study, typically the broad scope or category of content of a bioinformatics journal or conference proceeding.",
      "replacedBy": ["http://edamontology.org/topic_0003"],
      "text": "Study topic"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_2754"
      },
      "definition": "Introns in a nucleotide sequences.",
      "replacedBy": ["http://edamontology.org/topic_3512"],
      "text": "Introns"
    }, {
      "consider": ["http://edamontology.org/data_0966"],
      "data": {
        "uri": "http://edamontology.org/data_1720"
      },
      "definition": "A term from the Plant Ontology (PO).",
      "text": "Plant ontology term"
    }, {
      "consider": ["http://edamontology.org/operation_0291"],
      "data": {
        "uri": "http://edamontology.org/operation_2452"
      },
      "definition": "Process (read and / or write) a sequence cluster.",
      "text": "Sequence cluster processing"
    }, {
      "consider": ["http://edamontology.org/data_1883"],
      "data": {
        "uri": "http://edamontology.org/data_2875"
      },
      "definition": "An entry (resource) from the DRCAT bioinformatics resource catalogue.",
      "text": "DRCAT resource"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0568"
      },
      "definition": "Visualise RNA secondary structure, knots, pseudoknots etc.",
      "replacedBy": ["http://edamontology.org/operation_0570"],
      "text": "RNA secondary structure visualisation"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1572"
      },
      "definition": "Entry format for the Gene3D protein secondary database.",
      "text": "Gene3D entry format"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_2846"
      },
      "definition": "Gene regulatory networks.",
      "replacedBy": ["http://edamontology.org/topic_0602"],
      "text": "Gene regulatory networks"
    }, {
      "consider": ["http://edamontology.org/operation_0338"],
      "data": {
        "uri": "http://edamontology.org/operation_0348"
      },
      "definition": "Search a sequence database and retrieve sequences of a given amino acid composition.",
      "text": "Sequence database search (by amino acid composition)"
    }, {
      "comment": ["A symmetry contact is a contact between two atoms in different asymmetric unit."],
      "data": {
        "uri": "http://edamontology.org/operation_1837"
      },
      "definition": "Calculate the number of symmetry contacts made by residues in a protein structure.",
      "replacedBy": ["http://edamontology.org/operation_2950"],
      "text": "Residue symmetry contact calculation"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_2420"
      },
      "definition": "Process (read and / or write) data of a specific type, for example applying analytical methods.",
      "replacedBy": ["http://edamontology.org/operation_2945"],
      "text": "Operation (typed)"
    }, {
      "consider": ["http://edamontology.org/topic_0621"],
      "data": {
        "uri": "http://edamontology.org/topic_2817"
      },
      "definition": "Yeast, e.g. information on a specific yeast genome including molecular sequences, genes and annotation.",
      "text": "Yeast"
    }, {
      "consider": ["http://edamontology.org/data_1026"],
      "data": {
        "uri": "http://edamontology.org/data_1890"
      },
      "definition": "A unique identifier for an Arabidopsis gene, which is an acronym or abbreviation of the gene name.",
      "text": "Gene name (Arabidopsis)"
    }, {
      "consider": ["http://edamontology.org/data_1276"],
      "data": {
        "uri": "http://edamontology.org/data_2213"
      },
      "definition": "An informative report on the prevalence of mutation(s), including data on samples and mutation prevalence (e.g. by tumour type)..",
      "text": "Mutation annotation (prevalence)"
    }, {
      "consider": ["http://edamontology.org/operation_0306", "http://edamontology.org/operation_3778"],
      "data": {
        "uri": "http://edamontology.org/operation_2947"
      },
      "definition": "Analyse a body of scientific text (typically a full text article from a scientific journal.)",
      "text": "Article analysis"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0562"
      },
      "definition": "Reformat (a file or other report of) molecular sequence alignment(s).",
      "replacedBy": ["http://edamontology.org/operation_0335"],
      "text": "Sequence alignment formatting"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_2661"
      },
      "definition": "Structural and associated data for toxic chemical substances.",
      "replacedBy": ["http://edamontology.org/topic_0154"],
      "text": "Toxins and targets"
    }, {
      "comment": ["This is a broad data type and is used a placeholder for other, more specific types."],
      "consider": ["http://edamontology.org/data_0955"],
      "data": {
        "uri": "http://edamontology.org/data_2540"
      },
      "definition": "Data concerning an index of data.",
      "text": "Data index data"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_2459"
      },
      "definition": "Process (read and / or write) a protein tertiary structure.",
      "replacedBy": ["http://edamontology.org/operation_2406"],
      "text": "Structure processing (protein)"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_0172"
      },
      "definition": "The prediction, modelling, recognition or design of protein secondary or tertiary structure or other structural features.",
      "replacedBy": ["http://edamontology.org/topic_0082"],
      "text": "Protein structure prediction"
    }, {
      "consider": ["http://edamontology.org/data_0957"],
      "data": {
        "uri": "http://edamontology.org/data_2748"
      },
      "definition": "The name of a subdivision of the Osteogenesis database.",
      "text": "Database name (Osteogenesis)"
    }, {
      "consider": ["http://edamontology.org/operation_0269"],
      "data": {
        "uri": "http://edamontology.org/operation_2457"
      },
      "definition": "Predict G-protein coupled receptor (GPCR) coupling selectivity.",
      "text": "GPCR coupling selectivity prediction"
    }, {
      "consider": ["http://edamontology.org/operation_2928"],
      "data": {
        "uri": "http://edamontology.org/operation_2946"
      },
      "definition": "Process or analyse an alignment of molecular sequences or structures.",
      "text": "Alignment analysis"
    }, {
      "consider": ["http://edamontology.org/data_1772"],
      "data": {
        "uri": "http://edamontology.org/data_2146"
      },
      "definition": "A value that serves as a threshold for a tool (usually to control scoring or output).",
      "text": "Threshold"
    }, {
      "consider": ["http://edamontology.org/data_0850"],
      "data": {
        "uri": "http://edamontology.org/data_1243"
      },
      "definition": "A nucleotide sequence library of sequences to avoid during amplification (for example repetitive sequences, or possibly the sequences of genes in a gene family that should not be amplified. The file must is in a restricted FASTA format.",
      "text": "Primer3 mispriming library file"
    }, {
      "consider": ["http://edamontology.org/topic_0203"],
      "data": {
        "uri": "http://edamontology.org/topic_0107"
      },
      "definition": "The study of codon usage in nucleotide sequence(s), genetic codes and so on.",
      "text": "Genetic codes and codon usage"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_2509"
      },
      "definition": "Compare two or more protein sequences.",
      "replacedBy": ["http://edamontology.org/operation_2451"],
      "text": "Protein sequence comparison"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_2397"
      },
      "definition": "Exons in a nucleotide sequences.",
      "replacedBy": ["http://edamontology.org/topic_3512"],
      "text": "Exons"
    }, {
      "consider": ["http://edamontology.org/data_0962"],
      "data": {
        "uri": "http://edamontology.org/data_0964"
      },
      "definition": "An informative report about a specific scent.",
      "text": "Scent annotation"
    }, {
      "consider": ["http://edamontology.org/data_3148"],
      "data": {
        "uri": "http://edamontology.org/data_3269"
      },
      "definition": "An informative report on gene homologues between species.",
      "text": "Gene homology (report)"
    }, {
      "comment": ["This includes the study of promoters, coding regions, splice sites, etc. Methods for gene prediction might be ab initio, based on phylogenetic comparisons, use motifs, sequence features, support vector machine, alignment etc."],
      "consider": ["http://edamontology.org/topic_0114"],
      "data": {
        "uri": "http://edamontology.org/topic_0109"
      },
      "definition": "Methods that aims to identify, predict, model or analyse genes or gene structure in DNA sequences.",
      "text": "Gene finding"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1782"
      },
      "definition": "Entry (gene) format of the NCBI database.",
      "text": "NCBI gene report format"
    }, {
      "comment": ["This is a broad data type and is used a placeholder for other, more specific types."],
      "consider": ["http://edamontology.org/data_2087"],
      "data": {
        "uri": "http://edamontology.org/data_2528"
      },
      "definition": "Data concerning a specific type of molecule.",
      "text": "Molecular data"
    }, {
      "consider": ["http://edamontology.org/topic_0121"],
      "data": {
        "uri": "http://edamontology.org/topic_0141"
      },
      "definition": "Enzyme or chemical cleavage sites and proteolytic or mass calculations on a protein sequence.",
      "text": "Protein cleavage sites and proteolysis"
    }, {
      "consider": ["http://edamontology.org/data_2984", "http://edamontology.org/data_2600"],
      "data": {
        "uri": "http://edamontology.org/data_2983"
      },
      "definition": "Data concerning a specific biological pathway or network.",
      "text": "Pathway or network data"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_0698"
      },
      "definition": "Protein tertiary structures.",
      "replacedBy": ["http://edamontology.org/topic_2814"],
      "text": "Protein tertiary structure"
    }, {
      "consider": ["http://edamontology.org/operation_2422"],
      "data": {
        "uri": "http://edamontology.org/operation_2470"
      },
      "definition": "Retrieve information on a protein family.",
      "text": "Data retrieval (protein family annotation)"
    }, {
      "comment": ["The significant and top-scoring hits for regions of the compared structures is shown. Data such as Z-Scores, number of aligned residues, root-mean-square deviation (RMSD) of atoms and sequence identity are given."],
      "consider": ["http://edamontology.org/data_0887"],
      "data": {
        "uri": "http://edamontology.org/data_1495"
      },
      "definition": "DaliLite hit table of protein chain tertiary structure alignment data.",
      "text": "DaliLite hit table"
    }, {
      "consider": ["http://edamontology.org/topic_0160"],
      "data": {
        "uri": "http://edamontology.org/topic_0158"
      },
      "definition": "Conserved patterns (motifs) in molecular sequences, that (typically) describe functional or other key sites.",
      "exact_synonyms": ["Motifs"],
      "text": "Sequence motifs"
    }, {
      "consider": ["http://edamontology.org/topic_0659"],
      "data": {
        "uri": "http://edamontology.org/topic_0660"
      },
      "definition": "One or more ribosomal RNA (rRNA) sequences.",
      "text": "rRNA"
    }, {
      "data": {
        "uri": "http://edamontology.org/format_2188"
      },
      "definition": "UniProt entry sequence format.",
      "replacedBy": ["http://edamontology.org/format_1963"],
      "text": "UniProt format"
    }, {
      "consider": ["http://edamontology.org/operation_2406", "http://edamontology.org/operation_2479"],
      "data": {
        "uri": "http://edamontology.org/operation_2502"
      },
      "definition": "Process (read and / or write) protein sequence or structural data.",
      "text": "Protein analysis"
    }, {
      "comment": ["Use this concept for methods that are exclusively for nucleic acid structures."],
      "consider": ["http://edamontology.org/topic_1770", "http://edamontology.org/topic_0097"],
      "data": {
        "uri": "http://edamontology.org/topic_2280"
      },
      "definition": "The comparison two or more nucleic acid (typically RNA) secondary or tertiary structures.",
      "text": "Nucleic acid structure comparison"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_3131"
      },
      "definition": "Report on the location of matches to profiles, motifs (conserved or functional patterns) or other signatures in one or more nucleic acid sequences.",
      "replacedBy": ["http://edamontology.org/data_0858"],
      "text": "Sequence motif matches (nucleic acid)"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_1324"
      },
      "definition": "post-translation modifications in a protein sequence, typically describing the specific sites involved.",
      "replacedBy": ["http://edamontology.org/data_1277"],
      "text": "Protein features (post-translation modifications)"
    }, {
      "comment": ["Possible options including sorting by score, rank, by increasing P-value (probability, i.e. most statistically significant hits given first) and so on."],
      "consider": ["http://edamontology.org/data_0006"],
      "data": {
        "uri": "http://edamontology.org/data_2134"
      },
      "definition": "A control of the order of data that is output, for example the order of sequences in an alignment.",
      "text": "Results sort order"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_3024"
      },
      "definition": "Predict, recognise, detect or identify some properties of nucleic acids.",
      "replacedBy": ["http://edamontology.org/operation_2423"],
      "text": "Prediction and recognition (nucleic acid)"
    }, {
      "consider": ["http://edamontology.org/data_2610"],
      "data": {
        "uri": "http://edamontology.org/data_2681"
      },
      "definition": "Identifier of an entry (exon, gene, transcript or protein) from the Ensembl 'core' database ('Felis catus' division).",
      "text": "Ensembl ID ('Felis catus')"
    }, {
      "consider": ["http://edamontology.org/format_1997"],
      "data": {
        "uri": "http://edamontology.org/format_1955"
      },
      "definition": "Phylip interleaved sequence format.",
      "text": "phylip sequence format"
    }, {
      "consider": ["http://edamontology.org/data_1448"],
      "data": {
        "uri": "http://edamontology.org/data_1451"
      },
      "definition": "Matrix of floating point numbers for nucleotide comparison.",
      "exact_synonyms": ["Nucleotide substitution matrix (floats)"],
      "text": "Nucleotide comparison matrix (floats)"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_3130"
      },
      "definition": "Report on the location of matches to profiles, motifs (conserved or functional patterns) or other signatures in one or more protein sequences.",
      "replacedBy": ["http://edamontology.org/data_0858"],
      "text": "Sequence motif matches (protein)"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0333"
      },
      "definition": "Predict and optimise zinc finger protein domains for DNA/RNA binding (for example for transcription factors and nucleases).",
      "replacedBy": ["http://edamontology.org/operation_0420"],
      "text": "Zinc finger prediction"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_2959"
      },
      "definition": "A probability profile of a double-stranded nucleic acid molecule (DNA or DNA/RNA).",
      "replacedBy": ["http://edamontology.org/data_1583"],
      "text": "Nucleic acid probability profile"
    }, {
      "consider": ["http://edamontology.org/data_2337"],
      "data": {
        "uri": "http://edamontology.org/data_2180"
      },
      "definition": "Two or more things.",
      "text": "2 or more"
    }, {
      "consider": ["http://edamontology.org/data_2048"],
      "data": {
        "uri": "http://edamontology.org/data_1688"
      },
      "definition": "EMBOSS vectorstrip log file.",
      "text": "EMBOSS vectorstrip log file"
    }, {
      "consider": ["http://edamontology.org/data_0954"],
      "data": {
        "uri": "http://edamontology.org/data_1673"
      },
      "definition": "Cross-mapping of Swiss-Prot codes to PDB identifiers.",
      "text": "Swiss-Prot to PDB mapping"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_1838"
      },
      "definition": "Calculate contacts between residues and ligands in a protein structure.",
      "replacedBy": ["http://edamontology.org/operation_2950"],
      "text": "Residue contact calculation (residue-ligand)"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_0220"
      },
      "definition": "The management and manipulation of digital documents, including database records, files and reports.",
      "replacedBy": ["http://edamontology.org/topic_3489"],
      "text": "Document, record and content management"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_3742"
      },
      "definition": "The analysis, using any of diverse techniques, to identify genes that are differentially expressed under a given experimental setup.",
      "replacedBy": ["http://edamontology.org/operation_3223"],
      "text": "Differential gene expression analysis"
    }, {
      "consider": ["http://edamontology.org/data_0907"],
      "data": {
        "uri": "http://edamontology.org/data_1559"
      },
      "definition": "Information on a protein 'homologous superfamily' node from the CATH database.",
      "text": "CATH homologous superfamily"
    }, {
      "consider": ["http://edamontology.org/topic_2229"],
      "data": {
        "uri": "http://edamontology.org/topic_0608"
      },
      "definition": "General cell culture or data on a specific cell lines.",
      "text": "Cell and tissue culture"
    }, {
      "consider": ["http://edamontology.org/data_2610"],
      "data": {
        "uri": "http://edamontology.org/data_2672"
      },
      "definition": "Identifier of an entry (exon, gene, transcript or protein) from the Ensembl 'core' database ('Bos taurus' division).",
      "text": "Ensembl ID ('Bos taurus')"
    }, {
      "consider": ["http://edamontology.org/data_2099"],
      "data": {
        "uri": "http://edamontology.org/data_2592"
      },
      "definition": "A type (represented as a string) of cancer.",
      "text": "Cancer type"
    }, {
      "consider": ["http://edamontology.org/data_0907"],
      "data": {
        "uri": "http://edamontology.org/data_3141"
      },
      "definition": "Information on a 'class' node from the SCOP database.",
      "text": "SCOP class"
    }, {
      "consider": ["http://edamontology.org/format_2350"],
      "data": {
        "uri": "http://edamontology.org/format_2542"
      },
      "definition": "Format of a report on protein features (domain composition).",
      "text": "Protein features (domains) format"
    }, {
      "comment": ["C-beta atoms from amino acid side-chains may be included."],
      "consider": ["http://edamontology.org/data_1467"],
      "data": {
        "uri": "http://edamontology.org/data_1472"
      },
      "definition": "3D coordinate and associated data for a polypeptide chain tertiary (3D) structure (typically C-alpha atoms only).",
      "text": "Protein chain (C-alpha atoms)"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_1769"
      },
      "definition": "Compute energies of nucleic acid folding, e.g. minimum folding energies for DNA or RNA sequences or energy landscape of RNA mutants.",
      "replacedBy": ["http://edamontology.org/operation_0279"],
      "text": "Nucleic acid folding energy calculation"
    }, {
      "comment": ["See the EMBOSS documentation (http://emboss.sourceforge.net/) for a definition of what this includes."],
      "consider": ["http://edamontology.org/data_2534"],
      "data": {
        "uri": "http://edamontology.org/data_1110"
      },
      "definition": "The EMBOSS type of a molecular sequence.",
      "text": "EMBOSS sequence type"
    }, {
      "consider": ["http://edamontology.org/operation_0295"],
      "data": {
        "uri": "http://edamontology.org/operation_0506"
      },
      "definition": "Align RNA tertiary structures.",
      "text": "Structure alignment (RNA)"
    }, {
      "comment": ["This is a broad data type and is used a placeholder for other, more specific types.  This includes entities derived from sequences and structures such as motifs and profiles."],
      "consider": ["http://edamontology.org/data_2083", "http://edamontology.org/data_1916"],
      "data": {
        "uri": "http://edamontology.org/data_2539"
      },
      "definition": "Data concerning an alignment of two or more molecular sequences, structures or derived data.",
      "text": "Alignment data"
    }, {
      "comment": ["Various protein sequence analysis methods might generate a sequence rendering but are not (for brevity) listed under here."],
      "data": {
        "uri": "http://edamontology.org/operation_2516"
      },
      "definition": "Visualise, format or render a protein sequence.",
      "replacedBy": ["http://edamontology.org/operation_0564"],
      "text": "Protein sequence visualisation"
    }, {
      "consider": ["http://edamontology.org/operation_2495"],
      "data": {
        "uri": "http://edamontology.org/operation_0312"
      },
      "definition": "Process (read and / or write) SAGE, MPSS or SBS experimental data.",
      "text": "Sequencing-based expression profile data processing"
    }, {
      "consider": ["http://edamontology.org/topic_2275"],
      "data": {
        "uri": "http://edamontology.org/topic_0175"
      },
      "definition": "The modelling of the three-dimensional structure of a protein using known sequence and structural data.",
      "text": "Homology modelling"
    }, {
      "comment": ["The forward or 'top' strand might specify a sequence is to be used as given, the reverse or 'bottom' strand specifying the reverse complement of the sequence is to be used."],
      "consider": ["http://edamontology.org/data_2534"],
      "data": {
        "uri": "http://edamontology.org/data_0853"
      },
      "definition": "The strand of a DNA sequence (forward or reverse).",
      "text": "DNA sense specification"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_3471"
      },
      "definition": "Prediction of nucleic-acid folding using sequence alignments as a source of data.",
      "replacedBy": ["http://edamontology.org/operation_0279"],
      "text": "Nucleic acid folding prediction (alignment-based)"
    }, {
      "comment": ["For example 'nj', 'upgmp' etc."],
      "consider": ["http://edamontology.org/data_0842"],
      "data": {
        "uri": "http://edamontology.org/data_1122"
      },
      "definition": "A label (text token) describing the type of a phylogenetic tree.",
      "text": "Phylogenetic tree type"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_0180"
      },
      "definition": "The recognition (prediction and assignment) of known protein structural domains or folds in protein sequence(s).",
      "replacedBy": ["http://edamontology.org/topic_0082"],
      "text": "Protein fold recognition"
    }, {
      "consider": ["http://edamontology.org/data_0883"],
      "data": {
        "uri": "http://edamontology.org/data_2081"
      },
      "definition": "The secondary structure assignment (predicted or real) of a nucleic acid or protein.",
      "text": "Secondary structure"
    }, {
      "consider": ["http://edamontology.org/format_1992"],
      "data": {
        "uri": "http://edamontology.org/format_1971"
      },
      "definition": "Mega non-interleaved output sequence format.",
      "text": "meganon sequence format"
    }, {
      "comment": ["This is a broad data type and is used a placeholder for other, more specific types.  It is primarily intended to help navigation of EDAM and would not typically be used for annotation."],
      "consider": ["http://edamontology.org/data_1537"],
      "data": {
        "uri": "http://edamontology.org/data_1543"
      },
      "definition": "Data on the surface properties (shape, hydropathy, electrostatic patches etc) of a protein structure.",
      "text": "Protein surface report"
    }, {
      "consider": ["http://edamontology.org/operation_2422"],
      "data": {
        "uri": "http://edamontology.org/operation_2434"
      },
      "definition": "Retrieve a codon usage table and / or associated annotation.",
      "text": "Data retrieval (codon usage table)"
    }, {
      "consider": ["http://edamontology.org/operation_2422"],
      "data": {
        "uri": "http://edamontology.org/operation_2264"
      },
      "definition": "Query a biological pathways database and retrieve annotation on one or more pathways.",
      "text": "Data retrieval (pathway or network)"
    }, {
      "consider": ["http://edamontology.org/data_1015"],
      "data": {
        "uri": "http://edamontology.org/data_1018"
      },
      "definition": "Name or other identifier of an nucleic acid feature.",
      "text": "Nucleic acid feature identifier"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0434"
      },
      "definition": "Predict whole gene structure using a combination of multiple methods to achieve better predictions.",
      "replacedBy": ["http://edamontology.org/operation_2454"],
      "text": "Integrated gene prediction"
    }, {
      "consider": ["http://edamontology.org/operation_2478", "http://edamontology.org/operation_2481"],
      "data": {
        "uri": "http://edamontology.org/operation_2501"
      },
      "definition": "Process (read and / or write) nucleic acid sequence or structural data.",
      "text": "Nucleic acid analysis"
    }, {
      "consider": ["http://edamontology.org/operation_2520"],
      "data": {
        "uri": "http://edamontology.org/operation_2521"
      },
      "definition": "Process (read and / or write) a DNA map of some type.",
      "text": "Map data processing"
    }, {
      "consider": ["http://edamontology.org/operation_0432"],
      "data": {
        "uri": "http://edamontology.org/operation_0453"
      },
      "definition": "Predict nucleosome formation potential of DNA sequences.",
      "text": "Nucleosome formation potential prediction"
    }, {
      "consider": ["http://edamontology.org/topic_0203"],
      "data": {
        "uri": "http://edamontology.org/topic_0629"
      },
      "definition": "Gene expression e.g. microarray data, northern blots, gene-indexed expression profiles etc.",
      "text": "Gene expression and microarray"
    }, {
      "consider": ["http://edamontology.org/data_1381", "http://edamontology.org/data_1383"],
      "data": {
        "uri": "http://edamontology.org/data_1386"
      },
      "definition": "Alignment of exactly two nucleotide sequences.",
      "text": "Sequence alignment (nucleic acid pair)"
    }, {
      "consider": ["http://edamontology.org/data_1035"],
      "data": {
        "uri": "http://edamontology.org/data_1797"
      },
      "definition": "Gene identifier from Glossina morsitans GeneDB database.",
      "text": "Gene ID (GeneDB Glossina morsitans)"
    }, {
      "comment": ["A protein binding site signature corresponds to a site that reversibly binds chemical compounds, which are not themselves substrates of the enzymatic reaction. This includes enzyme cofactors and residues involved in electron transport or protein structure modification."],
      "consider": ["http://edamontology.org/data_2071"],
      "data": {
        "uri": "http://edamontology.org/data_1379"
      },
      "definition": "A protein binding site signature (sequence classifier) from the InterPro database.",
      "text": "Protein binding site signature"
    }, {
      "comment": ["Sequence masking is where specific characters or positions in a molecular sequence are masked (replaced) with an another (mask character). The mask type indicates what is masked, for example regions that are not of interest or which are information-poor including acidic protein regions, basic protein regions, proline-rich regions, low compositional complexity regions, short-periodicity internal repeats, simple repeats and low complexity regions. Masked sequences are used in database search to eliminate statistically significant but biologically uninteresting hits."],
      "consider": ["http://edamontology.org/data_0842"],
      "data": {
        "uri": "http://edamontology.org/data_0852"
      },
      "definition": "A label (text token) describing the type of sequence masking to perform.",
      "text": "Sequence mask type"
    }, {
      "comment": ["The location and size of the secondary structure elements and intervening loop regions is usually indicated."],
      "data": {
        "uri": "http://edamontology.org/data_0875"
      },
      "definition": "Predicted or actual protein topology represented as a string of protein secondary structure elements.",
      "replacedBy": ["http://edamontology.org/data_1277"],
      "text": "Protein topology"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_3086"
      },
      "definition": "A report (typically a table) on character or word composition / frequency of nucleic acid sequence(s).",
      "replacedBy": ["http://edamontology.org/data_1261"],
      "text": "Nucleic acid sequence composition (report)"
    }, {
      "comment": ["This includes long terminal repeats (LTRs); sequences (typically retroviral) directly repeated at  both ends of a defined sequence and other types of repeating unit."],
      "data": {
        "uri": "http://edamontology.org/topic_3126"
      },
      "definition": "Repetitive elements within a nucleic acid sequence.",
      "replacedBy": ["http://edamontology.org/topic_0157"],
      "text": "Nucleic acid repeats"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0424"
      },
      "definition": "Predict epitopes that bind to MHC class II molecules.",
      "replacedBy": ["http://edamontology.org/operation_0416"],
      "text": "Epitope mapping (MHC Class II)"
    }, {
      "consider": ["http://edamontology.org/data_2531"],
      "data": {
        "uri": "http://edamontology.org/data_2838"
      },
      "definition": "Data concerning a proteomics experiment.",
      "text": "Experimental data (proteomics)"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0401"
      },
      "definition": "Hydropathy calculation on a protein sequence.",
      "replacedBy": ["http://edamontology.org/operation_2574"],
      "text": "Protein hydropathy calculation (from sequence)"
    }, {
      "comment": ["This includes direct retrieval methods but not those that perform calculations on the sequence or structure."],
      "consider": ["http://edamontology.org/operation_2422"],
      "data": {
        "uri": "http://edamontology.org/operation_1814"
      },
      "definition": "Query a tertiary structure data resource (typically a database) and retrieve structures, structure-related data and annotation.",
      "text": "Structure retrieval"
    }, {
      "consider": ["http://edamontology.org/data_0850"],
      "data": {
        "uri": "http://edamontology.org/data_1767"
      },
      "definition": "FASTA sequence database for all CATH domains (based on COMBS sequence data).",
      "text": "CATH domain sequences (COMBS)"
    }, {
      "consider": ["http://edamontology.org/data_1584"],
      "data": {
        "uri": "http://edamontology.org/data_1594"
      },
      "definition": "RNA calculated energy data generated by the Vienna package.",
      "text": "Vienna RNA calculated energy"
    }, {
      "consider": ["http://edamontology.org/data_1035"],
      "data": {
        "uri": "http://edamontology.org/data_1799"
      },
      "definition": "Gene identifier from Plasmodium falciparum GeneDB database.",
      "text": "Gene ID (GeneDB Plasmodium falciparum)"
    }, {
      "consider": ["http://edamontology.org/data_0006"],
      "data": {
        "uri": "http://edamontology.org/data_1694"
      },
      "definition": "Number of entities (for example database hits, sequences, alignments etc) to write to an output file.",
      "text": "Number of output entities"
    }, {
      "consider": ["http://edamontology.org/data_1027"],
      "data": {
        "uri": "http://edamontology.org/data_1028"
      },
      "definition": "An NCBI RefSeq unique identifier of a gene.",
      "text": "Gene identifier (NCBI RefSeq)"
    }, {
      "consider": ["http://edamontology.org/topic_0082", "http://edamontology.org/topic_0820"],
      "data": {
        "uri": "http://edamontology.org/topic_2278"
      },
      "definition": "Predict transmembrane domains and topology in protein sequences.",
      "text": "Transmembrane protein prediction"
    }, {
      "consider": ["http://edamontology.org/data_1268", "http://edamontology.org/data_1266"],
      "data": {
        "uri": "http://edamontology.org/data_2157"
      },
      "definition": "Word composition data for a molecular sequence.",
      "text": "Word composition"
    }, {
      "consider": ["http://edamontology.org/data_2048"],
      "data": {
        "uri": "http://edamontology.org/data_2252"
      },
      "definition": "An XSLT stylesheet.",
      "text": "XSLT stylesheet"
    }, {
      "consider": ["http://edamontology.org/data_2992"],
      "data": {
        "uri": "http://edamontology.org/data_2880"
      },
      "definition": "Image of one or more molecular secondary structures.",
      "text": "Secondary structure image"
    }, {
      "comment": ["For example 'blosum', 'pam', 'gonnet', 'id' etc. Comparison matrix type may be required where a series of matrices of a certain type are used."],
      "consider": ["http://edamontology.org/data_0842"],
      "data": {
        "uri": "http://edamontology.org/data_1125"
      },
      "definition": "A label (text token) describing the type of a comparison matrix.",
      "text": "Comparison matrix type"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0340"
      },
      "definition": "Search a secondary protein database (of classification information) to assign a protein sequence(s) to a known protein family or group.",
      "replacedBy": ["http://edamontology.org/operation_3092"],
      "text": "Protein secondary database search"
    }, {
      "comment": ["Models are annotated and linked to relevant data resources, such as publications, databases of compounds and pathways, controlled vocabularies, etc."],
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1666"
      },
      "definition": "Format of mathematical models from the BioModel database.",
      "text": "BioModel mathematical model format"
    }, {
      "consider": ["http://edamontology.org/operation_0295", "http://edamontology.org/operation_0503", "http://edamontology.org/operation_0294"],
      "data": {
        "uri": "http://edamontology.org/operation_0513"
      },
      "definition": "Align exactly two molecular Structural (3D) profiles.",
      "text": "3D profile-to-3D profile alignment (pairwise)"
    }, {
      "consider": ["http://edamontology.org/operation_0284", "http://edamontology.org/operation_0285"],
      "data": {
        "uri": "http://edamontology.org/operation_2433"
      },
      "definition": "Process (read and / or write) a codon usage table.",
      "text": "Codon usage table processing"
    }, {
      "comment": ["Mappable features may be based on Gramene's notion of map features; see http://www.gramene.org/db/cmap/feature_type_info."],
      "consider": ["http://edamontology.org/data_1255", "http://edamontology.org/data_1276", "http://edamontology.org/data_2019"],
      "data": {
        "uri": "http://edamontology.org/data_1865"
      },
      "definition": "A feature which may mapped (positioned) on a genetic or other type of map.",
      "text": "Map feature"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_3496"
      },
      "definition": "A raw RNA sequence.",
      "exact_synonyms": ["RNA raw sequence", "Raw RNA sequence", "Raw sequence (RNA)"],
      "replacedBy": ["http://edamontology.org/data_3495"],
      "text": "RNA sequence (raw)"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_1659"
      },
      "definition": "A report typically including a map (diagram) of a signal transduction pathway.",
      "replacedBy": ["http://edamontology.org/data_2984"],
      "text": "Signal transduction pathway report"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_1864"
      },
      "definition": "Data describing a set of multiple genetic or physical maps, typically sharing a common set of features which are mapped.",
      "replacedBy": ["http://edamontology.org/data_2019"],
      "text": "Map set data"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_2966"
      },
      "definition": "General annotation on a set of oligonucleotide probes, such as the gene name with which the probe set is associated and which probes belong to the set.",
      "replacedBy": ["http://edamontology.org/data_2717"],
      "text": "Oligonucleotide probe sets annotation"
    }, {
      "consider": ["http://edamontology.org/data_1015"],
      "data": {
        "uri": "http://edamontology.org/data_1019"
      },
      "definition": "Name or other identifier of a protein feature.",
      "text": "Protein feature identifier"
    }, {
      "consider": ["http://edamontology.org/data_3106"],
      "data": {
        "uri": "http://edamontology.org/data_2192"
      },
      "definition": "Data on an error generated by computer system or tool.",
      "text": "Error"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_2491"
      },
      "definition": "Identify potential hydrogen bonds between amino acid residues.",
      "replacedBy": ["http://edamontology.org/operation_0394"],
      "text": "Hydrogen bond calculation (inter-residue)"
    }, {
      "consider": ["http://edamontology.org/data_2337"],
      "data": {
        "uri": "http://edamontology.org/data_2179"
      },
      "definition": "Exactly two things.",
      "text": "Exactly 2"
    }, {
      "comment": ["Various nucleic acid sequence analysis methods might generate a sequence rendering but are not (for brevity) listed under here."],
      "data": {
        "uri": "http://edamontology.org/operation_2515"
      },
      "definition": "Visualise, format or render a nucleic acid sequence.",
      "replacedBy": ["http://edamontology.org/operation_0564"],
      "text": "Nucleic acid sequence visualisation"
    }, {
      "consider": ["http://edamontology.org/operation_0227"],
      "data": {
        "uri": "http://edamontology.org/operation_0228"
      },
      "definition": "Analyse an index of biological data.",
      "text": "Data index analysis"
    }, {
      "data": {
        "uri": "http://edamontology.org/format_2203"
      },
      "definition": "Data format for a molecular sequence record 'lite', typically molecular sequence and minimal metadata, such as an identifier of the sequence and/or a comment.",
      "replacedBy": ["http://edamontology.org/format_1919"],
      "text": "Sequence record lite format"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0423"
      },
      "definition": "Predict epitopes that bind to MHC class I molecules.",
      "replacedBy": ["http://edamontology.org/operation_0416"],
      "text": "Epitope mapping (MHC Class I)"
    }, {
      "consider": ["http://edamontology.org/operation_2495"],
      "data": {
        "uri": "http://edamontology.org/operation_2432"
      },
      "definition": "Process (read and / or write) microarray data.",
      "text": "Microarray data processing"
    }, {
      "consider": ["http://edamontology.org/data_2535"],
      "data": {
        "uri": "http://edamontology.org/data_0933"
      },
      "definition": "Output from a serial analysis of gene expression (SAGE) experiment.",
      "text": "SAGE experimental data"
    }, {
      "consider": ["http://edamontology.org/operation_2422"],
      "data": {
        "uri": "http://edamontology.org/operation_0344"
      },
      "definition": "Query a database and retrieve sequences with a given entry code or accession number.",
      "text": "Sequence retrieval (by code)"
    }, {
      "consider": ["http://edamontology.org/data_3106"],
      "data": {
        "uri": "http://edamontology.org/data_2218"
      },
      "definition": "Basic information about a server on the web, such as an SRS server.",
      "text": "Server metadata"
    }, {
      "consider": ["http://edamontology.org/format_1973"],
      "data": {
        "uri": "http://edamontology.org/format_1995"
      },
      "definition": "Nexus/paup non-interleaved format for (aligned) sequences.",
      "text": "nexusnon alignment format"
    }, {
      "consider": ["http://edamontology.org/operation_2422"],
      "data": {
        "uri": "http://edamontology.org/operation_2469"
      },
      "definition": "Retrieve information on a protein interaction.",
      "text": "Data retrieval (protein interaction annotation)"
    }, {
      "consider": ["http://edamontology.org/format_2005"],
      "data": {
        "uri": "http://edamontology.org/format_1965"
      },
      "definition": "Treecon output sequence format.",
      "text": "treecon sequence format"
    }, {
      "comment": ["This includes the generation, storage, analysis, rendering etc. of structure alignments."],
      "data": {
        "uri": "http://edamontology.org/topic_0183"
      },
      "definition": "The superimposition of molecular tertiary structures or structural (3D) profiles (representing a structure or structure alignment).",
      "replacedBy": ["http://edamontology.org/topic_0081"],
      "text": "Structure alignment"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_2560"
      },
      "definition": "Entry format for the STRING database of protein interaction.",
      "text": "STRING entry format"
    }, {
      "comment": ["A suffix array consists of the lexicographically sorted list of suffixes of a genome."],
      "data": {
        "uri": "http://edamontology.org/operation_3213"
      },
      "definition": "Generate an index of a genome sequence using a suffix arrays algorithm.",
      "replacedBy": ["http://edamontology.org/operation_3211"],
      "text": "Genome indexing (suffix arrays)"
    }, {
      "consider": ["http://edamontology.org/operation_2422"],
      "data": {
        "uri": "http://edamontology.org/operation_0358"
      },
      "definition": "Query a tertiary structure database and retrieve entries containing a given keyword.",
      "text": "Structure retrieval (by keyword)"
    }, {
      "consider": ["http://edamontology.org/data_0966"],
      "data": {
        "uri": "http://edamontology.org/data_1715"
      },
      "definition": "A term from the BioPax ontology.",
      "text": "BioPax term"
    }, {
      "consider": ["http://edamontology.org/data_0950"],
      "data": {
        "uri": "http://edamontology.org/data_0859"
      },
      "definition": "Data files used by motif or profile methods.",
      "text": "Sequence signature model"
    }, {
      "comment": ["A protein site signature is a classifier for a specific site in a protein."],
      "consider": ["http://edamontology.org/data_1355"],
      "data": {
        "uri": "http://edamontology.org/data_1376"
      },
      "definition": "A protein site signature (sequence classifier) from the InterPro database.",
      "text": "Protein site signature"
    }, {
      "consider": ["http://edamontology.org/data_0857"],
      "data": {
        "uri": "http://edamontology.org/data_1339"
      },
      "definition": "Alignments from a sequence database search (for example a BLAST search).",
      "text": "Sequence database hits alignments list"
    }, {
      "consider": ["http://edamontology.org/topic_0081", "http://edamontology.org/topic_0080"],
      "data": {
        "uri": "http://edamontology.org/topic_0083"
      },
      "definition": "The alignment (equivalence between sites) of molecular sequences, structures or profiles (representing a sequence or structure alignment).",
      "text": "Alignment"
    }, {
      "consider": ["http://edamontology.org/operation_2945"],
      "data": {
        "uri": "http://edamontology.org/operation_2417"
      },
      "definition": "Process (read and / or write) data on the physicochemical property of a molecule.",
      "text": "Physicochemical property data processing"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_1304"
      },
      "definition": "CpG rich regions (isochores) in a nucleotide sequence.",
      "replacedBy": ["http://edamontology.org/topic_3512"],
      "text": "CpG island and isochores"
    }, {
      "consider": ["http://edamontology.org/data_1482"],
      "data": {
        "uri": "http://edamontology.org/data_1492"
      },
      "definition": "Alignment (superimposition) of more than two nucleic acid tertiary (3D) structures.",
      "text": "Multiple nucleic acid tertiary structure alignment"
    }, {
      "consider": ["http://edamontology.org/data_1276"],
      "data": {
        "uri": "http://edamontology.org/data_2882"
      },
      "definition": "DNA sequence-specific feature annotation (not in a feature table).",
      "text": "DNA features"
    }, {
      "consider": ["http://edamontology.org/data_2535"],
      "data": {
        "uri": "http://edamontology.org/data_0934"
      },
      "definition": "Massively parallel signature sequencing (MPSS) data.",
      "text": "MPSS experimental data"
    }, {
      "comment": ["This includes assignment, analysis, comparison, prediction, rendering etc. of secondary structure data."],
      "data": {
        "uri": "http://edamontology.org/topic_0694"
      },
      "definition": "Protein secondary structure or secondary structure alignments.",
      "replacedBy": ["http://edamontology.org/topic_2814"],
      "text": "Protein secondary structure"
    }, {
      "consider": ["http://edamontology.org/data_1026"],
      "data": {
        "uri": "http://edamontology.org/data_1783"
      },
      "definition": "Name of a gene from Aspergillus Genome Database.",
      "text": "Gene name (ASPGD)"
    }, {
      "consider": ["http://edamontology.org/topic_2229"],
      "data": {
        "uri": "http://edamontology.org/topic_0616"
      },
      "definition": "A specific organelle, or organelles in general, typically the genes and proteins (or genome and proteome).",
      "text": "Organelles"
    }, {
      "consider": ["http://edamontology.org/data_2984"],
      "data": {
        "uri": "http://edamontology.org/data_0946"
      },
      "definition": "An informative report about a specific biological pathway or network, typically including a map (diagram) of the pathway.",
      "text": "Pathway or network annotation"
    }, {
      "consider": ["http://edamontology.org/operation_2480"],
      "data": {
        "uri": "http://edamontology.org/operation_2465"
      },
      "definition": "Process (read and / or write) a molecular tertiary structure.",
      "text": "Structure processing"
    }, {
      "consider": ["http://edamontology.org/data_3106"],
      "data": {
        "uri": "http://edamontology.org/data_1678"
      },
      "definition": "A report of tool-specific metadata on some analysis or process performed, for example a log of diagnostic or error messages.",
      "text": "Tool log"
    }, {
      "consider": ["http://edamontology.org/operation_2495"],
      "data": {
        "uri": "http://edamontology.org/operation_2435"
      },
      "definition": "Process (read and / or write) a gene expression profile.",
      "text": "Gene expression profile processing"
    }, {
      "consider": ["http://edamontology.org/data_1460"],
      "data": {
        "uri": "http://edamontology.org/data_1469"
      },
      "definition": "3D coordinate and associated data for a protein tertiary (3D) structure (all atoms).",
      "text": "Protein structure (all atoms)"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_3231"
      },
      "definition": "Report concerning genome-wide association study experiments.",
      "replacedBy": ["http://edamontology.org/data_2531"],
      "text": "GWAS report"
    }, {
      "consider": ["http://edamontology.org/data_0950"],
      "data": {
        "uri": "http://edamontology.org/data_1344"
      },
      "definition": "Alphabet for the motifs (patterns) that MEME will search for.",
      "text": "MEME motif alphabet"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_1540"
      },
      "definition": "Data on inter-atomic or inter-residue contacts, distances and interactions in protein structure(s) or on the interactions of protein atoms or residues with non-protein groups.",
      "replacedBy": ["http://edamontology.org/data_0906"],
      "text": "Protein non-covalent interactions report"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1514"
      },
      "definition": "Format of an entry from the KEGG ENZYME database.",
      "text": "KEGG ENZYME enzyme report format"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_3023"
      },
      "definition": "Predict, recognise, detect or identify some properties of proteins.",
      "replacedBy": ["http://edamontology.org/operation_2423"],
      "text": "Prediction and recognition (protein)"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_0869"
      },
      "definition": "Alignment of one or more molecular sequence(s) to one or more sequence profile(s) (each profile typically representing a sequence alignment).",
      "replacedBy": ["http://edamontology.org/data_0858"],
      "text": "Sequence-profile alignment"
    }, {
      "consider": ["http://edamontology.org/data_0867"],
      "data": {
        "uri": "http://edamontology.org/data_0882"
      },
      "definition": "An informative report of RNA secondary structure alignment-derived data or metadata.",
      "text": "Secondary structure alignment metadata (RNA)"
    }, {
      "comment": ["IntEnz is the master copy of the Enzyme Nomenclature, the recommendations of the NC-IUBMB on the Nomenclature and Classification of Enzyme-Catalysed Reactions."],
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1511"
      },
      "definition": "Format of an entry from IntEnz (The Integrated Relational Enzyme Database).",
      "text": "IntEnz enzyme report format"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0419"
      },
      "definition": "Predict catalytic residues, active sites or other ligand-binding sites in protein sequences.",
      "replacedBy": ["http://edamontology.org/operation_2575"],
      "text": "Protein binding site prediction (from sequence)"
    }, {
      "consider": ["http://edamontology.org/data_0976"],
      "data": {
        "uri": "http://edamontology.org/data_1067"
      },
      "definition": "Identifier of a phylogenetic distance matrix.",
      "text": "Phylogenetic distance matrix identifier"
    }, {
      "consider": ["http://edamontology.org/operation_2495"],
      "data": {
        "uri": "http://edamontology.org/operation_0528"
      },
      "definition": "Process (read and / or write) serial analysis of gene expression (SAGE) data.",
      "text": "SAGE data processing"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_0134"
      },
      "definition": "An analytical chemistry technique that measures the mass-to-charge ratio and abundance of ions in the gas phase.",
      "replacedBy": ["http://edamontology.org/topic_3520"],
      "text": "Mass spectrometry"
    }, {
      "consider": ["http://edamontology.org/data_2084", "http://edamontology.org/data_0896"],
      "data": {
        "uri": "http://edamontology.org/data_2529"
      },
      "definition": "An informative report on a specific molecule.",
      "text": "Molecule report"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0311"
      },
      "definition": "Standardize or normalize microarray data.",
      "replacedBy": ["http://edamontology.org/operation_3435"],
      "text": "Microarray data standardisation and normalisation"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_0922"
      },
      "definition": "PCR primers and hybridisation oligos in a nucleic acid sequence.",
      "replacedBy": ["http://edamontology.org/topic_0632"],
      "text": "Primers"
    }, {
      "consider": ["http://edamontology.org/data_2610"],
      "data": {
        "uri": "http://edamontology.org/data_2695"
      },
      "definition": "Identifier of an entry (exon, gene, transcript or protein) from the Ensembl 'core' database ('Rattus norvegicus' division).",
      "text": "Ensembl ID ('Rattus norvegicus')"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1577"
      },
      "definition": "Entry format for the SMART protein secondary database.",
      "text": "SMART entry format"
    }, {
      "consider": ["http://edamontology.org/data_1353"],
      "data": {
        "uri": "http://edamontology.org/data_1359"
      },
      "definition": "A protein regular expression pattern from the Prosite database.",
      "text": "Prosite protein pattern"
    }, {
      "consider": ["http://edamontology.org/topic_0196"],
      "data": {
        "uri": "http://edamontology.org/topic_3178"
      },
      "definition": "The alignment of sequences of (typically millions) of short reads to a reference genome.  This is a specialised topic within sequence alignment, especially because of complications arising from RNA splicing.",
      "text": "RNA-Seq alignment"
    }, {
      "consider": ["http://edamontology.org/data_0897"],
      "data": {
        "uri": "http://edamontology.org/data_2164"
      },
      "definition": "A plot of general physicochemical properties of a protein sequence.",
      "text": "Protein sequence properties plot"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_3043"
      },
      "definition": "Protein sequences and associated concepts such as sequence sites, alignments, motifs and profiles.",
      "replacedBy": ["http://edamontology.org/topic_0080"],
      "text": "Protein sequences"
    }, {
      "comment": ["This concept is required for completeness. It should never have child concepts."],
      "consider": ["http://edamontology.org/data_0842"],
      "data": {
        "uri": "http://edamontology.org/data_1062"
      },
      "definition": "An identifier of an entry from a database where the same type of identifier is used for objects (data) of different semantic type.",
      "text": "Database entry identifier"
    }, {
      "consider": ["http://edamontology.org/topic_0130"],
      "data": {
        "uri": "http://edamontology.org/topic_0144"
      },
      "definition": "The processing and analysis of inter-atomic or inter-residue interactions in protein (3D) structures.",
      "text": "Protein residue interactions"
    }, {
      "consider": ["http://edamontology.org/topic_0154"],
      "data": {
        "uri": "http://edamontology.org/topic_0618"
      },
      "definition": "A database about scents.",
      "text": "Scents"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_2514"
      },
      "definition": "Generate a protein sequence by some means.",
      "replacedBy": ["http://edamontology.org/operation_0230"],
      "text": "Sequence generation (protein)"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_3190"
      },
      "definition": "Trim sequences (typically from an automated DNA sequencer) to remove sequence-specific end regions, typically contamination from vector sequences.",
      "replacedBy": ["http://edamontology.org/operation_3192"],
      "text": "Trim vector"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0332"
      },
      "definition": "Design molecules that elicit an immune response (immunogens).",
      "replacedBy": ["http://edamontology.org/operation_0252"],
      "text": "Immunogen design"
    }, {
      "consider": ["http://edamontology.org/topic_0639", "http://edamontology.org/topic_0160"],
      "data": {
        "uri": "http://edamontology.org/topic_0748"
      },
      "definition": "The detection, identification and analysis of positional features in proteins, such as functional sites.",
      "text": "Protein sites and features"
    }, {
      "consider": ["http://edamontology.org/data_1381", "http://edamontology.org/data_1384"],
      "data": {
        "uri": "http://edamontology.org/data_1387"
      },
      "definition": "Alignment of exactly two protein sequences.",
      "text": "Sequence alignment (protein pair)"
    }, {
      "consider": ["http://edamontology.org/data_2610"],
      "data": {
        "uri": "http://edamontology.org/data_2698"
      },
      "definition": "Identifier of an entry (exon, gene, transcript or protein) from the Ensembl 'core' database ('Tupaia belangeri' division).",
      "text": "Ensembl ID ('Tupaia belangeri')"
    }, {
      "consider": ["http://edamontology.org/data_2534"],
      "data": {
        "uri": "http://edamontology.org/data_1396"
      },
      "definition": "Controls the order of sequences in an output sequence alignment.",
      "text": "Aligned sequence order"
    }, {
      "consider": ["http://edamontology.org/operation_0306", "http://edamontology.org/operation_3778"],
      "data": {
        "uri": "http://edamontology.org/operation_2505"
      },
      "definition": "Process (read and / or write) text.",
      "text": "Text processing"
    }, {
      "consider": ["http://edamontology.org/data_2048"],
      "data": {
        "uri": "http://edamontology.org/data_1684"
      },
      "definition": "EMBOSS (EMBASSY) sites application log file.",
      "text": "EMBOSS sites log file"
    }, {
      "comment": ["For properties that can be mapped to a sequence, use 'Sequence report' instead."],
      "consider": ["http://edamontology.org/data_0896"],
      "data": {
        "uri": "http://edamontology.org/data_1776"
      },
      "definition": "Report on general functional properties of specific protein(s).",
      "text": "Protein report (function)"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1603"
      },
      "definition": "Entry format of Ensembl genome database.",
      "text": "Ensembl gene report format"
    }, {
      "consider": ["http://edamontology.org/operation_0227"],
      "data": {
        "uri": "http://edamontology.org/operation_2412"
      },
      "definition": "Process (read and / or write) an index of (typically a file of) biological data.",
      "text": "Data index processing"
    }, {
      "consider": ["http://edamontology.org/operation_2928"],
      "data": {
        "uri": "http://edamontology.org/operation_0500"
      },
      "definition": "Align molecular secondary structure (represented as a 1D string).",
      "text": "Secondary structure alignment generation"
    }, {
      "consider": ["http://edamontology.org/topic_3512", "http://edamontology.org/topic_3320"],
      "data": {
        "uri": "http://edamontology.org/topic_1307"
      },
      "definition": "Splice sites in a nucleotide sequence or alternative RNA splicing events.",
      "text": "Splice sites"
    }, {
      "consider": ["http://edamontology.org/data_1026"],
      "data": {
        "uri": "http://edamontology.org/data_1784"
      },
      "definition": "Name of a gene from Candida Genome Database.",
      "text": "Gene name (CGD)"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_0655"
      },
      "definition": "Protein-coding regions including coding sequences (CDS), exons, translation initiation sites and open reading frames",
      "replacedBy": ["http://edamontology.org/topic_3512"],
      "text": "Coding RNA"
    }, {
      "consider": ["http://edamontology.org/operation_2949"],
      "data": {
        "uri": "http://edamontology.org/operation_2948"
      },
      "definition": "Analyse the interactions of two or more molecules (or parts of molecules) that are known to interact.",
      "text": "Molecular interaction analysis"
    }, {
      "comment": ["A protein region signature defines a region which cannot be described as a protein family or domain signature."],
      "consider": ["http://edamontology.org/data_1355"],
      "data": {
        "uri": "http://edamontology.org/data_1374"
      },
      "definition": "A protein region signature (sequence classifier) from the InterPro database.",
      "text": "Protein region signature"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0536"
      },
      "definition": "Assign a protein tertiary structure (3D coordinates) from raw X-ray crystallography data.",
      "replacedBy": ["http://edamontology.org/operation_0320"],
      "text": "Protein structure assignment (from X-ray crystallographic data)"
    }, {
      "consider": ["http://edamontology.org/operation_2422"],
      "data": {
        "uri": "http://edamontology.org/operation_2471"
      },
      "definition": "Retrieve information on an RNA family.",
      "text": "Data retrieval (RNA family annotation)"
    }, {
      "consider": ["http://edamontology.org/topic_0749"],
      "data": {
        "uri": "http://edamontology.org/topic_3123"
      },
      "definition": "Regions within a nucleic acid sequence containing a signal that alters a biological function.",
      "text": "Expression signals"
    }, {
      "comment": ["This includes tools based on the Needleman and Wunsch algorithm."],
      "consider": ["http://edamontology.org/operation_0346"],
      "data": {
        "uri": "http://edamontology.org/operation_0353"
      },
      "definition": "Search sequence(s) or a sequence database for sequences that are similar to a query sequence using a global alignment-based method.",
      "text": "Sequence database search (by sequence using global alignment-based methods)"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1810"
      },
      "definition": "Format of a report on Escherichia coli genes, proteins and molecules from the CyberCell Database (CCDB).",
      "text": "ColiCard report format"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0275"
      },
      "definition": "Identify or predict protein-protein interactions, interfaces, binding sites etc in protein structures.",
      "replacedBy": ["http://edamontology.org/operation_2464"],
      "text": "Protein-protein interaction prediction (from protein structure)"
    }, {
      "consider": ["http://edamontology.org/topic_0621"],
      "data": {
        "uri": "http://edamontology.org/topic_0210"
      },
      "definition": "Information on a specific fish genome including molecular sequences, genes and annotation.",
      "text": "Fish"
    }, {
      "consider": ["http://edamontology.org/data_1035"],
      "data": {
        "uri": "http://edamontology.org/data_1801"
      },
      "definition": "Gene identifier from Trypanosoma brucei GeneDB database.",
      "text": "Gene ID (GeneDB Trypanosoma brucei)"
    }, {
      "comment": ["Core data entities typically have a format and may be identified by an accession number."],
      "data": {
        "uri": "http://edamontology.org/data_3031"
      },
      "definition": "A type of data that (typically) corresponds to entries from the primary biological databases and which is (typically) the primary input or output of a tool, i.e. the data the tool processes or generates, as distinct from metadata and identifiers which describe and identify such core data, parameters that control the behaviour of tools, reports of derivative data generated by tools and annotation.",
      "replacedBy": ["http://edamontology.org/data_0006"],
      "text": "Core data"
    }, {
      "consider": ["http://edamontology.org/data_2048"],
      "data": {
        "uri": "http://edamontology.org/data_1681"
      },
      "definition": "NACCESS log file.",
      "text": "NACCESS log file"
    }, {
      "comment": ["This is a broad data type and is used a placeholder for other, more specific types."],
      "consider": ["http://edamontology.org/data_0883", "http://edamontology.org/data_2085"],
      "data": {
        "uri": "http://edamontology.org/data_2053"
      },
      "definition": "Data concerning molecular structural data.",
      "text": "Structural data"
    }, {
      "consider": ["http://edamontology.org/data_0907"],
      "data": {
        "uri": "http://edamontology.org/data_0900"
      },
      "definition": "Data concerning the classification of the sequences and/or structures of protein structural domain(s).",
      "text": "Protein domain classification"
    }, {
      "consider": ["http://edamontology.org/data_1276"],
      "data": {
        "uri": "http://edamontology.org/data_2169"
      },
      "definition": "A report on siRNA duplexes in mRNA.",
      "text": "Nucleic acid features (siRNA)"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_1746"
      },
      "definition": "Cartesian z coordinate of an atom (in a molecular structure).",
      "exact_synonyms": ["Cartesian z coordinate"],
      "replacedBy": ["http://edamontology.org/data_1743"],
      "text": "Atomic z coordinate"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_3060"
      },
      "definition": "Regulatory RNA sequences including microRNA (miRNA) and small interfering RNA (siRNA).",
      "replacedBy": ["http://edamontology.org/topic_0659"],
      "text": "Regulatory RNA"
    }, {
      "consider": ["http://edamontology.org/topic_0780"],
      "data": {
        "uri": "http://edamontology.org/topic_0786"
      },
      "definition": "Arabidopsis-specific data.",
      "text": "Arabidopsis"
    }, {
      "consider": ["http://edamontology.org/topic_1317"],
      "data": {
        "uri": "http://edamontology.org/topic_2226"
      },
      "definition": "Experimental methods for biomolecular structure determination, such as X-ray crystallography, nuclear magnetic resonance (NMR), circular dichroism (CD) spectroscopy, microscopy etc., including the assignment or modelling of molecular structure from such data.",
      "text": "Structure determination"
    }, {
      "comment": ["A protein active site signature corresponds to an enzyme catalytic pocket. An active site typically includes non-contiguous residues, therefore multiple signatures may be required to describe an active site. ; residues involved in enzymatic reactions for which mutational data is typically available."],
      "consider": ["http://edamontology.org/data_2071"],
      "data": {
        "uri": "http://edamontology.org/data_1378"
      },
      "definition": "A protein active site signature (sequence classifier) from the InterPro database.",
      "text": "Protein active site signature"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0522"
      },
      "definition": "Predict primers for methylation PCRs.",
      "replacedBy": ["http://edamontology.org/operation_0308"],
      "text": "PCR primer design (for methylation PCRs)"
    }, {
      "consider": ["http://edamontology.org/topic_0634"],
      "data": {
        "uri": "http://edamontology.org/topic_2813"
      },
      "definition": "The genes, gene variations and proteins involved in one or more specific diseases.",
      "text": "Disease genes and proteins"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_1312"
      },
      "definition": "Whole promoters or promoter elements (transcription start sites, RNA polymerase binding site, transcription factor binding sites, promoter enhancers etc) in a DNA sequence.",
      "replacedBy": ["http://edamontology.org/topic_0749"],
      "text": "Promoters"
    }, {
      "consider": ["http://edamontology.org/data_2610"],
      "data": {
        "uri": "http://edamontology.org/data_2680"
      },
      "definition": "Identifier of an entry (exon, gene, transcript or protein) from the Ensembl 'core' database ('Erinaceus europaeus' division).",
      "text": "Ensembl ID ('Erinaceus europaeus')"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_2427"
      },
      "definition": "Perform basic operations on some data or a database.",
      "replacedBy": ["http://edamontology.org/operation_2409"],
      "text": "Data handling"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_2043"
      },
      "definition": "A molecular sequence and minimal metadata, typically an identifier of the sequence and/or a comment.",
      "replacedBy": ["http://edamontology.org/data_0849"],
      "text": "Sequence record lite"
    }, {
      "consider": ["http://edamontology.org/topic_0121"],
      "data": {
        "uri": "http://edamontology.org/topic_0133"
      },
      "definition": "Two-dimensional gel electrophoresis image and related data.",
      "text": "Two-dimensional gel electrophoresis"
    }, {
      "consider": ["http://edamontology.org/data_0907"],
      "data": {
        "uri": "http://edamontology.org/data_1561"
      },
      "definition": "Information on a protein 'functional category' node from the CATH database.",
      "text": "CATH functional category"
    }, {
      "comment": ["Global alignment methods identify similarity across the entire structures."],
      "consider": ["http://edamontology.org/operation_0295", "http://edamontology.org/operation_0510"],
      "data": {
        "uri": "http://edamontology.org/operation_0508"
      },
      "definition": "Globally align (superimpose) exactly two molecular tertiary structures.",
      "text": "Pairwise structure alignment generation (global)"
    }, {
      "comment": ["The doc2loc output includes the url, format, type and availability code of a document for every service provider."],
      "consider": ["http://edamontology.org/data_0970"],
      "data": {
        "uri": "http://edamontology.org/data_1738"
      },
      "definition": "Information on a published article provided by the doc2loc program.",
      "text": "doc2loc document information"
    }, {
      "consider": ["http://edamontology.org/data_0888"],
      "data": {
        "uri": "http://edamontology.org/data_1496"
      },
      "definition": "A score reflecting structural similarities of two molecules.",
      "text": "Molecular similarity score"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1654"
      },
      "definition": "The format of an entry from the CPDB database.",
      "text": "CPDB entry format"
    }, {
      "consider": ["http://edamontology.org/topic_2259"],
      "data": {
        "uri": "http://edamontology.org/topic_3075"
      },
      "definition": "Topic for modelling biological systems in mathematical terms.",
      "text": "Biological system modelling"
    }, {
      "consider": ["http://edamontology.org/operation_2409"],
      "data": {
        "uri": "http://edamontology.org/operation_2234"
      },
      "definition": "Perform basic (non-analytical) operations on a file of molecular tertiary structural data.",
      "text": "Structure file processing"
    }, {
      "comment": ["The report (for example http://www.cathdb.info/cathnode/1.10.10.10) includes CATH code (of the node and upper levels in the hierarchy), classification text (of appropriate levels in hierarchy), list of child nodes, representative domain and other relevant data and links."],
      "consider": ["http://edamontology.org/data_0907"],
      "data": {
        "uri": "http://edamontology.org/data_1553"
      },
      "definition": "Information on a node from the CATH database.",
      "text": "CATH node"
    }, {
      "consider": ["http://edamontology.org/operation_0296"],
      "data": {
        "uri": "http://edamontology.org/operation_2413"
      },
      "definition": "Process (read and / or write) some type of sequence profile.",
      "text": "Sequence profile processing"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1604"
      },
      "definition": "Entry format of DictyBase genome database.",
      "text": "DictyBase gene report format"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_3191"
      },
      "definition": "Trim sequences (typically from an automated DNA sequencer) to remove the sequence ends that extend beyond an assembled reference sequence.",
      "replacedBy": ["http://edamontology.org/operation_3192"],
      "text": "Trim to reference"
    }, {
      "comment": ["The concepts are typically provided as a persistent identifier or some other link the source ontologies. Evidence of the validity of the annotation might be included."],
      "consider": ["http://edamontology.org/data_2872"],
      "data": {
        "uri": "http://edamontology.org/data_2765"
      },
      "definition": "One or more terms from one or more controlled vocabularies which are annotations on an entity.",
      "text": "Term ID list"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_2941"
      },
      "definition": "Visualise gene expression data where each band (or line graph) corresponds to a sample.",
      "replacedBy": ["http://edamontology.org/operation_0571"],
      "text": "Whole microarray graph plotting"
    }, {
      "comment": ["References are included and a functional inference is made where possible."],
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1571"
      },
      "definition": "Entry format for the textual abstract of signatures in an InterPro entry and its protein matches.",
      "text": "InterPro entry abstract format"
    }, {
      "consider": ["http://edamontology.org/data_0850"],
      "data": {
        "uri": "http://edamontology.org/data_1237"
      },
      "definition": "Sequences generated by HMMER package in FASTA-style format.",
      "text": "HMMER synthetic sequences set"
    }, {
      "consider": ["http://edamontology.org/operation_0262"],
      "data": {
        "uri": "http://edamontology.org/operation_0261"
      },
      "definition": "Process (read and / or write) physicochemical property data of nucleic acids.",
      "text": "Nucleic acid property processing"
    }, {
      "consider": ["http://edamontology.org/data_2610"],
      "data": {
        "uri": "http://edamontology.org/data_2686"
      },
      "definition": "Identifier of an entry (exon, gene, transcript or protein) from the Ensembl 'core' database ('Macaca mulatta' division).",
      "text": "Ensembl ID ('Macaca mulatta')"
    }, {
      "comment": ["Local alignment methods identify regions of local similarity, common substructures etc."],
      "consider": ["http://edamontology.org/operation_0295", "http://edamontology.org/operation_0509"],
      "data": {
        "uri": "http://edamontology.org/operation_0507"
      },
      "definition": "Locally align (superimpose) exactly two molecular tertiary structures.",
      "text": "Pairwise structure alignment generation (local)"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0501"
      },
      "definition": "Align protein secondary structures.",
      "replacedBy": ["http://edamontology.org/operation_2488"],
      "text": "Protein secondary structure alignment generation"
    }, {
      "consider": ["http://edamontology.org/data_1883"],
      "data": {
        "uri": "http://edamontology.org/data_0948"
      },
      "definition": "A definition of a data resource serving one or more types of data, including metadata and links to the resource or data proper.",
      "text": "Data resource definition"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_3426"
      },
      "definition": "Report concerning proteomics experiments.",
      "replacedBy": ["http://edamontology.org/data_2531"],
      "text": "Proteomics experiment report"
    }, {
      "consider": ["http://edamontology.org/data_2530"],
      "data": {
        "uri": "http://edamontology.org/data_2307"
      },
      "definition": "An informative report on a specific virus.",
      "text": "Virus annotation"
    }, {
      "consider": ["http://edamontology.org/operation_2495"],
      "data": {
        "uri": "http://edamontology.org/operation_0532"
      },
      "definition": "Analyse one or more gene expression profiles, typically to interpret them in functional terms.",
      "text": "Gene expression profile analysis"
    }, {
      "consider": ["http://edamontology.org/data_2530"],
      "data": {
        "uri": "http://edamontology.org/data_2308"
      },
      "definition": "An informative report on the taxonomy of a specific virus.",
      "text": "Virus annotation (taxonomy)"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0442"
      },
      "definition": "Identify, predict or analyse cis-regulatory elements (for example riboswitches) in RNA sequences.",
      "replacedBy": ["http://edamontology.org/operation_0441"],
      "text": "Transcriptional regulatory element prediction (RNA-cis)"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1809"
      },
      "definition": "Format of a report on the DNA and protein sequences for a given gene label from a bacterial chromosome maps from the BacMap database.",
      "text": "BacMap gene card format"
    }, {
      "consider": ["http://edamontology.org/operation_0338"],
      "data": {
        "uri": "http://edamontology.org/operation_0356"
      },
      "definition": "Search sequence(s) or a sequence database for sequences of a given isoelectric point.",
      "text": "Sequence database search (by isoelectric point)"
    }, {
      "consider": ["http://edamontology.org/operation_2422"],
      "data": {
        "uri": "http://edamontology.org/operation_0345"
      },
      "definition": "Query a database and retrieve sequences containing a given keyword.",
      "text": "Sequence retrieval (by keyword)"
    }, {
      "comment": ["Methods typically involve scanning for known motifs, patterns and regular expressions."],
      "consider": ["http://edamontology.org/operation_3092"],
      "data": {
        "uri": "http://edamontology.org/operation_0414"
      },
      "definition": "Predict, recognise and identify positional features in protein sequences such as functional sites or regions and secondary structure.",
      "text": "Protein feature prediction (from sequence)"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1620"
      },
      "definition": "Entry format for the dbSNP database.",
      "text": "dbSNP polymorphism report format"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0518"
      },
      "definition": "Predict primers for genotyping polymorphisms, for example single nucleotide polymorphisms (SNPs).",
      "replacedBy": ["http://edamontology.org/operation_0308"],
      "text": "PCR primer design (for genotyping polymorphisms)"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0274"
      },
      "definition": "Identify or predict protein-protein interactions, interfaces, binding sites etc in protein sequences.",
      "replacedBy": ["http://edamontology.org/operation_2464"],
      "text": "Protein-protein interaction prediction (from protein sequence)"
    }, {
      "comment": ["ChEBI includes an ontological classification defining relations between entities or classes of entities."],
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1703"
      },
      "definition": "The format of an entry from Chemical Entities of Biological Interest (ChEBI).",
      "text": "ChEBI entry format"
    }, {
      "consider": ["http://edamontology.org/data_2526"],
      "data": {
        "uri": "http://edamontology.org/data_2857"
      },
      "definition": "Bibliographic data concerning scientific article(s).",
      "text": "Article metadata"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_1294"
      },
      "definition": "Images based on GlobPlot prediction of intrinsic disordered regions and globular domains in protein sequences.",
      "replacedBy": ["http://edamontology.org/data_2969"],
      "text": "GlobPlot domain image"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1581"
      },
      "definition": "Entry format for the FSSP database.",
      "text": "FSSP entry format"
    }, {
      "consider": ["http://edamontology.org/data_1449"],
      "data": {
        "uri": "http://edamontology.org/data_1453"
      },
      "definition": "Matrix of floating point numbers for amino acid comparison.",
      "text": "Amino acid comparison matrix (floats)"
    }, {
      "comment": ["Local alignment methods identify regions of local similarity."],
      "consider": ["http://edamontology.org/operation_0491", "http://edamontology.org/operation_0495"],
      "data": {
        "uri": "http://edamontology.org/operation_0493"
      },
      "definition": "Locally align exactly two molecular sequences.",
      "text": "Pairwise sequence alignment generation (local)"
    }, {
      "consider": ["http://edamontology.org/operation_2422"],
      "data": {
        "uri": "http://edamontology.org/operation_0254"
      },
      "definition": "Extract a sequence feature table from a sequence database entry.",
      "text": "Data retrieval (feature table)"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1698"
      },
      "definition": "The format of an entry from the KEGG COMPOUND database.",
      "text": "KEGG COMPOUND entry format"
    }, {
      "consider": ["http://edamontology.org/data_0966"],
      "data": {
        "uri": "http://edamontology.org/data_1721"
      },
      "definition": "A term from the UMLS vocabulary.",
      "text": "UMLS"
    }, {
      "consider": ["http://edamontology.org/format_1963"],
      "data": {
        "uri": "http://edamontology.org/format_1977"
      },
      "definition": "Swiss-Prot feature format.",
      "text": "swiss feature"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_0217"
      },
      "definition": "The processing and analysis of the bioinformatics literature and bibliographic data, such as literature search and query.",
      "replacedBy": ["http://edamontology.org/topic_0218"],
      "text": "Literature analysis"
    }, {
      "consider": ["http://edamontology.org/operation_0004"],
      "data": {
        "uri": "http://edamontology.org/operation_2246"
      },
      "definition": "An operation performing purely illustrative (pedagogical) purposes.",
      "text": "Demonstration"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_1824"
      },
      "definition": "Calculate the solvent accessibility ('accessible surface') for a structure as a whole.",
      "replacedBy": ["http://edamontology.org/operation_0387"],
      "text": "Protein surface calculation (accessible)"
    }, {
      "consider": ["http://edamontology.org/topic_0632"],
      "data": {
        "uri": "http://edamontology.org/topic_3032"
      },
      "definition": "The design of primers for PCR and DNA amplification or the design of molecular probes.",
      "text": "Primer or probe design"
    }, {
      "consider": ["http://edamontology.org/data_0962"],
      "data": {
        "uri": "http://edamontology.org/data_2400"
      },
      "definition": "An informative report on a specific toxin.",
      "text": "Toxin annotation"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_2443"
      },
      "definition": "Generate, process or analyse phylogenetic tree or trees.",
      "replacedBy": ["http://edamontology.org/operation_0324"],
      "text": "Phylogenetic tree processing"
    }, {
      "consider": ["http://edamontology.org/operation_2422"],
      "data": {
        "uri": "http://edamontology.org/operation_2467"
      },
      "definition": "Retrieve information on a protein.",
      "text": "Data retrieval (protein annotation)"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_3088"
      },
      "definition": "Calculate (or predict) physical or chemical properties of a protein, including any non-positional properties of the molecular sequence, from processing a protein sequence.",
      "replacedBy": ["http://edamontology.org/operation_0250"],
      "text": "Protein property calculation (from sequence)"
    }, {
      "comment": ["The resource may be specific to a group of mice / rats or all mice / rats."],
      "consider": ["http://edamontology.org/topic_0621"],
      "data": {
        "uri": "http://edamontology.org/topic_0213"
      },
      "definition": "Information on a specific mouse or rat genome including molecular sequences, genes and annotation.",
      "text": "Mice or rats"
    }, {
      "consider": ["http://edamontology.org/topic_3168"],
      "data": {
        "uri": "http://edamontology.org/topic_2842"
      },
      "definition": "Parallelised sequencing processes that are capable of sequencing many thousands of sequences simultaneously.",
      "exact_synonyms": ["Next-generation sequencing"],
      "text": "High-throughput sequencing"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_1308"
      },
      "definition": "Matrix/scaffold attachment regions (MARs/SARs) in a DNA sequence.",
      "replacedBy": ["http://edamontology.org/topic_3125"],
      "text": "Matrix/scaffold attachment sites"
    }, {
      "comment": ["This is a broad data type and is used a placeholder for other, more specific types."],
      "consider": ["http://edamontology.org/data_0962"],
      "data": {
        "uri": "http://edamontology.org/data_2601"
      },
      "definition": "Data concerning one or more small molecules.",
      "text": "Small molecule data"
    }, {
      "consider": ["http://edamontology.org/topic_0621"],
      "data": {
        "uri": "http://edamontology.org/topic_0211"
      },
      "definition": "Information on a specific fly genome including molecular sequences, genes and annotation.",
      "text": "Flies"
    }, {
      "consider": ["http://edamontology.org/operation_0295"],
      "data": {
        "uri": "http://edamontology.org/operation_2952"
      },
      "definition": "Process (read and / or write) a molecular tertiary (3D) structure alignment.",
      "text": "Structure alignment processing"
    }, {
      "consider": ["http://edamontology.org/data_1026"],
      "data": {
        "uri": "http://edamontology.org/data_1786"
      },
      "definition": "Primary name of a gene from EcoGene Database.",
      "exact_synonyms": ["EcoGene primary gene name"],
      "text": "Gene name (EcoGene primary)"
    }, {
      "consider": ["http://edamontology.org/data_2610"],
      "data": {
        "uri": "http://edamontology.org/data_2685"
      },
      "definition": "Identifier of an entry (exon, gene, transcript or protein) from the Ensembl 'core' database ('Loxodonta africana' division).",
      "text": "Ensembl ID ('Loxodonta africana')"
    }, {
      "comment": ["A displacement loop is a region of mitochondrial DNA in which one of the strands is displaced by an RNA molecule."],
      "consider": ["http://edamontology.org/data_3128"],
      "data": {
        "uri": "http://edamontology.org/data_3132"
      },
      "definition": "A report on displacement loops in a mitochondrial DNA sequence.",
      "text": "Nucleic acid features (d-loop)"
    }, {
      "comment": ["Tau is the backbone angle N-Calpha-C (angle over the C-alpha)."],
      "data": {
        "uri": "http://edamontology.org/operation_1828"
      },
      "definition": "For each amino acid in a protein structure calculate the backbone angle tau.",
      "replacedBy": ["http://edamontology.org/operation_0249"],
      "text": "Tau angle calculation"
    }, {
      "consider": ["http://edamontology.org/topic_0097"],
      "data": {
        "uri": "http://edamontology.org/topic_0697"
      },
      "definition": "RNA secondary or tertiary structure and alignments.",
      "text": "RNA structure"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_2322"
      },
      "definition": "Format of an entry from the BioCyc enzyme database.",
      "text": "BioCyc enzyme report format"
    }, {
      "consider": ["http://edamontology.org/data_1249"],
      "data": {
        "uri": "http://edamontology.org/data_1252"
      },
      "definition": "Specification of range(s) of length of sequences.",
      "text": "Sequence length range"
    }, {
      "consider": ["http://edamontology.org/data_2048"],
      "data": {
        "uri": "http://edamontology.org/data_1687"
      },
      "definition": "EMBOSS megamerger log file.",
      "text": "EMBOSS whichdb log file"
    }, {
      "consider": ["http://edamontology.org/data_0006"],
      "data": {
        "uri": "http://edamontology.org/data_1695"
      },
      "definition": "Controls the order of hits (reported matches) in an output file from a database search.",
      "text": "Hit sort order"
    }, {
      "consider": ["http://edamontology.org/format_1947"],
      "data": {
        "uri": "http://edamontology.org/format_1993"
      },
      "definition": "MSF format for (aligned) sequences.",
      "text": "msf alignment format"
    }, {
      "comment": ["This is a broad data type and is used a placeholder for other, more specific types."],
      "consider": ["http://edamontology.org/data_0914"],
      "data": {
        "uri": "http://edamontology.org/data_2927"
      },
      "definition": "Data concerning codon usage.",
      "text": "Codon usage"
    }, {
      "consider": ["http://edamontology.org/data_2339"],
      "data": {
        "uri": "http://edamontology.org/data_2584"
      },
      "definition": "The name of a concept for a cellular component from the GO ontology.",
      "text": "GO concept name (cellular component)"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0383"
      },
      "definition": "Analyse the hydrophobic, hydrophilic or charge properties of a protein structure.",
      "replacedBy": ["http://edamontology.org/operation_2574"],
      "text": "Protein hydropathy calculation (from structure)"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0519"
      },
      "definition": "Predict primers for gene transcription profiling.",
      "replacedBy": ["http://edamontology.org/operation_0308"],
      "text": "PCR primer design (for gene transcription profiling)"
    }, {
      "consider": ["http://edamontology.org/data_0867"],
      "data": {
        "uri": "http://edamontology.org/data_0866"
      },
      "definition": "Report of general information on a sequence alignment, typically include a description, sequence identifiers and alignment score.",
      "text": "Sequence alignment metadata"
    }, {
      "consider": ["http://edamontology.org/data_2530"],
      "data": {
        "uri": "http://edamontology.org/data_2396"
      },
      "definition": "An informative report on a specific fungus anamorph.",
      "text": "Fungi annotation (anamorph)"
    }, {
      "consider": ["http://edamontology.org/data_0957"],
      "data": {
        "uri": "http://edamontology.org/data_0952"
      },
      "definition": "Resource definition for an EMBOSS database.",
      "text": "EMBOSS database resource definition"
    }, {
      "consider": ["http://edamontology.org/data_2610"],
      "data": {
        "uri": "http://edamontology.org/data_2684"
      },
      "definition": "Identifier of an entry (exon, gene, transcript or protein) from the Ensembl 'core' database ('Homo sapiens' division).",
      "text": "Ensembl ID ('Homo sapiens')"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_2092"
      },
      "definition": "single nucleotide polymorphism (SNP) in a DNA sequence.",
      "replacedBy": ["http://edamontology.org/data_1276"],
      "text": "SNP"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0572"
      },
      "definition": "Identify and analyse networks of protein interactions.",
      "replacedBy": ["http://edamontology.org/operation_3925"],
      "text": "Protein interaction network visualisation"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_3433"
      },
      "definition": "Construct some entity (typically a molecule sequence) from component pieces.",
      "replacedBy": ["http://edamontology.org/operation_0310"],
      "text": "Assembly"
    }, {
      "comment": ["Sequence type might reflect the molecule (protein, nucleic acid etc) or the sequence itself (gapped, ambiguous etc)."],
      "consider": ["http://edamontology.org/data_0842"],
      "data": {
        "uri": "http://edamontology.org/data_1094"
      },
      "definition": "A label (text token) describing a type of molecular sequence.",
      "text": "Sequence type"
    }, {
      "consider": ["http://edamontology.org/operation_2403"],
      "data": {
        "uri": "http://edamontology.org/operation_2446"
      },
      "definition": "Process (read and / or write) one or more molecular sequences and associated annotation.",
      "text": "Sequence processing"
    }, {
      "consider": ["http://edamontology.org/data_0906"],
      "data": {
        "uri": "http://edamontology.org/data_2360"
      },
      "definition": "Data on indirect protein domain-protein domain interaction(s).",
      "text": "Domain-domain interaction (indirect)"
    }, {
      "consider": ["http://edamontology.org/data_2139"],
      "data": {
        "uri": "http://edamontology.org/data_1586"
      },
      "definition": "Melting temperature of hybridised or double stranded nucleic acid (DNA or RNA/DNA).",
      "text": "Nucleic acid melting temperature"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1616"
      },
      "definition": "Entry format of The Arabidopsis Information Resource (TAIR) genome database.",
      "text": "TAIR gene report format"
    }, {
      "comment": ["This includes tools based on PSI-BLAST."],
      "consider": ["http://edamontology.org/operation_0346"],
      "data": {
        "uri": "http://edamontology.org/operation_0351"
      },
      "definition": "Search a sequence database and retrieve sequences that are similar to a query sequence using a sequence profile-based method, or with a supplied profile as query.",
      "text": "Sequence database search (by sequence using profile-based methods)"
    }, {
      "comment": ["This is a broad data type and is used  for example for reports on confidence, shape or stratigraphic (age) data derived from phylogenetic tree analysis."],
      "consider": ["http://edamontology.org/data_2523"],
      "data": {
        "uri": "http://edamontology.org/data_1438"
      },
      "definition": "A report of data concerning or derived from a phylogenetic tree, or from comparing two or more phylogenetic trees.",
      "text": "Phylogenetic report"
    }, {
      "consider": ["http://edamontology.org/data_1481"],
      "data": {
        "uri": "http://edamontology.org/data_1489"
      },
      "definition": "Alignment (superimposition) of exactly two protein tertiary (3D) structures (all atoms considered).",
      "text": "Multiple protein tertiary structure alignment (all atoms)"
    }, {
      "consider": ["http://edamontology.org/data_0994"],
      "data": {
        "uri": "http://edamontology.org/format_2562"
      },
      "definition": "Text format (representation) of amino acid residues.",
      "text": "Amino acid identifier format"
    }, {
      "consider": ["http://edamontology.org/topic_0091"],
      "data": {
        "uri": "http://edamontology.org/topic_0770"
      },
      "definition": "Structuring data into basic types and (computational) objects.",
      "text": "Data types and objects"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0534"
      },
      "definition": "Assign secondary structure from protein coordinate data.",
      "replacedBy": ["http://edamontology.org/operation_0319"],
      "text": "Protein secondary structure assignment (from coordinate data)"
    }, {
      "consider": ["http://edamontology.org/operation_2495"],
      "data": {
        "uri": "http://edamontology.org/operation_2410"
      },
      "definition": "Analyse gene expression and regulation data.",
      "text": "Gene expression analysis"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_3540"
      },
      "definition": "Key residues involved in protein folding.",
      "replacedBy": ["http://edamontology.org/topic_3510"],
      "text": "Protein key folding sites"
    }, {
      "consider": ["http://edamontology.org/data_1481"],
      "data": {
        "uri": "http://edamontology.org/data_1485"
      },
      "definition": "Alignment (superimposition) of protein tertiary (3D) structures (all atoms considered).",
      "text": "Structure alignment (protein all atoms)"
    }, {
      "consider": ["http://edamontology.org/topic_0203"],
      "data": {
        "uri": "http://edamontology.org/topic_0200"
      },
      "definition": "Microarrays, for example, to process microarray data or design probes and experiments.",
      "text": "Microarrays"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_3427"
      },
      "definition": "RNAi experiments.",
      "replacedBy": ["http://edamontology.org/data_2531"],
      "text": "RNAi report"
    }, {
      "consider": ["http://edamontology.org/format_1978"],
      "data": {
        "uri": "http://edamontology.org/data_1269"
      },
      "definition": "Annotation of a molecular sequence in DAS format.",
      "text": "DAS sequence feature annotation"
    }, {
      "comment": ["Bootstrapping is often performed in phylogenetic analysis."],
      "consider": ["http://edamontology.org/data_0850"],
      "data": {
        "uri": "http://edamontology.org/data_2245"
      },
      "definition": "A collection of sequences output from a bootstrapping (resampling) procedure.",
      "text": "Sequence set (bootstrapped)"
    }, {
      "consider": ["http://edamontology.org/data_1534"],
      "data": {
        "uri": "http://edamontology.org/data_1536"
      },
      "definition": "A report on the immunogenicity of MHC class I or class II binding peptides.",
      "text": "MHC peptide immunogenicity report"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_0620"
      },
      "definition": "The structures of drugs, drug target, their interactions and binding affinities.",
      "replacedBy": ["http://edamontology.org/topic_0154"],
      "text": "Drugs and target structures"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_0178"
      },
      "definition": "The prediction of secondary or supersecondary structure of protein sequences.",
      "replacedBy": ["http://edamontology.org/topic_0082"],
      "text": "Protein secondary structure prediction"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_3061"
      },
      "definition": "The documentation of resources such as tools, services and databases and how to get help.",
      "replacedBy": ["http://edamontology.org/topic_3068"],
      "text": "Documentation and help"
    }, {
      "consider": ["http://edamontology.org/data_0006"],
      "data": {
        "uri": "http://edamontology.org/data_1693"
      },
      "definition": "Number of iterations of an algorithm.",
      "text": "Number of iterations"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1640"
      },
      "definition": "Entry format for the ArrayExpress microarrays database.",
      "text": "ArrayExpress entry format"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1653"
      },
      "definition": "The format of an entry from the aMAZE biological pathways and molecular interactions database.",
      "text": "aMAZE entry format"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_2456"
      },
      "definition": "Classify G-protein coupled receptors (GPCRs) into families and subfamilies.",
      "replacedBy": ["http://edamontology.org/operation_2995"],
      "text": "GPCR classification"
    }, {
      "consider": ["http://edamontology.org/operation_2422"],
      "data": {
        "uri": "http://edamontology.org/operation_2468"
      },
      "definition": "Retrieve a phylogenetic tree from a data resource.",
      "text": "Data retrieval (phylogenetic tree)"
    }, {
      "comment": ["This includes the results of sequence clustering, ortholog identification, assignment to families, annotation etc."],
      "consider": ["http://edamontology.org/topic_0080"],
      "data": {
        "uri": "http://edamontology.org/topic_3052"
      },
      "definition": "The comparison, grouping together and classification of macromolecules on the basis of sequence similarity.",
      "text": "Sequence clusters and classification"
    }, {
      "consider": ["http://edamontology.org/data_2968"],
      "data": {
        "uri": "http://edamontology.org/data_2142"
      },
      "definition": "An image of a graph generated by the EMBOSS suite.",
      "text": "EMBOSS graph"
    }, {
      "comment": ["This is a broad data type and is used a placeholder for other, more specific types."],
      "consider": ["http://edamontology.org/data_1354"],
      "data": {
        "uri": "http://edamontology.org/data_2982"
      },
      "definition": "Data concerning models representing a (typically multiple) sequence alignment.",
      "text": "Sequence profile data"
    }, {
      "comment": ["Use this concept for collections of specific sites which are not necessarily contiguous, rather than contiguous stretches of amino acids."],
      "consider": ["http://edamontology.org/data_1277"],
      "data": {
        "uri": "http://edamontology.org/data_1321"
      },
      "definition": "A report on predicted or known key residue positions (sites) in a protein sequence, such as binding or functional sites.",
      "text": "Protein features (sites)"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_0624"
      },
      "definition": "Study of chromosomes.",
      "replacedBy": ["http://edamontology.org/topic_0654"],
      "text": "Chromosomes"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_2807"
      },
      "definition": "A topic concerning primarily bioinformatics software tools, typically the broad function or purpose of a tool.",
      "replacedBy": ["http://edamontology.org/topic_0003"],
      "text": "Tool topic"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_2932"
      },
      "definition": "Generate a Hopp and Woods plot of antigenicity of a protein.",
      "replacedBy": ["http://edamontology.org/operation_0252"],
      "text": "Hopp and Woods plotting"
    }, {
      "consider": ["http://edamontology.org/data_2610"],
      "data": {
        "uri": "http://edamontology.org/data_2674"
      },
      "definition": "Identifier of an entry (exon, gene, transcript or protein) from the Ensembl 'core' database ('Cavia porcellus' division).",
      "text": "Ensembl ID ('Cavia porcellus')"
    }, {
      "consider": ["http://edamontology.org/data_2610"],
      "data": {
        "uri": "http://edamontology.org/data_2682"
      },
      "definition": "Identifier of an entry (exon, gene, transcript or protein) from the Ensembl 'core' database ('Gallus gallus' division).",
      "text": "Ensembl ID ('Gallus gallus')"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0517"
      },
      "definition": "Predict primers for large scale sequencing.",
      "replacedBy": ["http://edamontology.org/operation_0308"],
      "text": "PCR primer design (for large scale sequencing)"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0421"
      },
      "definition": "Predict protein sites that are key to protein folding, such as possible sites of nucleation or stabilisation.",
      "replacedBy": ["http://edamontology.org/operation_2415"],
      "text": "Protein folding site prediction"
    }, {
      "consider": ["http://edamontology.org/data_0949"],
      "data": {
        "uri": "http://edamontology.org/data_2972"
      },
      "definition": "A computational workflow.",
      "text": "Workflow"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1704"
      },
      "definition": "The format of an entry from the MSDchem ligand dictionary.",
      "text": "MSDchem ligand dictionary entry format"
    }, {
      "comment": ["Protein domain signatures identify structural or functional domains or other units with defined boundaries."],
      "consider": ["http://edamontology.org/data_1355"],
      "data": {
        "uri": "http://edamontology.org/data_1373"
      },
      "definition": "A protein domain signature (sequence classifier) from the InterPro database.",
      "text": "Protein domain signature"
    }, {
      "consider": ["http://edamontology.org/data_2093"],
      "data": {
        "uri": "http://edamontology.org/data_1674"
      },
      "definition": "Cross-references from a sequence record to other databases.",
      "text": "Sequence database cross-references"
    }, {
      "consider": ["http://edamontology.org/data_2968"],
      "data": {
        "uri": "http://edamontology.org/data_2967"
      },
      "definition": "An image from a microarray experiment which (typically) allows a visualisation of probe hybridisation and gene-expression data.",
      "text": "Microarray image"
    }, {
      "consider": ["http://edamontology.org/data_2610"],
      "data": {
        "uri": "http://edamontology.org/data_2690"
      },
      "definition": "Identifier of an entry (exon, gene, transcript or protein) from the Ensembl 'core' database ('Ornithorhynchus anatinus' division).",
      "text": "Ensembl ID (\"Ornithorhynchus anatinus\")"
    }, {
      "consider": ["http://edamontology.org/data_0871"],
      "data": {
        "uri": "http://edamontology.org/data_2242"
      },
      "definition": "Phylogenetic property values data.",
      "text": "Phylogenetic property values"
    }, {
      "comment": ["Solvent accessibility might be calculated for the backbone, sidechain and total (backbone plus sidechain)."],
      "data": {
        "uri": "http://edamontology.org/operation_1820"
      },
      "definition": "Calculate the solvent accessibility ('vacuum accessible surface') for each residue in a structure. This is the accessibility of the residue when taken out of the protein together with the backbone atoms of any residue it is covalently bound to.",
      "replacedBy": ["http://edamontology.org/operation_0387"],
      "text": "Protein residue surface calculation (vacuum accessible)"
    }, {
      "consider": ["http://edamontology.org/data_1026"],
      "data": {
        "uri": "http://edamontology.org/data_1787"
      },
      "definition": "Name of a gene from MaizeGDB (maize genes) database.",
      "text": "Gene name (MaizeGDB)"
    }, {
      "comment": ["Protein family signatures cover all domains in the matching proteins and span >80% of the protein length and with no adjacent protein domain signatures or protein region signatures."],
      "consider": ["http://edamontology.org/data_1355"],
      "data": {
        "uri": "http://edamontology.org/data_1372"
      },
      "definition": "A protein family signature (sequence classifier) from the InterPro database.",
      "text": "Protein family signature"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_3537"
      },
      "definition": "Chemical modification of a protein.",
      "replacedBy": ["http://edamontology.org/topic_0601"],
      "text": "Protein chemical modifications"
    }, {
      "consider": ["http://edamontology.org/data_1448"],
      "data": {
        "uri": "http://edamontology.org/data_1450"
      },
      "definition": "Matrix of integer numbers for nucleotide comparison.",
      "exact_synonyms": ["Nucleotide substitution matrix (integers)"],
      "text": "Nucleotide comparison matrix (integers)"
    }, {
      "comment": ["This concept may be used for sequence sets that are expected to be read and processed a single sequence at a time."],
      "consider": ["http://edamontology.org/data_0850"],
      "data": {
        "uri": "http://edamontology.org/data_2173"
      },
      "definition": "A collection of multiple molecular sequences and (typically) associated metadata that is intended for sequential processing.",
      "text": "Sequence set (stream)"
    }, {
      "comment": ["This can include an entire classification, components such as classifiers, assignments of entities to a classification and so on."],
      "consider": ["http://edamontology.org/data_2048"],
      "data": {
        "uri": "http://edamontology.org/data_2987"
      },
      "definition": "A report on a classification of molecular sequences, structures or other entities.",
      "text": "Classification report"
    }, {
      "comment": ["This is a broad data type and is used a placeholder for other, more specific types.  It is primarily intended to help navigation of EDAM and would not typically be used for annotation."],
      "consider": ["http://edamontology.org/data_1255"],
      "data": {
        "uri": "http://edamontology.org/data_1256"
      },
      "definition": "Comparative data on sequence features such as statistics, intersections (and data on intersections), differences etc.",
      "text": "Sequence features (comparative)"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1569"
      },
      "definition": "Entry format for the IntAct database of protein interaction.",
      "text": "IntAct entry format"
    }, {
      "consider": ["http://edamontology.org/data_1481", "http://edamontology.org/data_1479"],
      "data": {
        "uri": "http://edamontology.org/data_1483"
      },
      "definition": "Alignment (superimposition) of exactly two protein tertiary (3D) structures.",
      "text": "Structure alignment (protein pair)"
    }, {
      "consider": ["http://edamontology.org/data_2085"],
      "data": {
        "uri": "http://edamontology.org/data_2881"
      },
      "definition": "An informative report on general information, properties or features of one or more molecular secondary structures.",
      "text": "Secondary structure report"
    }, {
      "consider": ["http://edamontology.org/data_0916"],
      "data": {
        "uri": "http://edamontology.org/data_1314"
      },
      "definition": "A report on selenocysteine insertion sequence (SECIS) element in a DNA sequence.",
      "text": "Gene features (SECIS element)"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_2831"
      },
      "definition": "A flat-file (textual) data archive.",
      "replacedBy": ["http://edamontology.org/data_0957"],
      "text": "Databank"
    }, {
      "consider": ["http://edamontology.org/data_1026"],
      "data": {
        "uri": "http://edamontology.org/data_1792"
      },
      "definition": "Symbol of a gene from the Mouse Genome Database.",
      "text": "Gene name (MGD)"
    }, {
      "consider": ["http://edamontology.org/topic_0078"],
      "data": {
        "uri": "http://edamontology.org/topic_2225"
      },
      "definition": "Protein data resources.",
      "text": "Protein databases"
    }, {
      "consider": ["http://edamontology.org/topic_0621"],
      "data": {
        "uri": "http://edamontology.org/topic_3048"
      },
      "definition": "Mammals, e.g. information on a specific mammal genome including molecular sequences, genes and annotation.",
      "text": "Mammals"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_2323"
      },
      "definition": "Format of an entry from the Enzyme nomenclature database (ENZYME).",
      "text": "ENZYME enzyme report format"
    }, {
      "consider": ["http://edamontology.org/data_2534"],
      "data": {
        "uri": "http://edamontology.org/data_2145"
      },
      "definition": "An offset for a single-point sequence position.",
      "text": "Sequence offset"
    }, {
      "consider": ["http://edamontology.org/format_1927"],
      "data": {
        "uri": "http://edamontology.org/format_1980"
      },
      "definition": "EMBL feature format.",
      "text": "EMBL feature"
    }, {
      "consider": ["http://edamontology.org/data_1468"],
      "data": {
        "uri": "http://edamontology.org/data_1473"
      },
      "definition": "3D coordinate and associated data for a protein domain tertiary (3D) structure (all atoms).",
      "text": "Protein domain (all atoms)"
    }, {
      "consider": ["http://edamontology.org/operation_2480"],
      "data": {
        "uri": "http://edamontology.org/operation_2482"
      },
      "definition": "Process (read and / or write) a molecular secondary structure.",
      "text": "Secondary structure processing"
    }, {
      "comment": ["For example trim polyA tails, introns and primer sequence flanking the sequence of amplified exons, or other unwanted sequence."],
      "data": {
        "uri": "http://edamontology.org/operation_3189"
      },
      "definition": "Trim sequences (typically from an automated DNA sequencer) to remove misleading ends.",
      "replacedBy": ["http://edamontology.org/operation_3192"],
      "text": "Trim ends"
    }, {
      "consider": ["http://edamontology.org/operation_0475", "http://edamontology.org/operation_0474"],
      "data": {
        "uri": "http://edamontology.org/operation_0271"
      },
      "definition": "Predict tertiary structure of a molecular (biopolymer) sequence.",
      "text": "Structure prediction"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0385"
      },
      "definition": "Identify clusters of hydrophobic or charged residues in a protein structure.",
      "replacedBy": ["http://edamontology.org/operation_0393"],
      "text": "Protein hydropathy cluster calculation"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_3202"
      },
      "definition": "Detect mutations in multiple DNA sequences, for example, from the alignment and comparison of the fluorescent traces produced by DNA sequencing hardware.",
      "replacedBy": ["http://edamontology.org/operation_3227"],
      "text": "Polymorphism detection"
    }, {
      "consider": ["http://edamontology.org/data_1026"],
      "data": {
        "uri": "http://edamontology.org/data_1793"
      },
      "definition": "Symbol of a gene from Bacillus subtilis Genome Sequence Project.",
      "text": "Gene name (Bacillus subtilis)"
    }, {
      "consider": ["http://edamontology.org/data_2339"],
      "data": {
        "uri": "http://edamontology.org/data_2581"
      },
      "definition": "The name of a concept from the GO ontology.",
      "text": "GO concept name"
    }, {
      "consider": ["http://edamontology.org/data_0842"],
      "data": {
        "uri": "http://edamontology.org/data_0975"
      },
      "definition": "An identifier of a data resource.",
      "text": "Data resource identifier"
    }, {
      "consider": ["http://edamontology.org/format_1475"],
      "data": {
        "uri": "http://edamontology.org/format_1918"
      },
      "definition": "Data format for an individual atom.",
      "text": "Atomic data format"
    }, {
      "consider": ["http://edamontology.org/data_0912"],
      "data": {
        "uri": "http://edamontology.org/data_1258"
      },
      "definition": "A report of general sequence properties derived from nucleotide sequence data.",
      "text": "Sequence property (nucleic acid)"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_3515"
      },
      "definition": "Protein-drug interaction(s).",
      "replacedBy": ["http://edamontology.org/topic_0128"],
      "text": "Protein-drug interactions"
    }, {
      "consider": ["http://edamontology.org/data_2610"],
      "data": {
        "uri": "http://edamontology.org/data_2678"
      },
      "definition": "Identifier of an entry (exon, gene, transcript or protein) from the Ensembl 'core' database ('Dasypus novemcinctus' division).",
      "text": "Ensembl ID ('Dasypus novemcinctus')"
    }, {
      "consider": ["http://edamontology.org/data_0867"],
      "data": {
        "uri": "http://edamontology.org/data_1414"
      },
      "definition": "Data on molecular sequence alignment quality (estimated accuracy).",
      "text": "Sequence alignment metadata (quality report)"
    }, {
      "comment": ["This includes signature metadata, sequence references and a reference to the signature itself. There is normally a header (entry accession numbers and name), abstract, taxonomy information, example proteins etc. Each entry also includes a match list which give a number of different views of the signature matches for the sequences in each InterPro entry."],
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1570"
      },
      "definition": "Entry format for the InterPro database of protein signatures (sequence classifiers) and classified sequences.",
      "text": "InterPro entry format"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_1326"
      },
      "definition": "ligand-binding (non-catalytic) residues of a protein, such as sites that bind metal, prosthetic groups or lipids.",
      "replacedBy": ["http://edamontology.org/data_1277"],
      "text": "Protein features report (binding sites)"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_2414"
      },
      "definition": "Analyse protein function, typically by processing protein sequence and/or structural data, and generate an informative report.",
      "replacedBy": ["http://edamontology.org/operation_1777"],
      "text": "Protein function analysis"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_2934"
      },
      "definition": "Generate a view of clustered quantitative data, annotated with textual information.",
      "replacedBy": ["http://edamontology.org/operation_2938"],
      "text": "Cluster textual view generation"
    }, {
      "consider": ["http://edamontology.org/data_0850"],
      "data": {
        "uri": "http://edamontology.org/data_1241"
      },
      "definition": "File of sequence vectors used by EMBOSS vectorstrip application, or any file in same format.",
      "text": "vectorstrip cloning vector definition file"
    }, {
      "consider": ["http://edamontology.org/topic_0081"],
      "data": {
        "uri": "http://edamontology.org/topic_0167"
      },
      "definition": "The processing, analysis or use of some type of structural (3D) profile or template; a computational entity (typically a numerical matrix) that is derived from and represents a structure or structure alignment.",
      "text": "Structural (3D) profiles"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1607"
      },
      "definition": "Entry format of EcoCyc genome database.",
      "text": "EcoCyc gene report format"
    }, {
      "comment": ["The resource may be specific to a fungus, a group of fungi or all fungi."],
      "consider": ["http://edamontology.org/topic_0621"],
      "data": {
        "uri": "http://edamontology.org/topic_0782"
      },
      "definition": "Fungi and molds, e.g. information on a specific fungal genome including molecular sequences, genes and annotation.",
      "narrow_synonyms": ["Yeast"],
      "text": "Fungi"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1623"
      },
      "definition": "Format of an entry from the OMIM database of genotypes and phenotypes.",
      "text": "OMIM entry format"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_2627"
      },
      "definition": "Identifier of a report of molecular interactions from a database (typically).",
      "replacedBy": ["http://edamontology.org/data_1074"],
      "text": "Molecular interaction ID"
    }, {
      "comment": ["The report (for example http://www.cathdb.info/pdb/1cuk) includes chain identifiers, domain identifiers and CATH codes for domains in a given PDB file."],
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1761"
      },
      "definition": "Format of CATH domain classification information for a protein PDB file.",
      "text": "CATH PDB report format"
    }, {
      "consider": ["http://edamontology.org/data_1235"],
      "data": {
        "uri": "http://edamontology.org/data_1764"
      },
      "definition": "FASTA sequence database (based on ATOM records in PDB) for CATH domains (clustered at different levels of sequence identity).",
      "text": "CATH representative domain sequences (ATOM)"
    }, {
      "consider": ["http://edamontology.org/data_0967"],
      "data": {
        "uri": "http://edamontology.org/data_1732"
      },
      "definition": "A comment on a concept from an ontology.",
      "text": "Ontology concept comment"
    }, {
      "consider": ["http://edamontology.org/data_2048"],
      "data": {
        "uri": "http://edamontology.org/data_1685"
      },
      "definition": "EMBOSS (EMBASSY) supermatcher error file.",
      "text": "EMBOSS supermatcher error file"
    }, {
      "consider": ["http://edamontology.org/data_2285"],
      "data": {
        "uri": "http://edamontology.org/data_1887"
      },
      "definition": "Identifier for genetic elements in MIPS Maize database.",
      "text": "Gene ID (MIPS Maize)"
    }, {
      "consider": ["http://edamontology.org/data_1399"],
      "data": {
        "uri": "http://edamontology.org/data_1409"
      },
      "definition": "A simple floating point number defining the penalty for gaps that are close together in an alignment.",
      "text": "Gap separation penalty (float)"
    }, {
      "consider": ["http://edamontology.org/topic_0160"],
      "data": {
        "uri": "http://edamontology.org/topic_3072"
      },
      "definition": "The detection of the positional features, such as functional and other key sites, in molecular sequences.",
      "text": "Sequence feature detection"
    }, {
      "consider": ["http://edamontology.org/operation_2422"],
      "data": {
        "uri": "http://edamontology.org/operation_2222"
      },
      "definition": "Search and retrieve documentation on a bioinformatics ontology.",
      "text": "Data retrieval (ontology annotation)"
    }, {
      "consider": ["http://edamontology.org/data_2610"],
      "data": {
        "uri": "http://edamontology.org/data_2677"
      },
      "definition": "Identifier of an entry (exon, gene, transcript or protein) from the Ensembl 'core' database ('Danio rerio' division).",
      "text": "Ensembl ID ('Danio rerio')"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0473"
      },
      "definition": "Analyse G-protein coupled receptor proteins (GPCRs).",
      "replacedBy": ["http://edamontology.org/operation_0270"],
      "text": "GPCR analysis"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1614"
      },
      "definition": "Entry format of the Saccharomyces Genome Database (SGD).",
      "text": "SGD gene report format"
    }, {
      "consider": ["http://edamontology.org/topic_0780"],
      "data": {
        "uri": "http://edamontology.org/topic_0787"
      },
      "definition": "Rice-specific data.",
      "text": "Rice"
    }, {
      "consider": ["http://edamontology.org/operation_2409"],
      "data": {
        "uri": "http://edamontology.org/operation_2120"
      },
      "definition": "Process an EMBOSS listfile (list of EMBOSS Uniform Sequence Addresses).",
      "text": "Listfile processing"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0563"
      },
      "definition": "Reformat a codon usage table.",
      "replacedBy": ["http://edamontology.org/operation_0335"],
      "text": "Codon usage table formatting"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_3525"
      },
      "definition": "Protein-DNA/RNA interaction(s).",
      "replacedBy": ["http://edamontology.org/topic_0128"],
      "text": "Protein-nucleic acid interactions"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0467"
      },
      "definition": "Predict secondary structure of protein sequence(s) using multiple methods to achieve better predictions.",
      "replacedBy": ["http://edamontology.org/operation_0267"],
      "text": "Protein secondary structure prediction (integrated)"
    }, {
      "consider": ["http://edamontology.org/data_0967"],
      "data": {
        "uri": "http://edamontology.org/data_1730"
      },
      "definition": "A relation type defined in an ontology.",
      "text": "Ontology relation type"
    }, {
      "consider": ["http://edamontology.org/data_0842"],
      "data": {
        "uri": "http://edamontology.org/data_1152"
      },
      "definition": "Identifier of an entry from the HIVDB database.",
      "text": "HIVDB identifier"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_3165"
      },
      "definition": "sequencing experiment, including samples, sampling, preparation, sequencing, and analysis.",
      "replacedBy": ["http://edamontology.org/data_2531"],
      "text": "NGS experiment"
    }, {
      "consider": ["http://edamontology.org/data_1467"],
      "data": {
        "uri": "http://edamontology.org/data_1471"
      },
      "definition": "3D coordinate and associated data for a polypeptide chain tertiary (3D) structure (all atoms).",
      "text": "Protein chain (all atoms)"
    }, {
      "comment": ["The report might include derived data map such as classification, annotation, organisation, periodicity etc."],
      "consider": ["http://edamontology.org/data_1255"],
      "data": {
        "uri": "http://edamontology.org/data_1299"
      },
      "definition": "Location of short repetitive subsequences (repeat sequences) in (typically nucleotide) sequences.",
      "text": "Sequence features (repeats)"
    }, {
      "comment": ["Word-based methods (for example BLAST, gapped BLAST, MEGABLAST, WU-BLAST etc.) are usually quicker than alignment-based methods. They may or may not handle gaps."],
      "consider": ["http://edamontology.org/operation_0346"],
      "data": {
        "uri": "http://edamontology.org/operation_0350"
      },
      "definition": "Search a sequence database and retrieve sequences that are similar to a query sequence using a word-based method.",
      "text": "Sequence database search (by sequence using word-based methods)"
    }, {
      "consider": ["http://edamontology.org/data_1622"],
      "data": {
        "uri": "http://edamontology.org/data_2217"
      },
      "definition": "An informative report on a specific tumor including nature and origin of the sample, anatomic site, organ or tissue, tumor type, including morphology and/or histologic type, and so on.",
      "text": "Tumor annotation"
    }, {
      "consider": ["http://edamontology.org/operation_2422"],
      "data": {
        "uri": "http://edamontology.org/operation_0357"
      },
      "definition": "Query a tertiary structure database and retrieve entries with a given entry code or accession number.",
      "text": "Structure retrieval (by code)"
    }, {
      "consider": ["http://edamontology.org/data_3779", "http://edamontology.org/data_0972"],
      "data": {
        "uri": "http://edamontology.org/data_2954"
      },
      "definition": "Data derived from the analysis of a scientific text such as a full text article from a scientific journal.",
      "text": "Article report"
    }, {
      "comment": ["STSs are genetic markers that are easily detected by the polymerase chain reaction (PCR) using specific primers."],
      "consider": ["http://edamontology.org/operation_0346"],
      "data": {
        "uri": "http://edamontology.org/operation_0354"
      },
      "definition": "Search a DNA database (for example a database of conserved sequence tags) for matches to Sequence-Tagged Site (STS) primer sequences.",
      "text": "Sequence database search (by sequence for primer sequences)"
    }, {
      "consider": ["http://edamontology.org/data_2048"],
      "data": {
        "uri": "http://edamontology.org/data_2251"
      },
      "definition": "A relax-NG schema.",
      "text": "Relax-NG schema"
    }, {
      "comment": ["This is a broad data type and is used a placeholder for other, more specific types."],
      "consider": ["http://edamontology.org/data_0896"],
      "data": {
        "uri": "http://edamontology.org/data_2524"
      },
      "definition": "Data concerning one or more protein molecules.",
      "text": "Protein data"
    }, {
      "comment": ["This is a broad data type and is used a placeholder for other, more specific types.  It is primarily intended to help navigation of EDAM and would not typically be used for annotation."],
      "consider": ["http://edamontology.org/data_0896"],
      "data": {
        "uri": "http://edamontology.org/data_0904"
      },
      "definition": "Data on the effect of (typically point) mutation on protein folding, stability, structure and function.",
      "text": "Protein features (mutation)"
    }, {
      "comment": ["This includes systems that generate, process and analyse sequence clusters."],
      "data": {
        "uri": "http://edamontology.org/topic_0164"
      },
      "definition": "The comparison and grouping together of molecular sequences on the basis of their similarities.",
      "replacedBy": ["http://edamontology.org/topic_0080"],
      "text": "Sequence clustering"
    }, {
      "consider": ["http://edamontology.org/operation_2421"],
      "data": {
        "uri": "http://edamontology.org/operation_3093"
      },
      "definition": "Screen a molecular sequence(s) against a database (of some type) to identify similarities between the sequence and database entries.",
      "text": "Database search (by sequence)"
    }, {
      "consider": ["http://edamontology.org/data_0850"],
      "data": {
        "uri": "http://edamontology.org/data_1766"
      },
      "definition": "FASTA sequence database for all CATH domains (based on PDB ATOM records).",
      "text": "CATH domain sequences (ATOM)"
    }, {
      "consider": ["http://edamontology.org/data_0907"],
      "data": {
        "uri": "http://edamontology.org/data_3143"
      },
      "definition": "Information on a 'superfamily' node from the SCOP database.",
      "text": "SCOP superfamily"
    }, {
      "consider": ["http://edamontology.org/data_2048"],
      "data": {
        "uri": "http://edamontology.org/data_1682"
      },
      "definition": "EMBOSS wordfinder log file.",
      "text": "EMBOSS wordfinder log file"
    }, {
      "consider": ["http://edamontology.org/operation_0295"],
      "data": {
        "uri": "http://edamontology.org/operation_0505"
      },
      "definition": "Align protein tertiary structures.",
      "text": "Structure alignment (protein)"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1650"
      },
      "definition": "The format of an entry from the INOH signal transduction pathways database.",
      "text": "INOH entry format"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1613"
      },
      "definition": "Entry format of the Rat Genome Database (RGD).",
      "text": "RGD gene report format"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_0079"
      },
      "definition": "The structures of reactants or products of metabolism, for example small molecules such as including vitamins, polyols, nucleotides and amino acids.",
      "replacedBy": ["http://edamontology.org/topic_0154"],
      "text": "Metabolites"
    }, {
      "data": {
        "uri": "http://edamontology.org/format_1976"
      },
      "definition": "PIR feature format.",
      "replacedBy": ["http://edamontology.org/format_1948"],
      "text": "pir"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_0177"
      },
      "definition": "The modelling the structure of proteins in complex with small molecules or other macromolecules.",
      "replacedBy": ["http://edamontology.org/topic_2275"],
      "text": "Molecular docking"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_3530"
      },
      "definition": "Genetic information processing pathways.",
      "replacedBy": ["http://edamontology.org/topic_0602"],
      "text": "Genetic information processing pathways"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_1306"
      },
      "definition": "Report on nucleosome formation potential or exclusion sequence(s).",
      "replacedBy": ["http://edamontology.org/data_1276"],
      "text": "Nucleosome exclusion sequences"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0521"
      },
      "definition": "Predict primers based on gene structure.",
      "replacedBy": ["http://edamontology.org/operation_0308"],
      "text": "PCR primer design (based on gene structure)"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_1842"
      },
      "definition": "Calculate for each position in a protein structure the chance that a proline, when introduced at this position, would increase the stability of the whole protein.",
      "replacedBy": ["http://edamontology.org/operation_0331"],
      "text": "Proline mutation value calculation"
    }, {
      "comment": ["This includes a gene name and abbreviation of the name which may be in a name space indicating the gene status and relevant organisation."],
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1808"
      },
      "definition": "Report format for biological functions associated with a gene name and its alternative names (synonyms, homonyms), as generated by the GeneIlluminator service.",
      "text": "GeneIlluminator gene report format"
    }, {
      "consider": ["http://edamontology.org/operation_2422"],
      "data": {
        "uri": "http://edamontology.org/operation_2472"
      },
      "definition": "Retrieve information on a specific gene.",
      "text": "Data retrieval (gene annotation)"
    }, {
      "consider": ["http://edamontology.org/data_0842"],
      "data": {
        "uri": "http://edamontology.org/data_0980"
      },
      "definition": "Name or other identifier of a collection of discrete biological entities.",
      "text": "Entity collection identifier"
    }, {
      "consider": ["http://edamontology.org/data_0842"],
      "data": {
        "uri": "http://edamontology.org/data_0979"
      },
      "definition": "Name or other identifier of an entity feature (a physical part or region of a discrete biological entity, or a feature that can be mapped to such a thing).",
      "text": "Entity feature identifier"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_1567"
      },
      "definition": "protein-DNA/RNA interaction(s).",
      "replacedBy": ["http://edamontology.org/data_0906"],
      "text": "Protein-nucleic acid interactions report"
    }, {
      "consider": ["http://edamontology.org/topic_0623"],
      "data": {
        "uri": "http://edamontology.org/topic_0595"
      },
      "definition": "primarily the classification of proteins (from sequence or structural data) into clusters, groups, families etc.",
      "text": "Protein classification"
    }, {
      "consider": ["http://edamontology.org/data_1277"],
      "data": {
        "uri": "http://edamontology.org/data_1329"
      },
      "definition": "A report on epitopes that bind to MHC class I molecules.",
      "text": "MHC Class I epitopes report"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_3430"
      },
      "definition": "Predict, recognise and identify functional or other key sites within nucleic acid sequences, typically by scanning for known motifs, patterns and regular expressions.",
      "replacedBy": ["http://edamontology.org/operation_0415"],
      "text": "Nucleic acid sequence feature detection"
    }, {
      "consider": ["http://edamontology.org/data_1410", "http://edamontology.org/data_1411"],
      "data": {
        "uri": "http://edamontology.org/data_1400"
      },
      "definition": "A penalty for gaps at the termini of an alignment, either from the N/C terminal of protein or 5'/3' terminal of nucleotide sequences.",
      "text": "Terminal gap penalty"
    }, {
      "consider": ["http://edamontology.org/topic_0089"],
      "data": {
        "uri": "http://edamontology.org/topic_2230"
      },
      "definition": "Topic focused on identifying, grouping, or naming things in a structured way according to some schema based on observable relationships.",
      "text": "Classification"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_3533"
      },
      "definition": "Catalytic residues (active site) of an enzyme.",
      "replacedBy": ["http://edamontology.org/topic_3510"],
      "text": "Protein active sites"
    }, {
      "consider": ["http://edamontology.org/data_0950"],
      "data": {
        "uri": "http://edamontology.org/data_1346"
      },
      "definition": "File of directives for ordering and spacing of MEME motifs.",
      "text": "MEME motifs directive file"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1626"
      },
      "definition": "Format of an entry from the KEGG DISEASE database.",
      "text": "KEGG DISEASE entry format"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1516"
      },
      "definition": "Format of an entry from the withrefm section of the REBASE enzyme database.",
      "text": "REBASE withrefm enzyme report format"
    }, {
      "consider": ["http://edamontology.org/topic_0123"],
      "data": {
        "uri": "http://edamontology.org/topic_0137"
      },
      "definition": "The study of the hydrophobic, hydrophilic and charge properties of a protein.",
      "text": "Protein hydropathy"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0472"
      },
      "definition": "Predict G protein-coupled receptors (GPCR).",
      "replacedBy": ["http://edamontology.org/operation_0269"],
      "text": "GPCR prediction"
    }, {
      "consider": ["http://edamontology.org/topic_3168"],
      "data": {
        "uri": "http://edamontology.org/topic_3177"
      },
      "definition": "A topic concerning high-throughput sequencing of randomly fragmented genomic DNA, for example, to investigate whole-genome sequencing and resequencing, SNP discovery, identification of copy number variations and chromosomal rearrangements.",
      "text": "DNA-Seq"
    }, {
      "consider": ["http://edamontology.org/data_0966"],
      "data": {
        "uri": "http://edamontology.org/data_1725"
      },
      "definition": "A term from the MGED ontology.",
      "text": "MGED"
    }, {
      "consider": ["http://edamontology.org/operation_0239"],
      "data": {
        "uri": "http://edamontology.org/operation_0342"
      },
      "definition": "Search a database of sequence profiles with a query sequence.",
      "text": "Sequence profile database search"
    }, {
      "consider": ["http://edamontology.org/topic_0160"],
      "data": {
        "uri": "http://edamontology.org/topic_3074"
      },
      "definition": "The detection, identification and analysis of positional protein sequence features, such as functional sites.",
      "text": "Protein feature detection"
    }, {
      "consider": ["http://edamontology.org/data_2610"],
      "data": {
        "uri": "http://edamontology.org/data_2694"
      },
      "definition": "Identifier of an entry (exon, gene, transcript or protein) from the Ensembl 'core' database ('Pan troglodytes' division).",
      "text": "Ensembl ID ('Pan troglodytes')"
    }, {
      "consider": ["http://edamontology.org/data_1026"],
      "data": {
        "uri": "http://edamontology.org/data_2740"
      },
      "definition": "Name of an entry (gene) from the Genolist genes database.",
      "exact_synonyms": ["Genolist gene name"],
      "text": "Gene name (Genolist)"
    }, {
      "comment": ["The query is a structure-based entity such as another structure, a 3D (structural) motif, 3D profile or template."],
      "consider": ["http://edamontology.org/topic_0081"],
      "data": {
        "uri": "http://edamontology.org/topic_2271"
      },
      "definition": "Search for and retrieve molecular structures that are similar to a structure-based query (typically another structure or part of a structure).",
      "text": "Structure database search"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0497"
      },
      "definition": "Align two or more molecular sequences with user-defined constraints.",
      "replacedBy": ["http://edamontology.org/operation_0292"],
      "text": "Constrained sequence alignment"
    }, {
      "comment": ["Values for EBI services are 'DONE' (job has finished and the results can then be retrieved), 'ERROR' (the job failed or no results where found), 'NOT_FOUND' (the job id is no longer available; job results might be deleted, 'PENDING' (the job is in a queue waiting processing), 'RUNNING' (the job is currently being processed)."],
      "consider": ["http://edamontology.org/data_3106"],
      "data": {
        "uri": "http://edamontology.org/data_1675"
      },
      "definition": "Metadata on the status of a submitted job.",
      "text": "Job status"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_2506"
      },
      "definition": "Analyse a protein sequence alignment, typically to detect features or make predictions.",
      "replacedBy": ["http://edamontology.org/operation_2479"],
      "text": "Protein sequence alignment analysis"
    }, {
      "consider": ["http://edamontology.org/data_2969"],
      "data": {
        "uri": "http://edamontology.org/data_1293"
      },
      "definition": "SMART protein schematic in PNG format.",
      "text": "SMART protein schematic"
    }, {
      "consider": ["http://edamontology.org/data_1026"],
      "data": {
        "uri": "http://edamontology.org/data_1806"
      },
      "definition": "Any name (other than the recommended one) for a gene.",
      "text": "Gene synonym"
    }, {
      "comment": ["C-beta atoms from amino acid side-chains may be considered."],
      "consider": ["http://edamontology.org/data_1481"],
      "data": {
        "uri": "http://edamontology.org/data_1486"
      },
      "definition": "Alignment (superimposition) of protein tertiary (3D) structures (typically C-alpha atoms only considered).",
      "text": "Structure alignment (protein C-alpha atoms)"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_2867"
      },
      "definition": "Variable number of tandem repeat (VNTR) polymorphism in a DNA sequence.",
      "replacedBy": ["http://edamontology.org/topic_2885"],
      "text": "VNTR"
    }, {
      "comment": ["A HET group usually corresponds to ligands, lipids, but might also (not consistently) include groups that are attached to amino acids. Each HET group is supposed to have a unique three letter code and a unique name which might be given in the output."],
      "data": {
        "uri": "http://edamontology.org/operation_1846"
      },
      "definition": "Identify HET groups in PDB files.",
      "replacedBy": ["http://edamontology.org/operation_2950"],
      "text": "HET group detection"
    }, {
      "comment": ["Waters are not considered."],
      "data": {
        "uri": "http://edamontology.org/operation_1817"
      },
      "definition": "Calculate the solvent accessibility ('accessible surface') for each atom in a structure.",
      "replacedBy": ["http://edamontology.org/operation_0387"],
      "text": "Protein atom surface calculation (accessible)"
    }, {
      "consider": ["http://edamontology.org/data_0842"],
      "data": {
        "uri": "http://edamontology.org/data_0974"
      },
      "definition": "An identifier of a biological entity or phenomenon.",
      "text": "Entity identifier"
    }, {
      "consider": ["http://edamontology.org/operation_2495"],
      "data": {
        "uri": "http://edamontology.org/operation_0529"
      },
      "definition": "Process (read and / or write) massively parallel signature sequencing (MPSS) data.",
      "text": "MPSS data processing"
    }, {
      "consider": ["http://edamontology.org/data_0906"],
      "data": {
        "uri": "http://edamontology.org/data_2599"
      },
      "definition": "An informative report on the physical, chemical or other information concerning the interaction of two or more molecules (or parts of molecules).",
      "text": "Molecule interaction report"
    }, {
      "consider": ["http://edamontology.org/topic_0121"],
      "data": {
        "uri": "http://edamontology.org/topic_0135"
      },
      "definition": "Protein microarray data.",
      "text": "Protein microarrays"
    }, {
      "consider": ["http://edamontology.org/data_0582"],
      "data": {
        "uri": "http://edamontology.org/data_1884"
      },
      "definition": "A controlled vocabulary for words and phrases that can appear in the keywords field (KW line) of entries from the UniProt database.",
      "text": "UniProt keywords"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_2511"
      },
      "definition": "Edit or change a nucleic acid sequence, either randomly or specifically.",
      "replacedBy": ["http://edamontology.org/operation_0231"],
      "text": "Sequence editing (nucleic acid)"
    }, {
      "consider": ["http://edamontology.org/data_0907"],
      "data": {
        "uri": "http://edamontology.org/data_1557"
      },
      "definition": "Information on a protein 'architecture' node from the CATH database.",
      "text": "CATH architecture"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1624"
      },
      "definition": "Format of a record from the HGVbase database of genotypes and phenotypes.",
      "text": "HGVbase entry format"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_1456"
      },
      "definition": "Trans- or intra-membrane regions of a protein, typically describing physicochemical properties of the secondary structure elements.",
      "replacedBy": ["http://edamontology.org/topic_0736"],
      "text": "Protein membrane regions"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_3428"
      },
      "definition": "biological computational model experiments (simulation), for example the minimum information required in order to permit its correct interpretation and reproduction.",
      "replacedBy": ["http://edamontology.org/data_2531"],
      "text": "Simulation experiment report"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_3224"
      },
      "definition": "Analyse gene expression patterns (typically from DNA microarray datasets) to identify sets of genes that are associated with a specific trait, condition, clinical outcome etc.",
      "replacedBy": ["http://edamontology.org/operation_2436"],
      "text": "Gene set testing"
    }, {
      "comment": ["A protein conserved site signature is any short sequence pattern that may contain one or more unique residues and is cannot be described as a active site, binding site or post-translational modification."],
      "consider": ["http://edamontology.org/data_2071"],
      "data": {
        "uri": "http://edamontology.org/data_1377"
      },
      "definition": "A protein conserved site signature (sequence classifier) from the InterPro database.",
      "text": "Protein conserved site signature"
    }, {
      "consider": ["http://edamontology.org/data_1465"],
      "data": {
        "uri": "http://edamontology.org/data_2022"
      },
      "definition": "Data used by the Vienna RNA analysis package.",
      "text": "Vienna RNA structural data"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0397"
      },
      "definition": "Validate a Ramachandran plot of a protein structure.",
      "replacedBy": ["http://edamontology.org/operation_1844"],
      "text": "Ramachandran plot validation"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_0753"
      },
      "definition": "Metabolic pathways.",
      "replacedBy": ["http://edamontology.org/topic_0602"],
      "text": "Metabolic pathways"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_0876"
      },
      "definition": "Secondary structure (predicted or real) of a protein.",
      "replacedBy": ["http://edamontology.org/data_1277"],
      "text": "Protein features report (secondary structure)"
    }, {
      "consider": ["http://edamontology.org/topic_0820"],
      "data": {
        "uri": "http://edamontology.org/topic_0151"
      },
      "definition": "G-protein coupled receptors (GPCRs).",
      "text": "G protein-coupled receptors (GPCR)"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_1657"
      },
      "definition": "genetic information processing pathways.",
      "replacedBy": ["http://edamontology.org/data_2984"],
      "text": "Genetic information processing pathway report"
    }, {
      "consider": ["http://edamontology.org/data_2538"],
      "data": {
        "uri": "http://edamontology.org/data_2132"
      },
      "definition": "A type of point or block mutation, including insertion, deletion, change, duplication and moves.",
      "text": "Mutation type"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1618"
      },
      "definition": "Entry format of the Zebrafish Information Network (ZFIN) genome database.",
      "text": "ZFIN gene report format"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0535"
      },
      "definition": "Assign secondary structure from circular dichroism (CD) spectroscopic data.",
      "replacedBy": ["http://edamontology.org/operation_0319"],
      "text": "Protein secondary structure assignment (from CD data)"
    }, {
      "consider": ["http://edamontology.org/data_0966"],
      "data": {
        "uri": "http://edamontology.org/data_1718"
      },
      "definition": "A term from the HGNC controlled vocabulary.",
      "text": "HGNC"
    }, {
      "consider": ["http://edamontology.org/data_0842"],
      "data": {
        "uri": "http://edamontology.org/data_2357"
      },
      "definition": "A label (text token) describing a type of protein family signature (sequence classifier) from the InterPro database.",
      "text": "Protein signature type"
    }, {
      "consider": ["http://edamontology.org/data_0966"],
      "data": {
        "uri": "http://edamontology.org/data_1723"
      },
      "definition": "A term from the EMAP mouse ontology.",
      "text": "EMAP"
    }, {
      "consider": ["http://edamontology.org/data_1026"],
      "data": {
        "uri": "http://edamontology.org/data_1892"
      },
      "definition": "Name of a gene from the GeneFarm database.",
      "exact_synonyms": ["GeneFarm gene ID"],
      "text": "Gene name (GeneFarm)"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1579"
      },
      "definition": "Entry format for the TIGRFam protein secondary database.",
      "text": "TIGRFam entry format"
    }, {
      "consider": ["http://edamontology.org/format_1963"],
      "data": {
        "uri": "http://edamontology.org/format_2189"
      },
      "definition": "ipi sequence format.",
      "text": "ipi"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_2975"
      },
      "definition": "A raw nucleic acid sequence.",
      "exact_synonyms": ["Nucleotide sequence (raw)", "Raw sequence (nucleic acid)", "Raw nucleic acid sequence", "Nucleic acid raw sequence"],
      "replacedBy": ["http://edamontology.org/data_2977"],
      "text": "Nucleic acid sequence (raw)"
    }, {
      "consider": ["http://edamontology.org/data_2523"],
      "data": {
        "uri": "http://edamontology.org/data_1443"
      },
      "definition": "Molecular clock and stratigraphic (age) data derived from phylogenetic tree analysis.",
      "text": "Phylogenetic tree report (tree stratigraphic)"
    }, {
      "comment": ["A protein post-translational modification signature corresponds to sites that undergo modification of the primary structure, typically to activate or de-activate a function. For example, methylation, sumoylation, glycosylation etc. The modification might be permanent or reversible."],
      "consider": ["http://edamontology.org/data_2071"],
      "data": {
        "uri": "http://edamontology.org/data_1380"
      },
      "definition": "A protein post-translational modification signature (sequence classifier) from the InterPro database.",
      "text": "Protein post-translational modification signature"
    }, {
      "consider": ["http://edamontology.org/data_2534"],
      "data": {
        "uri": "http://edamontology.org/data_1395"
      },
      "definition": "Whether end gaps are scored or not.",
      "text": "Score end gaps control"
    }, {
      "consider": ["http://edamontology.org/data_3128"],
      "data": {
        "uri": "http://edamontology.org/data_1303"
      },
      "definition": "A report on quadruplex-forming motifs in a nucleotide sequence.",
      "text": "Nucleic acid features (quadruplexes)"
    }, {
      "consider": ["http://edamontology.org/operation_3927", "http://edamontology.org/operation_3928"],
      "data": {
        "uri": "http://edamontology.org/operation_2497"
      },
      "definition": "Generate, process or analyse a biological pathway or network.",
      "text": "Pathway or network analysis"
    }, {
      "consider": ["http://edamontology.org/data_0006"],
      "data": {
        "uri": "http://edamontology.org/data_1592"
      },
      "definition": "Structure constraints used by the Vienna package.",
      "text": "Vienna RNA structure constraints"
    }, {
      "consider": ["http://edamontology.org/data_1481"],
      "data": {
        "uri": "http://edamontology.org/data_1484"
      },
      "definition": "Alignment (superimposition) of more than two protein tertiary (3D) structures.",
      "text": "Multiple protein tertiary structure alignment"
    }, {
      "comment": ["This is a broad data type and is used a placeholder for other, more specific types."],
      "consider": ["http://edamontology.org/data_1394"],
      "data": {
        "uri": "http://edamontology.org/data_2083"
      },
      "definition": "Data concerning, extracted from, or derived from the analysis of molecular alignment of some type.",
      "text": "Alignment data"
    }, {
      "consider": ["http://edamontology.org/data_0916"],
      "data": {
        "uri": "http://edamontology.org/data_0917"
      },
      "definition": "A report on the classification of nucleic acid / gene sequences according to the functional classification of their gene products.",
      "text": "Gene classification"
    }, {
      "consider": ["http://edamontology.org/topic_2229"],
      "data": {
        "uri": "http://edamontology.org/topic_0617"
      },
      "definition": "Ribosomes, typically of ribosome-related genes and proteins.",
      "text": "Ribosomes"
    }, {
      "comment": ["Solvent accessibility might be calculated for the backbone, sidechain and total (backbone plus sidechain)."],
      "data": {
        "uri": "http://edamontology.org/operation_1822"
      },
      "definition": "Calculate the solvent accessibility ('vacuum molecular surface') for each residue in a structure. This is the accessibility of the residue when taken out of the protein together with the backbone atoms of any residue it is covalently bound to.",
      "replacedBy": ["http://edamontology.org/operation_0387"],
      "text": "Protein residue surface calculation (vacuum molecular)"
    }, {
      "consider": ["http://edamontology.org/data_0857"],
      "data": {
        "uri": "http://edamontology.org/data_1340"
      },
      "definition": "A report on the evaluation of the significance of sequence similarity scores from a sequence database search (for example a BLAST search).",
      "text": "Sequence database hits evaluation data"
    }, {
      "consider": ["http://edamontology.org/data_2339"],
      "data": {
        "uri": "http://edamontology.org/data_3027"
      },
      "definition": "The name of a concept for a molecular function from the GO ontology.",
      "text": "GO concept name (molecular function)"
    }, {
      "consider": ["http://edamontology.org/format_1982"],
      "data": {
        "uri": "http://edamontology.org/format_1924"
      },
      "definition": "Clustalw output format.",
      "text": "clustal sequence format"
    }, {
      "comment": ["For example transcription factor binding sites (TFBS) analysis to predict accessibility of DNA to binding factors."],
      "consider": ["http://edamontology.org/operation_0438"],
      "data": {
        "uri": "http://edamontology.org/operation_0241"
      },
      "definition": "Analyse the sequence, conformational or physicochemical properties of transcription regulatory elements in DNA sequences.",
      "text": "Transcription regulatory sequence analysis"
    }, {
      "comment": ["Output typically includes, for each residue position, the likelihoods for the 20 amino acid types with estimated reliability of the 20 likelihoods."],
      "data": {
        "uri": "http://edamontology.org/operation_1841"
      },
      "definition": "Predict rotamer likelihoods for all 20 amino acid types at each position in a protein structure.",
      "replacedBy": ["http://edamontology.org/operation_0480"],
      "text": "Rotamer likelihood prediction"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_1281"
      },
      "definition": "Image of a sequence with matches to signatures, motifs or profiles.",
      "replacedBy": ["http://edamontology.org/data_2969"],
      "text": "Sequence signature map"
    }, {
      "consider": ["http://edamontology.org/operation_0297"],
      "data": {
        "uri": "http://edamontology.org/operation_2411"
      },
      "definition": "Process (read and / or write) one or more structural (3D) profile(s) or template(s) of some type.",
      "text": "Structural profile processing"
    }, {
      "consider": ["http://edamontology.org/data_0006"],
      "data": {
        "uri": "http://edamontology.org/data_3105"
      },
      "definition": "Basic information concerning geographical location or time.",
      "text": "Geotemporal metadata"
    }, {
      "consider": ["http://edamontology.org/data_0968"],
      "data": {
        "uri": "http://edamontology.org/data_1878"
      },
      "definition": "A common misspelling of a word.",
      "text": "Misspelling"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_2372"
      },
      "definition": "An informative report on individual spot(s) from a two-dimensional (2D PAGE) gel.",
      "replacedBy": ["http://edamontology.org/data_2531"],
      "text": "2D PAGE spot report"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0569"
      },
      "definition": "Render and visualise protein secondary structure.",
      "replacedBy": ["http://edamontology.org/operation_0570"],
      "text": "Protein secondary structure visualisation"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_1913"
      },
      "definition": "Identify poor quality amino acid positions in protein structures.",
      "replacedBy": ["http://edamontology.org/operation_0321"],
      "text": "Residue validation"
    }, {
      "comment": ["This is a broad data type and is used a placeholder for other, more specific types."],
      "consider": ["http://edamontology.org/data_1274", "http://edamontology.org/data_2019"],
      "data": {
        "uri": "http://edamontology.org/data_2522"
      },
      "definition": "Data concerning a map of molecular sequence(s).",
      "text": "Map data"
    }, {
      "consider": ["http://edamontology.org/format_2000"],
      "data": {
        "uri": "http://edamontology.org/format_1959"
      },
      "definition": "Selex sequence format.",
      "text": "selex sequence format"
    }, {
      "consider": ["http://edamontology.org/data_2285"],
      "data": {
        "uri": "http://edamontology.org/data_1888"
      },
      "definition": "Identifier for genetic elements in MIPS Medicago database.",
      "text": "Gene ID (MIPS Medicago)"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_3535"
      },
      "definition": "RNA and DNA-binding proteins and binding sites in protein sequences.",
      "replacedBy": ["http://edamontology.org/topic_3534"],
      "text": "Protein-nucleic acid binding sites"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0425"
      },
      "definition": "Detect, predict and identify whole gene structure in DNA sequences. This includes protein coding regions, exon-intron structure, regulatory regions etc.",
      "replacedBy": ["http://edamontology.org/operation_2454"],
      "text": "Whole gene prediction"
    }, {
      "consider": ["http://edamontology.org/data_0907"],
      "data": {
        "uri": "http://edamontology.org/data_1554"
      },
      "definition": "Information on a node from the SCOP database.",
      "text": "SCOP node"
    }, {
      "comment": ["Sequence profiles include position-specific scoring matrix (position weight matrix), hidden Markov models etc."],
      "consider": ["http://edamontology.org/topic_0160"],
      "data": {
        "uri": "http://edamontology.org/topic_0188"
      },
      "definition": "Sequence profiles; typically a positional, numerical matrix representing a sequence alignment.",
      "text": "Sequence profiles and HMMs"
    }, {
      "consider": ["http://edamontology.org/format_2350"],
      "data": {
        "uri": "http://edamontology.org/format_2059"
      },
      "definition": "Format of a report on genotype / phenotype information.",
      "text": "Genotype and phenotype annotation format"
    }, {
      "consider": ["http://edamontology.org/topic_0128"],
      "data": {
        "uri": "http://edamontology.org/topic_0147"
      },
      "definition": "Protein-protein interactions, individual interactions and networks, protein complexes, protein functional coupling etc.",
      "text": "Protein-protein interactions"
    }, {
      "comment": ["A protein repeat signature is a repeated protein motif, that is not in single copy expected to independently fold into a globular domain."],
      "consider": ["http://edamontology.org/data_1355"],
      "data": {
        "uri": "http://edamontology.org/data_1375"
      },
      "definition": "A protein repeat signature (sequence classifier) from the InterPro database.",
      "text": "Protein repeat signature"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_0923"
      },
      "definition": "PCR experiments, e.g. quantitative real-time PCR.",
      "replacedBy": ["http://edamontology.org/data_2531"],
      "text": "PCR experiment report"
    }, {
      "consider": ["http://edamontology.org/data_0919"],
      "data": {
        "uri": "http://edamontology.org/data_1853"
      },
      "definition": "A report on a chromosome aberration such as abnormalities in chromosome structure.",
      "text": "Chromosome annotation (aberration)"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_0868"
      },
      "definition": "A profile-profile alignment (each profile typically representing a sequence alignment).",
      "replacedBy": ["http://edamontology.org/data_0858"],
      "text": "Profile-profile alignment"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_3441"
      },
      "definition": "Generate a graph, or other visual representation, of data, showing the relationship between two or more variables.",
      "replacedBy": ["http://edamontology.org/operation_0337"],
      "text": "Plotting"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_3526"
      },
      "definition": "Protein-protein interaction(s), including interactions between protein domains.",
      "replacedBy": ["http://edamontology.org/topic_0128"],
      "text": "Protein-protein interactions"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0559"
      },
      "definition": "Predict and optimise peptide ligands that elicit an immunological response.",
      "replacedBy": ["http://edamontology.org/operation_0252"],
      "text": "Immunogenicity prediction"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1606"
      },
      "definition": "Entry format of DragonDB genome database.",
      "text": "DragonDB gene report format"
    }, {
      "consider": ["http://edamontology.org/format_1476"],
      "data": {
        "uri": "http://edamontology.org/format_1747"
      },
      "definition": "Format of an ATOM record (describing data for an individual atom) from a PDB file.",
      "text": "PDB atom record format"
    }, {
      "consider": ["http://edamontology.org/data_1035"],
      "data": {
        "uri": "http://edamontology.org/data_1798"
      },
      "definition": "Gene identifier from Leishmania major GeneDB database.",
      "text": "Gene ID (GeneDB Leishmania major)"
    }, {
      "consider": ["http://edamontology.org/data_0962"],
      "data": {
        "uri": "http://edamontology.org/data_0895"
      },
      "definition": "An informative report about a specific peptide.",
      "text": "Peptide annotation"
    }, {
      "consider": ["http://edamontology.org/topic_3053"],
      "data": {
        "uri": "http://edamontology.org/topic_2816"
      },
      "definition": "Informatics resource (typically a database) primarily focussed on genes.",
      "text": "Gene resources"
    }, {
      "consider": ["http://edamontology.org/data_2534"],
      "data": {
        "uri": "http://edamontology.org/data_1121"
      },
      "definition": "The type of a BLAST sequence alignment.",
      "text": "BLAST sequence alignment type"
    }, {
      "comment": ["The report (for example http://www.cathdb.info/chain/1cukA) includes chain identifiers, domain identifiers and CATH codes for domains in a given protein chain."],
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1760"
      },
      "definition": "Format of CATH domain classification information for a polypeptide chain.",
      "text": "CATH chain report format"
    }, {
      "consider": ["http://edamontology.org/operation_2949"],
      "data": {
        "uri": "http://edamontology.org/operation_2993"
      },
      "definition": "Process (read and / or write) molecular interaction data.",
      "text": "Molecular interaction data processing"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0330"
      },
      "definition": "Map and model the effects of single nucleotide polymorphisms (SNPs) on protein structure(s).",
      "replacedBy": ["http://edamontology.org/operation_0331"],
      "text": "Protein SNP mapping"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_3137"
      },
      "definition": "features of non-coding or functional RNA molecules, including tRNA and rRNA.",
      "replacedBy": ["http://edamontology.org/data_1276"],
      "text": "Non-coding RNA"
    }, {
      "consider": ["http://edamontology.org/data_2610"],
      "data": {
        "uri": "http://edamontology.org/data_2691"
      },
      "definition": "Identifier of an entry (exon, gene, transcript or protein) from the Ensembl 'core' database ('Oryctolagus cuniculus' division).",
      "text": "Ensembl ID ('Oryctolagus cuniculus')"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_1634"
      },
      "definition": "A report on linkage disequilibrium; the non-random association of alleles or polymorphisms at two or more loci (not necessarily on the same chromosome).",
      "replacedBy": ["http://edamontology.org/data_0927"],
      "text": "Linkage disequilibrium (report)"
    }, {
      "consider": ["http://edamontology.org/data_1086"],
      "data": {
        "uri": "http://edamontology.org/data_0992"
      },
      "definition": "Code word for a ligand, for example from a PDB file.",
      "text": "Ligand identifier"
    }, {
      "consider": ["http://edamontology.org/data_3106"],
      "data": {
        "uri": "http://edamontology.org/data_1676"
      },
      "definition": "The (typically numeric) unique identifier of a submitted job.",
      "text": "Job ID"
    }, {
      "consider": ["http://edamontology.org/data_0582"],
      "data": {
        "uri": "http://edamontology.org/data_0835"
      },
      "definition": "Compendium of controlled vocabularies for the biomedical domain (Unified Medical Language System).",
      "text": "UMLS vocabulary"
    }, {
      "consider": ["http://edamontology.org/data_0006"],
      "data": {
        "uri": "http://edamontology.org/data_1591"
      },
      "definition": "RNA parameters used by the Vienna package.",
      "text": "Vienna RNA parameters"
    }, {
      "consider": ["http://edamontology.org/topic_0623"],
      "data": {
        "uri": "http://edamontology.org/topic_3078"
      },
      "definition": "Specific genes and/or their encoded proteins or a family or other grouping of related genes and proteins.",
      "text": "Genes and proteins resources"
    }, {
      "comment": ["This includes direct retrieval methods (e.g. the dbfetch program) but not those that perform calculations on the sequence."],
      "consider": ["http://edamontology.org/operation_2422"],
      "data": {
        "uri": "http://edamontology.org/operation_1813"
      },
      "definition": "Query a sequence data resource (typically a database) and retrieve sequences and / or annotation.",
      "text": "Sequence retrieval"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_2047"
      },
      "definition": "A protein sequence and minimal metadata, typically an identifier of the sequence and/or a comment.",
      "exact_synonyms": ["Sequence record lite (protein)"],
      "replacedBy": ["http://edamontology.org/data_0849"],
      "text": "Protein sequence record (lite)"
    }, {
      "comment": ["This is a broad data type and is used a placeholder for other, more specific types."],
      "data": {
        "uri": "http://edamontology.org/data_2981"
      },
      "definition": "Data concerning specific or conserved pattern in molecular sequences.",
      "replacedBy": ["http://edamontology.org/data_0860"],
      "text": "Sequence motif data"
    }, {
      "consider": ["http://edamontology.org/data_2610"],
      "data": {
        "uri": "http://edamontology.org/data_2697"
      },
      "definition": "Identifier of an entry (exon, gene, transcript or protein) from the Ensembl 'core' database ('Takifugu rubripes' division).",
      "text": "Ensembl ID ('Takifugu rubripes')"
    }, {
      "consider": ["http://edamontology.org/data_1385"],
      "data": {
        "uri": "http://edamontology.org/data_1388"
      },
      "definition": "Alignment of exactly two molecular sequences of different types.",
      "text": "Hybrid sequence alignment (pair)"
    }, {
      "comment": ["Methods for gene prediction might be ab initio, based on phylogenetic comparisons, use motifs, sequence features, support vector machine, alignment etc."],
      "data": {
        "uri": "http://edamontology.org/operation_0426"
      },
      "definition": "Detect, predict and identify genetic elements such as promoters, coding regions, splice sites, etc in DNA sequences.",
      "replacedBy": ["http://edamontology.org/operation_2454"],
      "text": "Gene component prediction"
    }, {
      "comment": ["A window is a region of fixed size but not fixed position over a molecular sequence. It is typically moved (computationally) over a sequence during scoring."],
      "consider": ["http://edamontology.org/data_1249"],
      "data": {
        "uri": "http://edamontology.org/data_1251"
      },
      "definition": "Size of a sequence window.",
      "text": "Window size"
    }, {
      "consider": ["http://edamontology.org/data_0907"],
      "data": {
        "uri": "http://edamontology.org/data_3146"
      },
      "definition": "Information on a 'species' node from the SCOP database.",
      "text": "SCOP species"
    }, {
      "consider": ["http://edamontology.org/data_2534"],
      "data": {
        "uri": "http://edamontology.org/data_0864"
      },
      "definition": "Some simple value controlling a sequence alignment (or similar 'match') operation.",
      "text": "Sequence alignment parameter"
    }, {
      "consider": ["http://edamontology.org/topic_0097"],
      "data": {
        "uri": "http://edamontology.org/topic_2953"
      },
      "definition": "Topic for the design of nucleic acid sequences with specific conformations.",
      "text": "Nucleic acid design"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_2381"
      },
      "definition": "Report of genotype experiment including case control, population, and family studies. These might use array based methods and re-sequencing methods.",
      "replacedBy": ["http://edamontology.org/data_2531"],
      "text": "Experiment report (genotyping)"
    }, {
      "comment": ["This is used for such things as a report including the sequence identifier, type and length."],
      "consider": ["http://edamontology.org/data_2955"],
      "data": {
        "uri": "http://edamontology.org/data_0855"
      },
      "definition": "Basic or general information concerning molecular sequences.",
      "text": "Sequence metadata"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0298"
      },
      "definition": "Align sequence profiles (representing sequence alignments).",
      "replacedBy": ["http://edamontology.org/operation_0300"],
      "text": "Profile-profile alignment"
    }, {
      "comment": ["Methods might perform one-to-one, one-to-many or many-to-many comparisons."],
      "consider": ["http://edamontology.org/operation_0300", "http://edamontology.org/operation_0292"],
      "data": {
        "uri": "http://edamontology.org/operation_0511"
      },
      "definition": "Align exactly two molecular profiles.",
      "text": "Profile-profile alignment (pairwise)"
    }, {
      "comment": ["Development status / maturity may be part of the version information, for example in case of tools, standards, or some data records."],
      "consider": ["http://edamontology.org/data_2337"],
      "data": {
        "uri": "http://edamontology.org/data_0953"
      },
      "definition": "Information on a version of software or data, for example name, version number and release date.",
      "text": "Version information"
    }, {
      "consider": ["http://edamontology.org/data_0896"],
      "data": {
        "uri": "http://edamontology.org/data_1509"
      },
      "definition": "An informative report on a specific enzyme.",
      "text": "Enzyme report"
    }, {
      "consider": ["http://edamontology.org/operation_2422"],
      "data": {
        "uri": "http://edamontology.org/operation_1914"
      },
      "definition": "Query a tertiary structure database and retrieve water molecules.",
      "text": "Structure retrieval (water)"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_2201"
      },
      "definition": "A molecular sequence and comprehensive metadata (such as a feature table), typically corresponding to a full entry from a molecular sequence database.",
      "replacedBy": ["http://edamontology.org/data_0849"],
      "text": "Sequence record full"
    }, {
      "consider": ["http://edamontology.org/topic_0081"],
      "data": {
        "uri": "http://edamontology.org/topic_3038"
      },
      "definition": "Molecular secondary or tertiary (3D) structural data resources, typically of proteins and nucleic acids.",
      "text": "Structure databases"
    }, {
      "consider": ["http://edamontology.org/data_0857"],
      "data": {
        "uri": "http://edamontology.org/data_1338"
      },
      "definition": "Scores from a sequence database search (for example a BLAST search).",
      "text": "Sequence database hits scores list"
    }, {
      "comment": ["This is a broad data type and is used a placeholder for other, more specific types."],
      "consider": ["http://edamontology.org/data_2084"],
      "data": {
        "uri": "http://edamontology.org/data_2525"
      },
      "definition": "Data concerning one or more nucleic acid molecules.",
      "text": "Nucleic acid data"
    }, {
      "comment": ["'PEST' motifs target proteins for proteolytic degradation and reduce the half-lives of proteins dramatically."],
      "data": {
        "uri": "http://edamontology.org/data_1331"
      },
      "definition": "A report or plot of PEST sites in a protein sequence.",
      "replacedBy": ["http://edamontology.org/data_1277"],
      "text": "Protein features (PEST sites)"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1701"
      },
      "definition": "The format of an entry from PubChem.",
      "text": "PubChem entry format"
    }, {
      "consider": ["http://edamontology.org/topic_0634"],
      "data": {
        "uri": "http://edamontology.org/topic_0803"
      },
      "definition": "Human diseases, typically describing the genes, mutations and proteins implicated in disease.",
      "text": "Human disease"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_0724"
      },
      "definition": "Primarily the classification of proteins (from sequence or structural data) into clusters, groups, families etc., curation of a particular protein or protein family, or any other proteins that have been classified as members of a common group.",
      "replacedBy": ["http://edamontology.org/topic_0623"],
      "text": "Protein families"
    }, {
      "consider": ["http://edamontology.org/data_0867"],
      "data": {
        "uri": "http://edamontology.org/data_2598"
      },
      "definition": "An informative report on protein secondary structure alignment-derived data or metadata.",
      "text": "Secondary structure alignment metadata"
    }, {
      "consider": ["http://edamontology.org/topic_0157"],
      "data": {
        "uri": "http://edamontology.org/topic_0641"
      },
      "definition": "The repetitive nature of molecular sequences.",
      "text": "Repeat sequences"
    }, {
      "consider": ["http://edamontology.org/data_1114", "http://edamontology.org/data_1115"],
      "data": {
        "uri": "http://edamontology.org/data_1065"
      },
      "definition": "Identifier of a sequence signature (motif or profile) for example from a database of sequence patterns.",
      "text": "Sequence signature identifier"
    }, {
      "consider": ["http://edamontology.org/data_0962"],
      "data": {
        "uri": "http://edamontology.org/data_2240"
      },
      "definition": "An informative report on the types of small molecules or 'heterogens' (non-protein groups) that are represented in PDB files.",
      "text": "Heterogen annotation"
    }, {
      "consider": ["http://edamontology.org/format_1936"],
      "data": {
        "uri": "http://edamontology.org/format_1981"
      },
      "definition": "Genbank feature format.",
      "text": "GenBank feature"
    }, {
      "consider": ["http://edamontology.org/data_0906"],
      "data": {
        "uri": "http://edamontology.org/data_2359"
      },
      "definition": "An informative report on protein domain-protein domain interaction(s).",
      "text": "Domain-domain interactions"
    }, {
      "comment": ["The resource may be specific to an invertebrate, a group of invertebrates or all invertebrates."],
      "consider": ["http://edamontology.org/topic_0621"],
      "data": {
        "uri": "http://edamontology.org/topic_2819"
      },
      "definition": "Invertebrates, e.g. information on a specific invertebrate genome including molecular sequences, genes and annotation.",
      "text": "Invertebrates"
    }, {
      "consider": ["http://edamontology.org/data_2717"],
      "data": {
        "uri": "http://edamontology.org/data_1643"
      },
      "definition": "Affymetrix library file of information about the probe sets such as the gene name with which the probe set is associated.",
      "text": "Affymetrix probe sets information library file"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_2211"
      },
      "definition": "Format for a report of strain data as used for CIP database entries.",
      "text": "CIP strain data format"
    }, {
      "comment": ["These are the parsable data files provided by CATH."],
      "consider": ["http://edamontology.org/data_0907"],
      "data": {
        "uri": "http://edamontology.org/data_2236"
      },
      "definition": "Raw CATH domain classification data files.",
      "text": "Raw CATH domain classification"
    }, {
      "consider": ["http://edamontology.org/topic_0080"],
      "data": {
        "uri": "http://edamontology.org/topic_3041"
      },
      "definition": "Molecular sequence data resources, including sequence sites, alignments, motifs and profiles.",
      "text": "Sequence databases"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_3539"
      },
      "definition": "Structural domains or 3D folds in a protein or polypeptide chain.",
      "replacedBy": ["http://edamontology.org/topic_0736"],
      "text": "Protein domains"
    }, {
      "consider": ["http://edamontology.org/data_2732"],
      "data": {
        "uri": "http://edamontology.org/data_2734"
      },
      "definition": "The name of a family of viruses.",
      "text": "Family name (virus)"
    }, {
      "comment": ["C-beta atoms from amino acid side-chains may be included."],
      "consider": ["http://edamontology.org/data_1481"],
      "data": {
        "uri": "http://edamontology.org/data_1490"
      },
      "definition": "Alignment (superimposition) of exactly two protein tertiary (3D) structures (typically C-alpha atoms only considered).",
      "text": "Multiple protein tertiary structure alignment (C-alpha atoms)"
    }, {
      "consider": ["http://edamontology.org/data_2717"],
      "data": {
        "uri": "http://edamontology.org/data_0932"
      },
      "definition": "Data on oligonucleotide probes (typically for use with DNA microarrays).",
      "text": "Oligonucleotide probe data"
    }, {
      "comment": ["The resource may be specific to a eukaryote, a group of eukaryotes or all eukaryotes."],
      "consider": ["http://edamontology.org/topic_0621"],
      "data": {
        "uri": "http://edamontology.org/topic_2818"
      },
      "definition": "Eukaryotes or data concerning eukaryotes, e.g. information on a specific eukaryote genome including molecular sequences, genes and annotation.",
      "text": "Eukaryotes"
    }, {
      "comment": ["A Psiblast checkpoint file uses ASN.1 Binary Format and usually has the extension '.asn'."],
      "consider": ["http://edamontology.org/data_0850"],
      "data": {
        "uri": "http://edamontology.org/data_1236"
      },
      "definition": "A file of intermediate results from a PSIBLAST search that is used for priming the search in the next PSIBLAST iteration.",
      "text": "Psiblast checkpoint file"
    }, {
      "consider": ["http://edamontology.org/data_2048"],
      "data": {
        "uri": "http://edamontology.org/data_1683"
      },
      "definition": "EMBOSS (EMBASSY) domainatrix application log file.",
      "text": "EMBOSS domainatrix log file"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_0007"
      },
      "definition": "A bioinformatics package or tool, e.g. a standalone application or web service.",
      "replacedBy": ["http://edamontology.org/data_0958"],
      "text": "Tool"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_3648"
      },
      "definition": "Statistical estimation of false discovery rate from score distribution for peptide-spectrum-matches, following a peptide database search.",
      "replacedBy": ["http://edamontology.org/operation_3649"],
      "text": "Validation of peptide-spectrum matches"
    }, {
      "consider": ["http://edamontology.org/operation_2421"],
      "data": {
        "uri": "http://edamontology.org/operation_0343"
      },
      "definition": "Search a database of transmembrane proteins, for example for sequence or structural similarities.",
      "text": "Transmembrane protein database search"
    }, {
      "consider": ["http://edamontology.org/data_1082"],
      "data": {
        "uri": "http://edamontology.org/data_1156"
      },
      "definition": "Identifier of an entry from the aMAZE database.",
      "exact_synonyms": ["aMAZE ID"],
      "text": "Pathway ID (aMAZE)"
    }, {
      "consider": ["http://edamontology.org/operation_0523"],
      "data": {
        "uri": "http://edamontology.org/operation_3260"
      },
      "definition": "Infer a transcriptome sequence by mapping short reads to a reference genome.",
      "text": "Transcriptome assembly (mapping)"
    }, {
      "consider": ["http://edamontology.org/data_0906"],
      "data": {
        "uri": "http://edamontology.org/data_2378"
      },
      "definition": "Data on the interaction of a protein (or protein domain) with specific structural (3D) and/or sequence motifs.",
      "text": "Protein-motif interaction"
    }, {
      "comment": ["Classifies anatomical entities according to their shared characteristics (genus) and distinguishing characteristics (differentia). Specifies the part-whole and spatial relationships of the entities, morphological transformation of the entities during prenatal development and the postnatal life cycle and principles, rules and definitions according to which classes and relationships in the other three components of FMA are represented."],
      "consider": ["http://edamontology.org/data_0966"],
      "data": {
        "uri": "http://edamontology.org/data_1722"
      },
      "definition": "A term from Foundational Model of Anatomy.",
      "text": "FMA"
    }, {
      "comment": ["Non-sequence characters may be used for example for gaps and translation stop."],
      "data": {
        "uri": "http://edamontology.org/data_0848"
      },
      "definition": "A raw molecular sequence (string of characters) which might include ambiguity, unknown positions and non-sequence characters.",
      "replacedBy": ["http://edamontology.org/data_2044"],
      "text": "Raw sequence"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_1823"
      },
      "definition": "Calculate the solvent accessibility ('accessible molecular surface') for a structure as a whole.",
      "replacedBy": ["http://edamontology.org/operation_0387"],
      "text": "Protein surface calculation (accessible molecular)"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_0903"
      },
      "definition": "A report on an analysis or model of protein folding properties, folding pathways, residues or sites that are key to protein folding, nucleation or stabilisation centers etc.",
      "replacedBy": ["http://edamontology.org/data_1537"],
      "text": "Protein folding report"
    }, {
      "comment": ["This might include name of enzyme, organism, isoschizomers, methylation, source, suppliers, literature references, or data on restriction enzyme patterns such as name of enzyme, recognition site, length of pattern, number of cuts made by enzyme, details of blunt or sticky end cut etc."],
      "consider": ["http://edamontology.org/data_0896"],
      "data": {
        "uri": "http://edamontology.org/data_1517"
      },
      "definition": "An informative report on a specific restriction enzyme such as enzyme reference data.",
      "text": "Restriction enzyme report"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1700"
      },
      "definition": "The format of an entry from the KEGG GLYCAN database.",
      "text": "KEGG GLYCAN entry format"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_3139"
      },
      "definition": "Sequence tagged sites (STS) in nucleic acid sequences.",
      "replacedBy": ["http://edamontology.org/topic_3511"],
      "text": "Sequence tagged sites"
    }, {
      "consider": ["http://edamontology.org/data_0863"],
      "data": {
        "uri": "http://edamontology.org/data_1389"
      },
      "definition": "Alignment of more than two nucleotide sequences.",
      "text": "Multiple nucleotide sequence alignment"
    }, {
      "comment": ["A MIRIAM entry describes a MIRIAM data type including the official name, synonyms, root URI, identifier pattern (regular expression applied to a unique identifier of the data type) and documentation. Each data type can be associated with several resources. Each resource is a physical location of a service (typically a database) providing information on the elements of a data type. Several resources may exist for each data type, provided the same (mirrors) or different information. MIRIAM provides a stable and persistent reference to its data types."],
      "consider": ["http://edamontology.org/data_1883"],
      "data": {
        "uri": "http://edamontology.org/data_1664"
      },
      "definition": "An entry (data type) from the Minimal Information Requested in the Annotation of Biochemical Models (MIRIAM) database of data resources.",
      "text": "MIRIAM datatype"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_1253"
      },
      "definition": "Report on basic information about a molecular sequence such as name, accession number, type (nucleic or protein), length, description etc.",
      "replacedBy": ["http://edamontology.org/data_2955"],
      "text": "Sequence information report"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1625"
      },
      "definition": "Format of a record from the HIVDB database of genotypes and phenotypes.",
      "text": "HIVDB entry format"
    }, {
      "comment": ["Chemical structure sketches are used for presentational purposes but also as inputs to various analysis software."],
      "data": {
        "uri": "http://edamontology.org/data_3490"
      },
      "definition": "A sketch of a small molecule made with some specialised drawing package.",
      "replacedBy": ["http://edamontology.org/data_1712"],
      "text": "Chemical structure sketch"
    }, {
      "consider": ["http://edamontology.org/data_2610"],
      "data": {
        "uri": "http://edamontology.org/data_2676"
      },
      "definition": "Identifier of an entry (exon, gene, transcript or protein) from the Ensembl 'core' database ('Ciona savignyi' division).",
      "text": "Ensembl ID ('Ciona savignyi')"
    }, {
      "comment": ["This is a broad data type and is used a placeholder for other, more specific types.  It is primarily intended to help navigation of EDAM and would not typically be used for annotation. Use this concept for calculated substitution rates, relative site variability, data on sites with biased properties, highly conserved or very poorly conserved sites, regions, blocks etc."],
      "consider": ["http://edamontology.org/data_2161"],
      "data": {
        "uri": "http://edamontology.org/data_1415"
      },
      "definition": "Data on character conservation in a molecular sequence alignment.",
      "text": "Sequence alignment report (site conservation)"
    }, {
      "consider": ["http://edamontology.org/data_1261"],
      "data": {
        "uri": "http://edamontology.org/data_3119"
      },
      "definition": "A report of regions in a molecular sequence that are biased to certain characters.",
      "text": "Sequence features (compositionally-biased regions)"
    }, {
      "consider": ["http://edamontology.org/operation_0253"],
      "data": {
        "uri": "http://edamontology.org/operation_2408"
      },
      "definition": "Analyse features in molecular sequences.",
      "text": "Sequence feature analysis"
    }, {
      "consider": ["http://edamontology.org/operation_0524"],
      "data": {
        "uri": "http://edamontology.org/operation_3259"
      },
      "definition": "Infer a transcriptome sequence without the aid of a reference genome, i.e. by comparing short sequences (reads) to each other.",
      "exact_synonyms": ["de novo transcriptome assembly"],
      "text": "Transcriptome assembly (de novo)"
    }, {
      "consider": ["http://edamontology.org/format_2036"],
      "data": {
        "uri": "http://edamontology.org/format_2243"
      },
      "definition": "PHYLIP file format for phylogenetic property data.",
      "text": "phylip property values"
    }, {
      "consider": ["http://edamontology.org/topic_0623"],
      "data": {
        "uri": "http://edamontology.org/topic_0635"
      },
      "definition": "A particular protein, protein family or other group of proteins.",
      "exact_synonyms": ["Specific protein"],
      "text": "Specific protein resources"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_3147"
      },
      "definition": "mass spectrometry experiments.",
      "replacedBy": ["http://edamontology.org/data_2531"],
      "text": "Mass spectrometry experiment"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1652"
      },
      "definition": "The format of an entry from the reactome biological pathways database.",
      "text": "Reactome entry format"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0388"
      },
      "definition": "Identify or predict catalytic residues, active sites or other ligand-binding sites in protein structures.",
      "replacedBy": ["http://edamontology.org/operation_2575"],
      "text": "Protein binding site prediction (from structure)"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_3528"
      },
      "definition": "Disease pathways, typically of human disease.",
      "replacedBy": ["http://edamontology.org/topic_0602"],
      "text": "Disease pathways"
    }, {
      "consider": ["http://edamontology.org/operation_2422"],
      "data": {
        "uri": "http://edamontology.org/operation_0280"
      },
      "definition": "Retrieve information on restriction enzymes or restriction enzyme sites.",
      "text": "Data retrieval (restriction enzyme annotation)"
    }, {
      "consider": ["http://edamontology.org/operation_2487", "http://edamontology.org/operation_2518"],
      "data": {
        "uri": "http://edamontology.org/operation_2931"
      },
      "definition": "Compare two or more molecular secondary structures.",
      "text": "Secondary structure comparison"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_1328"
      },
      "definition": "RNA and DNA-binding proteins and binding sites in protein sequences.",
      "replacedBy": ["http://edamontology.org/data_1277"],
      "text": "Protein features report (nucleic acid binding sites)"
    }, {
      "consider": ["http://edamontology.org/data_1893"],
      "data": {
        "uri": "http://edamontology.org/data_2009"
      },
      "definition": "A name for a genetic locus conforming to a scheme that names loci (such as predicted genes) depending on their position in a molecular sequence, for example a completely sequenced genome or chromosome.",
      "text": "Ordered locus name"
    }, {
      "consider": ["http://edamontology.org/data_0874"],
      "data": {
        "uri": "http://edamontology.org/data_1446"
      },
      "definition": "Matrix of integer numbers for sequence comparison.",
      "text": "Comparison matrix (integers)"
    }, {
      "consider": ["http://edamontology.org/topic_3407"],
      "data": {
        "uri": "http://edamontology.org/topic_3323"
      },
      "definition": "The study of metabolic diseases.",
      "text": "Metabolic disease"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1515"
      },
      "definition": "Format of an entry from the proto section of the REBASE enzyme database.",
      "text": "REBASE proto enzyme report format"
    }, {
      "consider": ["http://edamontology.org/operation_2422"],
      "data": {
        "uri": "http://edamontology.org/operation_0255"
      },
      "definition": "Query the features (in a feature table) of molecular sequence(s).",
      "text": "Feature table query"
    }, {
      "consider": ["http://edamontology.org/operation_0564"],
      "data": {
        "uri": "http://edamontology.org/operation_0574"
      },
      "definition": "Render a sequence with motifs.",
      "text": "Sequence motif rendering"
    }, {
      "comment": ["This can involve characterisation of the underlying quantitative trait loci (QTLs) or nucleotides (QTNs)."],
      "consider": ["http://edamontology.org/operation_0282"],
      "data": {
        "uri": "http://edamontology.org/operation_0486"
      },
      "definition": "Map the genetic architecture of dynamic complex traits.",
      "text": "Functional mapping"
    }, {
      "consider": ["http://edamontology.org/data_0842"],
      "data": {
        "uri": "http://edamontology.org/data_2767"
      },
      "definition": "Basic information concerning an identifier of data (typically including the identifier itself).  For example, a gene symbol with information concerning its provenance.",
      "text": "Identifier with metadata"
    }, {
      "consider": ["http://edamontology.org/data_0893"],
      "data": {
        "uri": "http://edamontology.org/data_0891"
      },
      "definition": "An alignment of a sequence to a 3D profile (representing structures or a structure alignment).",
      "exact_synonyms": ["Sequence-structural profile alignment"],
      "text": "Sequence-3D profile alignment"
    }, {
      "consider": ["http://edamontology.org/topic_0077"],
      "data": {
        "uri": "http://edamontology.org/topic_0195"
      },
      "definition": "Simulated polymerase chain reaction (PCR).",
      "text": "Virtual PCR"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_2512"
      },
      "definition": "Edit or change a protein sequence, either randomly or specifically.",
      "replacedBy": ["http://edamontology.org/operation_0231"],
      "text": "Sequence editing (protein)"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1575"
      },
      "definition": "Entry format for the Panther library of protein families and subfamilies.",
      "text": "Panther Families and HMMs entry format"
    }, {
      "comment": ["Solvent accessibility might be calculated for the backbone, sidechain and total (backbone plus sidechain)."],
      "data": {
        "uri": "http://edamontology.org/operation_1819"
      },
      "definition": "Calculate the solvent accessibility ('accessible surface') for each residue in a structure.",
      "replacedBy": ["http://edamontology.org/operation_0387"],
      "text": "Protein residue surface calculation (accessible)"
    }, {
      "consider": ["http://edamontology.org/data_0957"],
      "data": {
        "uri": "http://edamontology.org/data_2747"
      },
      "definition": "The name of a subdivision of the Collagen Mutation Database (CMD) database.",
      "text": "Database name (CMD)"
    }, {
      "comment": ["Epitope mapping is commonly done during vaccine design."],
      "data": {
        "uri": "http://edamontology.org/data_1327"
      },
      "definition": "A report on antigenic determinant sites (epitopes) in proteins, from sequence and / or structural data.",
      "replacedBy": ["http://edamontology.org/data_1277"],
      "text": "Protein features (epitopes)"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_3440"
      },
      "definition": "The process of assembling many short DNA sequences together such thay they represent the original chromosomes from which the DNA originated.",
      "replacedBy": ["http://edamontology.org/operation_0525"],
      "text": "Genome assembly"
    }, {
      "consider": ["http://edamontology.org/data_0863"],
      "data": {
        "uri": "http://edamontology.org/data_0861"
      },
      "definition": "Alignment of exact matches between subsequences (words) within two or more molecular sequences.",
      "exact_synonyms": ["Sequence word alignment"],
      "text": "Sequence alignment (words)"
    }, {
      "consider": ["http://edamontology.org/data_0582"],
      "data": {
        "uri": "http://edamontology.org/data_0832"
      },
      "definition": "Controlled vocabulary for gene names (symbols) from HUGO Gene Nomenclature Committee.",
      "text": "HGNC vocabulary"
    }, {
      "comment": ["This includes promoters, CAAT signals, TATA signals, -35 signals, -10 signals, GC signals, primer binding sites for initiation of transcription or reverse transcription, enhancer, attenuator, terminators and ribosome binding sites."],
      "consider": ["http://edamontology.org/data_3134"],
      "data": {
        "uri": "http://edamontology.org/data_3138"
      },
      "definition": "Features concerning transcription of DNA into RNA including the regulation of transcription.",
      "text": "Transcriptional features (report)"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_2341"
      },
      "definition": "The format of an entry from the NCI-Nature pathways database.",
      "text": "NCI-Nature pathway entry format"
    }, {
      "consider": ["http://edamontology.org/topic_0640", "http://edamontology.org/topic_0160"],
      "data": {
        "uri": "http://edamontology.org/topic_0747"
      },
      "definition": "The archival, detection, prediction and analysis ofpositional features such as functional sites in nucleotide sequences.",
      "text": "Nucleic acid sites and features"
    }, {
      "consider": ["http://edamontology.org/operation_3092"],
      "data": {
        "uri": "http://edamontology.org/operation_3090"
      },
      "definition": "Predict, recognise and identify positional features in proteins from analysing protein structure.",
      "text": "Protein feature prediction (from structure)"
    }, {
      "comment": ["A stem loop is a hairpin structure; a double-helical structure formed when two complementary regions of a single strand of RNA or DNA molecule form base-pairs."],
      "consider": ["http://edamontology.org/data_3128"],
      "data": {
        "uri": "http://edamontology.org/data_3133"
      },
      "definition": "A report on stem loops in a DNA sequence.",
      "text": "Nucleic acid features (stem loop)"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1617"
      },
      "definition": "Entry format of the WormBase genomes database.",
      "text": "WormBase gene report format"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1513"
      },
      "definition": "Format of an entry from the KEGG REACTION database of biochemical reactions.",
      "text": "KEGG REACTION enzyme report format"
    }, {
      "consider": ["http://edamontology.org/format_2331"],
      "data": {
        "uri": "http://edamontology.org/format_1605"
      },
      "definition": "Entry format of Candida Genome database.",
      "text": "CGD gene report format"
    }, {
      "comment": ["Super-secondary structures include leucine zippers, coiled coils, Helix-Turn-Helix etc."],
      "data": {
        "uri": "http://edamontology.org/data_0877"
      },
      "definition": "Super-secondary structure of protein sequence(s).",
      "replacedBy": ["http://edamontology.org/data_1277"],
      "text": "Protein features report (super-secondary)"
    }, {
      "data": {
        "uri": "http://edamontology.org/topic_3522"
      },
      "definition": "Northern Blot experiments.",
      "replacedBy": ["http://edamontology.org/topic_3520"],
      "text": "Northern blot experiment"
    }, {
      "consider": ["http://edamontology.org/data_0949"],
      "data": {
        "uri": "http://edamontology.org/data_2971"
      },
      "definition": "Data concerning a computational workflow.",
      "text": "Workflow data"
    }, {
      "data": {
        "uri": "http://edamontology.org/data_1745"
      },
      "definition": "Cartesian y coordinate of an atom (in a molecular structure).",
      "exact_synonyms": ["Cartesian y coordinate"],
      "replacedBy": ["http://edamontology.org/data_1743"],
      "text": "Atomic y coordinate"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_2513"
      },
      "definition": "Generate a nucleic acid sequence by some means.",
      "replacedBy": ["http://edamontology.org/operation_0230"],
      "text": "Sequence generation (nucleic acid)"
    }, {
      "consider": ["http://edamontology.org/topic_0102"],
      "data": {
        "uri": "http://edamontology.org/topic_0796"
      },
      "definition": "Informatics resources that aim to identify, map or analyse genetic markers in DNA sequences, for example to produce a genetic (linkage) map of a chromosome or genome or to analyse genetic linkage and synteny.",
      "text": "Genetic mapping and linkage"
    }, {
      "data": {
        "uri": "http://edamontology.org/operation_0328"
      },
      "definition": "Simulate the folding of a protein.",
      "replacedBy": ["http://edamontology.org/operation_2415"],
      "text": "Protein folding simulation"
    }, {
      "consider": ["http://edamontology.org/data_0896"],
      "data": {
        "uri": "http://edamontology.org/data_1533"
      },
      "definition": "An informative report on protein subcellular localisation (nuclear, cytoplasmic, mitochondrial, chloroplast, plastid, membrane etc) or destination (exported / extracellular proteins).",
      "exact_synonyms": ["Protein report (subcellular localisation)"],
      "text": "Protein subcellular localisation"
    }],
    "data": {
      "uri": "owl:DeprecatedClass"
    }
  }],
  "data": {
    "uri": "owl:Thing"
  },
  "meta": {
    "date": "18.06.2020 09:15 UTC",
    "version": "1.25"
  }
};
exports.json = json;
},{}],"kypQ":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.interactive_tree = void 0;

var d3 = _interopRequireWildcard(require("d3"));

var _file = require("./file.js");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

/**
 * Build an interactive tree
 * @return {object} the tree
 */
var interactive_tree = function interactive_tree() {
  var debug = false,
      margin = {
    top: 10,
    right: 50,
    bottom: 10,
    left: 80
  },
      voidHandler = function voidHandler(name) {
    return function () {
      if (debug) console.log(name);
    };
  },
      voidHandlerStrBlank = function voidHandlerStrBlank(name) {
    return function () {
      if (debug) console.log(name);
      return "";
    };
  },
      initiallySelectedElementHandler = voidHandler("initiallySelectedElementHandler"),
      addingElementHandler = voidHandler("addingElementHandler"),
      openElementHandler = voidHandler("openElementHandler"),
      clickedElementHandler = function clickedElementHandler(d) {
    if (debug) console.log(identifierAccessor(d));
  },
      removingElementHandler = voidHandler("removingElementHandler"),
      loadingDoneHandler = voidHandler("loadingDoneHandler"),
      metaInformationHandler = voidHandler("metaInformationHandler"),
      removeElementsWithNoSelectedDescendant = false,
      additionalCSSClassForNode = voidHandlerStrBlank("additionalCSSClassForNode"),
      additionalCSSClassForLink = voidHandlerStrBlank("additionalCSSClassForLink"),
      sortChildren = false,
      identifierAccessor = function identifierAccessor(d) {
    return d.data.id;
  },
      textAccessor = function textAccessor(d) {
    if (typeof d.data.text == "undefined") return identifierAccessor(d);
    if (d.data.text.constructor === Array) return d.data.text[0];
    return d.data.text;
  },
      elementEquality = function elementEquality(e, f) {
    return identifierAccessor(e) == identifierAccessor(f);
  },
      tooltipBuilder = function tooltipBuilder(d, tooltipContainer) {
    var c = "<div class=\"panel panel-default card\"><div class=\"panel-heading\">" + textAccessor(d) + "</div>" + "<div class=\"panel-body\">" + "Identifier: " + identifierAccessor(d) + "</div></div>";
    tooltipContainer.html(c);
  },
      preTreatmentOfLoadedTree = function preTreatmentOfLoadedTree(tree) {
    return tree;
  },
      tooltipEnabled = false,
      use_shift_to_open = false,
      use_control_to_open = true,
      use_alt_to_open = false,
      use_shift_to_add = true,
      use_control_to_add = false,
      use_alt_to_add = false,
      target_selector = null,
      data_url = null,
      root,
      treeSelectedElement = [],
      treeSelectedElementAncestors = null,
      duration = 500,
      update,
      updateWithoutPanAndZoomTuning,
      minX,
      minY,
      maxX,
      maxY,
      reset,
      manualZoom,
      moveElementsIntoView,
      id = 0,
      identifierToElement = {};

  function chart(selection) {
    selection.each(function () {
      target_selector = this;
      var treemap = d3.tree().nodeSize([12, 50]).separation(function (a, b) {
        var a_count = a.children ? a.children.length : 1;
        var b_count = b.children ? b.children.length : 1;
        return (a_count + b_count) / 2 + (a.parent == b.parent ? 0 : 1);
      });
      var diagonal = d3.linkHorizontal().x(function (d) {
        return d.y;
      }).y(function (d) {
        return d.x;
      });
      var zoom = d3.zoom().on("zoom", function () {
        var currentTransform = vis.attr("transform") || '';
        currentTransform = currentTransform.replace("(1)", "(1.0000000)");
        if (currentTransform.includes((d3.zoomTransform(svg.node()).k.toString() + ".0000000").substring(0, 6))) if (!svg.node().classList.contains("auto-drag")) svg.node().classList.add("dragged-or-moved");
        vis.attr("transform", d3.event.transform);
      }).on("end", function () {
        vis.attr("transform", d3.event.transform);
        svg.node().classList.remove("dragged-or-moved");
      });
      var svg = d3.select(this).append("svg:svg").attr("width", "100%").attr("height", "100%").call(zoom);
      var vis = svg.append("svg:g");
      var body = d3.select("body");
      var tooltip = (body.select("div.tooltip").empty() ? body.append("div") : body.select("div.tooltip")).attr("class", "tooltip").style("opacity", 0).on("mouseover", function (d) {
        if (tooltip.style("opacity") == 0) return;
        tooltip.transition().duration(200).style("opacity", 1);
      }).on("mouseout", function (d) {
        tooltip.transition().duration(200).style("opacity", 0);
        tooltip.transition().delay(200).style("top", "-2000px");
      });

      reset = function reset() {
        var shift;
        if (vis.select("g.node").node()) shift = vis.select("g.node").node().getBoundingClientRect().width;else shift = margin.left;
        var t = d3.zoomIdentity.translate(shift, $(target_selector).height() / 2).scale(1);
        svg.call(zoom.transform, t);
      };

      manualZoom = function manualZoom(type) {
        if (type == 'in') {
          zoom.scaleBy(svg, 2);
        } else if (type == 'out') {
          zoom.scaleBy(svg, 0.5);
        }
      };

      moveElementsIntoView = function moveElementsIntoView(elements) {
        var width = $(target_selector).width();
        var height = $(target_selector).height();
        var scale = d3.zoomTransform(svg.node()).k;
        var x = -elements[0].y0;
        var y = -elements[0].x0;
        x = x * scale + width / 2;
        y = y * scale + height / 2;
        var t = d3.zoomIdentity.translate(x, y).scale(scale);
        svg.transition().duration(duration).call(zoom.transform, t).node().classList.add("auto-drag");
        setTimeout(function () {
          svg.node().classList.remove("auto-drag");
        }, duration);
      };

      update = function update(source) {
        //getting the box surronding the svg element ()
        var svgBox = vis.node().getBBox();
        minX = svgBox.x;
        minY = svgBox.y;
        maxX = svgBox.width + svgBox.x;
        maxY = svgBox.height + svgBox.y;
        updateWithoutPanAndZoomTuning(source);
        var xShift = (maxX - minX) / 2;
        zoom.translateExtent([[minX - xShift, minY - xShift], [maxX + xShift, maxY + xShift]]);
      };

      updateWithoutPanAndZoomTuning = function updateWithoutPanAndZoomTuning(source) {
        if (treeSelectedElementAncestors == null) {
          refreshTreeSelectedElementAncestors();
        } // Compute the new tree layout.


        var treeData = treemap(root);
        var nodes = treeData.descendants(),
            links = treeData.descendants().slice(1); // Normalize for fixed-depth.

        nodes.forEach(function (d) {
          d.y = d.depth * 180;
        }); // ****************** Nodes section ***************************
        // Update the nodes…

        var node = vis.selectAll("g.node").data(nodes, function (d) {
          return d.__d3js_id || (d.__d3js_id = ++id);
        }); // Enter any new nodes at the parent's previous position.

        var nodeEnter = node.enter().append("svg:g").attr("class", "node").attr("transform", function (d) {
          return "translate(" + (source.y0 || source.y) + "," + (source.x0 || source.x) + ")";
        }).on("dblclick", function () {
          //stop doubleclick zoom effect
          d3.event.stopPropagation();
        }).on("click", function (d, i) {
          handleClick(d);
        });
        nodeEnter.append("svg:text").text(textAccessor).style("fill-opacity", 1e-6);
        nodeEnter.append("svg:text").text(textAccessor).style("fill-opacity", 1e-6);
        nodeEnter.append("svg:circle").attr("r", 1e-6).attr("class", function (d) {
          return (d._children || d.children ? "has-children " : " ") + additionalCSSClassForNode(d);
        }).on("mouseover", function (d) {
          if (!tooltipEnabled) return;
          tooltipBuilder(d, tooltip);
          var parentWidth = body._groups[0][0].clientWidth;
          var tooltipWidth = tooltip._groups[0][0].clientWidth;
          var tooltipX = d3.event.layerX + 20;
          tooltip.interrupt().transition().duration(200).style("opacity", 1); //checking if the tooltip is cropped and moving it to the left

          if (parentWidth < tooltipWidth + tooltipX) {
            tooltipX = d3.event.layerX - 10 - tooltip._groups[0][0].clientWidth;
          }

          tooltip.style("left", tooltipX + "px").style("top", d3.event.layerY - 5 + "px");
        }).on("mouseout", function (d) {
          tooltip.transition().duration(200).style("opacity", 0);
          tooltip.transition().delay(200).style("top", "-2000px");
        }); // UPDATE

        var nodeUpdate = nodeEnter.merge(node); // Transition nodes to their new position.

        nodeUpdate.transition().duration(duration).attr("transform", function (d) {
          minX = minX ? Math.min(minX, d.y) : d.y;
          minY = minY ? Math.min(minY, d.x) : d.x;
          maxX = maxX ? Math.max(maxX, d.y) : d.y;
          maxY = maxY ? Math.max(maxY, d.x) : d.x;
          return "translate(" + d.y + "," + d.x + ")";
        });
        nodeUpdate.select("circle").attr("r", 4.5).attr("class", function (d) {
          if (isElementSelected(d, treeSelectedElement)) return "selected " + additionalCSSClassForNode(d);
          return (d._children || d.children ? "has-children " : " ") + additionalCSSClassForNode(d);
        });
        nodeUpdate.selectAll("text").attr("x", function (d) {
          return d.children ? -10 : 10;
        }).attr("dy", function (d) {
          return d.parent && d.children && d.parent.children.length == 1 ? "-0.2em" : ".35em";
        }).attr("text-anchor", function (d) {
          return d.children ? "end" : "start";
        }).style("fill-opacity", '').style("font-size", '').attr("class", function (d) {
          return isElementSelected(d, treeSelectedElement) ? "selected" : "";
        }); // Transition exiting nodes to the parent's new position.

        var nodeExit = node.exit().transition().duration(duration).attr("transform", function (d) {
          return "translate(" + source.y0 + "," + source.x0 + ")";
        }).remove();
        nodeExit.select("circle").attr("r", 1e-6);
        nodeExit.selectAll("text").style("font-size", '1px').style("fill-opacity", 1e-6); // ****************** links section ***************************
        // Update the links…

        var link = vis.selectAll("path.link").data(links, function (d) {
          return d.__d3js_id;
        }); // Transition exiting nodes to the parent's new position.
        // Enter any new links at the parent's previous position.

        var linkEnter = link.enter().insert("svg:path", "g").attr("data-id", function (d) {
          return d.__d3js_id;
        }).attr("d", function (d) {
          var o = {
            x: source.x0 || source.x,
            y: source.y0 || source.y
          };
          return diagonal({
            source: o,
            target: o
          });
        }).attr("class", function (d) {
          return "link " + additionalCSSClassForLink(d);
        }); // UPDATE

        var linkUpdate = linkEnter.merge(link); // Transition links to their new position.

        linkUpdate.transition().duration(duration).attr('d', function (d) {
          return diagonal({
            source: d,
            target: d.parent
          });
        }).attr("class", function (d) {
          if ($.inArray(identifierAccessor(d), treeSelectedElementAncestors) > -1) return "link selected " + additionalCSSClassForLink(d);
          return "link " + additionalCSSClassForLink(d);
        });
        var linkExit = link.exit().transition().duration(duration).attr("d", function (d) {
          var o = {
            x: source.x,
            y: source.y
          };
          return diagonal({
            source: o,
            target: o
          });
        }).remove(); // Stash the old positions for transition.

        nodes.forEach(function (d) {
          d.x0 = d.x;
          d.y0 = d.y;
        });
      }; //end of update(source)


      if (data_url != null) {
        update(root);
        reset();
        loadingDoneHandler();
      }
    }); //end of selection.each
  } //end of function chart
  // Toggle children.


  function toggle(d) {
    if (d.children) {
      // collapse
      d._children = d.children;
      d.children = null;
    } else {
      // expand
      d.children = d._children;
      d._children = null;
    }
  } //end of toggle


  function toggleForceExpand(d) {
    if (d.children) return;
    toggle(d);
  } //end of toggleForceExpand


  function toggleForceCollapse(d) {
    if (d._children) return;
    toggle(d);
  } //end of toggleForceCollapse
  //Handle selection of a node


  function handleClick(d) {
    if (d3.event.shiftKey && use_shift_to_open || d3.event.ctrlKey && use_control_to_open || d3.event.altKey && use_alt_to_open) {
      openElementHandler(d);
    } else if (d3.event.shiftKey && use_shift_to_add || d3.event.ctrlKey && use_control_to_add || d3.event.altKey && use_alt_to_add) {
      var pos = treeSelectedElement.indexOf(d);

      if (pos > -1) {
        //removing ?
        attemptToRemoveElement(d, pos);
      } else {
        //adding ?
        attemptToSelectElement(d);
      }
    } else if (!d3.event.shiftKey && !d3.event.ctrlKey && !d3.event.altKey && d3.event.detail == 1) {
      chart.cmd.clearSelectedElements(false);
      toggle(d);
      clickedElementHandler(d);
    }

    update(d);
  } //end of handleClick


  function attemptToRemoveElement(d, pos) {
    if (typeof pos == "undefined" || pos == -1) pos = treeSelectedElement.indexOf(d);

    if (removingElementHandler(d) != false) {
      treeSelectedElement.splice(pos, 1);

      if (d.duplicate) {
        for (var i = pos; i < treeSelectedElement.length; i++) {
          if (elementEquality(treeSelectedElement[i], d)) {
            treeSelectedElement.splice(i, 1);
            i--;
          }
        }
      }

      refreshTreeSelectedElementAncestors();
    }
  } //end of attemptToRemoveElement


  function attemptToSelectElement(d) {
    if (addingElementHandler(d) != false) {
      if (d.duplicate) {
        recursivePush(d, root);
      } else {
        treeSelectedElement.push(d);
      }

      refreshTreeSelectedElementAncestors();
    }
  } //end of attemptToSelectElement


  function recursivePush(refElement, org) {
    var i;
    if (elementEquality(refElement, org)) treeSelectedElement.push(org);
    if (org.children) for (i = 0; i < org.children.length; i++) {
      recursivePush(refElement, org.children[i]);
    }
    if (org._children) for (i = 0; i < org._children.length; i++) {
      recursivePush(refElement, org._children[i]);
    }
  } //end of recursivePush


  function refreshTreeSelectedElementAncestors() {
    treeSelectedElementAncestors = [];
    var candidate;

    for (var i = 0; i < treeSelectedElement.length; i++) {
      candidate = treeSelectedElement[i];

      while (candidate != null
      /* && treeSelectedElementAncestors.indexOf(identifierAccessor(candidate))==-1*/
      ) {
        var id_candidate = identifierAccessor(candidate);
        if ($.inArray(id_candidate, treeSelectedElementAncestors)) treeSelectedElementAncestors.push(id_candidate);
        candidate = candidate.parent;
      }
    }
  } //end of refreshTreeSelectedElementAncestors


  function parenthood(element, parent) {
    var node = identifierToElement[identifierAccessor(element)];

    if (typeof node != "undefined") {
      if (typeof node.duplicate == "undefined") node.duplicate = [node];
      node.duplicate.push(element);
      element.duplicate = node.duplicate;
    } else {
      identifierToElement[identifierAccessor(element)] = element;
    }

    element.parent = parent;

    if (element.children) {
      if (sortChildren) {
        element.children.sort(function (a, b) {
          a = textAccessor(a).toUpperCase();
          b = textAccessor(b).toUpperCase();
          if (a < b) return -1;
          if (a > b) return 1;
          return 0;
        });
      }

      for (var i = 0; i < element.children.length; i++) {
        parenthood(element.children[i], element);
      }
    }

    if (initiallySelectedElementHandler(element)) {
      treeSelectedElement.push(element);
    }
  } //end of function parenthood


  function shouldRemoveThisElementsAsItHasNoSelectedDescendant(element) {
    var b = true;

    if (element.children) {
      for (var i = 0; i < element.children.length; i++) {
        if (shouldRemoveThisElementsAsItHasNoSelectedDescendant(element.children[i])) {
          element.children.splice(i, 1);
          i--;
        } else {
          b = false;
        }
      }

      if (element.children.length == 0) {
        element.children = null;
      }
    }

    b = b && !initiallySelectedElementHandler(element);

    if (b) {
      element.children = null;
      element._children = null;
    }

    return b;
  } //end of function shouldRemoveThisElementsAsItHasNoSelectedDescendant


  function browseToFromElement(identifier, element, selectedIt, expandToIt) {
    var b = false;

    if (identifier == identifierAccessor(element)) {
      if (selectedIt) attemptToSelectElement(element);
      return true;
    }

    var ch, i;

    if (element.children) {
      ch = element.children;

      for (i = 0; i < ch.length; i++) {
        if (browseToFromElement(identifier, ch[i], selectedIt, expandToIt)) {
          if (expandToIt) toggleForceExpand(element);
          b = true; //return true;
        }
      }
    } else if (element._children) {
      ch = element._children;

      for (i = 0; i < ch.length; i++) {
        if (browseToFromElement(identifier, ch[i], selectedIt, expandToIt)) {
          if (expandToIt) toggleForceExpand(element);
          b = true; //return true;
        }
      }
    }

    return b;
  } //end of browseToFromElement


  function isElementSelected(node) {
    return $.inArray(node, treeSelectedElement) > -1;
  } //end of isElementSelected


  function collapseNotSelectedElement(node) {
    var hasSelectedDescendant = false;

    if (node.children) {
      for (var i = 0; i < node.children.length; i++) {
        if (collapseNotSelectedElement(node.children[i])) {
          hasSelectedDescendant = true;
        }
      }
    }

    if (!hasSelectedDescendant) toggleForceCollapse(node);
    if (isElementSelected(node)) return true;
    return hasSelectedDescendant;
  } //end of collapseNotSelectedElement


  function expandSelectedElement(node) {
    var hasSelectedDescendant = false;
    var i;

    if (node._children) {
      for (i = 0; i < node._children.length; i++) {
        if (expandSelectedElement(node._children[i])) {
          hasSelectedDescendant = true;
        }
      }
    } else if (node.children) {
      for (i = 0; i < node.children.length; i++) {
        if (expandSelectedElement(node.children[i])) {
          hasSelectedDescendant = true;
        }
      }
    }

    if (hasSelectedDescendant) {
      console.log("Ex:" + node);
      toggleForceExpand(node);
    }

    if (isElementSelected(node)) return true;
    return hasSelectedDescendant;
  } //end of expandSelectedElement


  function expandAllDescendantElement(node) {
    var i,
        children = node._children || node.children;

    if (children) {
      for (i = 0; i < children.length; i++) {
        expandAllDescendantElement(children[i]);
      }
    }

    toggleForceExpand(node);
  } //end of expandAllElement


  function getFartherAncestorCollapsed(node) {
    var source = node;
    var pointer = node;

    while (pointer.parent) {
      if (pointer._children) source = pointer;
      pointer = pointer.parent;
    }

    return source;
  } //end of getFartherAncestorCollapsed


  function initTreeAndTriggerUpdate() {
    treeSelectedElement = [];
    treeSelectedElementAncestors = [];
    metaInformationHandler(root.data.meta);
    root.x0 = 0;
    root.y0 = 0;
    parenthood(root, null);
    refreshTreeSelectedElementAncestors();

    if (removeElementsWithNoSelectedDescendant) {
      shouldRemoveThisElementsAsItHasNoSelectedDescendant(root);
    }

    collapseNotSelectedElement(root);

    if (update) {
      update(root);
      loadingDoneHandler();
      reset();
    }
  } //accessors


  function cmd() {
    return cmd;
  }
  /**
   * Ask to collapse to element identified by identifier
   * @param {string} identifier - the element identifier that is returned by identifierAccessor
   * @return cmd() itself
   */


  cmd.collapseElement = function (identifier) {
    toggleForceCollapse(identifierToElement[identifier]);
    update(root);
    return cmd;
  };
  /**
   * Ask to expand an element
   * @param {string} identifier - the element identifier that is returned by identifierAccessor
   * @return cmd() itself
   */


  cmd.expandElement = function (identifier) {
    var source = getFartherAncestorCollapsed(identifierToElement[identifier]);
    browseToFromElement(identifier, root, false, true);
    update(source);
    return cmd;
  };
  /**
   * Add/remove elements identified by the identifier depending of the boolean status, and expand to selected element(s) when asked
   * @param {string} identifier - the element identifier that is returned by identifierAccessor
   * @param {boolean} status - true to add, false to remove
   * @param {boolean} [andExpand=true] - expand to selected element(s)
   * @return cmd() itself
   */


  cmd.selectElement = function (identifier, status, andExpand) {
    var node = identifierToElement[identifier];
    if (typeof node == "undefined") return cmd;
    var source = getFartherAncestorCollapsed(node);
    if (status) browseToFromElement(identifier, root, true, typeof andExpand == "undefined" || andExpand);else attemptToRemoveElement(node);
    update(source);
    return cmd;
  };
  /**
   *
   * @param {string} identifier - the element identifier that is returned by identifierAccessor
   * @return {boolean} true is the element is selected
   */


  cmd.isElementSelected = function (identifier) {
    return isElementSelected(identifierToElement[identifier]);
  };
  /**
   * Ask to de-select all elements
   * @param {boolean} [redraw=true] - redraw the tree
   * @return cmd() itself
   */


  cmd.clearSelectedElements = function (redraw) {
    treeSelectedElement = [];
    refreshTreeSelectedElementAncestors();
    if (redraw != false) update(root);
    return cmd;
  };
  /**
   * Ask to collapse all elements that have no selected descendants
   * @return cmd() itself
   */


  cmd.collapseNotSelectedElement = function () {
    collapseNotSelectedElement(root);
    update(root);
    return cmd;
  };
  /**
   * Ask to expand to all selected elements
   * @return cmd() itself
   */


  cmd.expandSelectedElement = function () {
    expandSelectedElement(root);
    update(root);
    return cmd;
  };
  /**
   * Ask to expand to all selected elements
   * @return cmd() itself
   */


  cmd.expandAllDescendantElement = function (identifier) {
    console.log(identifierAccessor(root));
    var node = identifierToElement[identifier] || root;
    browseToFromElement(identifier, root, false, true);
    expandAllDescendantElement(node);
    update(node);
    return cmd;
  };
  /**
   * Return the element that have this identifier
   * @return cmd() itself
   */


  cmd.getElementByIdentifier = function (identifier) {
    return identifierToElement[identifier];
  };
  /**
   * Iterate over ell the elements of the tree
   * @return cmd() itself
   */


  cmd.forEachElement = function (fcn) {
    $.each(identifierToElement, fcn);
    return cmd;
  };
  /**
   * Iterate over ell the elements of the tree
   * @return cmd() itself
   */


  cmd.resetPanAndZoom = function () {
    reset();
    return cmd;
  };
  /**
   * Zooming in and out with buttons
   * @param {string} type Zooming type (in or out)
   * @return cmd() itself
   */


  cmd.manualZoomInAndOut = function (type) {
    manualZoom(type);
    return cmd;
  };
  /**
  *
  * @param {Object[]} elements - the identifiers that should be visible after the call of this method
  */


  cmd.moveElementsIntoView = function (elements) {
    moveElementsIntoView(elements);
  }; // getter and setter functions. See Mike Bostocks post "Towards Reusable Charts" for a tutorial on how this works.


  chart.cmd = cmd;
  /**
   * Accessor configuring the animation's duration
   * @param {boolean} value
   */

  chart.duration = function (value) {
    if (!arguments.length) return duration;
    duration = value;
    return chart;
  };
  /**
   * Accessor configuring if debug message should be displayed
   * @param {boolean} value
   */


  chart.debug = function (value) {
    if (!arguments.length) return debug;
    debug = value;
    return chart;
  };
  /**
   * Accessor configuring if the tooltip should be displayed
   * @param {boolean} value
   */


  chart.tooltipEnabled = function (value) {
    if (!arguments.length) return tooltipEnabled;
    tooltipEnabled = value;
    return chart;
  };
  /**
   * Accessor configuring if the children should be sorted
   * @param {boolean} value
   */


  chart.sortChildren = function (value) {
    if (!arguments.length) return sortChildren;
    sortChildren = value;
    return chart;
  };
  /**
   * Accessor configuring if shift key should be used to open externally an element
   * @param {boolean} [value=false]
   */


  chart.use_shift_to_open = function (value) {
    if (!arguments.length) return use_shift_to_open;
    use_shift_to_open = value;
    return chart;
  };
  /**
   * Accessor configuring if alt control should be used to open externally an element
   * @param {boolean} [value=true]
   */


  chart.use_control_to_open = function (value) {
    if (!arguments.length) return use_control_to_open;
    use_control_to_open = value;
    return chart;
  };
  /**
   * Accessor configuring if alt key should be used to open externally an element
   * @param {boolean} [value=false]
   */


  chart.use_alt_to_open = function (value) {
    if (!arguments.length) return use_alt_to_open;
    use_alt_to_open = value;
    return chart;
  };
  /**
   * Accessor configuring if shift key should be used to add/remove an element to/from selection
   * @param {boolean} [value=true]
   */


  chart.use_shift_to_add = function (value) {
    if (!arguments.length) return use_shift_to_add;
    use_shift_to_add = value;
    return chart;
  };
  /**
   * Accessor configuring if control key should be used to add/remove an element to/from selection
   * @param {boolean} [value=false]
   */


  chart.use_control_to_add = function (value) {
    if (!arguments.length) return use_control_to_add;
    use_control_to_add = value;
    return chart;
  };
  /**
   * Accessor configuring if alt key should be used to add/remove an element to/from selection
   * @param {boolean} [value=false]
   */


  chart.use_alt_to_add = function (value) {
    if (!arguments.length) return use_alt_to_add;
    use_alt_to_add = value;
    return chart;
  };
  /**
   * Accessor to the url where the json formatted tree can be found
   * @param {string} value - a valid url
   */


  chart.data_url = function (value) {
    if (!arguments.length) return data_url;
    identifierToElement = {};
    data_url = value;

    if (_file.json == null) {
      alert('Unable to read content of "' + data_url + '"');
    } else {
      if (typeof _file.json.meta == "undefined") {
        _file.json.meta = {
          "version": "v n/a",
          "date": "n/a"
        };
      }

      _file.json.meta.data_url = data_url;
      chart.data(_file.json);
    }
  };
  /**
   * Accessor to the url where the json formatted tree can be found
   * @param {string} value - a valid url
   */


  chart.data = function (value) {
    if (!arguments.length) return root;
    identifierToElement = {};
    root = d3.hierarchy(preTreatmentOfLoadedTree(value), function (d) {
      return d.children;
    });
    initTreeAndTriggerUpdate();
    return chart;
  };
  /**
   * Accessor to the method adding classed to nodes
   * @param {function} value - an implementation of function (d){...} returning a class name(s)
   */


  chart.additionalCSSClassForNode = function (value) {
    if (!arguments.length) return additionalCSSClassForNode;
    additionalCSSClassForNode = value;
    return chart;
  };
  /**
   * Accessor to the method adding classed to links
   * @param {function} value - an implementation of function (d){...} returning a class name(s)
   */


  chart.additionalCSSClassForLink = function (value) {
    if (!arguments.length) return additionalCSSClassForLink;
    additionalCSSClassForLink = value;
    return chart;
  };
  /**
   * Accessor to the method returning the text of an element (toString)
   * @param {function} value - an implementation of function (a){...} returning the text
   */


  chart.textAccessor = function (value) {
    if (!arguments.length) return textAccessor;
    textAccessor = value;
    return chart;
  };
  /**
   * Accessor to the method returning the identifier of an element
   * @param {function} value - an implementation of function (a){...} returning the identifier
   */


  chart.identifierAccessor = function (value) {
    if (!arguments.length) return identifierAccessor;
    identifierAccessor = value;
    return chart;
  };
  /**
   * Accessor to the method building the tooltip of an element
   * @param {function} value - an implementation of function (d){...} returning the html code contained in the tooltip
   */


  chart.tooltipBuilder = function (value) {
    if (!arguments.length) return tooltipBuilder;
    tooltipBuilder = value;
    return chart;
  };
  /**
   * Accessor to the method building the tooltip of an element
   * @param {function} value - an implementation of function (d){...} returning the html code contained in the tooltip
   */


  chart.preTreatmentOfLoadedTree = function (value) {
    if (!arguments.length) return preTreatmentOfLoadedTree;
    preTreatmentOfLoadedTree = value;
    return chart;
  };
  /**
   * Accessor to the method testing if an element is initially selected
   * @param {function} value - an implementation of function (d){...} returning true if the element is initially selected
   */


  chart.initiallySelectedElementHandler = function (value) {
    if (!arguments.length) return initiallySelectedElementHandler;
    initiallySelectedElementHandler = value;
    return chart;
  };
  /**
   * Accessor to the method testing the validity of the selection of an element
   * @param {function} value - an implementation of function (d){...} returning true if the element can be selected
   */


  chart.addingElementHandler = function (value) {
    if (!arguments.length) return addingElementHandler;
    addingElementHandler = value;
    return chart;
  };
  /**
   * Accessor to the method launch when an element have been requested to open externally
   * @param {function} value - an implementation of function (d){...}
   */


  chart.openElementHandler = function (value) {
    if (!arguments.length) return openElementHandler;
    openElementHandler = value;
    return chart;
  };
  /**
   * Accessor to the method launch when an element have been clicked
   * @param {function} value - an implementation of function (){...}
   */


  chart.clickedElementHandler = function (value) {
    if (!arguments.length) return clickedElementHandler;
    clickedElementHandler = value;
    return chart;
  };
  /**
   * Accessor to the method testing the validity of the deselection of an element
   * @param {function} value - an implementation of function (d){...} returning true if the element can be deselected
   */


  chart.removingElementHandler = function (value) {
    if (!arguments.length) return removingElementHandler;
    removingElementHandler = value;
    return chart;
  };
  /**
   * Accessor to the method launch when the tree has been built
   * @param {function} value - an implementation of function (){...}
   */


  chart.loadingDoneHandler = function (value) {
    if (!arguments.length) return loadingDoneHandler;
    loadingDoneHandler = value;
    return chart;
  };
  /**
   * Accessor to the method launch when a tree is being loaded with the meta information fetched from the root element
   * @param {function} value - an implementation of function (meta){...}
   */


  chart.metaInformationHandler = function (value) {
    if (!arguments.length) return metaInformationHandler;
    metaInformationHandler = value;
    return chart;
  };
  /**
   * Accessor to the method testing equality between two nodes
   * @param {function} value - an implementation of function (a,b){...} returning true if a and b are equals
   */


  chart.elementEquality = function (value) {
    if (!arguments.length) return elementEquality;
    elementEquality = value;
    return chart;
  };

  return chart;
};

exports.interactive_tree = interactive_tree;
},{"d3":"BG5c","./file.js":"ZNE1"}],"IZXy":[function(require,module,exports) {
"use strict";Object.defineProperty(exports,"__esModule",{value:true});exports["default"]=exports.gtag=exports.install=void 0;var install=function install(trackingId){var additionalConfigInfo=arguments.length>1&&arguments[1]!==undefined?arguments[1]:{};var scriptId="ga-gtag";if(document.getElementById(scriptId))return;var _document=document,head=_document.head;var script=document.createElement("script");script.id=scriptId;script.type="text/javascript";script.async=true;script.src="https://www.googletagmanager.com/gtag/js?id=".concat(trackingId);head.insertBefore(script,head.firstChild);window.dataLayer=window.dataLayer||[];gtag("js",new Date);gtag("config",trackingId,additionalConfigInfo)};exports.install=install;var gtag=function gtag(){window.dataLayer.push(arguments)};exports.gtag=gtag;var _default=gtag;exports["default"]=_default;
},{}],"MgTz":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getUrlParameter = getUrlParameter;
exports.setCookie = setCookie;
exports.getCookie = getCookie;
exports.getHeight = getHeight;
exports.setUrlParameters = setUrlParameters;
exports.getDarkMode = getDarkMode;

require("jquery-ui-bundle");

if (!Array.prototype.remove) {
  Array.prototype.remove = function (val) {
    var i = this.indexOf(val);
    return i > -1 ? this.splice(i, 1) : [];
  };
}

function getUrlParameter(sParam, default_value) {
  var sPageURL = decodeURIComponent(window.location.search.substring(1)),
      sURLVariables = sPageURL.split('&'),
      sParameterName,
      i;

  for (i = 0; i < sURLVariables.length; i++) {
    sParameterName = sURLVariables[i].split('=');

    if (sParameterName[0] === sParam) {
      return sParameterName[1] === undefined ? true : sParameterName[1];
    }
  }

  return default_value;
}

function setCookie(cname, cvalue, exdays) {
  var d = new Date();
  d.setTime(d.getTime() + exdays * 24 * 60 * 60 * 1000);
  var expires = "expires=" + d.toUTCString();
  document.cookie = cname + "=" + cvalue + ";" + expires + ";path=/";
}

function getCookie(cname, default_value) {
  var name = cname + "=";
  var ca = document.cookie.split(';');

  for (var i = 0; i < ca.length; i++) {
    var c = ca[i];

    while (c.charAt(0) == ' ') {
      c = c.substring(1);
    }

    if (c.indexOf(name) == 0) {
      return c.substring(name.length, c.length);
    }
  }

  if (typeof default_value == "undefined") return "";
  return default_value;
}

function getHeight() {
  return Math.max(document.documentElement.clientHeight, window.innerHeight || 0) * 0.75;
}

jQuery.ui.autocomplete.prototype._resizeMenu = function () {
  var ul = this.menu.element;
  ul.outerWidth(this.element.outerWidth());
};

function setUrlParameters(serializedParameters) {
  if (typeof serializedParameters == "undefined") serializedParameters = "";
  var new_url = window.location.protocol + "//" + window.location.host + window.location.pathname + (serializedParameters === "" ? "" : "?" + serializedParameters) + window.location.hash;
  window.history.pushState({
    path: new_url
  }, '', new_url);
}

function getDarkMode() {
  var btn = document.querySelector(".btn-toggle");
  var currentTheme = localStorage.getItem("theme");

  if (currentTheme == "dark") {
    document.body.classList.add("dark-mode");
  }

  if (null == btn || undefined == btn) return;
  btn.addEventListener("click", function () {
    document.body.classList.toggle("dark-mode");
    var theme = "light";

    if (document.body.classList.contains("dark-mode")) {
      theme = "dark";
    }

    localStorage.setItem("theme", theme);
  });
}
},{"jquery-ui-bundle":"Hifx"}],"ppKG":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.typeDict = void 0;

require("../jquey-import");

require("bootstrap");

require("jquery-ui-themes/themes/smoothness/jquery-ui.css");

require("bootstrap/dist/css/bootstrap.css");

require("@fortawesome/fontawesome-free/css/all.css");

require("../css/bootstrap.xl.css");

require("../css/autocomplete-edam-reusable.css");

require("../css/edam.css");

require("../css/dark-theme.css");

require("regenerator-runtime/runtime");

require("jquery-ui-bundle");

var _utils = require("./utils.js");

var _autocompleteEdamReusable2 = require("./autocomplete-edam-reusable.js");

var browser;
var typeDict = {
  "has_topic_container": "topic",
  "is_format_of_container": "data",
  "has_input_container": "data",
  "has_output_container": "data",
  "is_identifier_of_container": "data"
};
exports.typeDict = typeDict;

function fill_form(identifier, parent, branch) {
  //not used, won't be used after loading from cache
  //let tree_file = getTreeFile(branch);
  (0, _autocompleteEdamReusable2.build_autocomplete_from_edam_browser)(browser, undefined, typeDict);
  browser.interactive_tree.cmd.getElementByIdentifier(identifier);
  build_form(browser.interactive_tree.cmd.getElementByIdentifier(identifier), browser.interactive_tree.cmd.getElementByIdentifier(parent));
}

function build_form(target, parentOfNewTerm) {
  var v;

  if (target) {
    $("#id_label").val(v = target.text);
    $("#id_label").attr('data-initial', v);
    $("#id_definition").val(v = target.definition);
    $("#id_definition").attr('data-initial', v);
    $("#id_exactSynonyms").val(v = join_if_exists(target.exact_synonyms));
    $("#id_exactSynonyms").attr('data-initial', v);
    $("#id_narrowSynonyms").val(v = join_if_exists(target.narrow_synonyms));
    $("#id_narrowSynonyms").attr('data-initial', v);
    /*v=[];
    for(var i=0;i<target.parent.length;i++){
        v.push(target.parents[i].data.uri);
    }
    v=v.join("|");*/

    var parents;
    var i;

    if (target.duplicate) {
      parents = {};
      parents[target.parent.data.uri] = target.parent;
      $.each(target.duplicate, function (id, clone) {
        parents[clone.parent.data.uri] = clone.parent;
      });
      parents = $.map(parents, function (value, key) {
        return value;
      });
    } else {
      parents = [target.parent];
    }

    $(".search-term[name=parent-0]").attr('data-initial', parents[0].data.uri);
    $(".search-term[name=parent-0]").attr('data-selected', parents[0].data.uri);
    $(".search-term[name=parent-0]").val(parents[0].text);

    for (i = 1; i < parents.length; i++) {
      addTermField("#parent_container", "parent", parents[i]);
    }

    for (i = 0; i < (target.has_topic || []).length; i++) {
      addTermField("#has_topic_container", "has_topic", browser.interactive_tree.cmd.getElementByIdentifier(target.has_topic[i]));
    }

    for (i = 0; i < (target.is_format_of || []).length; i++) {
      addTermField("#is_format_of_container", "is_format_of", browser.interactive_tree.cmd.getElementByIdentifier(target.is_format_of[i]));
    }

    for (i = 0; i < (target.has_input || []).length; i++) {
      addTermField("#has_input_container", "has_input", browser.interactive_tree.cmd.getElementByIdentifier(target.has_input[i]));
    }

    for (i = 0; i < (target.has_output || []).length; i++) {
      addTermField("#has_output_container", "has_output", browser.interactive_tree.cmd.getElementByIdentifier(target.has_output[i]));
    }

    for (i = 0; i < (target.is_identifier_of || []).length; i++) {
      addTermField("#is_identifier_of_container", "is_identifier_of", browser.interactive_tree.cmd.getElementByIdentifier(target.is_identifier_of[i]));
    }
  } else {
    $(".search-term").val(parentOfNewTerm.text);
  } // toggle per-branch attributs


  var s_branch = (0, _utils.getUrlParameter)('term') || (0, _utils.getUrlParameter)('parent');
  s_branch = s_branch.substring(s_branch.lastIndexOf('/') + 1, s_branch.lastIndexOf('_'));

  if (is_descendant_of_or_is(target || parentOfNewTerm, "http://edamontology.org/data_0842")) {
    s_branch = "identifier";
  }

  $('.optional_rel').hide();
  $('.' + s_branch + '_rel').show(); // unlock form

  $("form [disabled=disabled]").attr("disabled", false);
}

function is_descendant_of_or_is(node, ancestor_identifier) {
  if (browser.identifierAccessor(node) === ancestor_identifier) return true;
  if (browser.identifierAccessor(node) === "owl:Thing") return false;
  return is_descendant_of_or_is(node.parent, ancestor_identifier);
}

function join_if_exists(tab) {
  if (typeof tab == "undefined") {
    return "";
  }

  return tab.join('; ');
}

window.addTermField = function addTermField(container, kind, initial_term) {
  var i = $(container).find(".search-term").length;
  $(".search-term[name=parent-0]").clone().attr("name", kind + "-" + i).insertBefore($(container).children("button"));
  $(".search-term[name=" + kind + "-" + i + "]").val(initial_term ? initial_term.text : "").attr('data-initial', initial_term ? initial_term.data.uri : "").attr("data-selected", initial_term ? initial_term.data.uri : ""); //    build_autocomplete(
  //        getTreeFile(getCookie("edam_browser_branch","topic")),

  (0, _autocompleteEdamReusable2.build_autocomplete_from_edam_browser)(browser, ".search-term[name=" + kind + "-" + i + "]", typeDict);
};

var uri = "";
var parent_uri = null;

window.onload = function () {
  (0, _utils.getDarkMode)();
  var uri = (0, _utils.getUrlParameter)('term');
  var branch = (0, _utils.getUrlParameter)('branch');

  if (uri) {
    $('#pageTitle .new').hide();
  } else {
    $('#pageTitle .change').hide();
  }

  var sub_branch = (0, _utils.getUrlParameter)('term') + (0, _utils.getUrlParameter)('parent');
  sub_branch = sub_branch.substring(sub_branch.lastIndexOf('/') + 1, sub_branch.lastIndexOf('_'));
  $('#pageTitle .branch').text(sub_branch);
  typeDict.parent_container = sub_branch;
  browser = (0, _autocompleteEdamReusable2.fake_interactive_edam_browser)();
  browser.interactive_tree.loadingDoneHandler(function () {
    fill_form(uri, (0, _utils.getUrlParameter)('parent'), branch);
  });
  browser.current_branch((0, _utils.getUrlParameter)('branch'));
};

window.sendToGitHub = function sendToGitHub() {
  var ids = ["#id_parent", "#id_label", "#id_definition", "#id_exactSynonyms", "#id_narrowSynonyms"];
  var i;
  $(".search-term").each(function () {
    ids.push(".search-term[name=" + this.getAttribute("name") + "]");
  });
  var msg = "";
  msg += "[//]: # (You can add comment regarding your issue hereafter)\n";

  if ($("#id_github_comments").val()) {
    msg += "### Comments\n";
  }

  msg += $("#id_github_comments").val();
  msg += "\n\n";
  msg += "[//]: # (End of issue comments)\n";
  msg += "### Hereafter are the initial version and proposed modification of attributes of the given term\n";

  for (i = 0; i < ids.length; i++) {
    var val = $(ids[i]).attr('data-selected') || $(ids[i]).val();

    if (val != $(ids[i]).attr('data-initial')) {
      msg += "\n";
      msg += "| key | value |\n";
      msg += "| --- | --- |\n";
      msg += "| Attr  | **" + $(ids[i]).attr('name') + "** |\n";
      msg += "| Old | " + $(ids[i]).attr('data-initial') + " |\n";
      msg += "| New | " + val + " |\n";
      msg += "|  |  |\n";
      msg += "\n";
    }
  }

  if ($('#pageTitle .new:visible').length > 0) {
    $("#sender [name=title]").val("[Edam Browser User] New child proposition for " + $("#id_parent").val());
  } else {
    $("#sender [name=title]").val("[Edam Browser User] Change proposition for " + uri);
  }

  $("#sender [name=body]").val(msg);
  $("#sender").submit();
};
},{"../jquey-import":"FtjA","bootstrap":"jv0N","jquery-ui-themes/themes/smoothness/jquery-ui.css":"AC2V","bootstrap/dist/css/bootstrap.css":"gsgA","@fortawesome/fontawesome-free/css/all.css":"Eofe","../css/bootstrap.xl.css":"ju9n","../css/autocomplete-edam-reusable.css":"ju9n","../css/edam.css":"ju9n","../css/dark-theme.css":"ju9n","regenerator-runtime/runtime":"KA2S","jquery-ui-bundle":"Hifx","./utils.js":"MgTz","./autocomplete-edam-reusable.js":"ZZY2"}],"ZZY2":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.fake_interactive_edam_browser = fake_interactive_edam_browser;
exports.build_autocomplete_from_edam_browser = build_autocomplete_from_edam_browser;

var _file = require("./file.js");

var _edit = require("./edit.js");

function fake_interactive_edam_browser() {
  var identifierToElement = {},
      identifierAccessor = function identifierAccessor(d) {
    return d.data.uri;
  },
      textAccessor = function textAccessor(d) {
    if (typeof d.text == "undefined") return identifierAccessor(d);
    if (d.text.constructor === Array) return d.text[0];
    return d.text;
  },
      interactive_tree = function interactive_tree() {
    return interactive_tree;
  },
      loadingDoneHandler = function loadingDoneHandler() {};

  function buildIdentifierToElement(element, parent) {
    element.parent = parent;

    if (identifierAccessor(element) === "owl:DeprecatedClass") {
      element.deprecated = true;
    }

    var node = identifierToElement[identifierAccessor(element)];

    if (typeof node != "undefined") {
      if (typeof node.duplicate == "undefined") node.duplicate = [];
      node.duplicate.push(element);
      element.duplicate = node.duplicate;
    } else {
      identifierToElement[identifierAccessor(element)] = element;
    }

    element.parent = parent;

    for (var i = 0; i < (element.children || []).length; i++) {
      if (element.deprecated) {
        element.children[i].deprecated = true;
      }

      buildIdentifierToElement(element.children[i], element);
    }
  } //end of function buildIdentifierToElement

  /**
   * The browser
   */


  function browser() {}
  /**
   * Read-only accessor to the interactive tree
   * @return {object} the tree
   */


  browser.interactive_tree = interactive_tree;
  /**
   * Accessor to the method launch when the tree has been built
   * @param {function} value - an implementation of function (){...}
   */

  interactive_tree.loadingDoneHandler = function (value) {
    if (!arguments.length) return loadingDoneHandler;
    loadingDoneHandler = value;
    return interactive_tree;
  };
  /**
   * The tree's commands
   */


  function cmd() {
    return cmd;
  }

  interactive_tree.cmd = cmd;
  /**
   * Return the element that have this identifier
   * @return cmd() itself
   */

  cmd.getElementByIdentifier = function (identifier) {
    return identifierToElement[identifier];
  };
  /**
   * Iterate over ell the elements of the tree
   * @return cmd() itself
   */


  cmd.forEachElement = function (fcn) {
    $.each(identifierToElement, fcn);
    return cmd;
  };

  cmd.selectElement = function () {};

  cmd.clearSelectedElements = function () {};

  cmd.moveElementsIntoView = function () {};
  /**
   * Read-only proxy to use the identifierAccessor of the interactive_tree
   * @param {object} an element
   * @return {object} the value return by the identifierAccessor for the given parameter
   */


  browser.identifierAccessor = identifierAccessor;
  /**
   * Read-only proxy to use the textAccessor of the interactive_tree
   * @param {object} an element
   * @return {object} the value return by the textAccessor for the given parameter
   */

  browser.textAccessor = textAccessor;
  /**
   * Get the current branch or load the branch given in parameter if it is not
   * the current branch
   * @param {string} value
   */

  browser.current_branch = function (value) {
    //should be replaced with loading from cache
    buildIdentifierToElement(_file.json, null);
    loadingDoneHandler();
    return browser;
    /*$.ajax({
        type: "GET",
        dataType: "json",
        url:getTreeFile(value),
        data: {},
        success: function (data, textStatus, xhr) {
            buildIdentifierToElement(data, null);
            loadingDoneHandler();
        }
    });
    return browser;
    };
    return browser;*/
  };

  return browser;
}
/**
* Build the autocomplete from the edam browser.
* @param {object} the edam browser instance
* @param {str} the target where we should build the autocomplete
* @param {object} the filter dictionary (if a filter is applied)
*/


function build_autocomplete_from_edam_browser(edam_browser, elt, dict) {
  if (typeof elt == "undefined") {
    elt = '.search-term';
  }

  var t;
  if ($(elt).data('ui-autocomplete') != undefined) $(elt).autocomplete("destroy");

  function initIndex() {
    edam_browser.interactive_tree().cmd().forEachElement(function (i, elt) {
      var uri = edam_browser.identifierAccessor(elt);
      var key = uri.substring(uri.lastIndexOf('/') + 1);
      var values = [edam_browser.textAccessor(elt), key];
      if (elt.data.definition) values.push(elt.data.definition);
      if (elt.data.exact_synonyms) values = values.concat(elt.data.exact_synonyms);
      if (elt.data.narrow_synonyms) values = values.concat(elt.data.narrow_synonyms);
      elt.__autocomplete_from_edam_browser = values.join(' ').toUpperCase();
    });
  }

  initIndex();

  function span_matched(match) {
    return '<span class="matched">' + match + '</span>';
  }

  $(elt).autocomplete({
    source: function source(request, response) {
      var data = [];
      var tree = edam_browser.interactive_tree().cmd();
      var terms = request.term.toUpperCase().split(" ");
      tree.forEachElement(function (i, elt) {
        if (typeof elt.__autocomplete_from_edam_browser == "undefined") initIndex();

        for (var j = 0; j < terms.length; j++) {
          if (elt.__autocomplete_from_edam_browser.indexOf(terms[j]) == -1) return;
        }

        data.push({
          value: edam_browser.textAccessor(elt),
          node: elt
        });
      }); //if a filter dictionary is applied

      if (dict) {
        //match type with the parent's container id
        var type = _edit.typeDict[$(this.element).parent().attr('id')];

        var matcher = new RegExp(type + '_', "i"); //apply type filter to data

        data = data.filter(function filterCategories(item) {
          return matcher.test(item.node.__autocomplete_from_edam_browser);
        });
      }

      response(data);
    },
    minLength: 2,
    select: function select(event, ui) {
      // lors de la sélection d'une proposition
      $(event.target).attr("data-selected", edam_browser.identifierAccessor(ui.item.node));
      edam_browser.interactive_tree().cmd().clearSelectedElements(false);
      edam_browser.interactive_tree().cmd.selectElement(edam_browser.identifierAccessor(ui.item.node), true);
      edam_browser.interactive_tree().cmd.moveElementsIntoView([ui.item.node]);
    },
    response: function response(event, ui) {
      if (typeof window.Levenshtein == "undefined") return;
      var searched = $(event.target).val().toUpperCase(),
          i;

      for (i = 0; i < ui.content.length; i++) {
        ui.content[i].lev = window.Levenshtein(ui.content[i].label.toUpperCase(), searched); //+ window.Levenshtein(ui.content[i].node.__autocomplete_from_edam_browser,searched) / 5;
      }

      ui.content.sort(function (a, b) {
        return a.lev - b.lev;
      });
      ui.content.splice(20);
    }
  }).autocomplete("instance")._renderItem = function (ul, item) {
    var identifier = edam_browser.identifierAccessor(item.node);
    identifier = identifier.substring(identifier.lastIndexOf('/') + 1); //var branch = item.deprecated ? "deprecated" : identifier.substring(0,identifier.indexOf("_"));

    var branch = identifier.substring(0, identifier.indexOf("_"));
    var re = new RegExp($(elt).val(), 'ig');
    return $("<li class=\"autocomplete-entry\">").append('<div>' + '<div>' + '<span style="">' + edam_browser.textAccessor(item.node).replace(re, span_matched) + '</span>' + '<span style="">' + '<span class="label label-info pull-right bg-edam-' + branch + '" title="' + branch + '">' + identifier.replace(re, span_matched) + '</span>' + (item.node.deprecated ? '<span class="label label-info pull-right bg-edam-deprecated">deprecated</span>' : '') + '</span>' + '</div>' + (item.node.data.definition ? '<div>' + item.node.data.definition.replace(re, span_matched) + '</div>' : "") + '</div>').appendTo(ul);
  };

  $(elt).prop('disabled', false);
}
},{"./file.js":"ZNE1","./edit.js":"ppKG"}],"Imcy":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.biotool_api = biotool_api;

function biotool_api() {
  function api() {}

  function generic_counter(get_api_url, callback) {
    return $.ajax({
      url: get_api_url(),
      type: "GET",
      dataType: "json",
      data: {},
      success: function success(data, statut) {
        callback(data.count, data, statut);
      },
      error: function error(textStatus, xhr) {
        console.error(textStatus);
        console.error(xhr);
        data = {
          'count': '0'
        };
        callback(data.count, data, textStatus);
      }
    });
  } //end of generic_counter


  function decorate_children_with_count(node, get_api_url, callback, suffix) {
    var field_name = '__biotool_api_count' + (suffix || '');
    var queue = [];
    var job_length = 0; // recursive function that add in queue the element and all its descendant

    var pusher = function pusher(n) {
      queue.push(n);
      var i;
      if (typeof n[field_name] != "undefined") job_length--;

      for (i = 0; i < (n._children || []).length; i++) {
        pusher(n._children[i]);
      }

      for (i = 0; i < (n.children || []).length; i++) {
        pusher(n.children[i]);
      }
    }; // run pusher, fill queue with all the elements


    pusher(node);
    job_length += queue.length; // create a callback caller that sum all descendant usage and call the actual callback

    function call_callback() {
      var total = 0,
          total_d = {};
      $.each(queue, function (i, e) {
        total_d[e.data.data.uri] = e[field_name];
      });

      for (var key in total_d) {
        total += total_d[key];
      }

      callback({
        'descendants': queue.length,
        'total': total
      });
    } // if nothing to do, just run the callback


    if (job_length == 0) call_callback(); // create function that will call generic_counter not for the current elements, but an element passed as arg

    var generic_counter_for_this_i = function generic_counter_for_this_i(j) {
      generic_counter(function () {
        // get the api url for the focused elements
        return get_api_url(queue[j].data.data.uri);
      }, function (data, count, status) {
        // decorate the element with the count returned by bio.tools
        queue[j][field_name] = count.count;

        if (job_length == 1) {
          // when we are the last job, run the callback
          call_callback();
        }

        job_length--;
      });
    };

    for (var i = 0; i < queue.length; i++) {
      if (typeof queue[i][field_name] == "undefined") // for each element, run the custom generic_counter
        generic_counter_for_this_i(i);
    }
  } //end of decorate_children_with_count
  //getter for nothing


  var get_for_nothing = function get_for_nothing(name) {
    var getter = function getter() {};

    getter.count = function (callback) {};

    getter.is_enabled = function () {
      return false;
    };

    getter.get_url = function () {};

    getter.get_api_url = function () {};

    return getter;
  }; //end of function get_for_nothing
  // generic getter


  api.get_for = function (branch, name, uri, node) {
    if (typeof name == "undefined") return get_for_nothing(); //name=name.toLowerCase();

    if (branch == "deprecated") branch = uri.substring(uri.lastIndexOf("/") + 1, uri.lastIndexOf("_"));
    if (branch == "topic" || branch.indexOf('edam') != -1 && uri.indexOf('topic') != -1) return api.get_for_topic(name, uri, node);
    if (branch == "operation" || branch.indexOf('edam') != -1 && uri.indexOf('operation') != -1) return api.get_for_operation(name, uri, node);
    if (branch == "format" || branch.indexOf('edam') != -1 && uri.indexOf('format') != -1) return api.get_for_format(name, uri, node);
    if (branch == "data" || branch.indexOf('edam') != -1 && uri.indexOf('data') != -1) return api.get_for_data(name, uri, node);
    return get_for_nothing();
  }; //end of function get_for
  //getter for term with single usage (tagging)


  var get_for_single_search = function get_for_single_search(uiKey, apiKey) {
    return function (name, uri, node) {
      var identifier = uri.substring(uri.lastIndexOf("/") + 1); //getter object

      var getter = function getter() {}; //function to count the number of tools associated


      getter.count = function (callback) {
        return generic_counter(getter.get_api_url, callback);
      }; //function to count the number of tools associated including descendants


      getter.count_with_descendants = function (callback) {
        return decorate_children_with_count(node, getter.get_api_url, callback);
      }; //is the count function enabled


      getter.is_enabled = function () {
        return true;
      }; //get the url returning the tools for human


      getter.get_url = function () {
        return "https://bio.tools/t?" + uiKey + "=%22" + identifier + "%22";
      }; //get the url returning the tools for api call


      getter.get_api_url = function (value) {
        // use value when provided, otherwise user uri
        return "https://bio.tools/api/tool/?format=json&" + apiKey + "=%22" + (value || uri) + "%22";
      };

      return getter;
    };
  }; //end of function get_for_single_search


  api.get_for_topic = get_for_single_search("topicID", "topicID");
  api.get_for_operation = get_for_single_search("operationID", "operationID"); //getter for term with two usage (input and output)

  var get_for_double_search = function get_for_double_search(uiInKey, uiOutKey, apiInKey, apiOutKey) {
    return function (name, uri, node) {
      var identifier = uri.substring(uri.lastIndexOf("/") + 1); //getter object

      var getter = function getter() {}; //function to count the number of tools associated


      getter.count = function (callback) {
        return generic_counter(function () {
          return getter.get_api_url()[0];
        }, function (cpt_in, data_in) {
          generic_counter(function () {
            return getter.get_api_url()[1];
          }, function (cpt_out, data_out) {
            callback([cpt_in, cpt_out], [data_in, data_out]);
          });
        });
      }; //function to count the number of tools associated including descendants


      getter.count_with_descendants = function (callback) {
        return decorate_children_with_count(node, function (value) {
          return getter.get_api_url(value)[0];
        }, function (res_input) {
          decorate_children_with_count(node, function (value) {
            return getter.get_api_url(value)[1];
          }, function (res_output) {
            callback({
              'input': res_input,
              'output': res_output
            });
          }, "_ouput");
        }, "_input");
      }; //is the count function enabled


      getter.is_enabled = function () {
        return true;
      }; //get the url returning the tools for human


      getter.get_url = function () {
        return ["https://bio.tools/t?" + uiInKey + "=%22" + identifier + "%22", "https://bio.tools/t?" + uiOutKey + "=%22" + identifier + "%22"];
      }; //get the url returning the tools for api call


      getter.get_api_url = function (value) {
        // use value when provided, otherwise user uri
        return ["https://bio.tools/api/tool/?format=json&" + apiInKey + "=%22" + (value || uri) + "%22", "https://bio.tools/api/tool/?format=json&" + apiOutKey + "=%22" + (value || uri) + "%22"];
      };

      return getter;
    };
  }; //end of function get_for_double_search


  api.get_for_data = get_for_double_search("inputDataTypeID", "outputDataTypeID", "inputDataTypeID", "outputDataTypeID");
  api.get_for_format = get_for_double_search("inputID", "outputID", "inputDataFormatID", "outputDataFormatID");
  return api;
}
},{}],"vm1S":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.biosphere_api = biosphere_api;

if (typeof String.prototype.localeCompare === 'undefined') {
  String.prototype.localeCompare = function (str, locale, options) {
    return this == str ? 0 : this > str ? 1 : -1;
  };
}

function biosphere_api() {
  function api() {} //getter for nothing


  var get_for_nothing = function get_for_nothing(name) {
    var getter = function getter() {};

    getter.count = function (callback) {};

    getter.is_enabled = function () {
      return false;
    };

    getter.get_url = function () {};

    getter.get_api_url = function () {};

    return getter;
  }; // generic getter


  api.get_for = function (branch, name, uri, node) {
    if (uri.indexOf("edam") == -1) return get_for_nothing();
    var term_id = uri.substring(uri.lastIndexOf("/") + 1);
    branch = term_id.substring(0, term_id.lastIndexOf("_"));
    var number = term_id.substring(term_id.lastIndexOf("_") + 1); //getter object

    var getter = function getter() {}; //function to count the number of tools associated


    getter.count = function (callback) {
      return $.ajax({
        url: getter.get_api_url(),
        type: "GET",
        dataType: "json",
        data: {},
        headers: {
          'X-Requested-With': 'https://github.com/IFB-ElixirFr/edam-browser'
        },
        success: function success(data, statut) {
          var appliances_row = data.content.split("href=\"/catalogue/appliance/");
          var tools_row = data.content.split("href=\"/catalogue/tool/");
          var appliances = [];
          var tools = [];
          var i;

          for (i = 1; i < appliances_row.length; i++) {
            appliances.push(appliances_row[i].match(/[^>]*>([^<]*)[<]/)[1].trim());
          }

          for (i = 1; i < tools_row.length; i++) {
            tools.push(tools_row[i].match(/[^>]*>([^<]*)[<]/)[1].trim());
          }

          callback([appliances.length, tools.length], [appliances.sort(function (a, b) {
            return a.localeCompare(b);
          }), tools.sort(function (a, b) {
            return a.localeCompare(b);
          })], statut);
        },
        error: function error(textStatus, xhr) {
          console.error(textStatus);
          console.error(xhr);
          callback(-1, [], textStatus);
        }
      });
    }; //is the count function enabled


    getter.is_enabled = function () {
      return true;
    }; //get the url returning the tools for human


    getter.get_url = function () {
      return "https://biosphere.france-bioinformatique.fr/edamontology/" + branch + "/" + number + "/";
    }; //get the url returning the tools for api call


    getter.get_api_url = function () {
      return getter.get_url() + "?media=json&included=True";
    };

    return getter;
  }; //getter for topics


  api.get_for_topic = function (name) {
    return api.get_for("topic", name);
  }; //getter for operations


  api.get_for_operation = function (name) {
    return get_for_nothing();
  }; //getter for data


  api.get_for_data = function (name) {
    return get_for_nothing();
  }; //getter for format


  api.get_for_format = function (name) {
    return get_for_nothing();
  };

  return api;
}
},{}],"gGT0":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.bioweb_api = bioweb_api;

if (typeof String.prototype.localeCompare === 'undefined') {
  String.prototype.localeCompare = function (str, locale, options) {
    return this == str ? 0 : this > str ? 1 : -1;
  };
}

function bioweb_api() {
  function api() {} //getter for nothing


  var get_for_nothing = function get_for_nothing(name) {
    var getter = function getter() {};

    getter.count = function (callback) {};

    getter.is_enabled = function () {
      return false;
    };

    getter.get_url = function () {};

    getter.get_api_url = function () {};

    return getter;
  }; // generic getter


  api.get_for = function (branch, name, uri, node) {
    var term_id = uri.substring(uri.lastIndexOf("/") + 1);
    if (branch == "deprecated") branch = term_id.substring(0, uri.lastIndexOf("_"));
    if (branch != "topic" && (branch.indexOf('edam') == -1 || uri.indexOf('topic') == -1)) return get_for_nothing(); //getter object

    var getter = function getter() {}; //function to count the number of tools associated


    getter.count = function (callback) {
      return $.ajax({
        url: getter.get_api_url(),
        type: "GET",
        dataType: "json",
        data: {},
        headers: {
          'X-Requested-With': 'https://github.com/IFB-ElixirFr/edam-browser'
        },
        success: function success(data, statut) {
          callback(data.length, data.sort(function (a, b) {
            return a.name.localeCompare(b.name);
          }), statut);
        },
        error: function error(textStatus, xhr) {
          console.error(textStatus);
          console.error(xhr);
          callback(-1, [], textStatus);
        }
      });
    }; //is the count function enabled


    getter.is_enabled = function () {
      return false;
    }; //get the url returning the tools for human


    getter.get_url = function () {
      return "https://bioweb.pasteur.fr/packages/topics/" + term_id;
    }; //get the url returning the tools for api call


    getter.get_api_url = function () {
      return "https://cors-anywhere.pasteur.cloud/https://bioweb.pasteur.fr/api/packages?search=&topicId=" + term_id;
    };

    return getter;
  }; //getter for topics


  api.get_for_topic = function (name) {
    return api.get_for("topic", name);
  }; //getter for operations


  api.get_for_operation = function (name) {
    return get_for_nothing();
  }; //getter for data


  api.get_for_data = function (name) {
    return get_for_nothing();
  }; //getter for format


  api.get_for_format = function (name) {
    return get_for_nothing();
  };

  return api;
}
},{}],"KEE6":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.tess_api = tess_api;

function tess_api() {
  function api() {} //getter for nothing


  var get_for_nothing = function get_for_nothing(name) {
    var getter = function getter() {};

    getter.count = function (callback) {};

    getter.is_enabled = function () {
      return false;
    };

    getter.get_url = function () {};

    getter.get_api_url = function () {};

    return getter;
  }; // generic getter


  api.get_for = function (branch, name, uri, node) {
    if (uri.indexOf("edam") == -1) return get_for_nothing(); //getter object

    var getter = function getter() {}; //function to count the number of tools associated


    getter.count = function (callback) {
      return $.ajax({
        url: getter.get_api_url(),
        type: "GET",
        dataType: "json",
        data: {},
        success: function success(data, statut) {
          callback(data.length, data, statut);
        },
        error: function error(textStatus, xhr) {
          console.error(textStatus);
          console.error(xhr);
          callback(-1, [], textStatus);
        }
      });
    }; //is the count function enabled


    getter.is_enabled = function () {
      return typeof name != "undefined";
    }; //get the url returning the tools for human


    getter.get_url = function () {
      return "https://tess.elixir-europe.org/materials?scientific_topics=" + name.replace(/ /g, '+');
    }; //get the url returning the tools for api call


    getter.get_api_url = function () {
      return "https://tess.elixir-europe.org/materials.json?scientific_topics=" + name.replace(/ /g, '+');
    };

    return getter;
  }; //getter for topics


  api.get_for_topic = function (name) {
    return api.get_for("topic", name);
  }; //getter for operations


  api.get_for_operation = function (name) {
    return api.get_for("operation", name);
  }; //getter for data


  api.get_for_data = function (name) {
    return api.get_for("data", name);
  }; //getter for format


  api.get_for_format = function (name) {
    return api.get_for("format", name);
  };

  return api;
}
},{}],"qsCb":[function(require,module,exports) {
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getInitURI = getInitURI;
exports.interactive_edam_browser = interactive_edam_browser;
exports.getTreeFile = getTreeFile;

var _utils = require("./utils.js");

var _treeReusableD = require("./tree-reusable-d3");

var _file = require("./file.js");

var _autocompleteEdamReusable = require("./autocomplete-edam-reusable.js");

var _bioToolsApi = require("./bio.tools.api.js");

var _biosphereApi = require("./biosphere.api.js");

var _biowebApi = require("./bioweb.api.js");

var _tessApi = require("./tess.api.js");

function getInitURI(branch) {
  if (branch == "deprecated") return (0, _utils.getCookie)("edam_browser_" + branch, "owl:DeprecatedClass");
  if (branch == "data") return (0, _utils.getCookie)("edam_browser_" + branch, "http://edamontology.org/data_1916");
  if (branch == "format") return (0, _utils.getCookie)("edam_browser_" + branch, "http://edamontology.org/format_3464");
  if (branch == "operation") return (0, _utils.getCookie)("edam_browser_" + branch, "http://edamontology.org/operation_2451");
  if (branch == "topic") return (0, _utils.getCookie)("edam_browser_" + branch, "http://edamontology.org/topic_0091");
  if (branch == "edam") return (0, _utils.getCookie)("edam_browser_" + branch, "http://edamontology.org/topic_0091");
  if (branch == "edam_w_deprecated") return (0, _utils.getCookie)("edam_browser_" + branch, "http://edamontology.org/topic_0091");
  if (branch == "custom_file") return (0, _utils.getCookie)("edam_browser_" + branch, "");
  if (branch == "custom_url") return (0, _utils.getCookie)("edam_browser_" + branch, "");
}

function getTreeFile(branch) {
  if (branch == "deprecated") return "media/edam_extended.biotools.min.json"; //return "media/deprecated_extended.biotools.min.json";

  if (branch == "data") return "media/edam_extended.biotools.min.json"; //return "media/data_extended.biotools.min.json";

  if (branch == "format") return "media/edam_extended.biotools.min.json"; //return "media/format_extended.biotools.min.json";

  if (branch == "operation") return "media/edam_extended.biotools.min.json"; //return "media/operation_extended.biotools.min.json";

  if (branch == "topic") return "media/edam_extended.biotools.min.json"; //return "media/topic_extended.biotools.min.json";

  if (branch == "edam") return "media/edam_extended.biotools.min.json";
  if (branch == "edam_w_deprecated") return "media/edam_extended.biotools.min.json";
  if (branch == "custom_url") return (0, _utils.getCookie)("edam_browser_custom_loaded_url", "");
  return "";
}

function interactive_edam_browser() {
  var __my_interactive_tree,
      current_branch = "",
      identifier_accessor_mapping = {},
      text_accessor_mapping = {};

  function loadTree(branch, tree) {
    $("#edam-branches .branch").removeClass("active");

    if (typeof branch == "undefined") {
      branch = (0, _utils.getCookie)("edam_browser_branch", "topic");
    }

    $("#edam-branches .branch." + branch).addClass("active");
    (0, _utils.setCookie)("edam_browser_branch", branch);
    current_branch = branch;
    var tree_file = getTreeFile(branch);

    if (tree_file == "") {
      __my_interactive_tree.data(tree); //build_autocomplete_from_tree(tree)

    } else {
      __my_interactive_tree.data_url(tree_file); //build_autocomplete(tree_file);

    }

    (0, _autocompleteEdamReusable.build_autocomplete_from_edam_browser)(browser);
  }

  function selectCustom() {
    var branch = "custom";
    $("[name=identifier_accessor][value='" + (0, _utils.getCookie)("edam_browser_custom_identifier_accessor", "") + "']").prop("checked", true);
    $("[name=text_accessor][value='" + (0, _utils.getCookie)("edam_browser_custom_text_accessor", "") + "']").prop("checked", true);
    $("#id_url").val((0, _utils.getCookie)("edam_browser_custom_loaded_url", ""));
    $("#id_url").change();
    $("#myModal").modal('show');
  }

  function loadCustom() {
    var branch;
    var from = $("#custom_ontology_from")[0];

    if (!from.checkValidity()) {
      $(from).find("[type=submit]").click();
      return;
    }

    (0, _utils.setUrlParameters)($(from).serialize());
    if (typeof (0, _utils.getUrlParameter)("url") == "undefined") branch = "custom_file";else branch = "custom_url";
    (0, _utils.setCookie)("edam_browser_custom_loaded_url", (0, _utils.getUrlParameter)("url", ""));
    (0, _utils.setCookie)("edam_browser_custom_identifier_accessor", (0, _utils.getUrlParameter)("identifier_accessor"));
    (0, _utils.setCookie)("edam_browser_custom_text_accessor", (0, _utils.getUrlParameter)("text_accessor"));

    __my_interactive_tree.identifierAccessor(identifier_accessor_mapping[(0, _utils.getUrlParameter)("identifier_accessor")]);

    __my_interactive_tree.textAccessor(text_accessor_mapping[(0, _utils.getUrlParameter)("text_accessor")]);

    $("#myModal").modal('hide');
    $("#edamAccordion>.panel-group").remove();

    if (branch == "custom_url") {
      loadTree(branch);
      return;
    }

    var reader = new FileReader();
    var file = $("#id_file")[0].files[0];
    reader.readAsText(file);

    reader.onload = function (event) {
      _file.json = (JSON.parse(event.target.result), function () {
        throw new Error('"' + "json" + '" is read-only.');
      }());
      if (_file.json == null) return;

      if (typeof _file.json.meta == "undefined") {
        _file.json.meta = {
          "version": "v n/a"
        };
      }

      _file.json.meta.data_file = file.name;
      _file.json.meta.date = file.lastModifiedDate.toLocaleString();
      loadTree(branch, _file.json);
    };

    reader.onerror = function () {
      alert('Unable to read ' + file.fileName);
    };
  }

  function get_length_biotools(data) {
    return data.list.length;
  }

  function get_name_biotools(data, i) {
    return data.list[i].name;
  }

  function has_next_biotools(data) {
    return data.next != null;
  }

  function to_biotools_href(c, url, data) {
    return to_generic_href(c, url, data, get_length_biotools, get_name_biotools, has_next_biotools);
  }

  function get_length_default(data) {
    return data.length;
  }

  function get_name_default(data, i) {
    return data[i];
  }

  function get_name_tess(data, i) {
    return data[i].title;
  }

  function has_next_default(data) {
    return false;
  }

  function to_tess_href(c, url, data) {
    return to_generic_href(c, url, data, get_length_default, get_name_tess, has_next_default);
  }

  function to_biosphere_href(c, url, data) {
    return to_generic_href(c, url, data, get_length_default, get_name_default, has_next_default);
  }

  function get_name_bioweb(data, i) {
    return data[i].name;
  }

  function to_bioweb_href(c, url, data) {
    return to_generic_href(c, url, data, get_length_default, get_name_bioweb, has_next_default);
  }

  function to_generic_href(c, url, data, get_length, get_name, has_next) {
    var data_content = "";
    var msg;

    if (c > 0) {
      data_content = "title=\"Some associated elements\"  data-toggle=\"popover\" data-placement=\"auto right\" data-trigger=\"hover\" data-html=\"true\" data-content=\"<table class=' table table-condensed'>";
      var i = 0;

      for (; i < get_length(data) && i < 10; i++) {
        data_content += "<li class='list-group-item'>" + get_name(data, i) + "</li>";
      }

      if (i < get_length(data) || has_next_biotools(data)) {
        data_content += "<li class='list-group-item'>...</li>";
      }

      data_content += '</table>"';
      msg = c + " times";
    } else if (c == 0) {
      msg = "not used";
    } else {
      msg = "<i>unknown</i>";
    }

    return '<a href="' + url + '" target="_blank" ' + data_content + '>' + msg + '</a>';
  }

  function standAloneSelectedElementHandler(d, do_not_open) {
    var uri = __my_interactive_tree.identifierAccessor()(d);

    var branch_of_term = get_branch_of_term(uri);
    (0, _utils.setCookie)("edam_browser_" + current_branch, uri);
    var identifier = uri.substring(uri.lastIndexOf('/') + 1).replace(/[^a-zA-Z_0-9]/g, '-').toLowerCase().replace(/[-]+/g, '-');
    window.location.hash = uri.replace("http://edamontology.org/", "") + (current_branch != "edam" ? "&" + current_branch : "");

    if (current_branch != "custom_url" && window.location.search) {
      (0, _utils.setUrlParameters)("");
    }

    $("#details-" + identifier).remove();
    var details = build_detail_panel(d, uri, branch_of_term, identifier, true);
    fill_detail_panel(d, uri, branch_of_term, identifier, details);
    fill_community_panel(d, uri, branch_of_term, identifier, details);
    append_detail_panel_to_edam_accordion(d, uri, branch_of_term, identifier, details);
  }

  function build_detail_panel(d, uri, branch_of_term, identifier, collapsed) {
    var details = "";
    details += '<div class="panel-group edam-details" id="details-' + identifier + '">';
    details += '<div class="panel panel-default border-edam-' + branch_of_term + '">';
    details += '<div class="panel-heading xbg-edam-' + branch_of_term + '-light">';
    details += '<h4 class="panel-title">';
    details += collapsed ? '<a data-toggle="collapse" href="#collapse-' + identifier + '">Details of term "' : '';
    details += '<span class="term-name-heading"></span>';
    details += collapsed ? '"</a> ' : ''; //        details +=                 '<span class="label label-default bg-edam-'+branch_of_term+'-light border-one-solid fg-edam-'+branch_of_term+' border-edam-'+branch_of_term+'">'+branch_of_term+'</span>';

    details += '<span>';
    details += '<a title="edit this term" type="button" class="btn btn-default btn-xs pull-right" target="_blank" href="edit.html?term=' + uri + '&branch=' + current_branch + '"><span class="glyphicon glyphicon-pencil"></span></a>';
    details += '<a title="add a child to this term" type="button" class="btn btn-default btn-xs pull-right" target="_blank" href="edit.html?parent=' + uri + '&branch=' + current_branch + '"><span class="glyphicon glyphicon-plus"></span></a>';
    details += '</span>';
    details += '</h4>';
    details += '</div>';
    details += '<div id="collapse-' + identifier + '" ' + (collapsed ? 'class="panel-collapse collapse"' : '') + '>';
    details += '<div class="panel-body border-edam-' + branch_of_term + '"><table class="table table-condensed xborder-edam-' + branch_of_term + '"><tbody class="details"></tbody></table><table class="table table-condensed xborder-edam-' + branch_of_term + '"><tbody class="community"></tbody></table></div>';
    details += '</div>';
    details += '</div>';
    details += '</div>';
    details = $(details);
    details.find(".term-name-heading").text(__my_interactive_tree.textAccessor()(d));
    return details;
  }

  function fill_detail_panel(d, uri, branch_of_term, identifier, details) {
    var table = details.find("tbody.details");
    table.children().remove();
    var table_parent = details.find("table").parent();
    var fields = ["text", "definition", "comment", "exact_synonyms", "narrow_synonyms", "uri"];
    if (typeof d.data.has_topic != "undefined") fields.push("has_topic");
    if (typeof d.data.is_format_of != "undefined") fields.push("is_format_of");
    if (typeof d.data.has_input != "undefined") fields.push("has_input");
    if (typeof d.data.has_output != "undefined") fields.push("has_output");
    if (typeof d.data.is_identifier_of != "undefined") fields.push("is_identifier_of");
    if (d.parent != null && browser.identifierAccessor(d.parent) != "owl:Thing") fields.push("parents");
    if (typeof d.data.see_also != "undefined") fields.push("see_also");
    fields.forEach(function (entry) {
      if ("uri" == entry) append_row_all_opt(table, "URI", uri, false, "Permanent concept identifier");else if ("text" == entry) append_row_all_opt(table, "Term", d.data[entry], false, "Preferred name for the concept");else if ("parents" == entry) {
        if (typeof d.duplicate == "undefined") {
          append_row(table, entry, browser.identifierAccessor(d.parent), "Link(s) to the parent concept(s) which represent broader concepts");
        } else {
          var parents_uris = [];

          for (var i = d.duplicate.length - 1; i >= 0; i--) {
            parents_uris.push(browser.identifierAccessor(d.duplicate[i].parent));
          }

          append_row(table, entry, parents_uris, "Link(s) to the parent concept(s) which represent broader concepts");
        }
      } else {
        if (entry == "definition") {
          append_row(table, entry, d.data[entry], "Short definition of the concept");
        } else if (entry == "comment") {
          append_row(table, entry, d.data[entry], "Misc. information that may help understand the scope of the concept");
        } else if (entry == "exact_synonyms") {
          append_row(table, entry, d.data[entry], "Alternative term(s) that represent exactly the same concept");
        } else if (entry == "narrow_synonyms") {
          append_row(table, entry, d.data[entry], "Alternative term(s) that represent a slightly narrower scope");
        } else if (entry == "broad_synonyms") {
          append_row(table, entry, d.data[entry], "Alternative term(s) that represent a slightly broader scope");
        } else if (entry == "related_synonyms") {
          append_row(table, entry, d.data[entry], "Alternative term(s) that represent a closely overlapping scope");
        } else {
          append_row(table, entry, d.data[entry]);
        }
      }
    });
  }

  function fill_community_panel(d, uri, branch_of_term, identifier, details) {
    var community = details.find("tbody.community");
    var caller_b = (0, _bioToolsApi.biotool_api)().get_for(current_branch, __my_interactive_tree.textAccessor()(d), uri, d);

    if (caller_b.is_enabled()) {
      var id_b = append_row(community, "<a target=\"_blank\" href=\"https://bio.tools\">bio.tools</a>", "<i>loading</i>", "Bioinformatics Tools and Services Discovery Portal");
      caller_b.count(function (c, data) {
        var elt = $('#details-' + identifier + ' .' + id_b);
        var has_descendants = browser.identifierAccessor(d.parent) != "owl:Thing" && (d.children || d._children) && browser.identifierAccessor(d) != "http://edamontology.org/data_0842";
        elt.empty();

        if (c instanceof Array) {
          $('<span>' + to_biotools_href(c[0], caller_b.get_url()[0], data[0]) + ' as input<span class="' + id_b + '-dsc-i"></span>' + (has_descendants ? '<span class="' + id_b + '-dsc-i dscd" title="loading"> (<i class="fa fa-plus-square-o"></i> <span class="hit">?</span>)</span>' : '') + ', ' + to_biotools_href(c[1], caller_b.get_url()[1], data[1]) + ' as output<span class="' + id_b + '-dsc-o"></span>' + (has_descendants ? '<span class="' + id_b + '-dsc-o dscd" title="loading"> (<i class="fa fa-plus-square-o"></i> <span class="hit">?</span>)</span>' : '') + '.' + '</span>').appendTo(elt);

          if (has_descendants) {
            caller_b.count_with_descendants(function (count) {
              $('#details-' + identifier + ' .' + id_b + '-dsc-i .hit').text(count.input.total);
              $('#details-' + identifier + ' .' + id_b + '-dsc-i.dscd').attr("title", count.input.total + " times with its " + (count.input.descendants - 1) + " descendants");
              $('#details-' + identifier + ' .' + id_b + '-dsc-o .hit').text(count.output.total);
              $('#details-' + identifier + ' .' + id_b + '-dsc-o.dscd').attr("title", count.output.total + " times with its " + (count.output.descendants - 1) + " descendants");
            });
          }
        } else {
          $(to_biotools_href(c, caller_b.get_url(), data)).appendTo(elt);

          if (has_descendants) {
            $('<span class="' + id_b + '-descendants dscd" title="loading"> (<i class="fa fa-plus-square-o"></i> <span class="hit">?</span>)</span>').appendTo(elt);
            caller_b.count_with_descendants(function (count) {
              $('#details-' + identifier + ' .' + id_b + '-descendants .hit').text(count.total);
              $('#details-' + identifier + ' .' + id_b + '-descendants.dscd').attr("title", count.total + " times with its " + (count.descendants - 1) + " descendants");
            });
          }
        }

        $('#details-' + identifier + ' .' + id_b + ' [data-toggle="popover"]').popover();
      });
    }

    var caller_s = (0, _biosphereApi.biosphere_api)().get_for(current_branch, __my_interactive_tree.textAccessor()(d), uri, d);

    if (caller_s.is_enabled()) {
      var id_s = append_row(community, "<a target=\"_blank\" href=\"https://biosphere.france-bioinformatique.fr\">Biosphere</a>", "<i>loading</i>", "IFB (ELIXIR France) Cloud Services to analyze life science data");
      caller_s.count(function (c, data) {
        var elt = $('#details-' + identifier + ' .' + id_s);
        elt.empty();
        $('<span>' + to_biosphere_href(c[0], caller_s.get_url(), data[0]) + ' by appliances, ' + to_biosphere_href(c[1], caller_s.get_url(), data[1]) + ' by tools.' + '</span>').appendTo(elt);
        $('#details-' + identifier + ' .' + id_s + ' [data-toggle="popover"]').popover();
      });
    }

    var caller_w = (0, _biowebApi.bioweb_api)().get_for(current_branch, __my_interactive_tree.textAccessor()(d), uri, d);

    if (caller_w.is_enabled()) {
      var id_w = append_row(community, "<a target=\"_blank\" href=\"https://bioweb.pasteur.fr/\">BioWeb</a>", "<i>loading</i>", "Online catalog of bioinformatics programs and databanks available at the Institut Pasteur");
      caller_w.count(function (c, data) {
        var elt = $('#details-' + identifier + ' .' + id_w);
        elt.empty();
        $(to_bioweb_href(c, caller_w.get_url(), data)).appendTo(elt);
        $('#details-' + identifier + ' .' + id_w + ' [data-toggle="popover"]').popover();
      });
    }

    var caller_t = (0, _tessApi.tess_api)().get_for(current_branch, __my_interactive_tree.textAccessor()(d), uri, d);

    if (caller_t.is_enabled()) {
      var id_t = append_row(community, "<a target=\"_blank\" href=\"https://tess.elixir-europe.org/\">TeSS</a>", "<i>loading</i>", "ELIXIR Training Portal");
      caller_t.count(function (c, data) {
        var elt = $('#details-' + identifier + ' .' + id_t);
        elt.empty();
        $(to_tess_href(c, caller_t.get_url(), data)).appendTo(elt);
        $('#details-' + identifier + ' .' + id_t + ' [data-toggle="popover"]').popover();
      });
    }

    if (uri.startsWith("http://edamontology.org/")) {
      append_row(community, "Links", "Open in " + "<a target=\"_blank\" href=\"http://aber-owl.net/ontology/EDAM/#/Browse/%3Chttp%3A%2F%2Fedamontology.org%2F" + identifier + "%3E\">AberOWL</a>" + ", " + "<a target=\"_blank\" href=\"http://bioportal.bioontology.org/ontologies/EDAM/?p=classes&conceptid=" + uri + "\">BioPortal</a>" + ", " + "<a target=\"_blank\" href=\"https://www.ebi.ac.uk/ols/ontologies/edam/terms?iri=http%3A%2F%2Fedamontology.org%2F" + identifier + "\">OLS</a>" + " or " + "<a target=\"_blank\" href=\"https://webprotege.stanford.edu/#projects/98640503-a37d-4404-84da-caf30fadd685/edit/Classes?selection=Class(%3Chttp://edamontology.org/" + identifier + "%3E)\">WebProt&eacuteg&eacute</a>" + ".", "Links to this concept in other ontology browsers");
    }

    if (community.children().length > 0) {
      community.parent().prepend($('<thead><tr><th colspan="2" data-toggle=\"tooltip\" title=\"Usage of this concept in various databases and registries\">Community usage</th></tr></thead>'));
    } else {
      community.parent().remove();
    }

    details.find('[data-toggle="tooltip"]').tooltip();
  }

  function append_detail_panel_to_edam_accordion(d, uri, branch_of_term, identifier, details) {
    $("#edamAccordion").find(".panel-group").first().find(".collapse").collapse("hide");
    var length = $("#edamAccordion").find(".panel-group").length;

    if (length > 0) {
      $("#edamAccordion").prepend($("#history-separator"));
    }

    if (length > 5) {
      $("#edamAccordion").find(".panel-group").last().fadeOut(300, function () {
        $(this).remove();
      });
    }

    $("#edamAccordion").prepend(details);
    $("#edamAccordion").find(".panel-group").first().find(".collapse").collapse("show");
    return false;
  }

  function interactive_edam_uri(value, translate_to_text) {
    if (value.constructor === Object) {
      return JSON.stringify(value);
    }

    value = ("" + value).replace("&quot;", "").replace("&quot;", "");

    if (!value.startsWith("http://edamontology.org/")) {
      if (value.startsWith("http://") || value.startsWith("https://")) {
        return "<a href=\"" + value + "\" target=\"_blank\">" + value + "</a>";
      }

      return value;
    }

    if (current_branch.startsWith("custom")) return "<a href=\"#" + value + "&" + current_branch + "\" onclick=\"browser.interactive_tree().cmd().clearSelectedElements(false);browser.interactive_tree().cmd().selectElement(this.text,true);\">" + value + "</a>";
    var branch_of_term = get_branch_of_term(value);
    var text;

    if (translate_to_text != false && value.constructor != Object) {
      var element = __my_interactive_tree.cmd.getElementByIdentifier(value);

      if (typeof element != "undefined") {
        text = __my_interactive_tree.textAccessor()(element);
      } else {
        text = value;
      }
    } else {
      text = value.substring(value.lastIndexOf('/') + 1);
    }
    /* jshint -W014 */


    return '<div class="btn-group btn-group-xs"><a ' + 'role="button" ' + 'style="font-size: 1em;" ' + "href=\"#" + value + (current_branch == "deprecated" ? "&deprecated" : "") + "\" " + (current_branch.startsWith("edam") ? "onclick=\"browser.interactive_tree().cmd().clearSelectedElements(false);browser.interactive_tree().cmd().selectElement('" + value + "',true);browser.interactive_tree().cmd().moveElementsIntoView([browser.interactive_tree().cmd().getElementByIdentifier('" + value + "')]);\"" : "onclick=\"setCookie('edam_browser_'+'" + current_branch + "','" + value + "');browser.current_branch('" + branch_of_term + "');browser.interactive_tree().cmd().clearSelectedElements(false);browser.interactive_tree().cmd().selectElement('" + value + "',true)\"") + "class=\"btn bg-edam-" + branch_of_term + "-light fg-edam-" + branch_of_term + " border-one-solid border-edam-" + branch_of_term + "\" " + ">" + text + "</a>" + '<button class="btn bg-edam-' + branch_of_term + ' fg-edam-' + branch_of_term + '-light" type="button" style="font-size: 1em;">' + '<i class="fas fa-copy"  onClick="cpyToClipboard(\'' + value + '\')" ></i> ' + '</button>' + '</div>' //+' <i class="glyphicon glyphicon-stop bg-edam-'+branch_of_term+' fg-edam-'+branch_of_term+'"></i></a>'
    //+'<span class="badge bg-edam-'+branch_of_term+'">'+branch_of_term+'</span>'
    //+'<span class="label label-default bg-edam-'+branch_of_term+'-light fg-edam-'+branch_of_term+' border-edam-'+branch_of_term+'">'+branch_of_term+'</span>'
    ;
  }

  function get_branch_of_term(value) {
    return value.substring(value.lastIndexOf('/') + 1, value.lastIndexOf('_'));
  }

  function append_row(table, name, value, tootip) {
    return append_row_all_opt(table, name, value, undefined, tootip);
  }

  function append_row_all_opt(table, name, value, translate_uri_to_text, tootip) {
    var id = (name.replace(/[^a-zA-Z]/g, '-').toLowerCase() + "-val").replace(/[-]+/g, '-');

    if (typeof value == "undefined") {
      value = "";
    }

    if (name.indexOf("<") == -1) {
      name = name.replace(/[_]/g, "&nbsp;");
      name = name.charAt(0).toUpperCase() + name.substring(1);
    }

    if (value.constructor === Array) {
      if (value.length > 1) {
        //removing duplicates
        var uniqueValues = value.filter(function (element, index) {
          return value.indexOf(element) === index;
        });
        value = uniqueValues;
        var value_txt = "";

        for (var i = 0; i < value.length; i++) {
          if (value[i] != "") {
            value_txt = value_txt + "<li>" + interactive_edam_uri(value[i], translate_uri_to_text) + "</li>";
          }
        }

        value = '<ul class="list-unstyled">' + value_txt + '</ul>';
      } else {
        value = interactive_edam_uri(value[0], translate_uri_to_text);
      }
    }

    var html_tootip = '';

    if (tootip !== undefined) {
      html_tootip = " data-toggle=\"tooltip\" data-placement='top' title=\"" + tootip + "\"";
    }

    $("<tr><th><span" + html_tootip + ">" + name + "</span></th><td class=\"" + id + "\">" + interactive_edam_uri(value, translate_uri_to_text) + "</td></tr>").appendTo(table);
    return id;
  }

  function tooltipBuilder(d, tooltipContainer) {
    tooltipContainer.node().innerHTML = '';
    if ($("#tree-and-controls:not(:fullscreen)").length && !$("input[name='always-show-tooltip']:checked").length) return;

    var uri = __my_interactive_tree.identifierAccessor()(d);

    var branch_of_term = get_branch_of_term(uri);
    var identifier = uri.substring(uri.lastIndexOf('/') + 1).replace(/[^a-zA-Z_0-9]/g, '-').toLowerCase().replace(/[-]+/g, '-');
    var details = build_detail_panel(d, uri, branch_of_term, identifier, false);
    if ($("input[name='show-detail']:checked").length) fill_detail_panel(d, uri, branch_of_term, identifier, details);else details.find("tbody.details").parent().remove();
    if ($("input[name='show-community-usage']:checked").length) fill_community_panel(d, uri, branch_of_term, identifier, details);else details.find("tbody.community").parent().remove();
    details.find(".panel-body:empty").remove();
    $(tooltipContainer.node()).append(details);
  }

  function metaInformationHandler(meta) {
    if (typeof meta == "undefined") {
      $("#version").html("<i>n/a</i>");
      $("#release_date").html("<i>n/a</i>");
      $("#meta_data_url").html("<i>n/a</i>");
      $("#meta_data_file").html("<i>n/a</i>");
      return;
    }

    $("#version").html(meta.version);
    $("#release_date").html(meta.date);
    if (meta.repository) $("#ontology-repository").attr("href", meta.repository['@id']);
    if (meta.homepage) $("#homepage").attr("href", meta.repository).html(meta.homepage['@id'].match(/\/\/([^\/]+)\//)[1]);

    if (meta.logo) {
      meta.logo = meta.logo['@id'];
      $("#logo").attr("src", meta.logo);
      var fav = $("link[rel~='icon']");
      fav.attr("href", meta.logo);

      if (meta.logo.endsWith(".svg")) {
        fav.attr("type", "image/svg+xml");
      }
    }

    $("#meta_data_url").attr("href", meta.data_url).add("[for=meta_data_url]").toggle(typeof meta.data_url != "undefined");
    $("#meta_data_file").html(meta.data_file).add("[for=meta_data_file]").toggle(typeof meta.data_file != "undefined"); //        $("#meta_data_filename").attr("href", meta.data_filename).visible(typeof meta.data_filename != "undefined");
  }

  function identifierAccessorDefault(d, notPreTreated) {
    return notPreTreated ? d.id : d.data.id;
  }

  identifier_accessor_mapping['d.id'] = identifierAccessorDefault;

  function identifierAccessorEDAM(d, notPreTreated) {
    return notPreTreated ? d.data.uri : d.data.data.uri;
  }

  identifier_accessor_mapping['d.data.uri'] = identifierAccessorEDAM;

  function textAccessorDefault(d) {
    if (typeof d.data.text == "undefined") {
      var identifier = __my_interactive_tree.identifierAccessor()(d);

      var branch = "edam";
      if (identifier == "owl:Thing" && branch == "edam") return "EDAM";
      return identifier;
    }

    if (d.data.text.constructor === Object) return d.data.text["@value"] || JSON.stringify(d.data.text);
    return d.data.text;
  }

  text_accessor_mapping['d.text'] = textAccessorDefault;

  function textAccessorName(d) {
    return d.data.name;
  }

  text_accessor_mapping['d.name'] = textAccessorName;

  function markDeprecated(node) {
    node.deprecated = true;
    var i;

    for (i = 0; i < (node.children || []).length; i++) {
      markDeprecated(node.children[i]);
    }

    for (i = 0; i < (node._children || []).length; i++) {
      markDeprecated(node._children[i]);
    }
  }

  __my_interactive_tree = (0, _treeReusableD.interactive_tree)().identifierAccessor(identifierAccessorEDAM)
  /*.additionalCSSClassForNode(function(d){
      if (current_branch!="edam" &&
          current_branch!="data" &&
          current_branch!="format" &&
          current_branch!="operation" &&
          current_branch!="topic"
      )
          return ""
      return "bg-edam-"+get_branch_of_term(__my_interactive_tree.identifierAccessor()(d))+"-light";
  })*/
  .additionalCSSClassForLink(function (d) {
    if (current_branch != "edam" && current_branch != "edam_w_deprecated" && current_branch != "data" && current_branch != "format" && current_branch != "operation" && current_branch != "topic") return "";
    return "fg-edam-" + get_branch_of_term(__my_interactive_tree.identifierAccessor()(d)) + "-light";
  })
  /**/
  .clickedElementHandler(function (d) {
    if (__my_interactive_tree.cmd.isElementSelected(__my_interactive_tree.identifierAccessor()(d))) return;
    if (__my_interactive_tree.identifierAccessor()(d) === "owl:Thing") return;

    __my_interactive_tree.cmd.selectElement(__my_interactive_tree.identifierAccessor()(d), true, true);

    if ($("input[name='center-node-click']:checked").length) __my_interactive_tree.cmd.moveElementsIntoView([d]);
    return;
  }).addingElementHandler(function (d) {
    standAloneSelectedElementHandler(d, false);
    return true;
  }).preTreatmentOfLoadedTree(function (tree) {
    var i;

    if (current_branch === "edam") {
      var all_children = tree.children;
      tree.children = [];

      for (i = 0; i < all_children.length; i++) {
        if (__my_interactive_tree.identifierAccessor()(all_children[i], true) != "owl:DeprecatedClass") tree.children.push(all_children[i]);
      }
    }

    if (current_branch === "deprecated") {
      for (i = 0; i < tree.children.length; i++) {
        if (__my_interactive_tree.identifierAccessor()(tree.children[i], true) === "owl:DeprecatedClass") {
          tree.children[i].meta = tree.meta || {};
          markDeprecated(tree.children[i]);
          return tree.children[i];
        }
      }
    }

    var branches = ["data", "format", "operation", "topic"];

    for (var id = 0; id < branches.length; id++) {
      if (current_branch === branches[id]) {
        for (i = 0; i < tree.children.length; i++) {
          if (__my_interactive_tree.identifierAccessor()(tree.children[i], true).indexOf("/" + branches[id] + "_") != -1) {
            tree.children[i].meta = tree.meta || {};
            return tree.children[i];
          }
        }
      }
    }

    for (i = 0; i < tree.children.length; i++) {
      if (__my_interactive_tree.identifierAccessor()(tree.children[i], true) === "owl:DeprecatedClass") {
        markDeprecated(tree.children[i]);
        i = tree.children.length;
      }
    }

    return tree;
  }).initiallySelectedElementHandler(function (d) {
    if (d.text && d.text.constructor === Object) {
      d.text = JSON.stringify(d.text);
    }

    return __my_interactive_tree.identifierAccessor()(d) === getInitURI(current_branch);
  }).loadingDoneHandler(function () {
    __my_interactive_tree.cmd.selectElement("http://edamontology.org/" + getInitURI(current_branch), true, true);

    __my_interactive_tree.cmd.selectElement(getInitURI(current_branch), true, true);

    (0, _autocompleteEdamReusable.build_autocomplete_from_edam_browser)(browser);
    setTimeout(function () {
      __my_interactive_tree.cmd.moveElementsIntoView([__my_interactive_tree.cmd.getElementByIdentifier(getInitURI(current_branch))]);
    }, 10);
    $(".loader-wrapper").fadeOut();
  }).metaInformationHandler(metaInformationHandler).debug(false).sortChildren(true).use_shift_to_open(false).use_control_to_open(false).use_alt_to_open(false).use_shift_to_add(false).use_control_to_add(false).use_alt_to_add(false).tooltipEnabled(true).tooltipBuilder(tooltipBuilder);
  /**
   * The browser
   */

  function browser() {}
  /**
   * The browser's accessors
   */


  function cmd() {
    return cmd;
  }

  browser.cmd = cmd;
  /**
   * Command to prepare the modal to load a custom ontology
   * @param {boolean} value
   */

  cmd.selectCustom = function () {
    return selectCustom();
  };
  /**
   * Command to load a custom ontology
   * @param {boolean} value
   */


  cmd.loadCustom = function () {
    return loadCustom();
  }; // getter and setter functions. ----------------------------------------------------------

  /**
   * Read-only accessor to the interactive tree
   * @return {object} the tree
   */


  browser.interactive_tree = function () {
    return __my_interactive_tree;
  };
  /**
   * Get the current branch or load the branch given in parameter if it is not
   * the current branch
   * @param {string} value
   */


  browser.current_branch = function (value) {
    if (!arguments.length) return current_branch;
    if (current_branch === value) return browser;

    __my_interactive_tree.identifierAccessor(identifierAccessorEDAM);

    __my_interactive_tree.textAccessor(textAccessorDefault);

    loadTree(value);
    return browser;
  };
  /**
   * Read-only proxy to use the identifierAccessor of the interactive_tree
   * @param {object} an element
   * @return {object} the value return by the identifierAccessor for the given parameter
   */


  browser.identifierAccessor = function (value) {
    return __my_interactive_tree.identifierAccessor()(value);
  };
  /**
   * Read-only proxy to use the textAccessor of the interactive_tree
   * @param {object} an element
   * @return {object} the value return by the textAccessor for the given parameter
   */


  browser.textAccessor = function (value) {
    return __my_interactive_tree.textAccessor()(value);
  };

  return browser;
}

window.toggleFullscreen = function toggleFullscreen() {
  if (!document.fullscreenElement) {
    document.getElementById("tree-and-controls").requestFullscreen();
    $('#go-fullscreen').hide();
    $('#exit-fullscreen').show();
  } else {
    document.exitFullscreen();
    $('#exit-fullscreen').hide();
    $('#go-fullscreen').show();
  }
};
/**
 * 
 * @param {string} value Copies the value of the passed uri to the clipboard 
 */


window.cpyToClipboard = function cpyToClipboard(value) {
  //copying the uri value to the clipboard
  navigator.clipboard.writeText(value);
  var element = event.srcElement; //showing a tooltip indicating the value is copied

  $(element).attr('title', "URI copied!").tooltip('show'); //changing the icon to a check shape indicating success

  $(element).addClass("fa-check").removeClass("fa-copy"); //toggling back the icon and removing the copied tooltip

  setTimeout(function () {
    $(element).addClass("fa-copy").removeClass("fa-check");
    $(element).tooltip('destroy');
  }, 1000);
};
},{"./utils.js":"MgTz","./tree-reusable-d3":"kypQ","./file.js":"ZNE1","./autocomplete-edam-reusable.js":"ZZY2","./bio.tools.api.js":"Imcy","./biosphere.api.js":"vm1S","./bioweb.api.js":"gGT0","./tess.api.js":"KEE6"}],"QvaY":[function(require,module,exports) {
"use strict";

require("../jquey-import.js");

require("popper.js");

require("jquery-ui-themes/themes/smoothness/jquery-ui.css");

require("jquery-ui-bundle");

require("bootstrap");

require("bootstrap/dist/css/bootstrap.css");

require("@fortawesome/fontawesome-free/css/all.css");

require("../css/bootstrap.xl.css");

require("../css/tree-reusable-d3.css");

require("../css/autocomplete-edam-reusable.css");

require("../css/index.css");

require("../css/edam.css");

require("../css/dark-theme.css");

require("regenerator-runtime/runtime");

var d3 = _interopRequireWildcard(require("d3"));

var _treeReusableD2 = require("./tree-reusable-d3.js");

var _gaGtag = _interopRequireWildcard(require("ga-gtag"));

var _utils = require("./utils.js");

var _treeEdamStandAlone = require("./tree-edam-stand-alone.js");

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

window.interactive_tree = _treeReusableD2.interactive_tree;
var browser = (0, _treeEdamStandAlone.interactive_edam_browser)(); //enabling access from html to the browser variable

window.browser = browser;

window.onload = function () {
  configGtag();
  (0, _utils.getDarkMode)();
  var id;
  var $inputs = $('#id_file,#id_url');
  $inputs.on('input', function () {
    $inputs.not(this).prop('disabled', $(this).val().length);
  }).on('change', function () {
    $inputs.not(this).prop('disabled', $(this).val().length);
  });
  var branch;

  if (typeof (0, _utils.getUrlParameter)("url") != "undefined") {
    branch = "custom_url";
    (0, _utils.setCookie)("edam_browser_branch", branch);
    (0, _utils.setCookie)("edam_browser_custom_loaded_url", (0, _utils.getUrlParameter)("url"));
    (0, _utils.setCookie)("edam_browser_custom_identifier_accessor", (0, _utils.getUrlParameter)("identifier_accessor"));
    (0, _utils.setCookie)("edam_browser_custom_text_accessor", (0, _utils.getUrlParameter)("text_accessor"));
    $("[name=identifier_accessor][value='" + (0, _utils.getCookie)("edam_browser_custom_identifier_accessor", "") + "']").prop("checked", true);
    $("#id_url").val((0, _utils.getUrlParameter)("url"));
    $("#id_url").change();
    $("[name=text_accessor][value='" + (0, _utils.getCookie)("edam_browser_custom_text_accessor", "") + "']").prop("checked", true);
    console.log(window.location.hash);

    if (window.location.hash) {
      var _id = window.location.hash.substring(1);

      var pos = _id.lastIndexOf('&');

      if (pos != -1) {
        _id = _id.substring(0, pos);
      }

      (0, _utils.setCookie)("edam_browser_" + branch, _id);
    }
  } else if (window.location.hash) {
    var hash = window.location.hash.substring(1);

    var _pos = hash.lastIndexOf('&');

    if (_pos != -1) {
      id = hash.substring(0, _pos);
      branch = hash.substring(_pos + 1);
    } else {
      //only home-EDAM arrives here, so ok to work with edam
      //id=branch;
      //branch=branch.substring(branch.lastIndexOf('/')+1,branch.lastIndexOf('_'));
      id = ("http://edamontology.org/" + hash).replace("http://edamontology.org/http://edamontology.org/", "http://edamontology.org/");
      branch = "edam";
    }

    if (id === "") id = (0, _treeEdamStandAlone.getInitURI)(branch);
    (0, _utils.setCookie)("edam_browser_branch", branch);
    (0, _utils.setCookie)("edam_browser_" + branch, id);
  } else {
    branch = (0, _utils.getCookie)("edam_browser_branch", "edam");

    if (branch == "custom_url") {
      //if branch is custom we simulate the form to be filled, and submitted.
      $("[name=identifier_accessor][value='" + (0, _utils.getCookie)("edam_browser_custom_identifier_accessor", "") + "']").prop("checked", true);
      $("[name=text_accessor][value='" + (0, _utils.getCookie)("edam_browser_custom_text_accessor", "") + "']").prop("checked", true);
      $("#id_url").val((0, _utils.getCookie)("edam_browser_custom_loaded_url", ""));
      $inputs.change();
      (0, _utils.setUrlParameters)($("#custom_ontology_from").serialize());
    }
  }

  d3.select("#tree").call(browser.interactive_tree()); // draw chart in div

  if (branch == "custom_file") {
    browser.cmd.selectCustom();
  } else if (branch == "custom_url") {
    browser.cmd.loadCustom();
  } else {
    browser.current_branch(branch);
  }

  var treeElement = document.getElementById("tree-and-controls");
  treeElement.style.height = localStorage.getItem("tree-and-controls-height");
  var resizer = document.getElementById("handle");
  resizer.addEventListener("mousedown", initDrag, false);
  var startY, startHeight;

  function initDrag(e) {
    startY = e.clientY;
    startHeight = parseInt(document.defaultView.getComputedStyle(treeElement).height, 10);
    document.documentElement.addEventListener("mousemove", doDrag, false);
    document.documentElement.addEventListener("mouseup", stopDrag, false);
    document.getElementsByTagName("body")[0].classList.add("user-select-none");
  }

  function doDrag(e) {
    treeElement.style.height = startHeight + e.clientY - startY + "px";
  }

  function stopDrag(e) {
    document.documentElement.removeEventListener("mousemove", doDrag, false);
    document.documentElement.removeEventListener("mouseup", stopDrag, false);
    localStorage.setItem("tree-and-controls-height", treeElement.style.height);
    document.getElementsByTagName("body")[0].classList.remove("user-select-none");
  }

  $("#tree-settings").find("input").each(function (index) {
    var $this = $(this);
    $this.prop("checked", (localStorage.getItem($this.prop("name")) || $this.data("default")) == "true");

    if ($this.data("saved") !== "false") {
      $this.change(function () {
        localStorage.setItem($this.prop("name"), $this.prop('checked'));
      });
    }
  });
};

var configGtag = function configGtag() {
  (0, _gaGtag.install)('UA-115521967-1');
  window.dataLayer = window.dataLayer || [];

  function gtag() {
    dataLayer.push(arguments);
  }

  gtag('js', new Date());
  gtag('config', 'UA-115521967-1');
};
},{"../jquey-import.js":"FtjA","popper.js":"v5IM","jquery-ui-themes/themes/smoothness/jquery-ui.css":"AC2V","jquery-ui-bundle":"Hifx","bootstrap":"jv0N","bootstrap/dist/css/bootstrap.css":"gsgA","@fortawesome/fontawesome-free/css/all.css":"Eofe","../css/bootstrap.xl.css":"ju9n","../css/tree-reusable-d3.css":"ju9n","../css/autocomplete-edam-reusable.css":"ju9n","../css/index.css":"ju9n","../css/edam.css":"ju9n","../css/dark-theme.css":"ju9n","regenerator-runtime/runtime":"KA2S","d3":"BG5c","./tree-reusable-d3.js":"kypQ","ga-gtag":"IZXy","./utils.js":"MgTz","./tree-edam-stand-alone.js":"qsCb"}]},{},["QvaY"], null)
//# sourceMappingURL=https://hagerdakroury.github.io/edam-browser/js.9e07149a.js.map